/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

;// https://d3js.org Version 4.13.0. Copyright 2018 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var version = "4.13.0";

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

function pairs(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
}

function pair(a, b) {
  return [a, b];
}

function cross(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function number(x) {
  return x === null ? NaN : +x;
}

function variance(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
}

function deviation(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
}

function extent(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}

var array = Array.prototype;

var slice = array.slice;
var map = array.map;

function constant(x) {
  return function() {
    return x;
  };
}

function identity(x) {
  return x;
}

function sequence(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function sturges(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}

function histogram() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = sequence(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
}

function threshold(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function freedmanDiaconis(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (threshold(values, 0.75) - threshold(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}

function scott(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
}

function max(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}

function mean(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
}

function median(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return threshold(numbers.sort(ascending), 0.5);
}

function merge(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}

function min(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}

function permute(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
}

function scan(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
}

function shuffle(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}

function sum(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}

function transpose(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
}

function length(d) {
  return d.length;
}

function zip() {
  return transpose(arguments);
}

var slice$1 = Array.prototype.slice;

function identity$1(x) {
  return x;
}

var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number$1(scale) {
  return function(d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$1) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number$1)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "#000"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "#000")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "#000")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter
            : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = slice$1.call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : slice$1.call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : slice$1.call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}

var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function empty$1() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty$1 : function() {
    return this.querySelectorAll(selector);
  };
}

function selection_selectAll(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

var matcher = function(selector) {
  return function() {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector
        || element.msMatchesSelector
        || element.mozMatchesSelector
        || element.oMatchesSelector;
    matcher = function(selector) {
      return function() {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

var matcher$1 = matcher;

function selection_filter(match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant$1(x) {
  return function() {
    return x;
  };
}

var keyPrefix = "$"; // Protect against keys like __proto__.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant$1(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

function selection_merge(selection$$1) {

  for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending$1;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending$1(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

var filterEvents = {};

exports.event = null;

if (typeof document !== "undefined") {
  var element$1 = document.documentElement;
  if (!("onmouseenter" in element$1)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = exports.event; // Events can be reentrant (e.g., focus).
    exports.event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      exports.event = event0;
    }
  };
}

function parseTypenames$1(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, capture) {
  var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = exports.event;
  event1.sourceEvent = exports.event;
  exports.event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    exports.event = event0;
  }
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
}

function create(name) {
  return select(creator(name).call(document.documentElement));
}

var nextId = 0;

function local$1() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local$1.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

function sourceEvent() {
  var current = exports.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
}

function point(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}

function mouse(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
}

function selectAll(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
}

function touch(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
}

function touches(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
}

function nopropagation() {
  exports.event.stopImmediatePropagation();
}

function noevent() {
  exports.event.preventDefault();
  exports.event.stopImmediatePropagation();
}

function dragDisable(view) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", noevent, true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

function constant$2(x) {
  return function() {
    return x;
  };
}

function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// Ignore right-click, since that should open the context menu.
function defaultFilter$1() {
  return !exports.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: exports.event.x, y: exports.event.y} : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

function drag() {
  var filter = defaultFilter$1,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
    if (!gesture) return;
    select(exports.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    dragDisable(exports.event.view);
    nopropagation();
    mousemoving = false;
    mousedownx = exports.event.clientX;
    mousedowny = exports.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    noevent();
    if (!mousemoving) {
      var dx = exports.event.clientX - mousedownx, dy = exports.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    select(exports.event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(exports.event.view, mousemoving);
    noevent();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = exports.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, touch, this, arguments)) {
        nopropagation();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = exports.event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = exports.event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((exports.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$2(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant$2(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant$2(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$2(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex3 = /^#([0-9a-f]{3})$/;
var reHex6 = /^#([0-9a-f]{6})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

var Kn = 18;
var Xn = 0.950470;
var Yn = 1;
var Zn = 1.088830;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var b = rgb2xyz(o.r),
      a = rgb2xyz(o.g),
      l = rgb2xyz(o.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Rgb(
      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861;
var B = +1.78277;
var C = -0.29227;
var D = -0.90649;
var E = +1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

function basis$1(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function constant$3(x) {
  return function() {
    return x;
  };
}

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant$3(isNaN(a) ? b : a);
}

var interpolateRgb = (function rgbGamma(y) {
  var color$$1 = gamma(y);

  function rgb$$1(start, end) {
    var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),
        g = color$$1(start.g, end.g),
        b = color$$1(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$$1.gamma = rgbGamma;

  return rgb$$1;
})(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color$$1;
    for (i = 0; i < n; ++i) {
      color$$1 = rgb(colors[i]);
      r[i] = color$$1.r || 0;
      g[i] = color$$1.g || 0;
      b[i] = color$$1.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color$$1.opacity = 1;
    return function(t) {
      color$$1.r = r(t);
      color$$1.g = g(t);
      color$$1.b = b(t);
      return color$$1 + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

function array$1(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
}

function reinterpolate(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
}

function object(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = interpolateValue(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: reinterpolate(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function interpolateValue(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant$3(b)
      : (t === "number" ? reinterpolate
      : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
      : b instanceof color ? interpolateRgb
      : b instanceof Date ? date
      : Array.isArray(b) ? array$1
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : reinterpolate)(a, b);
}

function interpolateRound(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
}

var degrees = 180 / Math.PI;

var identity$2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var cssNode;
var cssRoot;
var cssView;
var svgNode;

function parseCss(value) {
  if (value === "none") return identity$2;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity$2;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: reinterpolate(xa, xb)}, {i: i - 2, x: reinterpolate(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: reinterpolate(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: reinterpolate(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: reinterpolate(xa, xb)}, {i: i - 2, x: reinterpolate(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2;
var rho2 = 2;
var rho4 = 4;
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
function interpolateZoom(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0  u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
}

function hsl$1(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = hsl(start)).h, (end = hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$2 = hsl$1(hue);
var hslLong = hsl$1(nogamma);

function lab$1(start, end) {
  var l = nogamma((start = lab(start)).l, (end = lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl$1(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = hcl(start)).h, (end = hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$2 = hcl$1(hue);
var hclLong = hcl$1(nogamma);

function cubehelix$1(hue$$1) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix$$1(start, end) {
      var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix$$1.gamma = cubehelixGamma;

    return cubehelix$$1;
  })(1);
}

var cubehelix$2 = cubehelix$1(hue);
var cubehelixLong = cubehelix$1(nogamma);

function quantize(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}

var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1000;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

function timeout$1(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

function interval$1(callback, delay, time) {
  var t = new Timer, total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? now() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
}

var emptyOn = dispatch("start", "end", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

function schedule(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create$1(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get$1(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set$1(node, id) {
  var schedule = get$1(node, id);
  if (schedule.state > STARTING) throw new Error("too late; already started");
  return schedule;
}

function get$1(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create$1(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return timeout$1(start);

      // Interrupt the active transition, if any.
      // Dispatch the interrupt event.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    timeout$1(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

function interrupt(node, name) {
  var schedules = node.__transition,
      schedule$$1,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule$$1 = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule$$1.state > STARTING && schedule$$1.state < ENDING;
    schedule$$1.state = ENDED;
    schedule$$1.timer.stop();
    if (active) schedule$$1.on.call("interrupt", node, node.__data__, schedule$$1.index, schedule$$1.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule$$1 = set$1(this, id),
        tween = schedule$$1.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule$$1.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule$$1 = set$1(this, id),
        tween = schedule$$1.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule$$1.tween = tween1;
  };
}

function transition_tween(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get$1(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule$$1 = set$1(this, id);
    (schedule$$1.value || (schedule$$1.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get$1(node, id).value[name];
  };
}

function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? reinterpolate
      : b instanceof color ? interpolateRgb
      : (c = color(b)) ? (b = c, interpolateRgb)
      : interpolateString)(a, b);
}

function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant$1(name, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function attrConstantNS$1(fullname, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function attrFunction$1(name, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS$1(fullname, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

function transition_attr(name, value) {
  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
      : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value + ""));
}

function attrTweenNS(fullname, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttribute(name, i(t));
    };
  }
  tween._value = value;
  return tween;
}

function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

function transition_delay(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get$1(this.node(), id).delay;
}

function durationFunction(id, value) {
  return function() {
    set$1(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set$1(this, id).duration = value;
  };
}

function transition_duration(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get$1(this.node(), id).duration;
}

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set$1(this, id).ease = value;
  };
}

function transition_ease(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get$1(this.node(), id).ease;
}

function transition_filter(match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
}

function transition_merge(transition$$1) {
  if (transition$$1._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
}

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set$1;
  return function() {
    var schedule$$1 = sit(this, id),
        on = schedule$$1.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule$$1.on = on1;
  };
}

function transition_on(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get$1(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}

function transition_select(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
}

function transition_selectAll(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
}

var Selection$1 = selection.prototype.constructor;

function transition_selection() {
  return new Selection$1(this._groups, this._parents);
}

function styleRemove$1(name, interpolate$$1) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = styleValue(this, name),
        value1 = (this.style.removeProperty(name), styleValue(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

function styleRemoveEnd(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant$1(name, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = styleValue(this, name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function styleFunction$1(name, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = styleValue(this, name),
        value1 = value(this);
    if (value1 == null) value1 = (this.style.removeProperty(name), styleValue(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this
          .styleTween(name, styleRemove$1(name, i))
          .on("end.style." + name, styleRemoveEnd(name))
      : this.styleTween(name, typeof value === "function"
          ? styleFunction$1(name, i, tweenValue(this, "style." + name, value))
          : styleConstant$1(name, i, value + ""), priority);
}

function styleTween(name, value, priority) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.style.setProperty(name, i(t), priority);
    };
  }
  tween._value = value;
  return tween;
}

function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction$1(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function transition_text(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction$1(tweenValue(this, "text", value))
      : textConstant$1(value == null ? "" : value + ""));
}

function transition_transition() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get$1(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
}

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return selection().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = selection.prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease
};

function linear$1(t) {
  return +t;
}

function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);

var pi = Math.PI;
var halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);

var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = now(), defaultTiming;
    }
  }
  return timing;
}

function selection_transition(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
}

selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;

var root$1 = [null];

function active(node, name) {
  var schedules = node.__transition,
      schedule$$1,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule$$1 = schedules[i]).state > SCHEDULED && schedule$$1.name === name) {
        return new Transition([[node]], root$1, name, +i);
      }
    }
  }

  return null;
}

function constant$4(x) {
  return function() {
    return x;
  };
}

function BrushEvent(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
}

function nopropagation$1() {
  exports.event.stopImmediatePropagation();
}

function noevent$1() {
  exports.event.preventDefault();
  exports.event.stopImmediatePropagation();
}

var MODE_DRAG = {name: "drag"};
var MODE_SPACE = {name: "space"};
var MODE_HANDLE = {name: "handle"};
var MODE_CENTER = {name: "center"};

var X = {
  name: "x",
  handles: ["e", "w"].map(type),
  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
  name: "xy",
  handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
  input: function(xy) { return xy; },
  output: function(xy) { return xy; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !exports.event.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

// Like d3.local, but with the name __brush rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush$1(X);
}

function brushY() {
  return brush$1(Y);
}

function brush() {
  return brush$1(XY);
}

function brush$1(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      listeners = dispatch(brush, "start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local(this).extent;
          select(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
        .on("mousedown.brush touchstart.brush", started);
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = interpolateValue(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && empty(selection1) ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 && selection1 ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            interrupt(that);
            state.selection = selection1 == null || empty(selection1) ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  function redraw() {
    var group = select(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args) {
    return that.__brush.emitter || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (exports.event.touches) { if (exports.event.changedTouches.length < exports.event.touches.length) return noevent$1(); }
    else if (touchending) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = exports.event.target.__data__.type,
        mode = (exports.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (exports.event.altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx,
        dy,
        moving,
        shifting = signX && signY && exports.event.shiftKey,
        lockX,
        lockY,
        point0 = mouse(that),
        point = point0,
        emit = emitter(that, arguments).beforestart();

    if (type === "overlay") {
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = select(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (exports.event.touches) {
      group
          .on("touchmove.brush", moved, true)
          .on("touchend.brush touchcancel.brush", ended, true);
    } else {
      var view = select(exports.event.view)
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);

      dragDisable(exports.event.view);
    }

    nopropagation$1();
    interrupt(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = mouse(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      noevent$1();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      nopropagation$1();
      if (exports.event.touches) {
        if (exports.event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        group.on("touchmove.brush touchend.brush touchcancel.brush", null);
      } else {
        yesdrag(exports.event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (exports.event.keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      noevent$1();
    }

    function keyupped() {
      switch (exports.event.keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (exports.event.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      noevent$1();
    }
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = extent.apply(this, arguments);
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant$4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$4(!!_), brush) : filter;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

var cos = Math.cos;
var sin = Math.sin;
var pi$1 = Math.PI;
var halfPi$1 = pi$1 / 2;
var tau$1 = pi$1 * 2;
var max$1 = Math.max;

function compareValue(compare) {
  return function(a, b) {
    return compare(
      a.source.value + a.target.value,
      b.source.value + b.target.value
    );
  };
}

function chord() {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = sequence(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j;

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(sequence(n));
      k += x;
    }

    // Sort groups
    if (sortGroups) groupIndex.sort(function(a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    });

    // Sort subgroups
    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
      d.sort(function(a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    });

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?
    k = max$1(0, tau$1 - padAngle * n) / k;
    dx = k ? padAngle : tau$1 / n;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function(_) {
    return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
  };

  chord.sortGroups = function(_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function(_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function(_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
}

var slice$2 = Array.prototype.slice;

function constant$5(x) {
  return function() {
    return x;
  };
}

var pi$2 = Math.PI;
var tau$2 = 2 * pi$2;
var epsilon$1 = 1e-6;
var tauEpsilon = tau$2 - epsilon$1;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon$1)) {}

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon$1) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? Were done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau$2 + tau$2;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon$1) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi$2)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

function ribbon() {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = slice$2.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - halfPi$1,
        sa1 = endAngle.apply(this, argv) - halfPi$1,
        sx0 = sr * cos(sa0),
        sy0 = sr * sin(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - halfPi$1,
        ta1 = endAngle.apply(this, argv) - halfPi$1;

    if (!context) context = buffer = path();

    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$5(+_), ribbon) : radius;
  };

  ribbon.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$5(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$5(+_), ribbon) : endAngle;
  };

  ribbon.source = function(_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function(_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, ribbon) : context;
  };

  return ribbon;
}

var prefix = "$";

function Map() {}

Map.prototype = map$1.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map$1(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

function nest() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map$1(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();
    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
}

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map$1();
}

function setMap(map, key, value) {
  map.set(key, value);
}

function Set() {}

var proto = map$1.prototype;

Set.prototype = set$2.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set$2(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume its an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

function keys(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
}

function values(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
}

function entries(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
}

var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function dsv(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    })).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return text == null ? ""
        : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\""
        : text;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatRows: formatRows
  };
}

var csv = dsv(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatRows = csv.formatRows;

var tsv = dsv("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatRows = tsv.formatRows;

function center$1(x, y) {
  var nodes;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}

function constant$6(x) {
  return function() {
    return x;
  };
}

function jiggle() {
  return (Math.random() - 0.5) * 1e-6;
}

function tree_add(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, inherit the existing extent.
  if (x1 < x0) x0 = this._x0, x1 = this._x1;
  if (y1 < y0) y0 = this._y0, y1 = this._y1;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

function tree_cover(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries dont change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else if (x0 > x || x > x1 || y0 > y || y > y1) {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {
      case 0: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);
        break;
      }
      case 1: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);
        break;
      }
      case 2: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);
        break;
      }
      case 3: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);
        break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  // If the quadtree covers the point already, just return.
  else return this;

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

function tree_data() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}

function tree_extent(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}

function Quad(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

function tree_find(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant cant contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new Quad(node[3], xm, ym, x2, y2),
        new Quad(node[2], x1, ym, xm, y2),
        new Quad(node[1], xm, y1, x2, ym),
        new Quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isnt necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}

function tree_remove(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return next ? previous.next = next : delete previous.next, this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

function tree_root() {
  return this._root;
}

function tree_size() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}

function tree_visit(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
}

function tree_visitAfter(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

function defaultX(d) {
  return d[0];
}

function tree_x(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

function defaultY(d) {
  return d[1];
}

function tree_y(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

function collide(radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = constant$6(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = quadtree(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = jiggle(), l += x * x;
            if (y === 0) y = jiggle(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : radius;
  };

  return force;
}

function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

function link(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = constant$6(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || jiggle();
        y = target.y + target.vy - source.y - source.vy || jiggle();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = map$1(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant$6(+_), initializeDistance(), force) : distance;
  };

  return force;
}

function x$1(d) {
  return d.x;
}

function y$1(d) {
  return d.y;
}

var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));

function simulation(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = map$1(),
      stepper = timer(step),
      event = dispatch("tick", "end");

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick() {
    var i, n = nodes.length, node;

    alpha += (alphaTarget - alpha) * alphaDecay;

    forces.each(function(force) {
      force(alpha);
    });

    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (node.fx == null) node.x += node.vx *= velocityDecay;
      else node.x = node.fx, node.vx = 0;
      if (node.fy == null) node.y += node.vy *= velocityDecay;
      else node.y = node.fy, node.vy = 0;
    }
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    force: function(name, _) {
      return arguments.length > 1 ? (_ == null ? forces.remove(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}

function manyBody() {
  var nodes,
      node,
      alpha,
      strength = constant$6(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = quadtree(nodes, x$1, y$1).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = jiggle(), l += x * x;
        if (y === 0) y = jiggle(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = jiggle(), l += x * x;
      if (y === 0) y = jiggle(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}

function radial(radius, x, y) {
  var nodes,
      strength = constant$6(0.1),
      strengths,
      radiuses;

  if (typeof radius !== "function") radius = constant$6(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _, initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : radius;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}

function x$2(x) {
  var strength = constant$6(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = constant$6(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : x;
  };

  return force;
}

function y$2(y) {
  var strength = constant$6(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = constant$6(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : y;
  };

  return force;
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent$1(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

function formatDefault(x, p) {
  x = x.toPrecision(p);

  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (x[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      case "e": break out;
      default: if (i0 > 0) i0 = 0; break;
    }
  }

  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "": formatDefault,
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

  var match,
      fill = match[1] || " ",
      align = match[2] || ">",
      sign = match[3] || "-",
      symbol = match[4] || "",
      zero = !!match[5],
      width = match[6] && +match[6],
      comma = !!match[7],
      precision = match[8] && +match[8].slice(1),
      type = match[9] || "";

  // The "n" type is an alias for ",g".
  if (type === "n") comma = true, type = "g";

  // Map invalid types to the default format.
  else if (!formatTypes[type]) type = "";

  // If zero fill is specified, padding goes after sign and before digits.
  if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

  this.fill = fill;
  this.align = align;
  this.sign = sign;
  this.symbol = symbol;
  this.zero = zero;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type;
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + this.type;
};

function identity$3(x) {
  return x;
}

var prefixes = ["y","z","a","f","p","n","\xB5","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$3,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$3,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        type = specifier.type;

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = !type || /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? (type ? 6 : 12)
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;



defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.format = locale.format;
  exports.formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent$1(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;
}

// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/

function adder() {
  return new Adder;
}

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function(y) {
    add$1(temp, y, this.t);
    add$1(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};

var temp = new Adder;

function add$1(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = (a - av) + (b - bv);
}

var epsilon$2 = 1e-6;
var epsilon2$1 = 1e-12;
var pi$3 = Math.PI;
var halfPi$2 = pi$3 / 2;
var quarterPi = pi$3 / 4;
var tau$3 = pi$3 * 2;

var degrees$1 = 180 / pi$3;
var radians = pi$3 / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos$1 = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;

var log = Math.log;
var pow = Math.pow;
var sin$1 = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi$3 : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi$2 : x < -1 ? -halfPi$2 : Math.asin(x);
}

function haversin(x) {
  return (x = sin$1(x / 2)) * x;
}

function noop$1() {}

function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

function geoStream(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

var areaRingSum = adder();

var areaSum = adder();
var lambda00;
var phi00;
var lambda0;
var cosPhi0;
var sinPhi0;

var areaStream = {
  point: noop$1,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: function() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau$3 + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop$1;
  },
  sphere: function() {
    areaSum.add(tau$3);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= radians, phi *= radians;
  lambda0 = lambda, cosPhi0 = cos$1(phi = phi / 2 + quarterPi), sinPhi0 = sin$1(phi);
}

function areaPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  phi = phi / 2 + quarterPi; // half the angular distance from south pole

  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnolis
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = cos$1(phi),
      sinPhi = sin$1(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * cos$1(adLambda),
      v = k * sdLambda * sin$1(adLambda);
  areaRingSum.add(atan2(v, u));

  // Advance the previous points.
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

function area(object) {
  areaSum.reset();
  geoStream(object, areaStream);
  return areaSum * 2;
}

function spherical(cartesian) {
  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
  return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

var lambda0$1;
var phi0;
var lambda1;
var phi1;
var lambda2;
var lambda00$1;
var phi00$1;
var p0;
var deltaSum = adder();
var ranges;
var range;

var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    areaStream.polygonStart();
  },
  polygonEnd: function() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon$2) phi1 = 90;
    else if (deltaSum < -epsilon$2) phi0 = -90;
    range[0] = lambda0$1, range[1] = lambda1;
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = cartesian([lambda * radians, phi * radians]);
  if (p0) {
    var normal = cartesianCross(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2,
        sign$$1 = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * degrees$1 * sign$$1,
        phii,
        antimeridian = abs(delta) > 180;
    if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
      phii = inflection[1] * degrees$1;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
      phii = -inflection[1] * degrees$1;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
      }
    } else {
      if (lambda1 >= lambda0$1) {
        if (lambda < lambda0$1) lambda0$1 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0$1, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00$1 = lambda, phi00$1 = phi;
  }
  areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00$1, phi00$1);
  areaStream.lineEnd();
  if (abs(deltaSum) > epsilon$2) lambda0$1 = -(lambda1 = 180);
  range[0] = lambda0$1, range[1] = lambda1;
  p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want
// the distance between 180 to be 360.
function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

function bounds(feature) {
  var i, n, a, b, merged, deltaMax, delta;

  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
  ranges = [];
  geoStream(feature, boundsStream);

  // First, sort ranges by their minimum longitudes.
  if (n = ranges.length) {
    ranges.sort(rangeCompare);

    // Then, merge any ranges that overlap.
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }

    // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;

  return lambda0$1 === Infinity || phi0 === Infinity
      ? [[NaN, NaN], [NaN, NaN]]
      : [[lambda0$1, phi0], [lambda1, phi1]];
}

var W0;
var W1;
var X0;
var Y0;
var Z0;
var X1;
var Y1;
var Z1;
var X2;
var Y2;
var Z2;
var lambda00$2;
var phi00$2;
var x0;
var y0;
var z0; // previous point

var centroidStream = {
  sphere: noop$1,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi);
  centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi);
  x0 = cosPhi * cos$1(lambda);
  y0 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi),
      x = cosPhi * cos$1(lambda),
      y = cosPhi * sin$1(lambda),
      z = sin$1(phi),
      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00$2, phi00$2);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00$2 = lambda, phi00$2 = phi;
  lambda *= radians, phi *= radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos$1(phi);
  x0 = cosPhi * cos$1(lambda);
  y0 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi),
      x = cosPhi * cos$1(lambda),
      y = cosPhi * sin$1(lambda),
      z = sin$1(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = sqrt(cx * cx + cy * cy + cz * cz),
      w = asin(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroid(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 =
  X2 = Y2 = Z2 = 0;
  geoStream(object, centroidStream);

  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z;

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < epsilon2$1) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < epsilon$2) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z;
    // If the feature still has an undefined ccentroid, then return.
    if (m < epsilon2$1) return [NaN, NaN];
  }

  return [atan2(y, x) * degrees$1, asin(z / sqrt(m)) * degrees$1];
}

function constant$7(x) {
  return function() {
    return x;
  };
}

function compose(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}

function rotationIdentity(lambda, phi) {
  return [lambda > pi$3 ? lambda - tau$3 : lambda < -pi$3 ? lambda + tau$3 : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau$3) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > pi$3 ? lambda - tau$3 : lambda < -pi$3 ? lambda + tau$3 : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos$1(deltaPhi),
      sinDeltaPhi = sin$1(deltaPhi),
      cosDeltaGamma = cos$1(deltaGamma),
      sinDeltaGamma = sin$1(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = cos$1(phi),
        x = cos$1(lambda) * cosPhi,
        y = sin$1(lambda) * cosPhi,
        z = sin$1(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      asin(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = cos$1(phi),
        x = cos$1(lambda) * cosPhi,
        y = sin$1(lambda) * cosPhi,
        z = sin$1(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      asin(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

function rotation(rotate) {
  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
  };

  return forward;
}

// Generates a circle centered at [0, 0], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = cos$1(radius),
      sinRadius = sin$1(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau$3;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$3;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = cartesian(point), point[0] -= cosRadius;
  cartesianNormalizeInPlace(point);
  var radius = acos(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + tau$3 - epsilon$2) % tau$3;
}

function circle() {
  var center = constant$7([0, 0]),
      radius = constant$7(90),
      precision = constant$7(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= degrees$1, x[1] *= degrees$1;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * radians,
        p = precision.apply(this, arguments) * radians;
    ring = [];
    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : constant$7([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$7(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : constant$7(+_), circle) : precision;
  };

  return circle;
}

function clipBuffer() {
  var lines = [],
      line;
  return {
    point: function(x, y) {
      line.push([x, y]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop$1,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

function pointEqual(a, b) {
  return abs(a[0] - b[0]) < epsilon$2 && abs(a[1] - b[1]) < epsilon$2;
}

function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.
    if (pointEqual(p0, p1)) {
      stream.lineStart();
      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link$1(subject);
  link$1(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link$1(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}

var sum$1 = adder();

function polygonContains(polygon, point) {
  var lambda = point[0],
      phi = point[1],
      normal = [sin$1(lambda), -cos$1(lambda), 0],
      angle = 0,
      winding = 0;

  sum$1.reset();

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = point0[0],
        phi0 = point0[1] / 2 + quarterPi,
        sinPhi0 = sin$1(phi0),
        cosPhi0 = cos$1(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = point1[0],
          phi1 = point1[1] / 2 + quarterPi,
          sinPhi1 = sin$1(phi1),
          cosPhi1 = cos$1(phi1),
          delta = lambda1 - lambda0,
          sign$$1 = delta >= 0 ? 1 : -1,
          absDelta = sign$$1 * delta,
          antimeridian = absDelta > pi$3,
          k = sinPhi0 * sinPhi1;

      sum$1.add(atan2(k * sign$$1 * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
      angle += antimeridian ? delta + sign$$1 * tau$3 : delta;

      // Are the longitudes either side of the points meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -epsilon$2 || angle < epsilon$2 && sum$1 < -epsilon$2) ^ (winding & 1);
}

function clip(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = clipBuffer(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi$2 - epsilon$2 : halfPi$2 - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - halfPi$2 - epsilon$2 : halfPi$2 - b[1]);
}

var clipAntimeridian = clip(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi$3, -halfPi$2]
);

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi$3 : -pi$3,
          delta = abs(lambda1 - lambda0);
      if (abs(delta - pi$3) < epsilon$2) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$2 : -halfPi$2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi$3) { // line crosses antimeridian
        if (abs(lambda0 - sign0) < epsilon$2) lambda0 -= sign0 * epsilon$2; // handle degeneracies
        if (abs(lambda1 - sign1) < epsilon$2) lambda1 -= sign1 * epsilon$2;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
  return abs(sinLambda0Lambda1) > epsilon$2
      ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
          - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi$2;
    stream.point(-pi$3, phi);
    stream.point(0, phi);
    stream.point(pi$3, phi);
    stream.point(pi$3, 0);
    stream.point(pi$3, -phi);
    stream.point(0, -phi);
    stream.point(-pi$3, -phi);
    stream.point(-pi$3, 0);
    stream.point(-pi$3, phi);
  } else if (abs(from[0] - to[0]) > epsilon$2) {
    var lambda = from[0] < to[0] ? pi$3 : -pi$3;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

function clipCircle(radius) {
  var cr = cos$1(radius),
      delta = 6 * radians,
      smallRadius = cr > 0,
      notHemisphere = abs(cr) > epsilon$2; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return cos$1(lambda) * cos$1(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? pi$3 : -pi$3), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        // Handle degeneracies.
        // TODO ignore if not clipping polygons.
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
            point1[0] += epsilon$2;
            point1[1] += epsilon$2;
            v = visible(point1[0], point1[1]);
          }
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }
        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = cartesian(a),
        pb = cartesian(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).
    var n1 = [1, 0, 0], // normal
        n2 = cartesianCross(pa, pb),
        n2n2 = cartesianDot(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = cartesianCross(n1, n2),
        A = cartesianScale(n1, c1),
        B = cartesianScale(n2, c2);
    cartesianAddInPlace(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = cartesianDot(A, u),
        uu = cartesianDot(u, u),
        t2 = w * w - uu * (cartesianDot(A, A) - 1);

    if (t2 < 0) return;

    var t = sqrt(t2),
        q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A);
    q = spherical(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = abs(delta - pi$3) < epsilon$2,
        meridian = polar || delta < epsilon$2;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon$2 ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > pi$3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q1, A);
      return [q, spherical(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : pi$3 - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$3, radius - pi$3]);
}

function clipLine(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}

var clipMax = 1e9;
var clipMin = -clipMax;

// TODO Use d3-polygons polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return abs(p[0] - x0) < epsilon$2 ? direction > 0 ? 0 : 3
        : abs(p[0] - x1) < epsilon$2 ? direction > 0 ? 2 : 1
        : abs(p[1] - y0) < epsilon$2 ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = clipBuffer(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = merge(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if (clipLine(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}

function extent$1() {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;

  return clip = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
    },
    extent: function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
}

var lengthSum = adder();
var lambda0$2;
var sinPhi0$1;
var cosPhi0$1;

var lengthStream = {
  sphere: noop$1,
  point: noop$1,
  lineStart: lengthLineStart,
  lineEnd: noop$1,
  polygonStart: noop$1,
  polygonEnd: noop$1
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop$1;
}

function lengthPointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  lambda0$2 = lambda, sinPhi0$1 = sin$1(phi), cosPhi0$1 = cos$1(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var sinPhi = sin$1(phi),
      cosPhi = cos$1(phi),
      delta = abs(lambda - lambda0$2),
      cosDelta = cos$1(delta),
      sinDelta = sin$1(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
  lengthSum.add(atan2(sqrt(x * x + y * y), z));
  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
}

function length$1(object) {
  lengthSum.reset();
  geoStream(object, lengthStream);
  return +lengthSum;
}

var coordinates = [null, null];
var object$1 = {type: "LineString", coordinates: coordinates};

function distance(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return length$1(object$1);
}

var containsObjectType = {
  Feature: function(object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function(object, point) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
    return false;
  }
};

var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPoint(coordinates[i], point)) return true;
    return false;
  },
  LineString: function(object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsLine(coordinates[i], point)) return true;
    return false;
  },
  Polygon: function(object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
    return false;
  },
  GeometryCollection: function(object, point) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) if (containsGeometry(geometries[i], point)) return true;
    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type)
      ? containsGeometryType[geometry.type](geometry, point)
      : false;
}

function containsPoint(coordinates, point) {
  return distance(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ab = distance(coordinates[0], coordinates[1]),
      ao = distance(coordinates[0], point),
      ob = distance(point, coordinates[1]);
  return ao + ob <= ab + epsilon$2;
}

function containsPolygon(coordinates, point) {
  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * radians, point[1] * radians];
}

function contains(object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type)
      ? containsObjectType[object.type]
      : containsGeometry)(object, point);
}

function graticuleX(y0, y1, dy) {
  var y = sequence(y0, y1 - epsilon$2, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = sequence(x0, x1 - epsilon$2, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return sequence(ceil(X0 / DX) * DX, X1, DX).map(X)
        .concat(sequence(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat(sequence(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon$2; }).map(x))
        .concat(sequence(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon$2; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + epsilon$2], [180, 90 - epsilon$2]])
      .extentMinor([[-180, -80 - epsilon$2], [180, 80 + epsilon$2]]);
}

function graticule10() {
  return graticule()();
}

function interpolate$1(a, b) {
  var x0 = a[0] * radians,
      y0 = a[1] * radians,
      x1 = b[0] * radians,
      y1 = b[1] * radians,
      cy0 = cos$1(y0),
      sy0 = sin$1(y0),
      cy1 = cos$1(y1),
      sy1 = sin$1(y1),
      kx0 = cy0 * cos$1(x0),
      ky0 = cy0 * sin$1(x0),
      kx1 = cy1 * cos$1(x1),
      ky1 = cy1 * sin$1(x1),
      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
      k = sin$1(d);

  var interpolate = d ? function(t) {
    var B = sin$1(t *= d) / k,
        A = sin$1(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [
      atan2(y, x) * degrees$1,
      atan2(z, sqrt(x * x + y * y)) * degrees$1
    ];
  } : function() {
    return [x0 * degrees$1, y0 * degrees$1];
  };

  interpolate.distance = d;

  return interpolate;
}

function identity$4(x) {
  return x;
}

var areaSum$1 = adder();
var areaRingSum$1 = adder();
var x00;
var y00;
var x0$1;
var y0$1;

var areaStream$1 = {
  point: noop$1,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: function() {
    areaStream$1.lineStart = areaRingStart$1;
    areaStream$1.lineEnd = areaRingEnd$1;
  },
  polygonEnd: function() {
    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop$1;
    areaSum$1.add(abs(areaRingSum$1));
    areaRingSum$1.reset();
  },
  result: function() {
    var area = areaSum$1 / 2;
    areaSum$1.reset();
    return area;
  }
};

function areaRingStart$1() {
  areaStream$1.point = areaPointFirst$1;
}

function areaPointFirst$1(x, y) {
  areaStream$1.point = areaPoint$1;
  x00 = x0$1 = x, y00 = y0$1 = y;
}

function areaPoint$1(x, y) {
  areaRingSum$1.add(y0$1 * x - x0$1 * y);
  x0$1 = x, y0$1 = y;
}

function areaRingEnd$1() {
  areaPoint$1(x00, y00);
}

var x0$2 = Infinity;
var y0$2 = x0$2;
var x1 = -x0$2;
var y1 = x1;

var boundsStream$1 = {
  point: boundsPoint$1,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: noop$1,
  polygonEnd: noop$1,
  result: function() {
    var bounds = [[x0$2, y0$2], [x1, y1]];
    x1 = y1 = -(y0$2 = x0$2 = Infinity);
    return bounds;
  }
};

function boundsPoint$1(x, y) {
  if (x < x0$2) x0$2 = x;
  if (x > x1) x1 = x;
  if (y < y0$2) y0$2 = y;
  if (y > y1) y1 = y;
}

// TODO Enforce positive area for exterior, negative area for interior?

var X0$1 = 0;
var Y0$1 = 0;
var Z0$1 = 0;
var X1$1 = 0;
var Y1$1 = 0;
var Z1$1 = 0;
var X2$1 = 0;
var Y2$1 = 0;
var Z2$1 = 0;
var x00$1;
var y00$1;
var x0$3;
var y0$3;

var centroidStream$1 = {
  point: centroidPoint$1,
  lineStart: centroidLineStart$1,
  lineEnd: centroidLineEnd$1,
  polygonStart: function() {
    centroidStream$1.lineStart = centroidRingStart$1;
    centroidStream$1.lineEnd = centroidRingEnd$1;
  },
  polygonEnd: function() {
    centroidStream$1.point = centroidPoint$1;
    centroidStream$1.lineStart = centroidLineStart$1;
    centroidStream$1.lineEnd = centroidLineEnd$1;
  },
  result: function() {
    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
        : [NaN, NaN];
    X0$1 = Y0$1 = Z0$1 =
    X1$1 = Y1$1 = Z1$1 =
    X2$1 = Y2$1 = Z2$1 = 0;
    return centroid;
  }
};

function centroidPoint$1(x, y) {
  X0$1 += x;
  Y0$1 += y;
  ++Z0$1;
}

function centroidLineStart$1() {
  centroidStream$1.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream$1.point = centroidPointLine;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidLineEnd$1() {
  centroidStream$1.point = centroidPoint$1;
}

function centroidRingStart$1() {
  centroidStream$1.point = centroidPointFirstRing;
}

function centroidRingEnd$1() {
  centroidPointRing(x00$1, y00$1);
}

function centroidPointFirstRing(x, y) {
  centroidStream$1.point = centroidPointRing;
  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0$3,
      dy = y - y0$3,
      z = sqrt(dx * dx + dy * dy);

  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;

  z = y0$3 * x - x0$3 * y;
  X2$1 += z * (x0$3 + x);
  Y2$1 += z * (y0$3 + y);
  Z2$1 += z * 3;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, tau$3);
        break;
      }
    }
  },
  result: noop$1
};

var lengthSum$1 = adder();
var lengthRing;
var x00$2;
var y00$2;
var x0$4;
var y0$4;

var lengthStream$1 = {
  point: noop$1,
  lineStart: function() {
    lengthStream$1.point = lengthPointFirst$1;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint$1(x00$2, y00$2);
    lengthStream$1.point = noop$1;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum$1;
    lengthSum$1.reset();
    return length;
  }
};

function lengthPointFirst$1(x, y) {
  lengthStream$1.point = lengthPoint$1;
  x00$2 = x0$4 = x, y00$2 = y0$4 = y;
}

function lengthPoint$1(x, y) {
  x0$4 -= x, y0$4 -= y;
  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
  x0$4 = x, y0$4 = y;
}

function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle$1(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle$1(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle$1(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}

function index$1(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      geoStream(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    geoStream(object, projectionStream(areaStream$1));
    return areaStream$1.result();
  };

  path.measure = function(object) {
    geoStream(object, projectionStream(lengthStream$1));
    return lengthStream$1.result();
  };

  path.bounds = function(object) {
    geoStream(object, projectionStream(boundsStream$1));
    return boundsStream$1.result();
  };

  path.centroid = function(object) {
    geoStream(object, projectionStream(centroidStream$1));
    return centroidStream$1.result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$4) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}

function transform(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};

function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  geoStream(object, projection.stream(boundsStream$1));
  fitBounds(boundsStream$1.result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

var maxDepth = 16;
var cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)

function resample(project, delta2) {
  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return transformer({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample$1(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = sqrt(a * a + b * b + c * c),
          phi2 = asin(c /= m),
          lambda2 = abs(abs(c) - 1) < epsilon$2 || abs(lambda0 - lambda1) < epsilon$2 ? (lambda0 + lambda1) / 2 : atan2(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = cartesian([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

var transformRadians = transformer({
  point: function(x, y) {
    this.stream.point(x * radians, y * radians);
  }
});

function transformRotate(rotate) {
  return transformer({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      dx, dy, lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate
      theta = null, preclip = clipAntimeridian, // clip angle
      x0 = null, y0, x1, y1, postclip = identity$4, // clip extent
      delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision
      cache,
      cacheStream;

  function projection(point) {
    point = projectRotate(point[0] * radians, point[1] * radians);
    return [point[0] * k + dx, dy - point[1] * k];
  }

  function invert(point) {
    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
    return point && [point[0] * degrees$1, point[1] * degrees$1];
  }

  function projectTransform(x, y) {
    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees$1;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees$1, phi * degrees$1];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return fitExtent(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return fitSize(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return fitWidth(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return fitHeight(projection, height, object);
  };

  function recenter() {
    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
    var center = project(lambda, phi);
    dx = x - center[0] * k;
    dy = y + center[1] * k;
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = pi$3 / 3,
      m = projectionMutator(projectAt),
      p = m(phi0, phi1);

  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees$1, phi1 * degrees$1];
  };

  return p;
}

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos$1(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
  }

  forward.invert = function(x, y) {
    return [x / cosPhi0, asin(y * cosPhi0)];
  };

  return forward;
}

function conicEqualAreaRaw(y0, y1) {
  var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;

  // Are the parallels symmetrical around the Equator?
  if (abs(n) < epsilon$2) return cylindricalEqualAreaRaw(y0);

  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;

  function project(x, y) {
    var r = sqrt(c - 2 * n * sin$1(y)) / n;
    return [r * sin$1(x *= n), r0 - r * cos$1(x)];
  }

  project.invert = function(x, y) {
    var r0y = r0 - y;
    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

function conicEqualArea() {
  return conicProjection(conicEqualAreaRaw)
      .scale(155.424)
      .center([0, 33.6442]);
}

function albers() {
  return conicEqualArea()
      .parallels([29.5, 45.5])
      .scale(1070)
      .translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
}

// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
  };
}

// A composite projection for the United States, configured by default for
// 960500. The projection also works quite well at 960600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
function albersUsa() {
  var cache,
      cacheStream,
      lower48 = albers(), lower48Point,
      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
      point, pointStream = {point: function(x, y) { point = [x, y]; }};

  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point = null, (lower48Point.point(x, y), point)
        || (alaskaPoint.point(x, y), point)
        || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
        : lower48).invert(coordinates);
  };

  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x = +_[0], y = +_[1];

    lower48Point = lower48
        .translate(_)
        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
        .stream(pointStream);

    alaskaPoint = alaska
        .translate([x - 0.307 * k, y + 0.201 * k])
        .clipExtent([[x - 0.425 * k + epsilon$2, y + 0.120 * k + epsilon$2], [x - 0.214 * k - epsilon$2, y + 0.234 * k - epsilon$2]])
        .stream(pointStream);

    hawaiiPoint = hawaii
        .translate([x - 0.205 * k, y + 0.212 * k])
        .clipExtent([[x - 0.214 * k + epsilon$2, y + 0.166 * k + epsilon$2], [x - 0.115 * k - epsilon$2, y + 0.234 * k - epsilon$2]])
        .stream(pointStream);

    return reset();
  };

  albersUsa.fitExtent = function(extent, object) {
    return fitExtent(albersUsa, extent, object);
  };

  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };

  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };

  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
}

function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = cos$1(x),
        cy = cos$1(y),
        k = scale(cx * cy);
    return [
      k * cy * sin$1(x),
      k * sin$1(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = sqrt(x * x + y * y),
        c = angle(z),
        sc = sin$1(c),
        cc = cos$1(c);
    return [
      atan2(x * sc, z * cc),
      asin(z && y * sc / z)
    ];
  }
}

var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});

function azimuthalEqualArea() {
  return projection(azimuthalEqualAreaRaw)
      .scale(124.75)
      .clipAngle(180 - 1e-3);
}

var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
  return (c = acos(c)) && c / sin$1(c);
});

azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});

function azimuthalEquidistant() {
  return projection(azimuthalEquidistantRaw)
      .scale(79.4188)
      .clipAngle(180 - 1e-3);
}

function mercatorRaw(lambda, phi) {
  return [lambda, log(tan((halfPi$2 + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
  return [x, 2 * atan(exp(y)) - halfPi$2];
};

function mercator() {
  return mercatorProjection(mercatorRaw)
      .scale(961 / tau$3);
}

function mercatorProjection(project) {
  var m = projection(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null, y0, x1, y1; // clip extent

  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function(_) {
    return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = pi$3 * scale(),
        t = m(rotation(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null
        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}

function tany(y) {
  return tan((halfPi$2 + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = cos$1(y0),
      n = y0 === y1 ? sin$1(y0) : log(cy0 / cos$1(y1)) / log(tany(y1) / tany(y0)),
      f = cy0 * pow(tany(y0), n) / n;

  if (!n) return mercatorRaw;

  function project(x, y) {
    if (f > 0) { if (y < -halfPi$2 + epsilon$2) y = -halfPi$2 + epsilon$2; }
    else { if (y > halfPi$2 - epsilon$2) y = halfPi$2 - epsilon$2; }
    var r = f / pow(tany(y), n);
    return [r * sin$1(n * x), f - r * cos$1(n * x)];
  }

  project.invert = function(x, y) {
    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi$2];
  };

  return project;
}

function conicConformal() {
  return conicProjection(conicConformalRaw)
      .scale(109.5)
      .parallels([30, 30]);
}

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

function equirectangular() {
  return projection(equirectangularRaw)
      .scale(152.63);
}

function conicEquidistantRaw(y0, y1) {
  var cy0 = cos$1(y0),
      n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
      g = cy0 / n + y0;

  if (abs(n) < epsilon$2) return equirectangularRaw;

  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * sin$1(nx), g - gy * cos$1(nx)];
  }

  project.invert = function(x, y) {
    var gy = g - y;
    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
  };

  return project;
}

function conicEquidistant() {
  return conicProjection(conicEquidistantRaw)
      .scale(131.154)
      .center([0, 13.9389]);
}

function gnomonicRaw(x, y) {
  var cy = cos$1(y), k = cos$1(x) * cy;
  return [cy * sin$1(x) / k, sin$1(y) / k];
}

gnomonicRaw.invert = azimuthalInvert(atan);

function gnomonic() {
  return projection(gnomonicRaw)
      .scale(144.049)
      .clipAngle(60);
}

function scaleTranslate(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity$4 : transformer({
    point: function(x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

function identity$5() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform$$1 = identity$4, // scale, translate and reflect
      x0 = null, y0, x1, y1, // clip extent
      postclip = identity$4,
      cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = transform$$1(postclip(cacheStream = stream));
    },
    postclip: function(_) {
      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    },
    clipExtent: function(_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function(_) {
      return arguments.length ? (transform$$1 = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function(_) {
      return arguments.length ? (transform$$1 = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function(_) {
      return arguments.length ? (transform$$1 = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function(_) {
      return arguments.length ? (transform$$1 = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function(extent, object) {
      return fitExtent(projection, extent, object);
    },
    fitSize: function(size, object) {
      return fitSize(projection, size, object);
    },
    fitWidth: function(width, object) {
      return fitWidth(projection, width, object);
    },
    fitHeight: function(height, object) {
      return fitHeight(projection, height, object);
    }
  };
}

function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
  ];
}

naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while (abs(delta) > epsilon$2 && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
    phi
  ];
};

function naturalEarth1() {
  return projection(naturalEarth1Raw)
      .scale(175.295);
}

function orthographicRaw(x, y) {
  return [cos$1(y) * sin$1(x), sin$1(y)];
}

orthographicRaw.invert = azimuthalInvert(asin);

function orthographic() {
  return projection(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + epsilon$2);
}

function stereographicRaw(x, y) {
  var cy = cos$1(y), k = 1 + cos$1(x) * cy;
  return [cy * sin$1(x) / k, sin$1(y) / k];
}

stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});

function stereographic() {
  return projection(stereographicRaw)
      .scale(250)
      .clipAngle(142);
}

function transverseMercatorRaw(lambda, phi) {
  return [log(tan((halfPi$2 + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * atan(exp(x)) - halfPi$2];
};

function transverseMercator() {
  var m = mercatorProjection(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90])
      .scale(159.155);
}

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

function cluster() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
}

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

function node_count() {
  return this.eachAfter(count);
}

function node_each(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
}

function node_eachBefore(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
}

function node_eachAfter(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
}

function node_sum(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}

function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

function node_path(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

function node_descendants() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
}

function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

function node_links() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Dont include the roots parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

var slice$3 = Array.prototype.slice;

function shuffle$1(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

function enclose(circles) {
  var i = 0, n = (circles = shuffle$1(slice$3.call(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

function place(a, b, c) {
  var ax = a.x,
      ay = a.y,
      da = b.r + c.r,
      db = a.r + c.r,
      dx = b.x - ax,
      dy = b.y - ay,
      dc = dx * dx + dy * dy;
  if (dc) {
    var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
    c.x = ax + x * dx + y * dy;
    c.y = ay + x * dy - y * dx;
  } else {
    c.x = ax + db;
    c.y = ay;
  }
}

function intersects(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r + b.r;
  return dr * dr - 1e-6 > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node$1(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // Closeness is determined by linear distance along the front-chain.
    // Ahead or behind is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

function siblings(circles) {
  packEnclose(circles);
  return circles;
}

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

function constantZero() {
  return 0;
}

function constant$8(x) {
  return function() {
    return x;
  };
}

function defaultRadius$1(d) {
  return Math.sqrt(d.value);
}

function index$2() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius$1))
          .eachAfter(packChildren(constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant$8(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

function roundNode(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

function treemapDice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

function partition() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}

var keyPrefix$1 = "$";
var preroot = {depth: -1};
var ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function stratify() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix$1 + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix$1 + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
}

function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
function tree() {
  var separation = defaultSeparation$1,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
}

function treemapSlice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var squarify = (function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi);

function index$3() {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$8(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$8(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$8(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$8(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$8(+x), treemap) : paddingLeft;
  };

  return treemap;
}

function binary(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}

function sliceDice(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
}

var resquarify = (function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
})(phi);

function area$1(polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
}

function centroid$1(polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
}

// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
function cross$1(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
}

function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}

// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

function hull(points) {
  if ((n = points.length) < 3) return null;

  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints);

  // Construct the hull polygon, removing possible duplicate endpoints.
  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = [];

  // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.
  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
}

function contains$1(polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0], y = point[1],
      x0 = p[0], y0 = p[1],
      x1, y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
}

function length$2(polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }

  return perimeter;
}

var slice$4 = [].slice;

var noabort = {};

function Queue(size) {
  this._size = size;
  this._call =
  this._error = null;
  this._tasks = [];
  this._data = [];
  this._waiting =
  this._active =
  this._ended =
  this._start = 0; // inside a synchronous task callback?
}

Queue.prototype = queue.prototype = {
  constructor: Queue,
  defer: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("defer after await");
    if (this._error != null) return this;
    var t = slice$4.call(arguments, 1);
    t.push(callback);
    ++this._waiting, this._tasks.push(t);
    poke$1(this);
    return this;
  },
  abort: function() {
    if (this._error == null) abort(this, new Error("abort"));
    return this;
  },
  await: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = function(error, results) { callback.apply(null, [error].concat(results)); };
    maybeNotify(this);
    return this;
  },
  awaitAll: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = callback;
    maybeNotify(this);
    return this;
  }
};

function poke$1(q) {
  if (!q._start) {
    try { start$1(q); } // let the current task complete
    catch (e) {
      if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously
      else if (!q._data) throw e; // await callback errored synchronously
    }
  }
}

function start$1(q) {
  while (q._start = q._waiting && q._active < q._size) {
    var i = q._ended + q._active,
        t = q._tasks[i],
        j = t.length - 1,
        c = t[j];
    t[j] = end(q, i);
    --q._waiting, ++q._active;
    t = c.apply(null, t);
    if (!q._tasks[i]) continue; // task finished synchronously
    q._tasks[i] = t || noabort;
  }
}

function end(q, i) {
  return function(e, r) {
    if (!q._tasks[i]) return; // ignore multiple callbacks
    --q._active, ++q._ended;
    q._tasks[i] = null;
    if (q._error != null) return; // ignore secondary errors
    if (e != null) {
      abort(q, e);
    } else {
      q._data[i] = r;
      if (q._waiting) poke$1(q);
      else maybeNotify(q);
    }
  };
}

function abort(q, e) {
  var i = q._tasks.length, t;
  q._error = e; // ignore active callbacks
  q._data = undefined; // allow gc
  q._waiting = NaN; // prevent starting

  while (--i >= 0) {
    if (t = q._tasks[i]) {
      q._tasks[i] = null;
      if (t.abort) {
        try { t.abort(); }
        catch (e) { /* ignore */ }
      }
    }
  }

  q._active = NaN; // allow notification
  maybeNotify(q);
}

function maybeNotify(q) {
  if (!q._active && q._call) {
    var d = q._data;
    q._data = undefined; // allow gc
    q._call(q._error, d);
  }
}

function queue(concurrency) {
  if (concurrency == null) concurrency = Infinity;
  else if (!((concurrency = +concurrency) >= 1)) throw new Error("invalid concurrency");
  return new Queue(concurrency);
}

function defaultSource$1() {
  return Math.random();
}

var uniform = (function sourceRandomUniform(source) {
  function randomUniform(min, max) {
    min = min == null ? 0 : +min;
    max = max == null ? 1 : +max;
    if (arguments.length === 1) max = min, min = 0;
    else max -= min;
    return function() {
      return source() * max + min;
    };
  }

  randomUniform.source = sourceRandomUniform;

  return randomUniform;
})(defaultSource$1);

var normal = (function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y;

      // If available, use the second previously-generated uniform random.
      if (x != null) y = x, x = null;

      // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);

      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;

  return randomNormal;
})(defaultSource$1);

var logNormal = (function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = normal.source(source).apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }

  randomLogNormal.source = sourceRandomLogNormal;

  return randomLogNormal;
})(defaultSource$1);

var irwinHall = (function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function() {
      for (var sum = 0, i = 0; i < n; ++i) sum += source();
      return sum;
    };
  }

  randomIrwinHall.source = sourceRandomIrwinHall;

  return randomIrwinHall;
})(defaultSource$1);

var bates = (function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = irwinHall.source(source)(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }

  randomBates.source = sourceRandomBates;

  return randomBates;
})(defaultSource$1);

var exponential$1 = (function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log(1 - source()) / lambda;
    };
  }

  randomExponential.source = sourceRandomExponential;

  return randomExponential;
})(defaultSource$1);

function request(url, callback) {
  var request,
      event = dispatch("beforesend", "progress", "load", "error"),
      mimeType,
      headers = map$1(),
      xhr = new XMLHttpRequest,
      user = null,
      password = null,
      response,
      responseType,
      timeout = 0;

  // If IE does not support CORS, use XDomainRequest.
  if (typeof XDomainRequest !== "undefined"
      && !("withCredentials" in xhr)
      && /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest;

  "onload" in xhr
      ? xhr.onload = xhr.onerror = xhr.ontimeout = respond
      : xhr.onreadystatechange = function(o) { xhr.readyState > 3 && respond(o); };

  function respond(o) {
    var status = xhr.status, result;
    if (!status && hasResponse(xhr)
        || status >= 200 && status < 300
        || status === 304) {
      if (response) {
        try {
          result = response.call(request, xhr);
        } catch (e) {
          event.call("error", request, e);
          return;
        }
      } else {
        result = xhr;
      }
      event.call("load", request, result);
    } else {
      event.call("error", request, o);
    }
  }

  xhr.onprogress = function(e) {
    event.call("progress", request, e);
  };

  request = {
    header: function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers.get(name);
      if (value == null) headers.remove(name);
      else headers.set(name, value + "");
      return request;
    },

    // If mimeType is non-null and no Accept header is set, a default is used.
    mimeType: function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return request;
    },

    // Specifies what type the response value should take;
    // for instance, arraybuffer, blob, document, or text.
    responseType: function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return request;
    },

    timeout: function(value) {
      if (!arguments.length) return timeout;
      timeout = +value;
      return request;
    },

    user: function(value) {
      return arguments.length < 1 ? user : (user = value == null ? null : value + "", request);
    },

    password: function(value) {
      return arguments.length < 1 ? password : (password = value == null ? null : value + "", request);
    },

    // Specify how to convert the response content to a specific type;
    // changes the callback value on "load" events.
    response: function(value) {
      response = value;
      return request;
    },

    // Alias for send("GET", ).
    get: function(data, callback) {
      return request.send("GET", data, callback);
    },

    // Alias for send("POST", ).
    post: function(data, callback) {
      return request.send("POST", data, callback);
    },

    // If callback is non-null, it will be used for error and load events.
    send: function(method, data, callback) {
      xhr.open(method, url, true, user, password);
      if (mimeType != null && !headers.has("accept")) headers.set("accept", mimeType + ",*/*");
      if (xhr.setRequestHeader) headers.each(function(value, name) { xhr.setRequestHeader(name, value); });
      if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);
      if (responseType != null) xhr.responseType = responseType;
      if (timeout > 0) xhr.timeout = timeout;
      if (callback == null && typeof data === "function") callback = data, data = null;
      if (callback != null && callback.length === 1) callback = fixCallback(callback);
      if (callback != null) request.on("error", callback).on("load", function(xhr) { callback(null, xhr); });
      event.call("beforesend", request, xhr);
      xhr.send(data == null ? null : data);
      return request;
    },

    abort: function() {
      xhr.abort();
      return request;
    },

    on: function() {
      var value = event.on.apply(event, arguments);
      return value === event ? request : value;
    }
  };

  if (callback != null) {
    if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
    return request.get(callback);
  }

  return request;
}

function fixCallback(callback) {
  return function(error, xhr) {
    callback(error == null ? xhr : null);
  };
}

function hasResponse(xhr) {
  var type = xhr.responseType;
  return type && type !== "text"
      ? xhr.response // null on error
      : xhr.responseText; // "" on error
}

function type$1(defaultMimeType, response) {
  return function(url, callback) {
    var r = request(url).mimeType(defaultMimeType).response(response);
    if (callback != null) {
      if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
      return r.get(callback);
    }
    return r;
  };
}

var html = type$1("text/html", function(xhr) {
  return document.createRange().createContextualFragment(xhr.responseText);
});

var json = type$1("application/json", function(xhr) {
  return JSON.parse(xhr.responseText);
});

var text = type$1("text/plain", function(xhr) {
  return xhr.responseText;
});

var xml = type$1("application/xml", function(xhr) {
  var xml = xhr.responseXML;
  if (!xml) throw new Error("parse error");
  return xml;
});

function dsv$1(defaultMimeType, parse) {
  return function(url, row, callback) {
    if (arguments.length < 3) callback = row, row = null;
    var r = request(url).mimeType(defaultMimeType);
    r.row = function(_) { return arguments.length ? r.response(responseOf(parse, row = _)) : row; };
    r.row(row);
    return callback ? r.get(callback) : r;
  };
}

function responseOf(parse, row) {
  return function(request$$1) {
    return parse(request$$1.responseText, row);
  };
}

var csv$1 = dsv$1("text/csv", csvParse);

var tsv$1 = dsv$1("text/tab-separated-values", tsvParse);

var array$2 = Array.prototype;

var map$3 = array$2.map;
var slice$5 = array$2.slice;

var implicit = {name: "implicit"};

function ordinal(range) {
  var index = map$1(),
      domain = [],
      unknown = implicit;

  range = range == null ? [] : slice$5.call(range);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = map$1();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$5.call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range$$1 = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range$$1[1] < range$$1[0],
        start = range$$1[reverse - 0],
        stop = range$$1[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = sequence(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice();
  };

  scale.rangeRound = function(_) {
    return range$$1 = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band()
        .domain(domain())
        .range(range$$1)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point$1() {
  return pointish(band().paddingInner(1));
}

function constant$9(x) {
  return function() {
    return x;
  };
}

function number$2(x) {
  return +x;
}

var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant$9(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap(domain, range, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = bisectRight(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range = unit,
      interpolate$$1 = interpolateValue,
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map$3.call(_, number$2), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$5.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = slice$5.call(_), interpolate$$1 = interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
  };

  return rescale();
}

function tickFormat(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = tickStep(start, stop, count == null ? 10 : count),
      precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return exports.formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return exports.format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return tickFormat(domain(), count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear$2() {
  var scale = continuous(deinterpolateLinear, reinterpolate);

  scale.copy = function() {
    return copy(scale, linear$2());
  };

  return linearish(scale);
}

function identity$6() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = map$3.call(_, number$2), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity$6().domain(domain);
  };

  return linearish(scale);
}

function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : constant$9(b);
}

function reinterpolate$1(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log$1() {
  var scale = continuous(deinterpolate, reinterpolate$1).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = exports.format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return copy(scale, log$1().base(base));
  };

  return scale;
}

function raise$1(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow$1() {
  var exponent = 1,
      scale = continuous(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise$1(b, exponent) - (a = raise$1(a, exponent)))
        ? function(x) { return (raise$1(x, exponent) - a) / b; }
        : constant$9(b);
  }

  function reinterpolate(a, b) {
    b = raise$1(b, exponent) - (a = raise$1(a, exponent));
    return function(t) { return raise$1(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return copy(scale, pow$1().exponent(exponent));
  };

  return linearish(scale);
}

function sqrt$1() {
  return pow$1().exponent(0.5);
}

function quantile$$1() {
  var domain = [],
      range = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = threshold(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range[bisectRight(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$5.call(_), rescale()) : range.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile$$1()
        .domain(domain)
        .range(range);
  };

  return scale;
}

function quantize$1() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1];

  function scale(x) {
    if (x <= x) return range[bisectRight(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = slice$5.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize$1()
        .domain([x0, x1])
        .range(range);
  };

  return linearish(scale);
}

function threshold$1() {
  var domain = [0.5],
      range = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range[bisectRight(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice$5.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$5.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold$1()
        .domain(domain)
        .range(range);
  };

  return scale;
}

var t0$1 = new Date;
var t1$1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0$1.setTime(+start), t1$1.setTime(+end);
      floori(t0$1), floori(t1$1);
      return Math.floor(count(t0$1, t1$1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

var milliseconds = millisecond.range;

var durationSecond$1 = 1e3;
var durationMinute$1 = 6e4;
var durationHour$1 = 36e5;
var durationDay$1 = 864e5;
var durationWeek$1 = 6048e5;

var second = newInterval(function(date) {
  date.setTime(Math.floor(date / durationSecond$1) * durationSecond$1);
}, function(date, step) {
  date.setTime(+date + step * durationSecond$1);
}, function(start, end) {
  return (end - start) / durationSecond$1;
}, function(date) {
  return date.getUTCSeconds();
});

var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(Math.floor(date / durationMinute$1) * durationMinute$1);
}, function(date, step) {
  date.setTime(+date + step * durationMinute$1);
}, function(start, end) {
  return (end - start) / durationMinute$1;
}, function(date) {
  return date.getMinutes();
});

var minutes = minute.range;

var hour = newInterval(function(date) {
  var offset = date.getTimezoneOffset() * durationMinute$1 % durationHour$1;
  if (offset < 0) offset += durationHour$1;
  date.setTime(Math.floor((+date - offset) / durationHour$1) * durationHour$1 + offset);
}, function(date, step) {
  date.setTime(+date + step * durationHour$1);
}, function(start, end) {
  return (end - start) / durationHour$1;
}, function(date) {
  return date.getHours();
});

var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1;
}, function(date) {
  return date.getDate() - 1;
});

var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute$1);
}, function(start, end) {
  return (end - start) / durationMinute$1;
}, function(date) {
  return date.getUTCMinutes();
});

var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour$1);
}, function(start, end) {
  return (end - start) / durationHour$1;
}, function(date) {
  return date.getUTCHours();
});

var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay$1;
}, function(date) {
  return date.getUTCDate() - 1;
});

var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek$1;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

var utcYears = utcYear.range;

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale$1(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day$$1;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day$$1 = week.getUTCDay();
          week = day$$1 > 4 || day$$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day$$1 = week.getDay();
          week = day$$1 > 4 || day$$1 === 0 ? monday.ceil(week) : monday(week);
          week = day.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day$$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"};
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + day.count(year(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day$$1 = d.getDay();
  return day$$1 === 0 ? 7 : day$$1;
}

function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(year(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day$$1 = d.getDay();
  d = (day$$1 >= 4 || day$$1 === 0) ? thursday(d) : thursday.ceil(d);
  return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(monday.count(year(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day$$1 = d.getUTCDay();
  d = (day$$1 >= 4 || day$$1 === 0) ? utcThursday(d) : utcThursday.ceil(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale$1;





defaultLocale$1({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  exports.timeFormat = locale$1.format;
  exports.timeParse = locale$1.parse;
  exports.utcFormat = locale$1.utcFormat;
  exports.utcParse = locale$1.utcParse;
  return locale$1;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

var durationSecond = 1000;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

function date$1(t) {
  return new Date(t);
}

function number$3(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format) {
  var scale = continuous(deinterpolateLinear, reinterpolate),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second$$1,  1,      durationSecond],
    [second$$1,  5,  5 * durationSecond],
    [second$$1, 15, 15 * durationSecond],
    [second$$1, 30, 30 * durationSecond],
    [minute$$1,  1,      durationMinute],
    [minute$$1,  5,  5 * durationMinute],
    [minute$$1, 15, 15 * durationMinute],
    [minute$$1, 30, 30 * durationMinute],
    [  hour$$1,  1,      durationHour  ],
    [  hour$$1,  3,  3 * durationHour  ],
    [  hour$$1,  6,  6 * durationHour  ],
    [  hour$$1, 12, 12 * durationHour  ],
    [   day$$1,  1,      durationDay   ],
    [   day$$1,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month$$1,  1,      durationMonth ],
    [ month$$1,  3,  3 * durationMonth ],
    [  year$$1,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second$$1(date) < date ? formatMillisecond
        : minute$$1(date) < date ? formatSecond
        : hour$$1(date) < date ? formatMinute
        : day$$1(date) < date ? formatHour
        : month$$1(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year$$1(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = tickStep(start / durationYear, stop / durationYear, interval);
        interval = year$$1;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(tickStep(start, stop, interval), 1);
        interval = millisecond$$1;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(map$3.call(_, number$3)) : domain().map(date$1);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format));
  };

  return scale;
}

function time() {
  return calendar(year, month, sunday, day, hour, minute, second, millisecond, exports.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
}

function utcTime() {
  return calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, exports.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
}

function colors(s) {
  return s.match(/.{6}/g).map(function(x) {
    return "#" + x;
  });
}

var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

var cubehelix$3 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

var rainbow = cubehelix();

function rainbow$1(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
}

function ramp(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return linearish(scale);
}

function constant$10(x) {
  return function constant() {
    return x;
  };
}

var abs$1 = Math.abs;
var atan2$1 = Math.atan2;
var cos$2 = Math.cos;
var max$2 = Math.max;
var min$1 = Math.min;
var sin$2 = Math.sin;
var sqrt$2 = Math.sqrt;

var epsilon$3 = 1e-12;
var pi$4 = Math.PI;
var halfPi$3 = pi$4 / 2;
var tau$4 = 2 * pi$4;

function acos$1(x) {
  return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);
}

function asin$1(x) {
  return x >= 1 ? halfPi$3 : x <= -1 ? -halfPi$3 : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt$2(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt$2(max$2(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant$10(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi$3,
        a1 = endAngle.apply(this, arguments) - halfPi$3,
        da = abs$1(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon$3)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau$4 - epsilon$3) {
      context.moveTo(r1 * cos$2(a0), r1 * sin$2(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon$3) {
        context.moveTo(r0 * cos$2(a1), r0 * sin$2(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon$3) && (padRadius ? +padRadius.apply(this, arguments) : sqrt$2(r0 * r0 + r1 * r1)),
          rc = min$1(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1  r0, da1  da0.
      if (rp > epsilon$3) {
        var p0 = asin$1(rp / r0 * sin$2(ap)),
            p1 = asin$1(rp / r1 * sin$2(ap));
        if ((da0 -= p0 * 2) > epsilon$3) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$3) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos$2(a01),
          y01 = r1 * sin$2(a01),
          x10 = r0 * cos$2(a10),
          y10 = r0 * sin$2(a10);

      // Apply rounded corners?
      if (rc > epsilon$3) {
        var x11 = r1 * cos$2(a11),
            y11 = r1 * sin$2(a11),
            x00 = r0 * cos$2(a00),
            y00 = r0 * sin$2(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < pi$4) {
          var oc = da0 > epsilon$3 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin$2(acos$1((ax * bx + ay * by) / (sqrt$2(ax * ax + ay * ay) * sqrt$2(bx * bx + by * by))) / 2),
              lc = sqrt$2(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min$1(rc, (r0 - lc) / (kc - 1));
          rc1 = min$1(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon$3)) context.moveTo(x01, y01);

      // Does the sectors outer ring have rounded corners?
      else if (rc1 > epsilon$3) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and its a circular sector?
      // Or perhaps its an annular sector collapsed due to padding?
      if (!(r0 > epsilon$3) || !(da0 > epsilon$3)) context.lineTo(x10, y10);

      // Does the sectors inner ring (or point) have rounded corners?
      else if (rc0 > epsilon$3) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$4 / 2;
    return [cos$2(a) * r, sin$2(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$10(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$10(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$10(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$10(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$10(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$10(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$10(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };

  return arc;
}

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

function curveLinear(context) {
  return new Linear(context);
}

function x$3(p) {
  return p[0];
}

function y$3(p) {
  return p[1];
}

function line() {
  var x$$1 = x$3,
      y$$1 = y$3,
      defined = constant$10(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$10(+_), line) : x$$1;
  };

  line.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$10(+_), line) : y$$1;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$10(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function area$2() {
  var x0 = x$3,
      x1 = null,
      y0 = constant$10(0),
      y1 = y$3,
      defined = constant$10(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$10(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$10(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$10(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$10(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$10(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$10(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$10(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

function descending$1(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function identity$7(d) {
  return d;
}

function pie() {
  var value = identity$7,
      sortValues = descending$1,
      sort = null,
      startAngle = constant$10(0),
      endAngle = constant$10(tau$4),
      padAngle = constant$10(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau$4, Math.max(-tau$4, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$10(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$10(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$10(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$10(+_), pie) : padAngle;
  };

  return pie;
}

var curveRadialLinear = curveRadial(curveLinear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

function lineRadial$1() {
  return lineRadial(line().curve(curveRadialLinear));
}

function areaRadial() {
  var a = area$2().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
}

function pointRadial(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

var slice$6 = Array.prototype.slice;

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link$2(curve) {
  var source = linkSource,
      target = linkTarget,
      x$$1 = x$3,
      y$$1 = y$3,
      context = null;

  function link() {
    var buffer, argv = slice$6.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = path();
    curve(context, +x$$1.apply(this, (argv[0] = s, argv)), +y$$1.apply(this, argv), +x$$1.apply(this, (argv[0] = t, argv)), +y$$1.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$10(+_), link) : x$$1;
  };

  link.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$10(+_), link) : y$$1;
  };

  link.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial$1(context, x0, y0, x1, y1) {
  var p0 = pointRadial(x0, y0),
      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
      p2 = pointRadial(x1, y0),
      p3 = pointRadial(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link$2(curveHorizontal);
}

function linkVertical() {
  return link$2(curveVertical);
}

function linkRadial() {
  var l = link$2(curveRadial$1);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

var circle$2 = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi$4);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau$4);
  }
};

var cross$2 = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30 = Math.sqrt(1 / 3);
var tan30_2 = tan30 * 2;

var diamond = {
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka = 0.89081309152928522810;
var kr = Math.sin(pi$4 / 10) / Math.sin(7 * pi$4 / 10);
var kx = Math.sin(tau$4 / 10) * kr;
var ky = -Math.cos(tau$4 / 10) * kr;

var star = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau$4 * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
};

var square = {
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3 = Math.sqrt(3);

var triangle = {
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};

var c = -0.5;
var s = Math.sqrt(3) / 2;
var k = 1 / Math.sqrt(12);
var a = (k / 2 + 1) * 3;

var wye = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};

var symbols = [
  circle$2,
  cross$2,
  diamond,
  square,
  star,
  triangle,
  wye
];

function symbol() {
  var type = constant$10(circle$2),
      size = constant$10(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant$10(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant$10(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}

function noop$2() {}

function point$2(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point$2(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point$2(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basis$2(context) {
  return new Basis(context);
}

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point$2(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisClosed$1(context) {
  return new BasisClosed(context);
}

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point$2(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisOpen(context) {
  return new BasisOpen(context);
}

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle = (function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function point$3(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$3(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$3(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$3(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed = (function custom(tension) {

  function cardinal$$1(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal$$1.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal$$1;
})(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$3(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen = (function custom(tension) {

  function cardinal$$1(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal$$1.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal$$1;
})(0);

function point$4(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon$3) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon$3) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$4(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$4(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed = (function custom(alpha) {

  function catmullRom$$1(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom$$1.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom$$1;
})(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$4(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen = (function custom(alpha) {

  function catmullRom$$1(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom$$1.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom$$1;
})(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

function linearClosed(context) {
  return new LinearClosed(context);
}

function sign$1(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bzier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$5(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$5(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$5(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$5(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

function natural(context) {
  return new Natural(context);
}

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

function step(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

function none$1(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

function none$2(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

function stackValue(d, key) {
  return d[key];
}

function stack() {
  var keys = constant$10([]),
      order = none$2,
      offset = none$1,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant$10(slice$6.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$10(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none$2 : typeof _ === "function" ? _ : constant$10(slice$6.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
  };

  return stack;
}

function expand(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none$1(series, order);
}

function diverging(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
}

function silhouette(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none$1(series, order);
}

function wiggle(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none$1(series, order);
}

function ascending$2(series) {
  var sums = series.map(sum$2);
  return none$2(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum$2(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

function descending$2(series) {
  return ascending$2(series).reverse();
}

function insideOut(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum$2),
      order = none$2(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

function reverse(series) {
  return none$2(series).reverse();
}

function constant$11(x) {
  return function() {
    return x;
  };
}

function x$4(d) {
  return d[0];
}

function y$4(d) {
  return d[1];
}

function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) { node.C = false; return; }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if ((sibling.L && sibling.L.C)
            || (sibling.R && sibling.R.C)) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if ((sibling.L && sibling.L.C)
          || (sibling.R && sibling.R.C)) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}

function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  cells[left.index].halfedges.push(index);
  cells[right.index].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// LiangBarsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];
      else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];
      else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
        || !clipEdge(edge, x0, y0, x1, y1)
        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$4
            || Math.abs(edge[0][1] - edge[1][1]) > epsilon$4)) {
      delete edges[i];
    }
  }
}

function createCell(site) {
  return cells[site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      index.sort(function(i, j) { return array[j] - array[i]; });
      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon$4 || Math.abs(endY - startY) > epsilon$4) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
              Math.abs(endX - x0) < epsilon$4 && y1 - endY > epsilon$4 ? [x0, Math.abs(startX - x0) < epsilon$4 ? startY : y1]
              : Math.abs(endY - y1) < epsilon$4 && x1 - endX > epsilon$4 ? [Math.abs(startY - y1) < epsilon$4 ? startX : x1, y1]
              : Math.abs(endX - x1) < epsilon$4 && endY - y0 > epsilon$4 ? [x1, Math.abs(startX - x1) < epsilon$4 ? startY : y0]
              : Math.abs(endY - y0) < epsilon$4 && endX - x0 > epsilon$4 ? [Math.abs(startY - y0) < epsilon$4 ? startX : x0, y0]
              : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there werent any edges, have the closest site cover the extent.
  // It doesnt matter which corner of the extent we measure!
  if (cover) {
    var dx, dy, d2, dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges.push(createBorderEdge(site, v01, v11)) - 1,
        edges.push(createBorderEdge(site, v11, v10)) - 1,
        edges.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

var circlePool = [];

var firstCircle;

function Circle() {
  RedBlackNode(this);
  this.x =
  this.y =
  this.arc =
  this.site =
  this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2$2) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle;
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = circles._;

  while (node) {
    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
      if (node.L) node = node.L;
      else { before = node.P; break; }
    } else {
      if (node.R) node = node.R;
      else { before = node; break; }
    }
  }

  circles.insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    circles.remove(circle);
    circlePool.push(circle);
    RedBlackNode(circle);
    arc.circle = null;
  }
}

var beachPool = [];

function Beach() {
  RedBlackNode(this);
  this.edge =
  this.site =
  this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach;
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle
      && Math.abs(x - lArc.circle.x) < epsilon$4
      && Math.abs(y - lArc.circle.cy) < epsilon$4) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  detachCircle(lArc);

  var rArc = next;
  while (rArc.circle
      && Math.abs(x - rArc.circle.x) < epsilon$4
      && Math.abs(y - rArc.circle.cy) < epsilon$4) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  detachCircle(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

  attachCircle(lArc);
  attachCircle(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > epsilon$4) node = node.L; else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > epsilon$4) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon$4) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon$4) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }

  if (!rArc) { // && lArc
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  detachCircle(lArc);
  detachCircle(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

var epsilon$4 = 1e-6;
var epsilon2$2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1]
      || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree;
  circles = new RedBlackTree;

  while (true) {
    circle = firstCircle;
    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
      if (site[0] !== x || site[1] !== y) {
        addBeach(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      removeBeach(circle.arc);
    } else {
      break;
    }
  }

  sortCellHalfedges();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    clipEdges(x0, y0, x1, y1);
    clipCells(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;

  beaches =
  circles =
  edges =
  cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function() {
    var edges = this.edges;

    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },

  find: function(x, y, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

    // Use the previously-found cell, or start with an arbitrary one.
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

    // Traverse the half-edges to find a closer cell, if any.
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;

    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};

function voronoi() {
  var x$$1 = x$4,
      y$$1 = y$4,
      extent = null;

  function voronoi(data) {
    return new Diagram(data.map(function(d, i) {
      var s = [Math.round(x$$1(d, i, data) / epsilon$4) * epsilon$4, Math.round(y$$1(d, i, data) / epsilon$4) * epsilon$4];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function(data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$11(+_), voronoi) : x$$1;
  };

  voronoi.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$11(+_), voronoi) : y$$1;
  };

  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
}

function constant$12(x) {
  return function() {
    return x;
  };
}

function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity$8 = new Transform(1, 0, 0);

transform$1.prototype = Transform.prototype;

function transform$1(node) {
  return node.__zoom || identity$8;
}

function nopropagation$2() {
  exports.event.stopImmediatePropagation();
}

function noevent$2() {
  exports.event.preventDefault();
  exports.event.stopImmediatePropagation();
}

// Ignore right-click, since that should open the context menu.
function defaultFilter$2() {
  return !exports.event.button;
}

function defaultExtent$1() {
  var e = this, w, h;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    w = e.width.baseVal.value;
    h = e.height.baseVal.value;
  } else {
    w = e.clientWidth;
    h = e.clientHeight;
  }
  return [[0, 0], [w, h]];
}

function defaultTransform() {
  return this.__zoom || identity$8;
}

function defaultWheelDelta() {
  return -exports.event.deltaY * (exports.event.deltaMode ? 120 : 1) / 500;
}

function defaultTouchable$1() {
  return "ontouchstart" in this;
}

function defaultConstrain(transform$$1, extent, translateExtent) {
  var dx0 = transform$$1.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform$$1.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform$$1.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform$$1.invertY(extent[1][1]) - translateExtent[1][1];
  return transform$$1.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

function zoom() {
  var filter = defaultFilter$2,
      extent = defaultExtent$1,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable$1,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = interpolateZoom,
      gestures = [],
      listeners = dispatch("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform$$1) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform$$1);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform$$1 === "function" ? transform$$1.apply(this, arguments) : transform$$1)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    });
  };

  zoom.scaleTo = function(selection, k) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = centroid(e),
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    });
  };

  zoom.translateBy = function(selection, x, y) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function(selection, x, y) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p = centroid(e);
      return constrain(identity$8.translate(p[0], p[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    });
  };

  function scale(transform$$1, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform$$1.k ? transform$$1 : new Transform(k, transform$$1.x, transform$$1.y);
  }

  function translate(transform$$1, p0, p1) {
    var x = p0[0] - p1[0] * transform$$1.k, y = p0[1] - p1[1] * transform$$1.k;
    return x === transform$$1.x && y === transform$$1.y ? transform$$1 : new Transform(transform$$1.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform$$1, center) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = center || centroid(e),
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform$$1 === "function" ? transform$$1.apply(that, args) : transform$$1,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args) {
    for (var i = 0, n = gestures.length, g; i < n; ++i) {
      if ((g = gestures[i]).that === that) {
        return g;
      }
    }
    return new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.index = -1;
    this.active = 0;
    this.extent = extent.apply(that, args);
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.index = gestures.push(this) - 1;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform$$1) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform$$1.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform$$1.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform$$1.invert(this.touch1[0]);
      this.that.__zoom = transform$$1;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        gestures.splice(this.index, 1);
        this.index = -1;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = mouse(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      interrupt(this);
      g.start();
    }

    noevent$2();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        v = select(exports.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = mouse(this),
        x0 = exports.event.clientX,
        y0 = exports.event.clientY;

    dragDisable(exports.event.view);
    nopropagation$2();
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt(this);
    g.start();

    function mousemoved() {
      noevent$2();
      if (!g.moved) {
        var dx = exports.event.clientX - x0, dy = exports.event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(exports.event.view, g.moved);
      noevent$2();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = mouse(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (exports.event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

    noevent$2();
    if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0);
    else select(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        touches = exports.event.changedTouches,
        started,
        n = touches.length, i, t, p;

    nopropagation$2();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = touch(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true;
      else if (!g.touch1) g.touch1 = p;
    }

    // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.
    if (touchstarting) {
      touchstarting = clearTimeout(touchstarting);
      if (!g.touch1) {
        g.end();
        p = select(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
        return;
      }
    }

    if (started) {
      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      interrupt(this);
      g.start();
    }
  }

  function touchmoved() {
    var g = gesture(this, arguments),
        touches = exports.event.changedTouches,
        n = touches.length, i, t, p, l;

    noevent$2();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = touch(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    var g = gesture(this, arguments),
        touches = exports.event.changedTouches,
        n = touches.length, i, t;

    nopropagation$2();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else g.end();
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant$12(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$12(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$12(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant$12([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
}

exports.version = version;
exports.bisect = bisectRight;
exports.bisectRight = bisectRight;
exports.bisectLeft = bisectLeft;
exports.ascending = ascending;
exports.bisector = bisector;
exports.cross = cross;
exports.descending = descending;
exports.deviation = deviation;
exports.extent = extent;
exports.histogram = histogram;
exports.thresholdFreedmanDiaconis = freedmanDiaconis;
exports.thresholdScott = scott;
exports.thresholdSturges = sturges;
exports.max = max;
exports.mean = mean;
exports.median = median;
exports.merge = merge;
exports.min = min;
exports.pairs = pairs;
exports.permute = permute;
exports.quantile = threshold;
exports.range = sequence;
exports.scan = scan;
exports.shuffle = shuffle;
exports.sum = sum;
exports.ticks = ticks;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
exports.transpose = transpose;
exports.variance = variance;
exports.zip = zip;
exports.axisTop = axisTop;
exports.axisRight = axisRight;
exports.axisBottom = axisBottom;
exports.axisLeft = axisLeft;
exports.brush = brush;
exports.brushX = brushX;
exports.brushY = brushY;
exports.brushSelection = brushSelection;
exports.chord = chord;
exports.ribbon = ribbon;
exports.nest = nest;
exports.set = set$2;
exports.map = map$1;
exports.keys = keys;
exports.values = values;
exports.entries = entries;
exports.color = color;
exports.rgb = rgb;
exports.hsl = hsl;
exports.lab = lab;
exports.hcl = hcl;
exports.cubehelix = cubehelix;
exports.dispatch = dispatch;
exports.drag = drag;
exports.dragDisable = dragDisable;
exports.dragEnable = yesdrag;
exports.dsvFormat = dsv;
exports.csvParse = csvParse;
exports.csvParseRows = csvParseRows;
exports.csvFormat = csvFormat;
exports.csvFormatRows = csvFormatRows;
exports.tsvParse = tsvParse;
exports.tsvParseRows = tsvParseRows;
exports.tsvFormat = tsvFormat;
exports.tsvFormatRows = tsvFormatRows;
exports.easeLinear = linear$1;
exports.easeQuad = quadInOut;
exports.easeQuadIn = quadIn;
exports.easeQuadOut = quadOut;
exports.easeQuadInOut = quadInOut;
exports.easeCubic = cubicInOut;
exports.easeCubicIn = cubicIn;
exports.easeCubicOut = cubicOut;
exports.easeCubicInOut = cubicInOut;
exports.easePoly = polyInOut;
exports.easePolyIn = polyIn;
exports.easePolyOut = polyOut;
exports.easePolyInOut = polyInOut;
exports.easeSin = sinInOut;
exports.easeSinIn = sinIn;
exports.easeSinOut = sinOut;
exports.easeSinInOut = sinInOut;
exports.easeExp = expInOut;
exports.easeExpIn = expIn;
exports.easeExpOut = expOut;
exports.easeExpInOut = expInOut;
exports.easeCircle = circleInOut;
exports.easeCircleIn = circleIn;
exports.easeCircleOut = circleOut;
exports.easeCircleInOut = circleInOut;
exports.easeBounce = bounceOut;
exports.easeBounceIn = bounceIn;
exports.easeBounceOut = bounceOut;
exports.easeBounceInOut = bounceInOut;
exports.easeBack = backInOut;
exports.easeBackIn = backIn;
exports.easeBackOut = backOut;
exports.easeBackInOut = backInOut;
exports.easeElastic = elasticOut;
exports.easeElasticIn = elasticIn;
exports.easeElasticOut = elasticOut;
exports.easeElasticInOut = elasticInOut;
exports.forceCenter = center$1;
exports.forceCollide = collide;
exports.forceLink = link;
exports.forceManyBody = manyBody;
exports.forceRadial = radial;
exports.forceSimulation = simulation;
exports.forceX = x$2;
exports.forceY = y$2;
exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;
exports.geoArea = area;
exports.geoBounds = bounds;
exports.geoCentroid = centroid;
exports.geoCircle = circle;
exports.geoClipAntimeridian = clipAntimeridian;
exports.geoClipCircle = clipCircle;
exports.geoClipExtent = extent$1;
exports.geoClipRectangle = clipRectangle;
exports.geoContains = contains;
exports.geoDistance = distance;
exports.geoGraticule = graticule;
exports.geoGraticule10 = graticule10;
exports.geoInterpolate = interpolate$1;
exports.geoLength = length$1;
exports.geoPath = index$1;
exports.geoAlbers = albers;
exports.geoAlbersUsa = albersUsa;
exports.geoAzimuthalEqualArea = azimuthalEqualArea;
exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
exports.geoAzimuthalEquidistant = azimuthalEquidistant;
exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
exports.geoConicConformal = conicConformal;
exports.geoConicConformalRaw = conicConformalRaw;
exports.geoConicEqualArea = conicEqualArea;
exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
exports.geoConicEquidistant = conicEquidistant;
exports.geoConicEquidistantRaw = conicEquidistantRaw;
exports.geoEquirectangular = equirectangular;
exports.geoEquirectangularRaw = equirectangularRaw;
exports.geoGnomonic = gnomonic;
exports.geoGnomonicRaw = gnomonicRaw;
exports.geoIdentity = identity$5;
exports.geoProjection = projection;
exports.geoProjectionMutator = projectionMutator;
exports.geoMercator = mercator;
exports.geoMercatorRaw = mercatorRaw;
exports.geoNaturalEarth1 = naturalEarth1;
exports.geoNaturalEarth1Raw = naturalEarth1Raw;
exports.geoOrthographic = orthographic;
exports.geoOrthographicRaw = orthographicRaw;
exports.geoStereographic = stereographic;
exports.geoStereographicRaw = stereographicRaw;
exports.geoTransverseMercator = transverseMercator;
exports.geoTransverseMercatorRaw = transverseMercatorRaw;
exports.geoRotation = rotation;
exports.geoStream = geoStream;
exports.geoTransform = transform;
exports.cluster = cluster;
exports.hierarchy = hierarchy;
exports.pack = index$2;
exports.packSiblings = siblings;
exports.packEnclose = enclose;
exports.partition = partition;
exports.stratify = stratify;
exports.tree = tree;
exports.treemap = index$3;
exports.treemapBinary = binary;
exports.treemapDice = treemapDice;
exports.treemapSlice = treemapSlice;
exports.treemapSliceDice = sliceDice;
exports.treemapSquarify = squarify;
exports.treemapResquarify = resquarify;
exports.interpolate = interpolateValue;
exports.interpolateArray = array$1;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateDate = date;
exports.interpolateNumber = reinterpolate;
exports.interpolateObject = object;
exports.interpolateRound = interpolateRound;
exports.interpolateString = interpolateString;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = interpolateZoom;
exports.interpolateRgb = interpolateRgb;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateHsl = hsl$2;
exports.interpolateHslLong = hslLong;
exports.interpolateLab = lab$1;
exports.interpolateHcl = hcl$2;
exports.interpolateHclLong = hclLong;
exports.interpolateCubehelix = cubehelix$2;
exports.interpolateCubehelixLong = cubehelixLong;
exports.quantize = quantize;
exports.path = path;
exports.polygonArea = area$1;
exports.polygonCentroid = centroid$1;
exports.polygonHull = hull;
exports.polygonContains = contains$1;
exports.polygonLength = length$2;
exports.quadtree = quadtree;
exports.queue = queue;
exports.randomUniform = uniform;
exports.randomNormal = normal;
exports.randomLogNormal = logNormal;
exports.randomBates = bates;
exports.randomIrwinHall = irwinHall;
exports.randomExponential = exponential$1;
exports.request = request;
exports.html = html;
exports.json = json;
exports.text = text;
exports.xml = xml;
exports.csv = csv$1;
exports.tsv = tsv$1;
exports.scaleBand = band;
exports.scalePoint = point$1;
exports.scaleIdentity = identity$6;
exports.scaleLinear = linear$2;
exports.scaleLog = log$1;
exports.scaleOrdinal = ordinal;
exports.scaleImplicit = implicit;
exports.scalePow = pow$1;
exports.scaleSqrt = sqrt$1;
exports.scaleQuantile = quantile$$1;
exports.scaleQuantize = quantize$1;
exports.scaleThreshold = threshold$1;
exports.scaleTime = time;
exports.scaleUtc = utcTime;
exports.schemeCategory10 = category10;
exports.schemeCategory20b = category20b;
exports.schemeCategory20c = category20c;
exports.schemeCategory20 = category20;
exports.interpolateCubehelixDefault = cubehelix$3;
exports.interpolateRainbow = rainbow$1;
exports.interpolateWarm = warm;
exports.interpolateCool = cool;
exports.interpolateViridis = viridis;
exports.interpolateMagma = magma;
exports.interpolateInferno = inferno;
exports.interpolatePlasma = plasma;
exports.scaleSequential = sequential;
exports.create = create;
exports.creator = creator;
exports.local = local$1;
exports.matcher = matcher$1;
exports.mouse = mouse;
exports.namespace = namespace;
exports.namespaces = namespaces;
exports.clientPoint = point;
exports.select = select;
exports.selectAll = selectAll;
exports.selection = selection;
exports.selector = selector;
exports.selectorAll = selectorAll;
exports.style = styleValue;
exports.touch = touch;
exports.touches = touches;
exports.window = defaultView;
exports.customEvent = customEvent;
exports.arc = arc;
exports.area = area$2;
exports.line = line;
exports.pie = pie;
exports.areaRadial = areaRadial;
exports.radialArea = areaRadial;
exports.lineRadial = lineRadial$1;
exports.radialLine = lineRadial$1;
exports.pointRadial = pointRadial;
exports.linkHorizontal = linkHorizontal;
exports.linkVertical = linkVertical;
exports.linkRadial = linkRadial;
exports.symbol = symbol;
exports.symbols = symbols;
exports.symbolCircle = circle$2;
exports.symbolCross = cross$2;
exports.symbolDiamond = diamond;
exports.symbolSquare = square;
exports.symbolStar = star;
exports.symbolTriangle = triangle;
exports.symbolWye = wye;
exports.curveBasisClosed = basisClosed$1;
exports.curveBasisOpen = basisOpen;
exports.curveBasis = basis$2;
exports.curveBundle = bundle;
exports.curveCardinalClosed = cardinalClosed;
exports.curveCardinalOpen = cardinalOpen;
exports.curveCardinal = cardinal;
exports.curveCatmullRomClosed = catmullRomClosed;
exports.curveCatmullRomOpen = catmullRomOpen;
exports.curveCatmullRom = catmullRom;
exports.curveLinearClosed = linearClosed;
exports.curveLinear = curveLinear;
exports.curveMonotoneX = monotoneX;
exports.curveMonotoneY = monotoneY;
exports.curveNatural = natural;
exports.curveStep = step;
exports.curveStepAfter = stepAfter;
exports.curveStepBefore = stepBefore;
exports.stack = stack;
exports.stackOffsetExpand = expand;
exports.stackOffsetDiverging = diverging;
exports.stackOffsetNone = none$1;
exports.stackOffsetSilhouette = silhouette;
exports.stackOffsetWiggle = wiggle;
exports.stackOrderAscending = ascending$2;
exports.stackOrderDescending = descending$2;
exports.stackOrderInsideOut = insideOut;
exports.stackOrderNone = none$2;
exports.stackOrderReverse = reverse;
exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeDay = day;
exports.timeDays = days;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeYear = year;
exports.timeYears = years;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcYear = utcYear;
exports.utcYears = utcYears;
exports.timeFormatDefaultLocale = defaultLocale$1;
exports.timeFormatLocale = formatLocale$1;
exports.isoFormat = formatIso;
exports.isoParse = parseIso;
exports.now = now;
exports.timer = timer;
exports.timerFlush = timerFlush;
exports.timeout = timeout$1;
exports.interval = interval$1;
exports.transition = transition;
exports.active = active;
exports.interrupt = interrupt;
exports.voronoi = voronoi;
exports.zoom = zoom;
exports.zoomTransform = transform$1;
exports.zoomIdentity = identity$8;

Object.defineProperty(exports, '__esModule', { value: true });

})));

;/*! 
 *  IDS Enterprise Components - v4.17.1
 *  Date: 2019-04-04T16:28:50.336Z
 *  Revision: a995b7377f8b75f2efd5a5878e882aaebf43000e
 *  
 *  
 *  Apache License
 *  Version 2.0, January 2004
 *  http://www.apache.org/licenses/
 *  
 *  TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *  
 *  1. Definitions.
 *  
 *  "License" shall mean the terms and conditions for use, reproduction,
 *  and distribution as defined by Sections 1 through 9 of this document.
 *  
 *  "Licensor" shall mean the copyright owner or entity authorized by
 *  the copyright owner that is granting the License.
 *  
 *  "Legal Entity" shall mean the union of the acting entity and all
 *  other entities that control, are controlled by, or are under common
 *  control with that entity. For the purposes of this definition,
 *  "control" means (i) the power, direct or indirect, to cause the
 *  direction or management of such entity, whether by contract or
 *  otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *  outstanding shares, or (iii) beneficial ownership of such entity.
 *  
 *  "You" (or "Your") shall mean an individual or Legal Entity
 *  exercising permissions granted by this License.
 *  
 *  "Source" form shall mean the preferred form for making modifications,
 *  including but not limited to software source code, documentation
 *  source, and configuration files.
 *  
 *  "Object" form shall mean any form resulting from mechanical
 *  transformation or translation of a Source form, including but
 *  not limited to compiled object code, generated documentation,
 *  and conversions to other media types.
 *  
 *  "Work" shall mean the work of authorship, whether in Source or
 *  Object form, made available under the License, as indicated by a
 *  copyright notice that is included in or attached to the work
 *  (an example is provided in the Appendix below).
 *  
 *  "Derivative Works" shall mean any work, whether in Source or Object
 *  form, that is based on (or derived from) the Work and for which the
 *  editorial revisions, annotations, elaborations, or other modifications
 *  represent, as a whole, an original work of authorship. For the purposes
 *  of this License, Derivative Works shall not include works that remain
 *  separable from, or merely link (or bind by name) to the interfaces of,
 *  the Work and Derivative Works thereof.
 *  
 *  "Contribution" shall mean any work of authorship, including
 *  the original version of the Work and any modifications or additions
 *  to that Work or Derivative Works thereof, that is intentionally
 *  submitted to Licensor for inclusion in the Work by the copyright owner
 *  or by an individual or Legal Entity authorized to submit on behalf of
 *  the copyright owner. For the purposes of this definition, "submitted"
 *  means any form of electronic, verbal, or written communication sent
 *  to the Licensor or its representatives, including but not limited to
 *  communication on electronic mailing lists, source code control systems,
 *  and issue tracking systems that are managed by, or on behalf of, the
 *  Licensor for the purpose of discussing and improving the Work, but
 *  excluding communication that is conspicuously marked or otherwise
 *  designated in writing by the copyright owner as "Not a Contribution."
 *  
 *  "Contributor" shall mean Licensor and any individual or Legal Entity
 *  on behalf of whom a Contribution has been received by Licensor and
 *  subsequently incorporated within the Work.
 *  
 *  2. Grant of Copyright License. Subject to the terms and conditions of
 *  this License, each Contributor hereby grants to You a perpetual,
 *  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *  copyright license to reproduce, prepare Derivative Works of,
 *  publicly display, publicly perform, sublicense, and distribute the
 *  Work and such Derivative Works in Source or Object form.
 *  
 *  3. Grant of Patent License. Subject to the terms and conditions of
 *  this License, each Contributor hereby grants to You a perpetual,
 *  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *  (except as stated in this section) patent license to make, have made,
 *  use, offer to sell, sell, import, and otherwise transfer the Work,
 *  where such license applies only to those patent claims licensable
 *  by such Contributor that are necessarily infringed by their
 *  Contribution(s) alone or by combination of their Contribution(s)
 *  with the Work to which such Contribution(s) was submitted. If You
 *  institute patent litigation against any entity (including a
 *  cross-claim or counterclaim in a lawsuit) alleging that the Work
 *  or a Contribution incorporated within the Work constitutes direct
 *  or contributory patent infringement, then any patent licenses
 *  granted to You under this License for that Work shall terminate
 *  as of the date such litigation is filed.
 *  
 *  4. Redistribution. You may reproduce and distribute copies of the
 *  Work or Derivative Works thereof in any medium, with or without
 *  modifications, and in Source or Object form, provided that You
 *  meet the following conditions:
 *  
 *  (a) You must give any other recipients of the Work or
 *  Derivative Works a copy of this License; and
 *  
 *  (b) You must cause any modified files to carry prominent notices
 *  stating that You changed the files; and
 *  
 *  (c) You must retain, in the Source form of any Derivative Works
 *  that You distribute, all copyright, patent, trademark, and
 *  attribution notices from the Source form of the Work,
 *  excluding those notices that do not pertain to any part of
 *  the Derivative Works; and
 *  
 *  (d) If the Work includes a "NOTICE" text file as part of its
 *  distribution, then any Derivative Works that You distribute must
 *  include a readable copy of the attribution notices contained
 *  within such NOTICE file, excluding those notices that do not
 *  pertain to any part of the Derivative Works, in at least one
 *  of the following places: within a NOTICE text file distributed
 *  as part of the Derivative Works; within the Source form or
 *  documentation, if provided along with the Derivative Works; or,
 *  within a display generated by the Derivative Works, if and
 *  wherever such third-party notices normally appear. The contents
 *  of the NOTICE file are for informational purposes only and
 *  do not modify the License. You may add Your own attribution
 *  notices within Derivative Works that You distribute, alongside
 *  or as an addendum to the NOTICE text from the Work, provided
 *  that such additional attribution notices cannot be construed
 *  as modifying the License.
 *  
 *  You may add Your own copyright statement to Your modifications and
 *  may provide additional or different license terms and conditions
 *  for use, reproduction, or distribution of Your modifications, or
 *  for any such Derivative Works as a whole, provided Your use,
 *  reproduction, and distribution of the Work otherwise complies with
 *  the conditions stated in this License.
 *  
 *  5. Submission of Contributions. Unless You explicitly state otherwise,
 *  any Contribution intentionally submitted for inclusion in the Work
 *  by You to the Licensor shall be under the terms and conditions of
 *  this License, without any additional terms or conditions.
 *  Notwithstanding the above, nothing herein shall supersede or modify
 *  the terms of any separate license agreement you may have executed
 *  with Licensor regarding such Contributions.
 *  
 *  6. Trademarks. This License does not grant permission to use the trade
 *  names, trademarks, service marks, or product names of the Licensor,
 *  except as required for reasonable and customary use in describing the
 *  origin of the Work and reproducing the content of the NOTICE file.
 *  
 *  7. Disclaimer of Warranty. Unless required by applicable law or
 *  agreed to in writing, Licensor provides the Work (and each
 *  Contributor provides its Contributions) on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *  implied, including, without limitation, any warranties or conditions
 *  of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *  PARTICULAR PURPOSE. You are solely responsible for determining the
 *  appropriateness of using or redistributing the Work and assume any
 *  risks associated with Your exercise of permissions under this License.
 *  
 *  8. Limitation of Liability. In no event and under no legal theory,
 *  whether in tort (including negligence), contract, or otherwise,
 *  unless required by applicable law (such as deliberate and grossly
 *  negligent acts) or agreed to in writing, shall any Contributor be
 *  liable to You for damages, including any direct, indirect, special,
 *  incidental, or consequential damages of any character arising as a
 *  result of this License or out of the use or inability to use the
 *  Work (including but not limited to damages for loss of goodwill,
 *  work stoppage, computer failure or malfunction, or any and all
 *  other commercial damages or losses), even if such Contributor
 *  has been advised of the possibility of such damages.
 *  
 *  9. Accepting Warranty or Additional Liability. While redistributing
 *  the Work or Derivative Works thereof, You may choose to offer,
 *  and charge a fee for, acceptance of support, warranty, indemnity,
 *  or other liability obligations and/or rights consistent with this
 *  License. However, in accepting such obligations, You may act only
 *  on Your own behalf and on Your sole responsibility, not on behalf
 *  of any other Contributor, and only if You agree to indemnify,
 *  defend, and hold each Contributor harmless for any liability
 *  incurred by, or claims asserted against, such Contributor by reason
 *  of your accepting any such warranty or additional liability.
 *  
 *  END OF TERMS AND CONDITIONS
 *  
 *  APPENDIX: How to apply the Apache License to your work.
 *  
 *  To apply the Apache License to your work, attach the following
 *  boilerplate notice, with the fields enclosed by brackets "[]"
 *  replaced with your own identifying information. (Don't include
 *  the brackets!)  The text should be enclosed in the appropriate
 *  comment syntax for the file format. We also recommend that a
 *  file or class name and description of purpose be included on the
 *  same "printed page" as the copyright notice for easier
 *  identification within third-party archives.
 *  
 *  Copyright 2018  Infor, Inc.
 *  
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  
 */ 
var Soho = (function (exports) {
  'use strict';

  /* eslint-disable no-console */

  // Easy flag for determining whether or not time will be logged to the console.
  var enableTimeLogging = false;

  /**
   * Start the logging timer
   * @param  {string} label Provide a way to match a timing operation.
   * @returns {void}
   */
  function logTimeStart(label) {
  }

  /**
   * End the logging timer and print the result
   * @param  {string} label End this matching timing operation
   * @returns {void}
   */
  function logTimeEnd(label) {
  }

  // Easy flag for allowing console debugging
  var enableConsoleLogging = false;

  /**
   * Simple wrapper for `console.[whatever]` to abstract out console access.
   * @param {string} type console display type
   * @param {string} message message type
   * @returns {void}
   */
  function log(type, message) {
    {
      return;
    }

    if (!console) {
      // eslint-disable-line
      return;
    }

    if (!message && typeof type === 'string') {
      message = type;
      type = 'log';
    }

    if (typeof !console[type] !== 'function') {
      // eslint-disable-line
      type = 'log';
    }

    console[type]('' + message); // eslint-disable-line
  }

  var debug = /*#__PURE__*/Object.freeze({
    enableTimeLogging: enableTimeLogging,
    logTimeStart: logTimeStart,
    logTimeEnd: logTimeEnd,
    enableConsoleLogging: enableConsoleLogging,
    log: log
  });

  var version = "4.17.1";

  var xssUtils = {};

  /**
   * Takes a string and removes all html tags
   * @param {string} str The string to parse
   * @returns {string} The string minus html tags.
   */
  xssUtils.stripHTML = function stripHTML(str) {
    var newStr = str;

    if (!newStr) {
      return '';
    }

    newStr = newStr.replace(/<\/?[^>]+(>|$)/g, '');
    return newStr;
  };

  /**
   * Remove all html tags except for the ones specified. I.E. White list to a specific set of accepted tags.
   * @private
   * @param {string} html HTML in string form
   * @param {string} allowed Comma seperated string of allowed tags e.g. '<b><i><p>''
   * @returns {string} the modified value
   */
  xssUtils.stripTags = function (html, allowed) {
    if (!html) {
      return '';
    }

    if (typeof html === 'number') {
      return html;
    }

    var whitelist = (('' + (allowed || '')).toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join(''); // making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)

    var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi;
    var commentsAndPhpTags = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi;
    var returnHTML = '';
    returnHTML = html.replace(commentsAndPhpTags, '').replace(tags, function ($0, $1) {
      return whitelist.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
    }); //eslint-disable-line
    returnHTML = returnHTML.replace(tags, function ($0, $1) {
      return whitelist.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
    }); //eslint-disable-line
    returnHTML = returnHTML.replace(tags, function ($0, $1) {
      return whitelist.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
    }); //eslint-disable-line

    return returnHTML;
  };

  /**
   * Remove Script tags and all onXXX functions
   * @private
   * @param {string} html HTML in string form
   * @returns {string} the modified value
   */
  xssUtils.sanitizeHTML = function (html) {
    var santizedHtml = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/g, '');
    santizedHtml = santizedHtml.replace(/<[^>]+/g, function (match) {
      return match.replace(/(\/|\s)on\w+=(\'|")?[^"]*(\'|")?/g, '');
    }); // eslint-disable-line

    // Remove console.logs
    santizedHtml = santizedHtml.replace(/console.log(\b[^<]*(?:(?!\);)<[^<]*)*);/g, '');
    santizedHtml = santizedHtml.replace(/console.log(\b[^<]*(?:(?!\))<[^<]*)*)/g, '');

    // Remove nested script tags
    santizedHtml = santizedHtml.replace(/<\/script>/g, '');

    return santizedHtml;
  };

  /**
   * Make sure a string is only alphanumeric (with dashes allowed.)
   * @private
   * @param {string} string HTML in string form
   * @returns {string} the modified value
   */
  xssUtils.ensureAlphaNumeric = function (string) {
    if (typeof string === 'number') {
      return string;
    }
    return this.stripTags(string).replace(/[^a-z0-9-]/gi, '', '');
  };

  /**
   * Escapes HTML, replacing special characters with encoded symbols.
   * Symbols taken from https://bit.ly/1iVkGlc
   * @private
   * @param {string} value HTML in string form
   * @returns {string} the modified value
   */
  xssUtils.escapeHTML = function (value) {
    var newValue = value;
    if (typeof newValue === 'string') {
      var map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      };
      var reg = /[&<>"']/ig;
      return newValue.replace(reg, function (match) {
        return map[match];
      });
    }
    return newValue;
  };

  /**
   * Un-escapes HTML, replacing encoded symbols with special characters.
   * Symbols taken from https://bit.ly/1iVkGlc
   * @private
   * @param {string} value HTML in string form
   * @returns {string} the modified value
   */
  xssUtils.unescapeHTML = function (value) {
    var newValue = value;
    if (typeof value === 'string') {
      newValue = newValue.replace(/&amp;/g, '&');
      newValue = newValue.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
      newValue = newValue.replace(/&quot;/g, '"');
      newValue = newValue.replace(/&#x27;/g, "'");
      newValue = newValue.replace(/&#x2F;/g, '/');
    }
    return newValue;
  };

  /**
   * htmlentities() is a PHP function which converts special characters (like <)
   * into their escaped/encoded values (like &lt;). This is a JS verson of it.
   * This allows you to show to display the string without the browser reading it as HTML.
   * This is useful for encoding hrefs.
   * @private
   * @param {string} string string to process
   * @returns {string} the processed value
   */
  xssUtils.htmlEntities = function (string) {
    return String(string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  };

  /**
   * Ensure that a link is a local link (relative to the current page)
   * @private
   * @param {string} url string to process
   * @returns {boolean} If it is local or not
   */
  xssUtils.isUrlLocal = function (url) {
    var isEmpty = url === '';
    return !isEmpty && (url[0] === '/' && (url.length === 1 || url[1] !== '/' && url[1] !== '\\') || // "/" or "/foo" but not "//" or "/\"
    url.length > 1 && url[0] === '~' && url[1] === '/') || // "~/" or "~/foo"
    url.length >= 1 && url[0] === '#'; // "#" or "#foo"
  };

  var DOM = {};

  /**
   * Returns an array containing an element's attributes.
   * @param {HTMLElement|SVGElement} element the element whose attributes are being accessed
   * @returns {object} list of attributes in name/value pairs.
   */
  DOM.getAttributes = function getAttributes(element) {
    if (!element || !(element instanceof HTMLElement) && !(element instanceof SVGElement)) {
      return {};
    }

    return element.attributes;
  };

  /**
   * Adding, removing, and testing for classes
   * @param {HTMLElement} element the element to test
   * @returns {boolean} whether or not a className exists
   */
  DOM.classNameExists = function classNameExists(element) {
    var cn = element.className;
    return cn && cn.length > 0;
  };

  /**
   * Checks the element for the existence of a particular class.
   * @param {HTMLElement|SVGElement} el a element being checked.
   * @param {string} className a string representing a class name to check for.
   * @returns {boolean} whether or not the element's class attribute contains the string.
   */
  DOM.hasClass = function hasClass(el, className) {
    if (!el.classList) {
      return false;
    }

    // Use `className` if there's no `classList`
    if (el.className) {
      return new RegExp('\\b' + className + '\\b').test(el.className);
    }

    // If no `className`, this element is probably an SVG or other namespace element
    var classAttr = el.getAttribute('class');
    if (!classAttr || !classAttr.length) {
      return false;
    }
    return classAttr.indexOf(className) > -1;
  };

  /**
   * Add a class to any element and handle multiple classes.
   * Handles DOM and SVG elements down to IE11
   * @param {HTMLElement} el a element being checked.
   * @param {...string} className a string representing a class name.
   */
  DOM.addClass = function addClass(el) {
    for (var _len = arguments.length, className = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      className[_key - 1] = arguments[_key];
    }

    for (var i = 0; i < className.length; i++) {
      if (el.classList) {
        el.classList.add(className[i]);
      } else if (!DOM.hasClass(el, [i])) {
        el.className += ' ' + className[i];
      }
    }
  };

  /**
   * Remove a class from any element and handle multiple classes.
   * Handles DOM and SVG elements down to IE11
   * @param {HTMLElement} el a element being checked.
   * @param {...string} className a string representing a class name.
   */
  DOM.removeClass = function removeClass(el) {
    for (var _len2 = arguments.length, className = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      className[_key2 - 1] = arguments[_key2];
    }

    for (var i = 0; i < className.length; i++) {
      if (el.classList) {
        el.classList.remove(className[i]);
      } else {
        var newClassName = '';
        var classes = el.className.split(' ');
        for (var j = 0; j < classes.length; j++) {
          if (classes[j] !== className[j]) {
            newClassName += classes[i] + ' ';
          }
        }
        this.className = newClassName;
      }
    }
  };

  /**
   * Checks if an element is valid
   * @param {HTMLElement|SVGElement|jQuery[]} el The element being checked
   * @returns {boolean} represents all values normally contained by a DOMRect or ClientRect
   */
  DOM.isElement = function isElement(el) {
    if (el instanceof HTMLElement || el instanceof SVGElement || el instanceof $ && el.length) {
      return true;
    }
    return false;
  };

  /**
   * Runs the generic _getBoundingClientRect()_ method on an element, but returns its results
   * as a plain object instead of a ClientRect
   * @param {HTMLElement|SVGElement|jQuery[]} el The element being manipulated
   * @returns {object} represents all values normally contained by a DOMRect or ClientRect
   */
  DOM.getDimensions = function getDimensions(el) {
    if (!DOM.isElement(el)) {
      return {};
    }

    if (el instanceof $) {
      if (!el.length) {
        return {};
      }

      el = el[0];
    }

    var rect = el.getBoundingClientRect();
    var rectObj = {};

    for (var prop in rect) {
      // eslint-disable-line
      if (!isNaN(rect[prop])) {
        rectObj[prop] = rect[prop];
      }
    }

    return rectObj;
  };

  /**
   * Append content to a DOM element (like jQuery.append)
   * @param {HTMLElement|SVGElement|jQuery[]} el The element to append to
   * @param {string|jQuery} contents The html string or jQuery object.
   * @param {string} stripTags A list of tags to strip to prevent xss, or * for sanitizing and allowing all tags.
   */
  DOM.append = function append(el, contents, stripTags) {
    var domEl = el;

    if (el instanceof $ && el.length) {
      domEl = domEl[0];
    }

    if (domEl instanceof HTMLElement || domEl instanceof SVGElement) {
      domEl.insertAdjacentHTML('beforeend', this.xssClean(contents, stripTags));
    }
  };

  /**
   * Remove a DOM Element
   * @param {HTMLElement|SVGElement|jQuery[]} el The element to remove.
   */
  DOM.remove = function append(el) {
    var domEl = el;

    if (el instanceof $ && el.length) {
      domEl = domEl[0];
    }

    if ((domEl instanceof HTMLElement || domEl instanceof SVGElement) && el.parentNode) {
      el.parentNode.removeChild(el);
    }
  };

  /**
   * Set an attribute with an extra check that the object exists.
   * @param {HTMLElement|SVGElement|jQuery[]} el The element to set the attribute on
   * @param {string} attribute The attribute name.
   * @param {string} value The attribute value.
   */
  DOM.setAttribute = function append(el, attribute, value) {
    var domEl = el;

    if (el instanceof $ && el.length) {
      domEl = domEl[0];
    }

    if (domEl instanceof HTMLElement || domEl instanceof SVGElement) {
      domEl.setAttribute('attribute', value);
    }
  };

  /**
   * Clean the markup before insertion.
   * @param {string|jQuery} contents The html string or jQuery object.
   * @param {string} stripTags A list of tags to strip to prevent xss, or * for sanitizing and allowing all tags.
   * @returns {string} the cleaned up markup
   */
  DOM.xssClean = function xssClean(contents, stripTags) {
    var markup = contents;

    if (stripTags && stripTags !== '*') {
      markup = xssUtils.stripTags(contents, stripTags);
    }

    if (stripTags === '*') {
      markup = xssUtils.sanitizeHTML(contents);
    }

    return markup;
  };

  /**
   * Append content to a DOM element (like jQuery.append)
   * @param {HTMLElement|SVGElement|jQuery[]} el The element to append to
   * @param {string|jQuery} contents The html string or jQuery object.
   * @param {string} stripTags A list of tags to strip to prevent xss, or * for sanitizing and allowing all tags.
   */
  DOM.html = function html(el, contents, stripTags) {
    var domEl = el;

    if (el instanceof $ && el.length) {
      domEl = domEl[0];
    }

    if (domEl instanceof HTMLElement || domEl instanceof SVGElement) {
      domEl.innerHTML = this.xssClean(contents, stripTags);
    }
  };

  // =================================================================
  // Soho JS-level Breakpoint Access
  // NOTE: these should match whatever the breakpoints are in "/sass/_config.scss"
  // =================================================================
  var breakpoints = {
    phone: 320,
    slim: 400,
    phablet: 610,
    'phone-to-tablet': 767,
    'wide-tablet': 968,
    'tablet-to-desktop': 1280,
    desktop: 1024,
    'desktop-to-extralarge': 1600
  };

  /**
   * Get the name of the current CSS breakpoint by checking the popuplated 'content' value of the
   * <body> tag's `::after` pseudo-element.  These names should be reflected in the breakpoints object
   * above.
   * @returns {string} name of the current breakpoint
   */
  breakpoints.current = function () {
    var afterElement = window.getComputedStyle ? window.getComputedStyle(document.body, ':after') : false;
    if (!afterElement) {
      return '';
    }
    return (afterElement.getPropertyValue('content') || '').replace(/"/g, '');
  };

  /**
   * @param {string} breakpoint matches one of the entries in the "Soho.breakpoints" object.
   * @returns {boolean} whether or not the window is currently wider than the breakpoint provided.
   */
  breakpoints.isAbove = function isAbove(breakpoint) {
    var bp = breakpoints[breakpoint];
    if (!bp) {
      return false;
    }

    var windowWidth = $(window).width();
    return windowWidth > bp - 1;
  };

  /**
   * @param {string} breakpoint matches one of the entries in the "Soho.breakpoints" object.
   * @returns {boolean} whether or not the window is currently more narrow
   *  than the breakpoint provided.
   */
  breakpoints.isBelow = function isBelow(breakpoint) {
    var bp = breakpoints[breakpoint];
    if (!bp) {
      return false;
    }

    var windowWidth = $(window).width();
    return windowWidth < bp;
  };

  /**
   * Compares the last-stored breakpoint with a check on the "current" breakpoint to see if the
   * breakpoint has changed.
   * @returns {void}
   */
  breakpoints.compare = function compare() {
    if (!this.last) {
      this.last = '';
    }

    var cur = this.current();
    if (this.last !== cur) {
      $('body').triggerHandler('breakpoint-change', [{
        previous: this.last,
        current: cur
      }]);
      this.last = cur;
    }
  };

  /**
   * Checks an element for Soho visibility classes and determines whether or not
   * should be hidden based on those values at the current breakpoint.
   * NOTE: this method does NOT determine if the element is ACTUALLY hidden with a
   * `display: none;` or `visibility: hidden;` rule.  It determines whether or not a CSS
   * visibility rule alone would hide the element.
   * @param {HTMLElement} element the element being checked.
   * @returns {boolean} whether or not the element is hidden at this breakpoint.
   */
  breakpoints.isHidden = function (element) {
    if (!element || !DOM.isElement(element)) {
      return false;
    }

    // If there are no CSS classes on the element, return false.
    var cl = element.classList;
    if (!cl.length) {
      return false;
    }

    // If it's always hidden, always return true.
    if (cl.contains('hidden')) {
      return true;
    }

    var bp = this.current();
    var map = {
      phonedown: 'xs',
      phone: 'sm',
      tablet: 'md',
      desktop: 'lg',
      extralarge: 'xl'
    };
    var size = map[bp];
    var hiddenClassName = 'hidden-' + size;
    var visibleClassName = 'visible-' + size + '-';

    // Should be hidden on this breakpoint
    if (cl.contains(hiddenClassName)) {
      return true;
    }

    // If explicitly visible, return
    if (cl.toString().indexOf(visibleClassName) > -1) {
      return false;
    }

    // Simply return false if none of these thing are found
    return false;
  };

  /**
   * jQuery wrapper for `Soho.breakpoints.isHidden()`
   * NOTE: if a jQuery selector with multiple elements is passed to this function,
   * it will only operate on the first one.
   * This method is NOT chainable.
   * @returns {boolean} whether or not the element is hidden at this breakpoint.
   */
  $.fn.isHiddenAtBreakpoint = function () {
    if (!this.length) {
      return false;
    }
    return breakpoints.isHidden($(this).first()[0]);
  };

  /**
   * Debounce method
   * @param {function} func the callback function to be run on a stagger.
   * @param {number} [threshold] the amount of time in CPU ticks to delay.
   * @param {boolean} [execAsap] if true, executes the callback immediately
   *  instead of waiting for the threshold to complete.
   * @returns {void}
   */
  function debounce(func, threshold, execAsap) {
    var timeout = void 0;

    return function debounced() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var obj = this;
      function delayed() {
        if (!execAsap) {
          func.apply(obj, args);
        }
        timeout = null;
      }

      if (timeout) {
        clearTimeout(timeout);
      } else if (execAsap) {
        func.apply(obj, args);
      }

      timeout = setTimeout(delayed, threshold || 250);
    };
  }

  var debouncedResizeName = 'debouncedResize';

  /**
   * Bind the smartResize method to $.fn()
   * @param {function} fn the callback function to be bound on debounced resize
   * @returns {void}
   */
  $.fn[debouncedResizeName] = function (fn) {
    if (fn) {
      return this.bind('resize', debounce(fn));
    }
    return this.trigger(debouncedResizeName);
  };

  // Utility Name
  var UTIL_NAME = 'environment';

  /**
   * @class {Environment}
   */
  var Environment = {

    browser: {},

    features: {
      touch: 'ontouchstart' in window || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0
    },

    os: {},
    devicespecs: {},

    rtl: $('html').attr('dir') === 'rtl',

    /**
     * Builds run-time environment settings
     */
    set: function set() {
      $('html').attr('data-sohoxi-version', version);
      this.addBrowserClasses();
      this.addGlobalResize();
      this.addGlobalEvents();
      this.addDeviceSpecs();
    },


    /**
     * Global Classes for browser, version and device as needed.
     */
    addBrowserClasses: function addBrowserClasses() {
      var ua = navigator.userAgent || navigator.vendor || window.opera;
      var platform = navigator.platform;
      var html = $('html');
      var cssClasses = ''; // User-agent string

      if (ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Android') === -1) {
        cssClasses += 'is-safari ';
        this.browser.name = 'safari';
      }

      if (ua.indexOf('Chrome') !== -1) {
        cssClasses += 'is-chrome ';
        this.browser.name = 'chrome';
      }

      var macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];
      if (macosPlatforms.indexOf(platform) > -1 && !/Linux/.test(platform)) {
        cssClasses += 'is-mac ';
        this.os.name = 'Mac OS X';
      }

      if (ua.indexOf('Firefox') > 0) {
        cssClasses += 'is-firefox ';
        this.browser.name = 'firefox';
      }

      // Class-based detection for IE
      if (ua.match(/Edge\//)) {
        cssClasses += 'ie ie-edge ';
        this.browser.name = 'edge';
        this.browser.version = navigator.appVersion.indexOf('Edge/18') > -1 ? '18' : '17';
        cssClasses += 'ie-edge' + this.browser.version;
      }
      if (ua.match(/Trident/)) {
        cssClasses += 'ie ';
        this.browser.name = 'ie';
      }
      if (navigator.appVersion.indexOf('MSIE 8.0') > -1 || ua.indexOf('MSIE 8.0') > -1 || document.documentMode === 8) {
        cssClasses += 'ie8 ';
        this.browser.version = '8';
      }
      if (navigator.appVersion.indexOf('MSIE 9.0') > -1) {
        cssClasses += 'ie9 ';
        this.browser.version = '9';
      }
      if (navigator.appVersion.indexOf('MSIE 10.0') > -1) {
        cssClasses += 'ie10 ';
        this.browser.version = '10';
      } else if (ua.match(/Trident\/7\./)) {
        cssClasses += 'ie11 ';
        this.browser.version = '11';
      }

      // Class-based detection for iOS
      // /iPhone|iPod|iPad|Silk|Android|BlackBerry|Opera Mini|IEMobile/
      if (/iPhone|iPod|iPad/.test(ua)) {
        cssClasses += 'ios ';
        this.os.name = 'ios';

        var iDevices = ['iPod', 'iPad', 'iPhone'];
        for (var i = 0; i < iDevices.length; i++) {
          if (new RegExp(iDevices[i]).test(ua)) {
            cssClasses += iDevices[i].toLowerCase() + ' ';
            this.device = iDevices[i];
          }
        }
      }

      if (/Android/.test(ua)) {
        cssClasses += 'android ';
        this.os.name = 'android';
      }

      if (!this.os.name && /Linux/.test(platform)) {
        this.os.name = 'linux';
      }

      html.addClass(cssClasses);
    },
    addDeviceSpecs: function addDeviceSpecs() {
      var unknown = '-';
      var nAppVer = navigator.appVersion;
      var nUAgent = navigator.userAgent;
      var browser = navigator.appName;
      var version = ' ' + parseFloat(navigator.appVersion);
      var majorVersion = parseInt(navigator.appVersion, 10);
      var nameOffset = void 0;
      var verOffset = void 0;
      var ix = void 0;

      if ((verOffset = nUAgent.indexOf('Opera')) !== -1) {
        //eslint-disable-line
        browser = 'Opera';
        version = nUAgent.substring(verOffset + 6);
        if ((verOffset = nUAgent.indexOf('Version')) !== -1) {
          //eslint-disable-line
          version = nUAgent.substring(verOffset + 8);
        }
      }
      if ((verOffset = nUAgent.indexOf('OPR')) !== -1) {
        //eslint-disable-line
        browser = 'Opera';
        version = nUAgent.substring(verOffset + 4);
      } else if ((verOffset = nUAgent.indexOf('Edge')) !== -1) {
        //eslint-disable-line
        browser = 'Microsoft Edge';
        version = nUAgent.substring(verOffset + 5);
      } else if ((verOffset = nUAgent.indexOf('MSIE')) !== -1) {
        //eslint-disable-line
        browser = 'Microsoft Internet Explorer';
        version = nUAgent.substring(verOffset + 5);
      } else if ((verOffset = nUAgent.indexOf('Chrome')) !== -1) {
        //eslint-disable-line
        browser = 'Chrome';
        version = nUAgent.substring(verOffset + 7);
      } else if ((verOffset = nUAgent.indexOf('Safari')) !== -1) {
        //eslint-disable-line
        browser = 'Safari';
        version = nUAgent.substring(verOffset + 7);
        if ((verOffset = nUAgent.indexOf('Version')) !== -1) {
          //eslint-disable-line
          version = nUAgent.substring(verOffset + 8);
        }
      } else if ((verOffset = nUAgent.indexOf('Firefox')) !== -1) {
        //eslint-disable-line
        browser = 'Firefox';
        version = nUAgent.substring(verOffset + 8);
      } else if (nUAgent.indexOf('Trident/') !== -1) {
        //eslint-disable-line
        browser = 'Microsoft Internet Explorer';
        version = nUAgent.substring(nUAgent.indexOf('rv:') + 3);
      } else if ((nameOffset = nUAgent.lastIndexOf(' ') + 1) < (verOffset = nUAgent.lastIndexOf('/'))) {
        //eslint-disable-line
        browser = nUAgent.substring(nameOffset, verOffset);
        version = nUAgent.substring(verOffset + 1);
        if (browser.toLowerCase() === browser.toUpperCase()) {
          browser = navigator.appName;
        }
      }
      // Trim the version string
      if ((ix = version.indexOf(';')) !== -1) version = version.substring(0, ix); //eslint-disable-line
      if ((ix = version.indexOf(' ')) !== -1) version = version.substring(0, ix); //eslint-disable-line
      if ((ix = version.indexOf(')')) !== -1) version = version.substring(0, ix); //eslint-disable-line

      majorVersion = ' ' + parseInt(version, 10);
      if (isNaN(majorVersion)) {
        version = ' ' + parseFloat(navigator.appVersion);
        majorVersion = parseInt(navigator.appVersion, 10);
      }

      // mobile version
      var mobile = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(nAppVer);

      var os = unknown;

      var clientStrings = [{ s: 'Windows 10', r: /(Windows 10.0|Windows NT 10.0)/ }, { s: 'Windows 8.1', r: /(Windows 8.1|Windows NT 6.3)/ }, { s: 'Windows 8', r: /(Windows 8|Windows NT 6.2)/ }, { s: 'Windows 7', r: /(Windows 7|Windows NT 6.1)/ }, { s: 'Android', r: /Android/ }, { s: 'Open BSD', r: /OpenBSD/ }, { s: 'Sun OS', r: /SunOS/ }, { s: 'Linux', r: /(Linux|X11)/ }, { s: 'iOS', r: /(iPhone|iPad|iPod)/ }, { s: 'Mac OS X', r: /Mac OS X/ }, { s: 'Mac OS', r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/ }, { s: 'UNIX', r: /UNIX/ }];

      for (var id in clientStrings) {
        //eslint-disable-line
        var cs = clientStrings[id];
        if (cs.r.test(nUAgent)) {
          os = cs.s;
          break;
        }
      }

      var osVersion = unknown;

      if (/Windows/.test(os)) {
        osVersion = /Windows (.*)/.exec(os)[1];
      }

      switch (os) {//eslint-disable-line
        case 'Mac OS X':
          osVersion = /Mac OS X (10[\.\_\d]+)/.exec(nUAgent)[1].replace(/\_/g, '.'); //eslint-disable-line
          break;

        case 'Android':
          osVersion = /Android ([\.\_\d]+)/.exec(nUAgent)[1]; //eslint-disable-line
          break;

        case 'iOS':
          osVersion = /OS (\d+)_?(\d+)?/.exec(nUAgent); //eslint-disable-line
          osVersion = osVersion[1] + '.' + osVersion[2] + '.' + (osVersion[3] | 0); //eslint-disable-line
          break;
      }

      this.devicespecs = {
        currentBrowser: browser,
        browserVersion: version,
        browserMajorVersion: majorVersion,
        isMobile: mobile,
        os: os,
        currentOSVersion: osVersion
      };
    },


    /**
     * Setup a global resize event trigger for controls to listen to
     */
    addGlobalResize: function addGlobalResize() {
      // Global resize event
      $(window).debouncedResize(function () {
        $('body').triggerHandler('resize', [window]);
        breakpoints.compare();
      });

      // Also detect whenenver a load or orientation change occurs
      $(window).on('orientationchange load', function () {
        return breakpoints.compare();
      });
    },


    /**
     * Sets up global UI-specific event handlers
     * @returns {void}
     */
    addGlobalEvents: function addGlobalEvents() {
      var _this = this;

      var self = this;

      this.globalMouseActive = 0;
      this.globalTouchActive = 0;

      // Detect mouse/touch events on the body to help scrolling detection along
      $('body').on('mousedown.' + UTIL_NAME, function () {
        ++_this.globalMouseActive;
      }).on('mouseup.' + UTIL_NAME, function () {
        --_this.globalMouseActive;
      }).on('touchstart.' + UTIL_NAME, function () {
        ++_this.globalTouchActive;
      }).on('touchend.' + UTIL_NAME, function () {
        --_this.globalTouchActive;
      });

      // On iOS, it's possible to scroll the body tag even if there's a `no-scroll` class attached
      // This listener persists and will prevent scrolling on the body tag in the event of a `no-scroll`
      // class, only in iOS environments
      $(window).on('scroll.' + UTIL_NAME, function (e) {
        if (self.os.name !== 'ios' || document.body.className.indexOf('no-scroll') === -1) {
          return true;
        }

        // If a mouse button or touch is still active, continue as normal
        if (_this.globalTouchActive || _this.globalMouseActive) {
          return true;
        }

        e.preventDefault();
        if (document.body.scrollTop > 0) {
          document.body.scrollTop = 0;
        }
        return false;
      });

      // Prevent zooming on inputs/textareas' `focusin`/`focusout` events.
      // Some components like Dropdown have this feature built in on their specified elements.
      // This particular setup prevents zooming on input fields not tied to a component wrapper.
      $('body').on('focusin.' + UTIL_NAME, 'input, textarea', function (e) {
        var target = e.target;
        if (target.className.indexOf('dropdown-search') > -1) {
          return;
        }

        if (self.os.name === 'ios') {
          $('head').triggerHandler('disable-zoom');
        }
      }).on('focusout.' + UTIL_NAME, 'input, textarea', function (e) {
        var target = e.target;
        if (target.className.indexOf('dropdown-search') > -1) {
          return;
        }

        if (self.os.name === 'ios') {
          $('head').triggerHandler('enable-zoom');
        }
      });
    },


    /**
     * Tears down global UI-specific event handlers
     * @returns {void}
     */
    removeGlobalEvents: function removeGlobalEvents() {
      $(window).off('scroll.' + UTIL_NAME);

      $('body').off(['focusin.' + UTIL_NAME, 'focusout.' + UTIL_NAME].join(' '));
    }
  };

  /**
   * @returns {boolean} whether or not the current browser is IE11
   */
  Environment.browser.isIE11 = function () {
    return Environment.browser.name === 'ie' && Environment.browser.version === '11';
  };

  /**
   * @returns {boolean} whether or not the current browser is IE10
   */
  Environment.browser.isIE10 = function () {
    return Environment.browser.name === 'ie' && Environment.browser.version === '10';
  };

  /**
   * Automatically set up the environment by virtue of including this script
   */
  Environment.set();

  /**
   * HideFocus Behavior
   * Only shows the focus state on key entry (tabs or arrows).
   * @param {HTMLElement|SVGElement} element the base element
   * @returns {HideFocus} component instance
   */
  function HideFocus(element) {
    return this.init(element);
  }

  HideFocus.prototype = {
    init: function init(element) {
      if (!this.element && (element instanceof HTMLElement || element instanceof SVGElement)) {
        this.element = element;
      }

      var $el = $(element);
      var isClick = false;
      var isFocused = false;
      var labelClicked = false;

      // Checkbox, Radio buttons or Switch
      if ($el.is('.checkbox, .radio, .switch')) {
        var label = $el.next();
        if (label.is('[type="hidden"]')) {
          label = label.next();
        }
        this.label = label[0];

        $el.addClass('hide-focus').on('focusin.hide-focus', function (e) {
          if (!isClick && !isFocused && !labelClicked) {
            $el.removeClass('hide-focus');
            $el.triggerHandler('hidefocusremove', [e]);
          }
          isClick = false;
          isFocused = true;
          labelClicked = false;
        }).on('focusout.hide-focus', function (e) {
          $el.addClass('hide-focus');
          labelClicked = label.is(labelClicked);
          isClick = false;
          isFocused = false;
          $el.triggerHandler('hidefocusadd', [e]);
        });

        label.on('mousedown.hide-focus', function (e) {
          labelClicked = this;
          isClick = true;
          $el.addClass('hide-focus');
          $el.triggerHandler('hidefocusadd', [e]);
        });
      } else {
        // All other elements (ie. Hyperlinks)
        var handleMousedown = function handleMousedown(e) {
          isClick = true;
          $el.addClass('hide-focus');
          $el.triggerHandler('hidefocusadd', [e]);
        };
        var isTouch = Environment.features.touch;

        if (isTouch) {
          $el.on('touchstart.hide-focus', function (e) {
            handleMousedown(e);
          });
        }

        $el.addClass('hide-focus').on('mousedown.hide-focus', function (e) {
          handleMousedown(e);
        }).on('focusin.hide-focus', function (e) {
          if (!isClick && !isFocused) {
            $el.removeClass('hide-focus');
            $el.triggerHandler('hidefocusremove', [e]);
          }
          isClick = false;
          isFocused = true;
        }).on('focusout.hide-focus', function (e) {
          $el.addClass('hide-focus');
          isClick = false;
          isFocused = false;
          $el.triggerHandler('hidefocusadd', [e]);
        });
      }

      return this;
    },
    updated: function updated() {
      return this.teardown().init();
    },
    teardown: function teardown() {
      if (this.label) {
        $(this.label).off('mousedown.hide-focus');
      }

      var elemEvents = ['focusin.hide-focus', 'focusout.hide-focus', 'mousedown.hide-focus', 'touchstart.hide-focus'];
      $(this.element).off(elemEvents.join(' '));

      return this;
    }
  };

  /**
   * jQuery component wrapper for the HideFocus behavior
   * @returns {jQuery[]} components being acted on
   */
  $.fn.hideFocus = function () {
    return this.each(function () {
      var instance = $.data(this, 'hidefocus');
      if (instance) {
        instance.updated();
      } else {
        instance = $.data(this, 'hidefocus', new HideFocus(this));
        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, 'hidefocus');
        };
      }
    });
  };

  /**
   * Allows for the smooth scrolling of an element's content area.
   * @param {HTMLElement|SVGElement|jQuery[]} el The element being manipulated.
   * @param {number} target target distance.
   * @param {number} duration the time that will be needed for the scrolling to complete.
   * @returns {$.Deferred} promise that resolved when scrolling completes.
   */
  function smoothScrollTo(el, target, duration) {
    var dfd = $.Deferred();

    if (!DOM.isElement(el)) {
      // Not a workable element
      return dfd.reject();
    }

    // Strip the jQuery
    if (el instanceof $ && el.length) {
      el = el[0];
    }

    // undefined (not zero) target should instantly resolve
    if (target === undefined || target === null) {
      return dfd.resolve();
    }

    if (isNaN(duration)) {
      duration = 0;
    }

    target = Math.round(target);
    duration = Math.round(duration);

    if (duration < 0) {
      // bad duration
      return dfd.fail();
    }

    if (duration === 0) {
      el.scrollLeft += target;
      return dfd.resolve();
    }

    var startTime = Date.now();
    var endTime = startTime + duration;
    var startLeft = el.scrollLeft;
    var distance = target;

    // based on http://en.wikipedia.org/wiki/Smoothstep
    function smoothStep(start, end, point) {
      if (point <= start) {
        return 0;
      }
      if (point >= end) {
        return 1;
      }
      var x = (point - start) / (end - start); // interpolation
      return x * x * (3 - 2 * x);
    }

    // This is to keep track of where the element's scrollLeft is
    // supposed to be, based on what we're doing
    var previousLeft = el.scrollLeft;

    // This is like a think function from a game loop
    function scrollFrame() {
      if (el.scrollLeft !== previousLeft) {
        // interrupted
        dfd.reject();
        return;
      }

      // set the scrollLeft for this frame
      var now = Date.now();
      var point = smoothStep(startTime, endTime, now);
      var frameLeft = Math.round(startLeft + distance * point);
      el.scrollLeft = frameLeft;

      // check if we're done!
      if (now >= endTime) {
        dfd.resolve();
        return;
      }

      // If we were supposed to scroll but didn't, then we
      // probably hit the limit, so consider it done; not
      // interrupted.
      if (el.scrollLeft === previousLeft && el.scrollLeft !== frameLeft) {
        dfd.resolve();
        return;
      }
      previousLeft = el.scrollLeft;

      // schedule next frame for execution
      setTimeout(scrollFrame, 0);
    }

    // boostrap the animation process
    setTimeout(scrollFrame, 0);

    return dfd;
  }

  /**
   * Binds the Soho Behavior _smoothScrollTo()_ to a jQuery selector
   * @param {number} target target distance to scroll the element
   * @param {number} duration the time that will be needed for the scrolling to complete.
   * @returns {$.Deferred} promise that resolved when scrolling completes.
   */
  $.fn.smoothScroll = function (target, duration) {
    return smoothScrollTo(this, target, duration);
  };

  /**
   * Uses 'requestAnimationFrame' or 'setTimeout' to defer a function.
   * @param {function} callback the callback that runs on a deferment.
   * @param {number} timer how long to delay before running the callback.
   * @returns {function} either `requestAnimationFrame` or `setTimeout`
   */
  function defer(callback, timer) {
    var deferMethod = typeof window.requestAnimationFrame !== 'undefined' ? window.requestAnimationFrame : setTimeout;
    return deferMethod(callback, timer);
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  /**
   * Used for changing the stacking order of jQuery events.  This is needed to override certain
   * Events invoked by other plugins http://stackoverflow.com/questions/2360655
   * @private
   * @param {string} name the event name
   * @param {function} fn callback function that will be called during the supplied event name
   * @returns {void}
   */
  $.fn.bindFirst = function (name, fn) {
    this.on(name, fn);
    this.each(function () {
      var handlers = $._data(this, 'events')[name.split('.')[0]]; // eslint-disable-line
      // take out the handler we just inserted from the end
      var handler = handlers.pop();
      // move it at the beginning
      handlers.splice(0, 0, handler);
    });
  };

  /**
   * @private
   * uniqueIdCount is a baseline unique number that will be used when generating
   * uniqueIds for elements and components.
   */
  var uniqueIdCount = []; // eslint-disable-line

  /**
   * Detect whether or not a text string represents a valid CSS property.  This check
   * includes an attempt at checking for vendor-prefixed versions of the CSS property
   * provided.
   * @private
   * @param {string} prop a possible CSS property
   * @returns {string|null} If the property exists, it will be returned in string format.
   *  If the property doesn't exist, a null result is returned.
   */
  $.fn.cssPropSupport = function (prop) {
    if (!prop) {
      return null;
    }

    var el = $('<div></div>')[0];
    var propStr = prop.toString();
    var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
    var capitalizedProp = propStr.charAt(0).toUpperCase() + propStr.substr(1);

    if (prop in el.style) {
      $(el).remove();
      return prop;
    }

    for (var i = 0; i < prefixes.length; i++) {
      var vendorProp = prefixes[i] + capitalizedProp;
      if (vendorProp in el.style) {
        $(el).remove();
        return vendorProp;
      }
    }

    $(el).remove();
    return null;
  };

  /**
   * Returns the name of the TransitionEnd event.
   * @private
   * @returns {string} a (possibly) vendor-adjusted CSS transition property name.
   */
  $.fn.transitionEndName = function () {
    var prop = $.fn.cssPropSupport('transition');
    var eventNames = {
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'transitionend',
      MSTransition: 'msTransitionEnd',
      OTransition: 'oTransitionEnd',
      transition: 'transitionend'
    };

    return eventNames[prop] || null;
  };

  /**
   * Checks to see if a provided element is visible based on its CSS `visibility` property.
   * @private
   * @param {HTMLElement} element the element being checked.
   * @returns {boolean} whether or not the element is visible.
   */
  function visible(element) {
    return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
      return $.css(this, 'visibility') === 'hidden';
    }).length;
  }

  /**
   * From jQueryUI Core: https://github.com/jquery/jquery-ui/blob/24756a978a977d7abbef5e5bce403837a01d964f/ui/jquery.ui.core.js#L93
   * Adapted from:  http://stackoverflow.com/questions/7668525/is-there-a-jquery-selector-to-get-all-elements-that-can-get-focus
   * Adds the ':focusable' selector to Sizzle to allow for the selection of elements
   * that can currently be focused.
   * @private
   * @param {HTMLElement} element the element being checked
   * @returns {boolean} whether or not the element is focusable.
   */
  function _focusable(element) {
    var map = void 0;
    var mapName = void 0;
    var img = void 0;
    var nodeName = element.nodeName.toLowerCase();
    var isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex'));

    if (nodeName === 'area') {
      map = element.parentNode;
      mapName = map.name;
      if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
        return false;
      }
      img = $('img[usemap=#' + mapName + ']')[0];
      return !!img && visible(img);
    }

    // The element and all of its ancestors must be visible.
    // Return out fast if this isn't the case.
    if (!visible(element)) {
      return false;
    }

    var match = /input|select|textarea|button|object/.test(nodeName);
    if (match) {
      return !element.disabled;
    }
    if (nodeName === 'a') {
      return element.href !== undefined || isTabIndexNotNaN;
    }
    return isTabIndexNotNaN;
  }

  // Adds a `:focusable` selector to jQuery's selector library.
  $.extend($.expr[':'], {
    focusable: function focusable(element) {
      return _focusable(element, !isNaN($.attr(element, 'tabindex')));
    }
  });

  /**
   * Returns a key/value list of currently attached event listeners
   * @private
   * @returns {object} containing list of event names as keys, and event listener functions as values.
   */
  $.fn.listEvents = function () {
    var data = {};

    this.each(function () {
      data = $._data(this, 'events'); // eslint-disable-line
    });

    return data;
  };

  var utils = {};

  /**
   * Generates a unique ID for an element based on the element's configuration, any
   * Soho components that are generated against it, and provided prefixes/suffixes.
   * @private
   * @param {HTMLElement} element the element being used for uniqueId capture
   * @param {string} [className] CSS classname (will be interpreted automatically
   *  if it's not provided)
   * @param {string} [prefix] optional prefix
   * @param {string} [suffix] optional suffix
   * @returns {string} the compiled uniqueID
   */
  utils.uniqueId = function (element, className, prefix, suffix) {
    var predefinedId = element.id;

    if (predefinedId && $('#' + predefinedId).length < 2) {
      return predefinedId;
    }

    prefix = !prefix ? '' : prefix + '-';
    suffix = !suffix ? '' : '-' + suffix;
    className = !className ? utils.getArrayFromList(element.classList).join('-') : className;

    if (!uniqueIdCount[className]) {
      uniqueIdCount[className] = 1;
    }
    var str = '' + prefix + className + '-' + uniqueIdCount[className] + suffix;
    uniqueIdCount[className] += 1;
    return str;
  };

  /**
   * Grabs an attribute from an HTMLElement containing stringified JSON syntax,
   * and interprets it into options.
   * @private
   * @param {HTMLElement} element the element whose settings are being interpreted
   * @param {string} [attr] optional different attribute to parse for settings
   * @returns {object} a list of interpreted settings for this element
   */
  utils.parseSettings = function parseSettings(element, attr) {
    var options = {};
    if (!element || !(element instanceof HTMLElement) && !(element instanceof $) || element instanceof $ && !element.length) {
      return options;
    }

    if (element instanceof $) {
      element = element[0];
    }

    // Use `data-options` as a default.
    attr = attr || 'data-options';

    var str = element.getAttribute(attr);
    if (!str || typeof str !== 'string' || str.indexOf('{') === -1) {
      return options;
    }

    // replace single to double quotes, since single-quotes may be necessary
    // due to entry in markup.
    function replaceDoubleQuotes(changedStr) {
      return changedStr.replace(/'/g, '"');
    }

    // Manually parse a string more in-depth
    function manualParse(changedStr) {
      // get keys
      var regex = /({|,)(?:\s*)(?:')?([A-Za-z_$\.][A-Za-z0-9_ \-\.$]*)(?:')?(?:\s*):/g; // eslint-disable-line

      // add double quotes to keys
      changedStr = changedStr.replace(regex, '$1\"$2\":'); // eslint-disable-line

      // get strings in values
      regex = /:(?:\s*)(?!(true|false|null|undefined))([A-Za-z_$\.#][A-Za-z0-9_ \-\.$]*)/g; // eslint-disable-line

      // add double quotes to strings in values
      changedStr = changedStr.replace(regex, ':\"$2\"'); // eslint-disable-line
      changedStr = replaceDoubleQuotes(changedStr);
      return changedStr;
    }

    try {
      options = JSON.parse(replaceDoubleQuotes(str));
    } catch (err) {
      options = JSON.parse(manualParse(str));
    }

    return options;
  };

  /**
   * Deprecate `utils.parseOptions` in favor of `utils.parseSettings`.
   * This method is slated to be removed in a future v4.10.0 or v5.0.0.
   * @private
   * @deprecated as of v4.4.0. Please use `parseSettings()` instead.
   * @param {HTMLElement|jQuery[]} element the element whose options are being parsed
   * @param {string} [attr] an optional alternate attribute name to use when obtaining settings
   * @returns {Object|Object[]} an object representation of parsed settings.
   */
  utils.parseOptions = function parseOptions(element, attr) {
    return utils.parseSettings(element, attr);
  };

  /**
  * jQuery Behavior Wrapper for `utils.parseOptions`.
  * @deprecated as of v4.4.0. This is no longer necessary to call directly and should be avoided.
  * @private
  * @param {HTMLElement|jQuery[]} element the element whose options are being parsed
  * @param {string} [attr] an optional alternate attribute name to use when obtaining settings
  * @returns {Object|Object[]} an object representation of parsed settings.
  */
  $.fn.parseOptions = function (element, attr) {
    var results = [];
    var isCalledDirectly = element instanceof HTMLElement || element instanceof SVGElement || element instanceof $;
    var targets = this;

    if (isCalledDirectly) {
      targets = $(element);
    } else {
      attr = element;
      element = undefined;
    }

    targets.each(function (i, item) {
      results.push({
        element: this,
        options: utils.parseOptions(item, attr)
      });
    });

    if (results.length === 1) {
      return results[0].options;
    }
    return results;
  };

  /**
   * Performs the usual Boolean coercion with the exception of the strings "false"
   * (case insensitive) and "0"
   * @private
   * @param {boolean|string|number} b the value to be checked
   * @returns {boolean} whether or not the value passed coerces to true.
   */
  utils.coerceToBoolean = function (b) {
    return !/^(false|0)$/i.test(b) && !!b;
  };

  /**
   * Coerces all properties inside of a settings object to a boolean.
   * @param {Object} settings incoming settings
   * @param {String[]} [targetPropsArr=undefined] optional array of specific settings keys to target.
   *  If no keys are provided, all keys will be targeted.
   * @returns {Object} modified settings.
   */
  utils.coerceSettingsToBoolean = function (settings, targetPropsArr) {
    if (!targetPropsArr || !Array.isArray(targetPropsArr)) {
      Object.keys(settings).forEach(function (key) {
        targetPropsArr.push(key);
      });
    }

    var i = void 0;
    var l = void 0;
    for (i = 0, l = targetPropsArr.length; i < l; i++) {
      settings[targetPropsArr[i]] = utils.coerceToBoolean(settings[targetPropsArr[i]]);
    }

    return settings;
  };

  /**
   * Timer - can be used for play/pause or stop for given time.
   * Use as new instance [ var timer = new $.fn.timer(function() {}, 6000); ]
   * then can be listen events as:
   * [ $(timer.event).on('update', function(e, data){console.log(data.counter)}); ]
   * or can access as [ timer.cancel(); -or- timer.pause(); -or- timer.resume(); ]
   * @private
   * @param {function} [callback] method that will run on each timer update
   * @param {number} delay amount of time between timer ticks
   * @returns {object} containing methods that can be run on the timer
   */
  $.fn.timer = function (callback, delay) {
    var self = $(this);
    var speed = 10;
    var interval = void 0;
    var counter = 0;

    function cancel() {
      self.triggerHandler('cancel');
      clearInterval(interval);
      counter = 0;
    }

    function pause() {
      self.triggerHandler('pause');
      clearInterval(interval);
    }

    function update() {
      interval = setInterval(function () {
        counter += speed;
        self.triggerHandler('update', [{ counter: counter }]);
        if (counter > delay) {
          self.triggerHandler('timeout');
          callback.apply(arguments); // eslint-disable-line
          clearInterval(interval);
          counter = 0;
        }
      }, speed);
    }

    function resume() {
      self.triggerHandler('resume');
      update();
    }

    update();

    return {
      event: this,
      cancel: cancel,
      pause: pause,
      resume: resume
    };
  };

  /**
   * Copies a string to the clipboard. Must be called from within an event handler such as click.
   * May return false if it failed, but this is not always
   * possible. Browser support for Chrome 43+, Firefox 42+, Edge and IE 10+.
   * No Safari support, as of (Nov. 2015). Returns false.
   * IE: The clipboard feature may be disabled by an adminstrator. By default a prompt is
   * shown the first time the clipboard is used (per session).
   * @private
   * @param {string} text incoming text content
   * @returns {string|boolean} copied text, or a false result if there was an error
   */
  $.copyToClipboard = function (text) {
    // eslint-disable-line
    if (window.clipboardData && window.clipboardData.setData) {
      // IE specific code path to prevent textarea being shown while dialog is visible.
      return window.clipboardData.setData('Text', text);
    } else if (document.queryCommandSupported && document.queryCommandSupported('copy')) {
      var textarea = document.createElement('textarea');
      textarea.textContent = text;
      textarea.style.position = 'fixed'; // Prevent scrolling to bottom of page in MS Edge.
      document.body.appendChild(textarea);
      textarea.select();
      try {
        return document.execCommand('copy'); // Security exception may be thrown by some browsers.
      } catch (ex) {
        // console.warn('Copy to clipboard failed.', ex);
        return false;
      } finally {
        document.body.removeChild(textarea);
      }
    }
  };

  /**
   * Clearable (Shows an X to clear)
   * @private
   */
  $.fn.clearable = function () {
    var self = this;
    this.element = $(this);

    var COMPONENT_NAME = 'clearable';

    // Create an X icon button styles in icons.scss
    this.xButton = this.element.find('.icon.close').first();
    if (!this.xButton || !this.xButton.length) {
      this.xButton = $.createIconElement({ classes: 'close is-empty', icon: 'close' }).icon();
    }

    // Clears the contents of the base element
    this.clear = function () {
      self.element.val('').trigger('change').focus().trigger('cleared');
      self.checkContents();
    };

    // Event listener for the xButton's `keydown` event
    this.handleKeydown = function (e) {
      var key = e.key;

      if (key === 'Enter' || e.altKey && (key === 'Delete' || key === 'Backspace')) {
        e.preventDefault();
        self.clear();
      }
    };

    // Checks the contents of the base element (presumably an input field) for empty
    this.checkContents = function () {
      var text = self.element.val();
      if (!text || !text.length) {
        this.xButton.addClass('is-empty');
      } else {
        this.xButton.removeClass('is-empty');
      }

      this.element.trigger('contents-checked');
    };

    // Add the button to field parent
    this.xButton.insertAfter(self.element);
    this.xButton[0].tabIndex = 0;
    this.xButton[0].setAttribute('focusable', true);

    // Handle Events
    this.xButton.off(['click.' + COMPONENT_NAME, 'keydown.' + COMPONENT_NAME].join(' ')).on('click.clearable', this.clear).on('keydown.clearable', this.handleKeydown);

    var elemEvents = ['blur.' + COMPONENT_NAME, 'change.' + COMPONENT_NAME, 'keyup.' + COMPONENT_NAME].join(' ');

    this.element.off(elemEvents).on(elemEvents, function () {
      self.checkContents();
    });

    // Set initial state
    this.checkContents();
  };

  /**
   * Replacement for String.fromCharCode() that takes meta keys into account when determining which
   * @private
   * character key was pressed.
   * @param {jQuery.Event} e jQuery-wrapped `keypress` event
   * @returns {string} text tcharacter
   */
  utils.actualChar = function (e) {
    var key = e.which;
    var character = '';
    var toAscii = {
      188: '44',
      // '109': '45', // changes "m" to "-" when using keypress
      190: '46',
      191: '47',
      192: '96',
      220: '92',
      222: '39',
      221: '93',
      219: '91',
      173: '45',
      187: '61', // IE Key codes
      186: '59', // IE Key codes
      189: '45' // IE Key codes
    };
    var shiftUps = {
      96: '~',
      49: '!',
      50: '@',
      51: '#',
      52: '$',
      53: '%',
      54: '^',
      55: '&',
      56: '*',
      57: '(',
      48: ')',
      45: '_',
      61: '+',
      91: '{',
      93: '}',
      92: '|',
      59: ':',
      37: '%',
      38: '&',
      39: '"',
      44: '<',
      46: '>',
      47: '?'
    };

    // Normalize weird keycodes
    if (Object.prototype.hasOwnProperty.call(toAscii, key)) {
      key = toAscii[key];
    }

    // Handle Numpad keys
    if (key >= 96 && key <= 105) {
      key -= 48;
    }

    // Convert Keycode to Character String
    if (!e.shiftKey && key >= 65 && key <= 90) {
      character = String.fromCharCode(key + 32);
    } else if (e.shiftKey && Object.prototype.hasOwnProperty.call(shiftUps, key)) {
      // User was pressing Shift + any key
      character = shiftUps[key];
    } else {
      character = String.fromCharCode(key);
    }

    return character;
  };

  /**
   * Get the actualy typed key from the event.
   * @private
   * @param  {object} e The event to check for the key.
   * @returns {string} The actual key typed.
   */
  $.actualChar = function (e) {
    return utils.actualChar(e);
  };

  /**
   * Equate two values quickly in a truthy fashion
   * @private
   * @param {any} a first value
   * @param {any} b second value
   * @returns {boolean} whether the two items compare in a truthy fashion.
   */
  utils.equals = function equals(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
  };

  /**
   * Converts an element wrapped in a jQuery collection down to its original HTMLElement reference.
   * If an HTMLElement is passed in, simply returns it.
   * If anything besides HTMLElements or jQuery[] is passed in, returns undefined;
   * @private
   * @param {any} item the item being evaluated
   * @returns {HTMLElement|undefined} the unwrapped item, or nothing.
   */
  DOM.convertToHTMLElement = function convertToHTMLElement(item) {
    if (item instanceof HTMLElement) {
      return item;
    }

    if (item instanceof $) {
      if (item.length) {
        item = item[0];
      } else {
        item = undefined;
      }
      return item;
    }

    return undefined;
  };

  /**
   * Object deep copy.
   * For now, alias jQuery.extend
   * Eventually we'll replace this with a non-jQuery extend method.
   * @private
   */
  utils.extend = $.extend;

  /**
   * Hack for IE11 and SVGs that get moved around/appended at inconvenient times.
   * The action of changing the xlink:href attribute to something else and back will fix the problem.
   * @private
   * @param {HTMLElement} rootElement the base element
   * @returns {void}
   */
  utils.fixSVGIcons = function fixSVGIcons(rootElement) {
    if (Environment.browser.name !== 'ie' && Environment.browser.version !== '11') {
      return;
    }

    if (rootElement === undefined) {
      return;
    }

    var xlinkNS = 'http://www.w3.org/1999/xlink';

    // Handle jQuery
    if (rootElement instanceof $) {
      if (!rootElement.length) {
        return;
      }

      if (rootElement.length === 1) {
        rootElement = rootElement[0];
      } else {
        rootElement.each(function (i, elem) {
          fixSVGIcons(elem);
        });
        return;
      }
    }

    // Handle NodeList in an IE-friendly way
    // https://developer.mozilla.org/en-US/docs/Web/API/NodeList#Example
    if (rootElement instanceof NodeList) {
      Array.prototype.forEach.call(rootElement, function (elem) {
        fixSVGIcons(elem);
      });
      return;
    }

    setTimeout(function () {
      var uses = rootElement.getElementsByTagName('use');
      for (var i = 0; i < uses.length; i++) {
        var attr = uses[i].getAttributeNS(xlinkNS, 'href');
        uses[i].setAttributeNS(xlinkNS, 'href', 'x');
        uses[i].setAttributeNS(xlinkNS, 'href', attr);
      }
    }, 1);
  };

  /**
   * Gets the current size of the viewport
   * @private
   * @returns {object} width/height of the viewport
   */
  utils.getViewportSize = function getViewportSize() {
    return {
      width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
      height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
    };
  };

  /**
   * Gets the various scrollable containers that an element is nested inside of, and returns
   *  their scrollHeight and scrollLeft values.
   * @private
   * @param {HTMLElement} element the base element to check for containment
   * @returns {object} containing references to the container element and its top/left
   */
  utils.getContainerScrollDistance = function getContainerScrollDistance(element) {
    if (!DOM.isElement(element)) {
      return [];
    }

    var containers = [];
    var scrollableElements = ['.scrollable', '.scrollable-x', '.scrollable-y', '.modal', '.card-content', '.widget-content', '.tab-panel', '.datagrid-content'];

    $(element).parents(scrollableElements.join(', ')).each(function () {
      var el = this;

      containers.push({
        element: el,
        left: el.scrollLeft,
        top: el.scrollTop
      });
    });

    // Push the body's scroll area if it's not a "no-scroll" area
    if (!document.body.classList.contains('no-scroll')) {
      containers.push({
        element: document.body,
        left: document.body.scrollLeft,
        top: document.body.scrollTop
      });
    }

    return containers;
  };

  /**
   * Takes an element that is currently hidden by some means (FX: "display: none;")
   *  and gets its potential dimensions by checking a clone of the element that is NOT hidden.
   * @private
   * @param {HTMLElement|SVGElement|jQuery[]} el The element being manipulated.
   * @param {object} options incoming options.
   * @param {jQuery[]} [parentElement] the parent element where a clone of this
   *  hidden element will be attached.
   * @returns {object} containing various width/height properties of the element provided.
   */
  utils.getHiddenSize = function getHiddenSize(el, options) {
    var defaults = {
      dims: { width: 0, height: 0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 },
      parentElement: undefined,
      includeMargin: false
    };

    if (!DOM.isElement(el)) {
      return defaults.dims;
    }

    el = $(el);
    options = $.extend({}, defaults, options);

    // element becomes clone and appended to a parentElement, if defined
    var hasDefinedParentElement = DOM.isElement(options.parentElement);
    if (hasDefinedParentElement) {
      el = el.clone().appendTo(options.parentElement);
    }

    var dims = options.dims;
    var hiddenParents = el.parents().add(el);
    var props = {
      transition: 'none',
      webkitTransition: 'none',
      mozTransition: 'none',
      msTransition: 'none',
      visibility: 'hidden',
      display: 'block'
    };
    var oldProps = [];

    hiddenParents.each(function () {
      var _this = this;

      var old = {};
      var propTypes = Object.keys(props);
      propTypes.forEach(function (name) {
        if (_this.style[name]) {
          old[name] = _this.style[name];
          _this.style[name] = props[name];
        }
      });

      oldProps.push(old);
    });

    dims.padding = {
      bottom: el.css('padding-bottom'),
      left: el.css('padding-left'),
      right: el.css('padding-right'),
      top: el.css('padding-top')
    };
    dims.width = el.width();
    dims.outerWidth = el.outerWidth(options.includeMargin);
    dims.innerWidth = el.innerWidth();
    dims.scrollWidth = el[0].scrollWidth;
    dims.height = el.height();
    dims.innerHeight = el.innerHeight();
    dims.outerHeight = el.outerHeight(options.includeMargin);
    dims.scrollHeight = el[0].scrollHeight;

    hiddenParents.each(function (i) {
      var _this2 = this;

      var old = oldProps[i];
      var propTypes = Object.keys(props);
      propTypes.forEach(function (name) {
        if (old[name]) {
          _this2.style[name] = old[name];
        }
      });
    });

    // element is ONLY removed when a parentElement is defined because it was cloned.
    if (hasDefinedParentElement) {
      el.remove();
    }

    return dims;
  };

  /**
   * Binds the Soho Util _getHiddenSize()_ to a jQuery selector
   * @private
   * @param {object} options - incoming options
   * @returns {object} hidden size
   */
  $.fn.getHiddenSize = function (options) {
    return utils.getHiddenSize(this, options);
  };

  /**
   * Checks if a specific input is a String
   * @private
   * @param {any} value an object of unknown type to check
   * @returns {boolean} whether or not a specific input is a String
   */
  utils.isString = function isString(value) {
    return typeof value === 'string' || value instanceof String;
  };

  /**
   * Checks if a specific input is a Number
   * @private
   * @param {any} value an object of unknown type to check
   * @returns {boolean} whether or not a specific input is a Number
   */
  utils.isNumber = function isNumber(value) {
    return typeof value === 'number' && value.length === undefined && !isNaN(value);
  };

  /**
   * Safely changes the position of a text caret inside of an editable element.
   * In most cases, will call "setSelectionRange" on an editable element immediately, but in some
   * cases, will be deferred with `requestAnimationFrame` or `setTimeout`.
   * @private
   * @param {HTMLElement} element the element to get selection
   * @param {number} startPos starting position of the text caret
   * @param {number} endPos ending position of the text caret
   */
  utils.safeSetSelection = function safeSetSelection(element, startPos, endPos) {
    if (startPos && endPos === undefined) {
      endPos = startPos;
    }

    if (document.activeElement === element) {
      if (Environment.os.name === 'android') {
        defer(function () {
          element.setSelectionRange(startPos, endPos, 'none');
        }, 0);
      } else {
        element.setSelectionRange(startPos, endPos, 'none');
      }
    }
  };

  /**
   * Checks to see if a variable is valid for containing Soho component options.
   * @private
   * @param {object|function} o an object or function
   * @returns {boolean} whether or not the object type is valid
   */
  function isValidOptions(o) {
    return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' || typeof o === 'function';
  }

  /**
   * In some cases, functions are passed to component constructors as the settings argument.
   * This method runs the settings function if it's present and returns the resulting object.
   * @private
   * @param {object|function} o represents settings
   * @returns {object} processed settings
   */
  function resolveFunctionBasedSettings(o) {
    if (typeof o === 'function') {
      return o();
    }
    return o;
  }

  /**
   * Merges various sets of options into a single object,
   * whose intention is to be set as options on a Soho component.
   * @private
   * @param {HTMLElement|SVGElement|jQuery[]} [element] the element to process for inline-settings
   * @param {Object|function} incomingOptions desired settings
   * @param {Object|function} [defaultOptions] optional base settings
   * @returns {object} processed settings
   */
  utils.mergeSettings = function mergeSettings(element, incomingOptions, defaultOptions) {
    if (!incomingOptions || !isValidOptions(incomingOptions)) {
      if (isValidOptions(defaultOptions)) {
        incomingOptions = defaultOptions;
      } else {
        incomingOptions = {};
      }
    }

    // Actually get ready to merge incoming options if we get to this point.
    return utils.extend(true, {}, resolveFunctionBasedSettings(defaultOptions || {}), resolveFunctionBasedSettings(incomingOptions), element !== undefined ? utils.parseSettings(element) : {}); // possible to run this without an element present -- will simply skip this part
  };

  /**
   * Test if a string is Html or not
   * @private
   * @param  {string} string The string to test.
   * @returns {boolean} True if it is html.
   */
  utils.isHTML = function (string) {
    return (/(<([^>]+)>)/i.test(string)
    );
  };

  var math = {};

  /**
   * Convert `setTimeout/Interval` delay values (CPU ticks) into frames-per-second
   * (FPS) numeric values.
   * @private
   * @param {number} delay CPU Ticks
   * @returns {number} Frames Per Second
   */
  math.convertDelayToFPS = function convertDelayToFPS(delay) {
    if (isNaN(delay)) {
      throw new Error('provided delay value is not a number');
    }
    return delay / 16.7;
  };

  /**
   * Convert `setTimeout/Interval` delay values (CPU ticks) into frames-per-second
   * (FPS) numeric values.
   * @private
   * @param {number} fps (Frames Per Second)
   * @returns {number} delay in CPU ticks
   */
  math.convertFPSToDelay = function convertFPSToDelay(fps) {
    if (isNaN(fps)) {
      throw new Error('provided delay value is not a number');
    }
    return fps * 16.7;
  };

  /**
   *  Determines whether the passed value is a finite number.
   * @private
   * @param {number} value The number
   * @returns {boolean} If it is finite or not.
   */
  math.isFinite = function isFinite(value) {
    // 1. If Type(number) is not Number, return false.
    if (typeof value !== 'number') {
      return false;
    }
    // 2. If number is NaN, +, or , return false.
    if (value !== value || value === Infinity || value === -Infinity) {
      //eslint-disable-line
      return false;
    }
    // 3. Otherwise, return true.
    return true;
  };

  /**
   * `Array.ForEach()`-style method that is also friendly to `NodeList` types.
   * @param {Array|NodeList} array incoming items
   * @param {function} callback the method to run
   * @param {object} scope the context in which to run the method
   */
  utils.forEach = function forEach(array, callback, scope) {
    for (var i = 0; i < array.length; i++) {
      callback.call(scope, array[i], i, array); // passes back stuff we need
    }
  };

  /**
   * Function to check if element has css class
   * @private
   * @param {object} elem The DOM element
   * @param {string} classStr The css class name to check
   * @returns {boolean} true if found given css class
   */
  utils.hasClass = function hasClass(elem, classStr) {
    var r = false;
    if (elem) {
      if ('classList' in elem) {
        r = elem.classList.contains(classStr);
      } else {
        var classAttr = elem.getAttribute('class');
        r = classAttr ? classAttr.split(/\s+/).indexOf(classStr) !== -1 : false;
      }
    }
    return r;
  };

  /**
   * Returns the sign of a number, indicating whether the number is positive, negative or zero
   * @param {number} x A number.
   * @returns {number} A number representing the sign of the given argument. If the argument is a positive number, negative number, positive zero or negative zero, the function will return 1, -1, 0 or -0 respectively. Otherwise, NaN is returned.
   */
  math.sign = function (x) {
    if (Math.sign) {
      return Math.sign(x);
    }

    x = +x;
    if (x === 0 || isNaN(x)) {
      return x;
    }
    return x > 0 ? 1 : -1;
  };

  /**
   * Convenience method for using `Array.prototype.slice()` on an Array-like object (or an actual array)
   * to make a copy.
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Array-like_objects
   * @param {Array|NodeList} listObj an array-like object
   * @returns {array} containing the list in array format.
   */
  utils.getArrayFromList = function (listObj) {
    var unboundSlice = Array.prototype.slice;
    return Function.prototype.call.bind(unboundSlice)(listObj);
  };

  /**
   * Gets the OS scollbar width in pixels.
   * @returns {number} The width as a number.
   */
  utils.getScrollbarWidth = function () {
    var outer = document.createElement('div');
    outer.style.visibility = 'hidden';
    outer.style.width = '100px';
    document.body.appendChild(outer);

    var widthNoScroll = outer.offsetWidth;
    outer.style.overflow = 'scroll';

    var inner = document.createElement('div');
    inner.style.width = '100%';
    outer.appendChild(inner);

    var widthWithScroll = inner.offsetWidth;
    outer.parentNode.removeChild(outer);

    return widthNoScroll - widthWithScroll;
  };

  var stringUtils = {};

  /**
   * Re-usable Empty String that can be referenced everywhere to save small amounts of space.
   */
  stringUtils.EMPTY = '';

  /**
  * The splice() method changes the content of a string by removing a range of
  * characters and/or adding new characters.
  *
  * @param {string} str The string that will be manipulated.
  * @param {number} start Index at which to start changing the string.
  * @param {number} delCount An integer indicating the number of old chars to remove.
  * @param {string} newSubStr The String that is spliced in.
  * @returns {string} A new string with the spliced substring.
  */
  stringUtils.splice = function splice(str, start, delCount, newSubStr) {
    return str.slice(0, start) + newSubStr + str.slice(start + Math.abs(delCount));
  };

  /**
   * Takes a string with possible duplicate characters and returns a string
   * containing ALL unique characters.  Useful for construction of REGEX objects
   * with characters from an input field, etc.
   * @param {string} str The string to process
   * @returns {string} The processed string
   */
  stringUtils.removeDuplicates = function removeDuplicates(str) {
    return str.split('').filter(function (item, pos, self) {
      //eslint-disable-line
      return self.indexOf(item) === pos;
    }).join('');
  };

  /**
   * Takes a string and uses a regex test to detect the presence of HTML elements.
   * @param {string} str The string to search
   * @returns {boolean} True if the string is contained.
   */
  stringUtils.containsHTML = function containsHTML(str) {
    return (/<[a-z][\s\S]*>/i.test(str)
    );
  };

  /**
   * Takes a string containing HTML and strips it of extraneous white space.
   * @param {string} str The string to parse
   * @returns {string} The string minus extraneous white space.
   */
  stringUtils.stripWhitespace = function stripWhitespace(str) {
    return str.replace(/\n/g, '').replace(/[\t ]+</g, '<').replace(/>[\t ]+</g, '><').replace(/>[\t ]+$/g, '>');
  };

  /**
   * Capitalizes the first letter of a string
   * @param {string} str the incoming text
   * @returns {string} the modified text
   */
  stringUtils.capitalize = function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  /**
   * [capitalize description]
   * @param  {string} val A text string ("true" or "false") that can be converted to a boolean.
   * @returns {boolean} true or false
   */
  stringUtils.toBoolean = function capitalize(val) {
    var num = +val;
    return !isNaN(num) ? !!num : !!String(val).toLowerCase().replace(!!0, '');
  };

  /**
   * Return the width in pixels, assuming fontsize 14 as a default
   * @param  {string} text A text string to measure.
   * @param  {string} fontsize The elements font size (defaults to 14)
   * @returns {number} The text width.
   */
  stringUtils.textWidth = function capitalize(text) {
    var fontsize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 14;

    this.canvas = this.canvas || (this.canvas = document.createElement('canvas'));
    var context = this.canvas.getContext('2d');
    context.font = fontsize + 'px arial';

    var metrics = context.measureText(text);
    return Math.round(metrics.width);
  };

  /**
   * Pad a date into a string with zeros added.
   * @private
   * @param {number} year The year to use.
   * @param {number} month The month to use.
   * @param {number} day The day to use.
   * @returns {void}
   */
  stringUtils.padDate = function padDate(year, month, day) {
    return year + ('0' + (month + 1)).slice(-2) + ('0' + day).slice(-2);
  };

  /**
   * Calculate the width for given text string.
   * @private
   * @param {string} text string to process
   * @param {number} padding value for left + right
   * @param {string} font size and family used with the given text string
   * @returns {number} calculated width
   */
  stringUtils.textWidth = function textWidth(text, padding, font) {
    this.canvasTW = this.canvasTW || (this.canvasTW = document.createElement('canvas'));
    var context = this.canvasTW.getContext('2d');
    context.font = font || '14px arial';

    var metrics = context.measureText(text);
    return Math.round(metrics.width + (padding || 0));
  };

  /**
   * Escape  user input to be treated as literal string with regular expressions
   * @private
   * @param {string} s string to process.
   * @returns {string} string after escaping.
   */
  stringUtils.escapeRegExp = function escapeRegExp(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& whole matched string
  };
   //eslint-disable-line

  /* eslint-disable no-nested-ternary, no-useless-escape */

  // If `SohoConfig` exists with a `culturesPath` property, use that path for retrieving
  // culture files. This allows manually setting the directory for the culture files.
  var existingCulturePath = '';
  if (_typeof(window.SohoConfig) === 'object' && typeof window.SohoConfig.culturesPath === 'string') {
    existingCulturePath = window.SohoConfig.culturesPath;
  }

  /**
  * The Locale component handles i18n
  * Data From: http://www.unicode.org/repos/cldr-aux/json/22.1/main/
  * For Docs See: http://ibm.co/1nXyNxp
  * @class Locale
  * @constructor
  *
  * @param {string} currentLocale  The Currently Set Locale
  * @param {object} cultures  Contains all currently-stored cultures.
  * @param {string} culturesPath  the web-server's path to culture files.
  */
  var Locale = { // eslint-disable-line

    currentLocale: { name: '', data: {} }, // default
    currentLanguage: { name: '' }, // default
    cultures: {},
    languages: {},
    culturesPath: existingCulturePath,
    defaultLocales: [{ lang: 'af', default: 'af-ZA' }, { lang: 'ar', default: 'ar-EG' }, { lang: 'bg', default: 'bg-BG' }, { lang: 'cs', default: 'cs-CZ' }, { lang: 'da', default: 'da-DK' }, { lang: 'de', default: 'de-DE' }, { lang: 'el', default: 'el-GR' }, { lang: 'en', default: 'en-US' }, { lang: 'es', default: 'es-ES' }, { lang: 'et', default: 'et-ET' }, { lang: 'fi', default: 'fi-FI' }, { lang: 'fr', default: 'fr-FR' }, { lang: 'he', default: 'he-IL' }, { lang: 'hi', default: 'hi-IN' }, { lang: 'hr', default: 'hr-HR' }, { lang: 'hu', default: 'hu-HU' }, { lang: 'id', default: 'id-ID' }, { lang: 'it', default: 'it-IT' }, { lang: 'iw', default: 'he-IL' }, { lang: 'ja', default: 'ja-JP' }, { lang: 'ko', default: 'ko-KR' }, { lang: 'lt', default: 'lt-LT' }, { lang: 'lv', default: 'lv-LV' }, { lang: 'ms', default: 'ms-bn' }, { lang: 'nb', default: 'nb-NO' }, { lang: 'nl', default: 'nl-NL' }, { lang: 'no', default: 'no-NO' }, { lang: 'pl', default: 'pl-PL' }, { lang: 'pt', default: 'pt-PT' }, { lang: 'ro', default: 'ro-RO' }, { lang: 'ru', default: 'ru-RU' }, { lang: 'sk', default: 'sk-SK' }, { lang: 'sl', default: 'sl-SI' }, { lang: 'sv', default: 'sv-SE' }, { lang: 'th', default: 'th-TH' }, { lang: 'tr', default: 'tr-TR' }, { lang: 'uk', default: 'uk-UA' }, { lang: 'vi', default: 'vi-VN' }, { lang: 'zh', default: 'zh-CN' }],
    supportedLocales: ['af-ZA', 'ar-EG', 'ar-SA', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-AU', 'en-GB', 'en-IN', 'en-NZ', 'en-US', 'en-ZA', 'es-AR', 'es-ES', 'es-MX', 'es-US', 'et-EE', 'fi-FI', 'fr-CA', 'fr-FR', 'he-IL', 'hi-IN', 'hr-HR', 'hu-HU', 'id-ID', 'it-IT', 'ja-JP', 'ko-KR', 'lt-LT', 'lv-LV', 'ms-bn', 'ms-my', 'nb-NO', 'nl-NL', 'no-NO', 'pl-PL', 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sk-SK', 'sl-SI', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN', 'zh-Hans', 'zh-Hant', 'zh-TW'],
    defaultLocale: 'en-US',

    /**
     * Sets the current language in the Html Header
     * @private
     * @param  {string} lang The two digit language code.
     */
    updateLanguage: function updateLanguage(lang) {
      var html = $('html');

      html.attr('lang', lang);
      if (this.isRTL()) {
        html.attr('dir', 'rtl');
      } else {
        html.removeAttr('dir');
      }

      // ICONS: Right to Left Direction
      if (this.isRTL()) {
        Locale.flipIconsHorizontally();
      }
      $('body').removeClass('busy-loading-locale');
    },


    /**
     * Get the path to the directory with the cultures
     * @private
     * @returns {string} path containing culture files.
     */
    getCulturesPath: function getCulturesPath() {
      if (!this.culturesPath) {
        var scripts = document.getElementsByTagName('script');
        var partialPathMin = 'sohoxi.min.js';
        var partialPath = 'sohoxi.js';

        for (var i = 0; i < scripts.length; i++) {
          var src = scripts[i].src;

          // remove from ? to end
          var idx = src.indexOf('?');
          if (src !== '' && idx > -1) {
            src = src.substr(0, idx);
          }

          if (scripts[i].id === 'sohoxi-script') {
            return src.substring(0, src.lastIndexOf('/')) + '/';
          }

          if (src.indexOf(partialPathMin) > -1) {
            this.culturesPath = src.replace(partialPathMin, '') + 'cultures/';
          }
          if (src.indexOf(partialPath) > -1) {
            this.culturesPath = src.replace(partialPath, '') + 'cultures/';
          }
        }
      }
      return this.culturesPath;
    },


    /**
     * Checks if the culture is set as an inline script in the head tag.
     * @private
     * @returns {boolean} whether or not a culture file exists in the document header.
     */
    cultureInHead: function cultureInHead() {
      var isThere = false;
      var scripts = document.getElementsByTagName('script');
      var partialPath = 'cultures';

      for (var i = 0; i < scripts.length; i++) {
        var src = scripts[i].src;

        if (src.indexOf(partialPath) > -1) {
          isThere = true;
        }
      }

      return isThere;
    },


    /**
     * Internally stores a new culture file for future use.
     * @private
     * @param {string} locale The locale to check.
     * @returns {string} The actual locale to use.
     */
    correctLocale: function correctLocale(locale) {
      // Map incorrect java locale to correct locale
      if (locale === 'in-ID') {
        locale = 'id-ID';
      }
      if (locale.substr(0, 2) === 'iw') {
        locale = 'he-IL';
      }

      var lang = locale.split('-')[0];
      if (this.supportedLocales.indexOf(locale) === -1) {
        locale = this.defaultLocales.filter(function (a) {
          return a.lang === lang;
        });

        if (locale && locale[0]) {
          return locale[0].default;
        }

        locale = this.defaultLocale;
      }

      return locale;
    },


    /**
     * Check if the language is supported, if not return 'en'.
     * @private
     * @param {string} lang The locale to check.
     * @returns {string} The actual lang to use.
     */
    correctLanguage: function correctLanguage(lang) {
      var correctLanguage = this.defaultLocales.filter(function (a) {
        return a.lang === lang;
      });

      if (correctLanguage && correctLanguage[0]) {
        return lang;
      }

      // Map incorrect java locale to correct locale
      if (lang === 'in') {
        correctLanguage = 'id';
      }
      if (lang === 'iw') {
        correctLanguage = 'he';
      }

      correctLanguage = this.defaultLocale.substr(0, 2);
      return correctLanguage;
    },


    /**
     * Internally stores a new culture file for future use.
     * @private
     * @param {string} locale The 4-character Locale ID
     * @param {object} data Translation data and locale-specific functions, such as calendars.
     * @param {object} langData Translation data if deperated.
     * @returns {void}
     */
    addCulture: function addCulture(locale, data, langData) {
      var lang = locale.substr(0, 2);

      this.cultures[locale] = data;
      this.cultures[locale].name = locale;
      this.languages[lang] = {
        name: lang,
        direction: data.direction || (langData ? langData.direction : ''),
        nativeName: data.nativeName || (langData ? langData.nativeName : ''),
        messages: data.messages || (langData ? langData.messages : {})
      };
      if (!langData) {
        delete this.cultures[locale].messages;
      }
    },


    /**
     * Append the local script to the page.
     * @private
     * @param {string} locale The locale name to append.
     * @param {boolean} isCurrent If we should set this as the current locale
     * @param {boolean} useLocale If we should resolve the promise base on locale
     * @returns {void}
     */
    appendLocaleScript: function appendLocaleScript(locale, isCurrent, useLocale) {
      var _this = this;

      var script = document.createElement('script');
      script.src = this.getCulturesPath() + locale + '.js';

      script.onload = function () {
        if (isCurrent) {
          _this.setCurrentLocale(locale, _this.cultures[locale]);
          _this.dff.resolve(locale);
        }
        if (useLocale) {
          _this.dff[locale].resolve(locale);
        }
      };

      script.onerror = function () {
        _this.dff.reject();
      };

      if (_typeof(window.SohoConfig) === 'object' && typeof window.SohoConfig.nonce === 'string') {
        script.setAttribute('nonce', window.SohoConfig.nonce);
      }

      document.head.appendChild(script);
    },


    /**
     * Sets the current locale.
     * @param {string} locale The locale to fetch and set.
     * @returns {jquery.deferred} which is resolved once the locale culture is retrieved and set
     */
    set: function set(locale) {
      var self = this;
      this.dff = $.Deferred();
      locale = this.correctLocale(locale);

      if (locale === '') {
        self.dff.resolve();
        return this.dff.promise();
      }

      if (locale && locale !== 'en-US' && !this.cultures['en-US']) {
        this.appendLocaleScript('en-US', false);
      }

      if (locale && !this.cultures[locale] && this.currentLocale.name !== locale) {
        this.setCurrentLocale(locale);
        // Fetch the local and cache it
        this.appendLocaleScript(locale, true);
      }

      if (locale && self.currentLocale.data && self.currentLocale.dataName === locale) {
        self.dff.resolve(self.currentLocale.name);
      }

      self.setCurrentLocale(locale, self.cultures[locale]);

      if (self.cultures[locale] && this.cultureInHead()) {
        self.dff.resolve(self.currentLocale.name);
      }

      return this.dff.promise();
    },


    /**
     * Loads the locale without setting it.
     * @param {string} locale The locale to fetch and set.
     * @returns {jquery.deferred} which is resolved once the locale culture is retrieved and set
     */
    getLocale: function getLocale(locale) {
      var self = this;
      this.dff[locale] = $.Deferred();
      locale = this.correctLocale(locale);

      if (locale === '') {
        var dff = $.Deferred();
        dff.resolve();
        return dff.promise();
      }

      if (locale && locale !== 'en-US' && !this.cultures['en-US']) {
        this.appendLocaleScript('en-US', false, true);
      }

      if (locale && !this.cultures[locale] && this.currentLocale.name !== locale) {
        this.appendLocaleScript(locale, false, true);
      }

      if (locale && self.currentLocale.data && self.currentLocale.dataName === locale) {
        this.dff[locale].resolve(locale);
      }
      if (self.cultures[locale] && this.cultureInHead()) {
        this.dff[locale].resolve(locale);
      }

      return this.dff[locale].promise();
    },


    /**
     * Sets the current language, this can be independent and different from the current locale.
     * @param {string} lang The two digit language code to use.
     * @returns {jquery.deferred} which is resolved once the locale culture is retrieved and set
     */
    setLanguage: function setLanguage(lang) {
      var _this2 = this;

      // If not call set and load it and then set back the locale after.
      // Make a new object for currentLanguage independent of currentLocale
      // Change translate to use the right one
      var currentLocale = this.currentLocale.name;

      // Map incorrect java locale to correct locale
      lang = this.correctLanguage(lang);

      // Ensure the language / culture is loaded.
      if (!this.languages[lang]) {
        this.set(lang).done(function () {
          _this2.set(currentLocale);
          _this2.setLanguage(lang);
        });
      }

      if (this.languages[lang]) {
        this.currentLanguage = this.languages[lang];
        this.updateLanguage(lang);
      } else {
        this.currentLanguage.name = lang;
      }
      return this.dff;
    },


    /**
     * Chooses a stored locale dataset and sets it as "current"
     * @private
     * @param {string} name the 4-character Locale ID
     * @param {object} data translation data and locale-specific functions, such as calendars.
     * @returns {void}
     */
    setCurrentLocale: function setCurrentLocale(name, data) {
      var lang = name.substr(0, 2);
      this.currentLocale.name = name;

      if (data) {
        this.currentLocale.data = data;
        this.currentLocale.dataName = name;
        this.currentLanguage = this.languages[lang];
        this.updateLanguage(lang);
      }
    },


    /**
    * Formats a date object and returns it parsed back using the current locale or settings.
    * The symbols for date formatting use the CLDR at https://bit.ly/2Jg0a6m
    * @param {date} value The date to show in the current locale.
    * @param {object} options Additional date formatting settings.
    * @returns {string} the formatted date.
    */
    formatDate: function formatDate(value, options) {
      if (!options) {
        options = { date: 'short' }; // can be date, time, datetime or pattern
      }
      var localeData = this.useLocale(options);

      if (!value) {
        return undefined;
      }

      if (value === '0000' || value === '000000' || value === '00000000') {
        // Means no date in some applications
        return '';
      }

      // Convert if a timezone string.
      if (!(value instanceof Date) && typeof value === 'string' && value.indexOf('Z') > -1) {
        var tDate1 = new Date(value);
        value = tDate1;
      }

      if (!(value instanceof Date) && typeof value === 'string' && value.indexOf('T') > -1) {
        var _tDate = new Date(value);
        value = _tDate;
      }

      // Convert if a string..
      if (!(value instanceof Date) && typeof value === 'string') {
        var tDate2 = Locale.parseDate(value, options);
        if (isNaN(tDate2) && options.date === 'datetime' && value.substr(4, 1) === '-' && value.substr(7, 1) === '-') {
          tDate2 = new Date(value.substr(0, 4), value.substr(5, 2) - 1, value.substr(8, 2), value.substr(11, 2), value.substr(14, 2), value.substr(17, 2));
        }
        value = tDate2;
      }

      if (!(value instanceof Date) && typeof value === 'number') {
        var tDate3 = new Date(value);
        value = tDate3;
      }

      if (!value) {
        return undefined;
      }

      var pattern = void 0;
      var ret = '';
      var cal = localeData.calendars ? localeData.calendars[0] : null;

      if (options.pattern) {
        pattern = options.pattern;
      }

      if (options.date) {
        pattern = cal.dateFormat[options.date];
      }

      if (!pattern) {
        pattern = cal.dateFormat.short;
      }

      var year = value instanceof Array ? value[0] : value.getFullYear();
      var month = value instanceof Array ? value[1] : value.getMonth();
      var day = value instanceof Array ? value[2] : value.getDate();
      var dayOfWeek = value.getDay ? value.getDay() : '';
      var hours = value instanceof Array ? value[3] : value.getHours();
      var mins = value instanceof Array ? value[4] : value.getMinutes();
      var seconds = value instanceof Array ? value[5] : value.getSeconds();
      var millis = value instanceof Array ? value[6] : value.getMilliseconds();

      if (cal && cal.conversions) {
        if (options.fromGregorian) {
          var islamicParts = cal.conversions.fromGregorian(value);
          day = islamicParts[2];
          month = islamicParts[1];
          year = islamicParts[0];
        } else if (options.toGregorian) {
          var gregorianDate = cal.conversions.toGregorian(year, month, day);
          day = gregorianDate.getDate();
          month = gregorianDate.getMonth();
          year = gregorianDate.getFullYear();
        }
      }

      // Special
      pattern = pattern.replace('de', 'nnnnn');
      pattern = pattern.replace('ngy', 'nnnn');
      pattern = pattern.replace('thng', 't1ng');
      pattern = pattern.replace('den', 'nnn');

      // Day of Month
      ret = pattern.replace('dd', this.pad(day, 2));
      ret = ret.replace('d', day);

      // years
      ret = ret.replace('yyyy', year);
      ret = ret.replace('yy', year.toString().substr(2));
      ret = ret.replace('y', year);

      // Time
      var showDayPeriods = ret.indexOf(' a') > -1;

      if (showDayPeriods && hours === 0) {
        ret = ret.replace('hh', 12);
        ret = ret.replace('h', 12);
      }

      ret = ret.replace('hh', hours > 12 ? this.pad(hours - 12, 2) : this.pad(hours, 2));
      ret = ret.replace('h', hours > 12 ? hours - 12 : hours);
      ret = ret.replace('HH', this.pad(hours, 2));
      ret = ret.replace('H', hours);
      ret = ret.replace('mm', this.pad(mins, 2));
      ret = ret.replace('ss', this.pad(seconds, 2));
      ret = ret.replace('SSS', this.pad(millis, 0));

      // months
      ret = ret.replace('MMMM', cal ? cal.months.wide[month] : null); // full
      ret = ret.replace('MMM', cal ? cal.months.abbreviated[month] : null); // abreviation
      if (pattern.indexOf('MMM') === -1) {
        ret = ret.replace('MM', this.pad(month + 1, 2)); // number padded
        ret = ret.replace('M', month + 1); // number unpadded
      }

      // PM
      if (cal) {
        ret = ret.replace(' a', ' ' + (hours >= 12 ? cal.dayPeriods[1] : cal.dayPeriods[0]));
        ret = ret.replace('EEEE', cal.days.wide[dayOfWeek]); // Day of Week
      }

      // Day of Week
      if (cal) {
        ret = ret.replace('EEEE', cal.days.wide[dayOfWeek]); // Day of Week
      }
      ret = ret.replace('nnnnn', 'de');
      ret = ret.replace('nnnn', 'ngy');
      ret = ret.replace('t1ng', 'thng');
      ret = ret.replace('nnn', 'den');

      // Timezone
      if (ret.indexOf('zz') > -1) {
        var timezoneDate = new Date();
        var shortName = this.getTimeZone(timezoneDate, 'short');
        var longName = this.getTimeZone(timezoneDate, 'long');

        ret = ret.replace('zzzz', longName);
        ret = ret.replace('zz', shortName);
      }

      return ret.trim();
    },


    /**
     * Get the timezone part of a date
     * @param  {date} date The date object to use.
     * @param  {string} timeZoneName Can be short or long.
     * @returns {string} The time zone as a string.
     */
    getTimeZone: function getTimeZone(date, timeZoneName) {
      var currentLocale = Locale.currentLocale.name || 'en-US';
      var time = date.toLocaleTimeString(currentLocale);
      var name = '';

      if (Environment.browser.name === 'ie' && Environment.browser.version === '11') {
        return date.toTimeString().match(new RegExp('[A-Z](?!.*[\(])', 'g')).join('');
      }

      if (timeZoneName === 'long') {
        name = date.toLocaleTimeString(currentLocale, { timeZoneName: 'long' });
        return name.replace(time + ' ', '');
      }

      name = date.toLocaleTimeString(currentLocale, { timeZoneName: 'short' });
      return name.replace(time + ' ', '');
    },


    /**
    * Takes a date object in the current locale and adjusts it for the given timezone.
    * @param {date} date The utc date to show in the desired timezone.
    * @param {string} timeZone The timezone name to show.
    * @param {string} timeZoneName How to display the time zone name. Defaults to none. But can be short or long.
    * @returns {date} the utc date
    */
    dateToTimeZone: function dateToTimeZone(date, timeZone, timeZoneName) {
      if (Environment.browser.name === 'ie' && Environment.browser.version === '11') {
        return date.toLocaleString(Locale.currentLocale.name) + ' ' + date.toTimeString().match(new RegExp('[A-Z](?!.*[\(])', 'g')).join('');
      }

      return date.toLocaleString(Locale.currentLocale.name, { timeZone: timeZone, timeZoneName: timeZoneName });
    },


    /**
    * Formats a Date Object and return it in UTC format
    * @param {date} date The date to show in the current locale.
    * @returns {date} the utc date
    */
    dateToUTC: function dateToUTC(date) {
      return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
    },


    /**
    * Formats a number into the current locale using toLocaleString
    * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString#Using_locales
    * @param {number} number The number to convert
    * @param {string} locale The number to convert
    * @param {object} options The number to convert
    * @returns {string} The converted number.
    */
    toLocaleString: function toLocaleString(number, locale, options) {
      if (typeof number !== 'number') {
        return '';
      }
      return number.toLocaleString(locale || Locale.currentLocale.name, options || undefined);
    },


    /**
     * Convert a number in arabic/chinese or hindi numerals to an "english" number.
     * @param  {[type]} string The string number in arabic/chinese or hindi
     * @returns {number} The english number.
     */
    convertNumberToEnglish: function convertNumberToEnglish(string) {
      var arabic = ['', '', '', '', '', '', '', '', '', ''];
      var devanagari = ['', '', '', '', '', '', '', '', '', '']; // Hindi
      var chineseFinancialTraditional = ['', '', '', '', '', '', '', '', '', ''];
      var chineseFinancialSimplified = ['', '', '', '', '', '', '', '', '', ''];
      var chinese = ['', '', '', '', '', '', '', '', '', ''];

      for (var i = 0; i <= 9; i++) {
        string = string.replace(arabic[i], i);
        string = string.replace('', '');
        string = string.replace(',', '');
        string = string.replace(devanagari[i], i);
        string = string.replace(chineseFinancialTraditional[i], i);
        string = string.replace(chineseFinancialSimplified[i], i);
        string = string.replace(chinese[i], i);

        if (i === 0) {
          // Second option for zero in chinese
          string = string.replace('', i);
        }
      }
      return parseFloat(string);
    },


    /**
     * Check if the date is valid using the current locale to do so.
     * @param {date} date  The date to show in the current locale.
     * @returns {boolean} whether or not the date is valid.
     */
    isValidDate: function isValidDate(date) {
      if (Object.prototype.toString.call(date) === '[object Date]') {
        // it is a date
        if (isNaN(date.getTime())) {
          // d.valueOf() could also work
          return false;
        }
        return true;
      }
      return false;
    },


    /**
     * Takes a formatted date string and parses back it into a date object
     * @param {string} dateString  The string to parse in the current format
     * @param {string|object} options  The source format for example 'yyyy-MM-dd' or { dateFormat: 'yyyy-MM-dd', locale: 'nl-NL'}
     * @param {boolean} isStrict  If true missing date parts will be considered invalid. If false the current month/day.
     * @returns {date|array|undefined} A correct date object, if islamic calendar then an array is used or undefined if invalid.
     */
    parseDate: function parseDate(dateString, options, isStrict) {
      if (!dateString) {
        return undefined;
      }

      var dateFormat = options;
      var locale = this.currentLocale.name;
      var thisLocaleCalendar = this.calendar();
      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
        locale = options.locale || locale;
        dateFormat = options.dateFormat || this.calendar(locale).dateFormat[dateFormat.date];
      }

      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && options.pattern) {
        dateFormat = options.dateFormat || options.pattern;
      }

      if (!dateFormat) {
        dateFormat = this.calendar(locale).dateFormat.short;
      }

      var orgDatestring = dateString;
      if (dateString === '0000' || dateString === '000000' || dateString === '00000000') {
        // Means no date in some applications
        return undefined;
      }

      if (dateFormat.pattern) {
        dateFormat = dateFormat.pattern;
      }

      var formatParts = void 0;
      var dateStringParts = void 0;
      var dateObj = {};
      var isDateTime = dateFormat.toLowerCase().indexOf('h') > -1;
      var isUTC = dateString.toLowerCase().indexOf('z') > -1;
      var i = void 0;
      var l = void 0;

      if (isDateTime) {
        // Remove Timezone
        var shortTimeZone = Locale.getTimeZone(new Date(), 'short');
        var longTimeZone = Locale.getTimeZone(new Date(), 'long');
        dateString = dateString.replace(' ' + shortTimeZone, '');
        dateString = dateString.replace(' ' + longTimeZone, '');
        dateFormat = dateFormat.replace(' zzzz', '').replace(' zz', '');

        // Replace [space & colon & dot] with "/"
        dateFormat = dateFormat.replace(/[T\s:.-]/g, '/').replace(/z/i, '');
        dateString = dateString.replace(/[T\s:.-]/g, '/').replace(/z/i, '');
      }

      // Remove spanish de
      dateFormat = dateFormat.replace(' de ', ' ');
      dateString = dateString.replace(' de ', ' ');

      if (dateFormat === 'Mdyyyy' || dateFormat === 'dMyyyy') {
        dateString = dateString.substr(0, dateString.length - 4) + '/' + dateString.substr(dateString.length - 4, dateString.length);
        dateString = dateString.substr(0, dateString.indexOf('/') / 2) + '/' + dateString.substr(dateString.indexOf('/') / 2);
      }

      if (dateFormat === 'Mdyyyy') {
        dateFormat = 'M/d/yyyy';
      }

      if (dateFormat === 'dMyyyy') {
        dateFormat = 'd/M/yyyy';
      }

      if (dateFormat.indexOf(' ') !== -1) {
        dateFormat = dateFormat.replace(/[\s:.]/g, '/');
        dateString = dateString.replace(/[\s:.]/g, '/');
      }

      // Extra Check incase month has spaces
      if (dateFormat.indexOf('MMMM') > -1 && Locale.isRTL() && dateFormat) {
        var lastIdx = dateString.lastIndexOf('/');
        dateString = dateString.substr(0, lastIdx - 1).replace('/', ' ') + dateString.substr(lastIdx);
      }

      if (dateFormat.indexOf(' ') === -1 && dateFormat.indexOf('.') === -1 && dateFormat.indexOf('/') === -1 && dateFormat.indexOf('-') === -1) {
        // Remove delimeter for the data string.
        if (dateString.indexOf(' ') !== -1) {
          dateString = dateString.split(' ').join('');
        } else if (dateString.indexOf('.') !== -1) {
          dateString = dateString.split('.').join('');
        } else if (dateString.indexOf('/') !== -1) {
          dateString = dateString.split('/').join('');
        } else if (dateString.indexOf('-') !== -1) {
          dateString = dateString.split('-').join('');
        }

        var lastChar = dateFormat[0];
        var newFormat = '';
        var newDateString = '';

        for (i = 0, l = dateFormat.length; i < l; i++) {
          newDateString += dateFormat[i] !== lastChar ? '/' + dateString[i] : dateString[i];
          newFormat += dateFormat[i] !== lastChar ? '/' + dateFormat[i] : dateFormat[i];

          if (i > 1) {
            lastChar = dateFormat[i];
          }
        }

        dateString = newDateString;
        dateFormat = newFormat;
      }

      formatParts = dateFormat.split('/');
      dateStringParts = dateString.split('/');

      if (formatParts.length === 1) {
        formatParts = dateFormat.split('.');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split('.');
      }

      if (formatParts.length === 1) {
        formatParts = dateFormat.split('-');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split('-');
      }

      if (formatParts.length === 1) {
        formatParts = dateFormat.split(' ');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split(' ');
      }

      // Check the incoming date string's parts to make sure the values are
      // valid against the localized Date pattern.
      var month = this.getDatePart(formatParts, dateStringParts, 'M', 'MM', 'MMM', 'MMMM');
      var year = this.getDatePart(formatParts, dateStringParts, 'yy', 'yyyy');
      var hasDays = false;

      for (i = 0, l = dateStringParts.length; i < l; i++) {
        var pattern = '' + formatParts[i];
        var value = dateStringParts[i];
        var numberValue = parseInt(value, 10);

        if (!hasDays) {
          hasDays = pattern.toLowerCase().indexOf('d') > -1;
        }

        var lastDay = void 0;
        var abrMonth = void 0;
        var textMonths = void 0;

        switch (pattern) {
          case 'd':
            lastDay = new Date(year, month, 0).getDate();

            if (numberValue < 1 || numberValue > 31 || numberValue > lastDay) {
              return undefined;
            }
            dateObj.day = value;
            break;
          case 'dd':
            if (numberValue < 1 || numberValue > 31 || numberValue < 10 && value.substr(0, 1) !== '0') {
              return undefined;
            }
            dateObj.day = value;
            break;
          case 'M':
            if (numberValue < 1 || numberValue > 12) {
              return undefined;
            }
            dateObj.month = value - 1;
            break;
          case 'MM':
            if (numberValue < 1 || numberValue > 12 || numberValue < 10 && value.substr(0, 1) !== '0') {
              return undefined;
            }
            dateObj.month = value - 1;
            break;
          case 'MMM':
            abrMonth = this.calendar(locale).months.abbreviated;

            for (var len = 0; len < abrMonth.length; len++) {
              if (orgDatestring.indexOf(abrMonth[len]) > -1) {
                dateObj.month = len;
              }
            }

            break;
          case 'MMMM':
            textMonths = this.calendar(locale).months.wide;

            for (var k = 0; k < textMonths.length; k++) {
              if (orgDatestring.indexOf(textMonths[k]) > -1) {
                dateObj.month = k;
              }
            }

            break;
          case 'yy':
            dateObj.year = this.twoToFourDigitYear(value);
            break;
          case 'yyyy':
            dateObj.year = value.length === 2 ? this.twoToFourDigitYear(value) : value;
            break;
          case 'h':
            if (numberValue < 0 || numberValue > 12) {
              return undefined;
            }
            dateObj.h = value;
            break;
          case 'hh':
            if (numberValue < 0 || numberValue > 12) {
              return undefined;
            }
            dateObj.h = value.length === 1 ? '0' + value : value;
            break;
          case 'H':
            if (numberValue < 0 || numberValue > 24) {
              return undefined;
            }
            dateObj.h = value;
            break;
          case 'HH':
            if (numberValue < 0 || numberValue > 24) {
              return undefined;
            }
            dateObj.h = value.length === 1 ? '0' + value : value;
            break;

          case 'ss':
            if (numberValue < 0 || numberValue > 60) {
              dateObj.ss = 0;
              break;
            }
            dateObj.ss = value;
            break;

          case 'SSS':
            dateObj.ms = value;
            break;

          case 'mm':
            if (numberValue < 0 || numberValue > 60) {
              dateObj.mm = 0;
              break;
            }
            dateObj.mm = value;
            break;

          case 'a':
            if (value.toLowerCase() === thisLocaleCalendar.dayPeriods[0] || value.toUpperCase() === thisLocaleCalendar.dayPeriods[0]) {
              dateObj.a = 'AM';

              if (dateObj.h) {
                if (dateObj.h === 12 || dateObj.h === '12') {
                  dateObj.h = 0;
                }
              }
            }

            if (value.toLowerCase() === thisLocaleCalendar.dayPeriods[1] || value.toUpperCase() === thisLocaleCalendar.dayPeriods[1]) {
              dateObj.a = 'PM';

              if (dateObj.h) {
                if (dateObj.h < 12) {
                  dateObj.h = parseInt(dateObj.h, 10) + 12;
                }
              }
            }
            break;
          default:
            break;
        }
      }

      dateObj.return = undefined;
      dateObj.leapYear = dateObj.year % 4 === 0 && dateObj.year % 100 !== 0 || dateObj.year % 400 === 0;

      if (isDateTime && !dateObj.h && !dateObj.mm) {
        return undefined;
      }

      if (!dateObj.year && dateObj.year !== 0 && !isStrict) {
        dateObj.isUndefindedYear = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('y') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedYear = false;
            break;
          }
        }
        if (dateObj.isUndefindedYear) {
          dateObj.year = new Date().getFullYear();
        } else {
          delete dateObj.year;
        }
      }

      // Fix incomelete 2 and 3 digit years
      if (dateObj.year && dateObj.year.length === 2) {
        dateObj.year = '20' + dateObj.year;
      }

      dateObj.year = $.trim(dateObj.year);
      dateObj.day = $.trim(dateObj.day);

      if (dateObj.year === '' || dateObj.year && !(('' + dateObj.year).length === 2 || ('' + dateObj.year).length === 4)) {
        delete dateObj.year;
      }

      if (!dateObj.month && dateObj.month !== 0 && !isStrict) {
        dateObj.isUndefindedMonth = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('M') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedMonth = false;
            break;
          }
        }
        if (dateObj.isUndefindedMonth) {
          dateObj.month = new Date().getMonth();
        }
      }

      if (!dateObj.day && dateObj.day !== 0 && (!isStrict || !hasDays)) {
        dateObj.isUndefindedDay = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('d') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedDay = false;
            break;
          }
        }
        if (dateObj.isUndefindedDay) {
          dateObj.day = 1;
        } else {
          delete dateObj.day;
        }
      }

      if (isDateTime) {
        if (isUTC) {
          if (dateObj.h !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm)); //eslint-disable-line
          }
          if (dateObj.ss !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss)); //eslint-disable-line
          }
          if (dateObj.ms !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss, dateObj.ms)); //eslint-disable-line
          }
        } else {
          if (dateObj.h !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm); //eslint-disable-line
          }
          if (dateObj.ss !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss); //eslint-disable-line
          }
          if (dateObj.ms !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss, dateObj.ms); //eslint-disable-line
          }
        }
      } else {
        dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day);
      }

      if (thisLocaleCalendar.name === 'islamic-umalqura') {
        return [parseInt(dateObj.year, 10), parseInt(dateObj.month, 10), parseInt(dateObj.day, 10), parseInt(dateObj.h || 0, 10), parseInt(dateObj.ss || 0, 10), parseInt(dateObj.ms || 0, 10)];
      }

      return this.isValidDate(dateObj.return) ? dateObj.return : undefined;
    },


    /**
     * Convert the two digit year year to the correct four digit year.
     * @private
     * @param  {number} twoDigitYear The two digit year.
     * @returns {number} Converted 3 digit year.
     */
    twoToFourDigitYear: function twoToFourDigitYear(twoDigitYear) {
      return parseInt((twoDigitYear > 39 ? '19' : '20') + twoDigitYear, 10);
    },


    /**
     * Format out the date into parts.
     * @private
     * @param  {array} formatParts An array of the format bits.
     * @param  {array} dateStringParts An array of the date parts.
     * @param  {string} filter1 The first option to filter.
     * @param  {string} filter2 The second option to filter.
     * @param  {string} filter3 The third option to filter.
     * @param  {string} filter4 The fourth option to filter.
     * @returns {string} The filtered out date part.
     */
    getDatePart: function getDatePart(formatParts, dateStringParts, filter1, filter2, filter3, filter4) {
      var ret = 0;

      $.each(dateStringParts, function (i) {
        if (filter1 === formatParts[i] || filter2 === formatParts[i] || filter3 === formatParts[i] || filter4 === formatParts[i]) {
          ret = dateStringParts[i];
        }
      });

      return ret;
    },


    /**
     * Use the current locale data or the one passed in.
     * @private
     * @param  {object} options The options to parse.
     * @returns {object} The locale data.
     */
    useLocale: function useLocale(options) {
      var localeData = this.currentLocale.data;
      if (options && options.locale && this.cultures[options.locale]) {
        localeData = this.cultures[options.locale];
      }
      if (!localeData.numbers) {
        localeData.numbers = this.numbers();
      }
      return localeData;
    },


    /**
     * Use the current language data or the one passed in.
     * @private
     * @param  {object} options The options to parse.
     * @returns {object} The language data.
     */
    useLanguage: function useLanguage(options) {
      var languageData = this.currentLanguage;
      if (options && options.locale) {
        var lang = options.locale.split('-')[0];
        return this.languages[lang];
      }
      if (options && options.language && this.languages[options.language]) {
        languageData = this.languages[options.language];
      }
      return languageData;
    },


    /**
    * Formats a decimal with thousands and padding in the current locale or settings.
    * @param {number} number The source number.
    * @param {object} options additional options (see Number Format Patterns)
    * @returns {string} the formatted number.
    */
    formatNumber: function formatNumber(number, options) {
      var localeData = this.useLocale(options);
      var formattedNum = void 0;
      var curFormat = void 0;
      var percentFormat = void 0;
      var decimal = options && options.decimal ? options.decimal : localeData.numbers.decimal;
      var minimumFractionDigits = options && options.minimumFractionDigits !== undefined ? options.minimumFractionDigits : options && options.style && options.style === 'currency' ? 2 : options && options.style && options.style === 'percent' ? 0 : 2;
      var maximumFractionDigits = options && options.maximumFractionDigits !== undefined ? options.maximumFractionDigits : options && options.style && (options.style === 'currency' || options.style === 'percent') ? 2 : options && options.minimumFractionDigits ? options.minimumFractionDigits : 3;

      if (number === undefined || number === null || number === '') {
        return undefined;
      }

      if (options && options.style === 'integer') {
        maximumFractionDigits = 0;
        minimumFractionDigits = 0;
      }

      if (options && options.style === 'currency') {
        var sign = options && options.currencySign ? options.currencySign : localeData.currencySign;
        var format = options && options.currencyFormat ? options.currencyFormat : localeData.currencyFormat;

        if (!format) {
          format = '#,##0.00'; // default to en-us
        }
        curFormat = format.replace('', sign);
      }

      if (options && options.style === 'percent') {
        var percentSign = !localeData.numbers ? '%' : localeData.numbers.percentSign;

        percentFormat = !localeData.numbers ? '### %' : localeData.numbers.percentFormat;
        percentFormat = percentFormat.replace('', percentSign);
      }

      if (typeof number === 'string') {
        if (decimal !== '.') {
          number = number.replace(decimal, '.');
        }
        number = Locale.parseNumber(number);
      }

      if (options && options.style === 'percent') {
        // the toFixed for maximumFractionDigits + 1 means we won't loose any precision
        number = (number * 100).toFixed(minimumFractionDigits);
      }

      var parts = this.truncateDecimals(number, minimumFractionDigits, maximumFractionDigits, options && options.round).split('.');
      var groupSizes = [3, 3]; // In case there is no data
      if (localeData && localeData.numbers && localeData.numbers.groupSizes) {
        groupSizes = localeData.numbers.groupSizes;
      }
      if (options && options.groupSizes) {
        groupSizes = options.groupSizes;
      }

      var sep = options && options.group !== undefined ? options.group : localeData.numbers.group;
      var expandedNum = this.expandNumber(parts[0], groupSizes, sep);
      parts[0] = expandedNum;
      formattedNum = parts.join(decimal);

      // Position the negative at the front - There is no CLDR info for this.
      var minusSign = localeData && localeData.numbers && localeData.numbers.minusSign ? localeData.numbers.minusSign : '-';
      var isNegative = formattedNum.indexOf(minusSign) > -1;
      formattedNum = formattedNum.replace(minusSign, '');

      if (minimumFractionDigits === 0) {
        // Not default
        formattedNum = formattedNum.replace(/(\.[0-9]*?)0+$/, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\.$/, ''); // remove trailing dot
      }

      if (minimumFractionDigits === 0 && decimal !== '.') {
        // Not default
        formattedNum = formattedNum.replace(/(\,[0-9]*?)0+$/, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\,$/, ''); // remove trailing dot
      }

      if (minimumFractionDigits > 0) {
        var expr = new RegExp('(\\..{' + minimumFractionDigits + '}[0-9]*?)0+$');
        formattedNum = formattedNum.replace(expr, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\.$/, ''); // remove trailing dot
      }

      if (options && options.style === 'currency') {
        formattedNum = curFormat.replace('###', formattedNum);
      }

      if (options && options.style === 'percent') {
        formattedNum = percentFormat.replace('###', formattedNum);
      }

      if (isNegative) {
        formattedNum = minusSign + formattedNum;
      }
      return formattedNum;
    },


    /**
     * Return the number of decimal places in a number
     * @private
     * @param  {number} number The starting number.
     * @returns {number} The number of decimal places.
     */
    decimalPlaces: function decimalPlaces(number) {
      if (Math.floor(number) === number) {
        return 0;
      }

      if (number.toString().indexOf('.') === -1) {
        return 0;
      }
      return number.toString().split('.')[1].length || 0;
    },


    /**
     * Expand the number to the groupsize.
     * @private
     * @param  {string} numberString The number to expand
     * @param  {array} groupSizes The groupSizes option.
     * @param  {string} sep The thousands seperator option.
     * @returns {string} The expanded number.
     */
    expandNumber: function expandNumber(numberString, groupSizes, sep) {
      var len = numberString.length;
      var isNegative = false;

      if (numberString.substr(0, 1) === '-') {
        numberString = numberString.substr(1);
        len = numberString.length;
        isNegative = true;
      }

      if (len <= 3) {
        return (isNegative ? '-' : '') + numberString;
      }

      if (groupSizes[0] === 0) {
        return (isNegative ? '-' : '') + numberString;
      }

      var firstGroup = numberString.substr(numberString.length - groupSizes[0]);
      var nthGroup = numberString.substr(0, numberString.length - groupSizes[0]);
      if (groupSizes[1] === 0) {
        return (isNegative ? '-' : '') + nthGroup + (nthGroup === '' ? '' : sep) + firstGroup;
      }
      var reversed = nthGroup.split('').reverse().join('');
      var regex = new RegExp('.{1,' + groupSizes[1] + '}', 'g');
      var reversedSplit = reversed.match(regex).join(sep);
      return (isNegative ? '-' : '') + reversedSplit.split('').reverse().join('') + sep + firstGroup;
    },


    /**
     * Truncate a number to a specific min and max digits.
     * @private
     * @param  {number} number The starting number.
     * @param  {number} minDigits Minimum number of digits to show on the decimal portion.
     * @param  {number} maxDigits Maximum number of digits to show on the decimal portion.
     * @param  {boolean} round If true round, if false truncate.
     * @returns {number} The updated number.
     */
    truncateDecimals: function truncateDecimals(number, minDigits, maxDigits, round) {
      var multiplier = Math.pow(10, maxDigits);
      var adjustedNum = number * multiplier;
      var truncatedNum = void 0;

      // Round Decimals
      var decimals = this.decimalPlaces(number);

      // Handle larger numbers
      if (number.toString().length - decimals - 1 >= 10 || decimals === minDigits && decimals === maxDigits || decimals < maxDigits) {
        multiplier = Math.pow(100, maxDigits);
        adjustedNum = number * multiplier;
      }

      truncatedNum = Math[adjustedNum < 0 ? 'ceil' : 'floor'](adjustedNum);

      if (round && decimals >= maxDigits && adjustedNum > 0) {
        truncatedNum = Math.round(adjustedNum);
      }

      if (round && decimals <= maxDigits && decimals > 0) {
        truncatedNum = Math.round(adjustedNum);
      }

      if (decimals < maxDigits && decimals > 0) {
        truncatedNum = Math.floor(adjustedNum);
        maxDigits = Math.max(decimals, minDigits);
      }

      return (truncatedNum / multiplier).toFixed(maxDigits);
    },


    /**
     * Takes a formatted number string and returns back real number object.
     * @param {string} input  The source number (as a string).
     * @param {object} options  Any special options to pass in such as the locale.
     * @returns {number} the number as an actual Number type.
     */
    parseNumber: function parseNumber(input, options) {
      var localeData = this.useLocale(options);
      var numSettings = localeData.numbers;
      var numString = void 0;

      numString = input;

      if (!numString) {
        return NaN;
      }

      if (typeof input === 'number') {
        numString = numString.toString();
      }

      var group = numSettings ? numSettings.group : ',';
      var decimal = numSettings ? numSettings.decimal : '.';
      var percentSign = numSettings ? numSettings.percentSign : '%';
      var currencySign = localeData.currencySign || '$';

      numString = numString.replace(new RegExp('\\' + group, 'g'), '');
      numString = numString.replace(decimal, '.');
      numString = numString.replace(percentSign, '');
      numString = numString.replace(currencySign, '');
      numString = numString.replace('$', '');
      numString = numString.replace(' ', '');

      return parseFloat(numString);
    },


    /**
     * Takes a translation key and returns the translation in the current locale.
     * @param {string} key  The key to search for on the string.
     * @param {object} [options] A list of options, supported are a non default locale and showAsUndefined which causes a translated phrase to be shown in square brackets
     * instead of defaulting to the default locale's version of the string.
     * @returns {string|undefined} a translated string, or nothing, depending on configuration
     */
    translate: function translate(key, options) {
      var languageData = this.useLanguage(options);
      var showAsUndefined = false;
      if (typeof options === 'boolean') {
        showAsUndefined = options;
      }
      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
        showAsUndefined = options.showAsUndefined;
      }

      if (languageData.messages === undefined) {
        return showAsUndefined ? undefined : '[' + key + ']';
      }

      if (languageData.messages[key] === undefined) {
        var enLang = 'en';
        // Substitue English Expression if missing
        if (!this.languages || !this.languages[enLang] || !this.languages[enLang].messages || this.languages[enLang].messages[key] === undefined) {
          return showAsUndefined ? undefined : '[' + key + ']';
        }
        return this.languages[enLang].messages[key].value;
      }

      return languageData.messages[key].value;
    },


    /**
     * Add an object full of translations to the given locale.
     * @param {string} lang The language to add them to.
     * @param  {object} messages Strings in the form of
     */
    extendTranslations: function extendTranslations(lang, messages) {
      if (!this.languages[lang]) {
        return;
      }
      var base = this.languages[lang].messages;
      this.languages[lang].messages = $.extend(false, base, messages);
    },


    /**
     * Shortcut function to get 'first' calendar
     * @private
     * @param {string} locale The locale to use
     * @param {string} name the name of the calendar (fx: "gregorian", "islamic-umalqura")
     * @returns {object} containing calendar data.
     */
    calendar: function calendar(locale, name) {
      var calendars = [];
      if (this.currentLocale.data.calendars && !locale) {
        calendars = this.currentLocale.data.calendars;
      }

      if (locale && this.cultures[locale]) {
        calendars = this.cultures[locale].calendars;
      }

      if (name && calendars) {
        for (var i = 0; i < calendars.length; i++) {
          var cal = calendars[i];
          if (cal.name === name) {
            return cal;
          }
        }
      }

      if (calendars[0]) {
        return calendars[0];
      }

      // Defaults to en-US
      return {
        dateFormat: {
          separator: '/',
          timeSeparator: ':',
          short: 'M/d/yyyy',
          medium: 'MMM d, yyyy',
          long: 'MMMM d, yyyy',
          full: 'EEEE, MMMM d, y',
          month: 'MMMM d',
          year: 'MMMM yyyy',
          timestamp: 'h:mm:ss a',
          datetime: 'M/d/yyyy h:mm a'
        },
        timeFormat: 'HH:mm:ss',
        dayPeriods: ['AM', 'PM']
      };
    },


    /**
     * Shortcut function to get numbers
     * @private
     * @returns {object} containing information for formatting numbers
     */
    numbers: function numbers() {
      return this.currentLocale.data.numbers ? this.currentLocale.data.numbers : {
        percentSign: '%',
        percentFormat: '### %',
        minusSign: '-',
        decimal: '.',
        group: ','
      };
    },


    /**
     * Padd a number to the given width and decimals
     * @private
     * @param {string} n the number
     * @param {number} width the decimal with
     * @param {string} z the padding character
     * @returns {string} the padded string
     */
    pad: function pad(n, width, z) {
      z = z || '0';
      n += '';
      return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
    },


    /**
     * Describes whether or not this locale is one that is read in "right-to-left" fashion.
     * @returns {boolean} whether or not this locale is "right-to-left".
     */
    isRTL: function isRTL() {
      return this.currentLanguage.direction === 'right-to-left';
    },


    /**
     * Takes a string and converts its contents to upper case, taking into account
     * Locale-specific character conversions.  In most cases this method will simply
     * pipe the string to `String.prototype.toUpperCase()`.
     * @private
     * @param {string} str the incoming string
     * @returns {string} modified string
     */
    toUpperCase: function toUpperCase(str) {
      if (typeof this.currentLocale.data.toUpperCase === 'function') {
        return this.currentLocale.data.toUpperCase(str);
      }

      return str.toLocaleUpperCase();
    },


    /**
     * Takes a string and converts its contents to lower case, taking into account
     * Locale-specific character conversions. In most cases this method will simply
     * pipe the string to `String.prototype.toLowerCase()`
     * @private
     * @param {string} str - the incoming string
     * @returns {string} The localized string
     */
    toLowerCase: function toLowerCase(str) {
      if (typeof this.currentLocale.data.toLowerCase === 'function') {
        return this.currentLocale.data.toLowerCase(str);
      }

      return str.toString().toLocaleLowerCase();
    },


    /**
     * Takes a string and capitalizes the first letter, taking into account Locale-specific
     * character conversions. In most cases this method will simply use a simple algorithm
     * for captializing the first letter of the string.
     * @private
     * @param {string} str the incoming string
     * @returns {string} the modified string
     */
    capitalize: function capitalize(str) {
      return this.toUpperCase(str.charAt(0)) + str.slice(1);
    },


    /**
     * Takes a string and capitalizes the first letter of each word in a string, taking
     * into account Locale-specific character conversions. In most cases this method
     * will simply use a simple algorithm for captializing the first letter of the string.
     * @private
     * @param {string} str the incoming string
     * @returns {string} the modified string
     */
    capitalizeWords: function capitalizeWords(str) {
      var words = str.split(' ');

      for (var i = 0; i < words.length; i++) {
        words[i] = this.capitalize(words[i]);
      }

      return words.join(' ');
    },


    /**
     * Modifies a specified list of icons by flipping them horizontally to make them
     * compatible for RTL-based locales.
     * @private
     * @returns {void}
     */
    flipIconsHorizontally: function flipIconsHorizontally() {
      var icons = ['attach', 'bottom-aligned', 'bullet-list', 'cancel', 'cart', 'collapse-app-tray', 'cut', 'document', 'drilldown', 'duplicate', 'expand-app-tray', 'export', 'first-page', 'folder', 'import', 'last-page', 'launch', 'left-align', 'left-text-align', 'left-arrow', 'new-document', 'next-page', 'number-list', 'paste', 'previous-page', 'quote', 'redo', 'refresh', 'right-align', 'right-arrow', 'right-text-align', 'save', 'search-folder', 'search-list', 'search', 'send', 'tack', 'tree-collapse', 'tree-expand', 'undo', 'unlocked', 'add-grid-record', 'add-grid-row', 'additional-help', 'bubble', 'cascade', 'change-font', 'clear-screen', 'script', 'clockwise-90', 'close-cancel', 'close-save', 'contacts', 'copy-from', 'copy-mail', 'copy-url', 'counter-clockwise-90', 'create-report', 'delete-grid-record', 'delete-grid-row', 'display', 'employee-directory', 'export-2', 'export-to-pdf', 'generate-key', 'get-more-rows', 'group-selection', 'headphones', 'help', 'helper-list-select', 'history', 'invoice-released', 'language', 'logout', 'key', 'lasso', 'line-bar-chart', 'line-chart', 'new-expense-report', 'new-payment-request', 'new-time-sheet', 'new-travel-plan', 'no-attachment', 'no-comment', 'no-filter', 'overlay-line', 'pdf-file', 'phone', 'payment-request', 'pie-chart', 'queries', 'quick-access', 'refresh-current', 'restore-user', 'run-quick-access', 'save-close', 'save-new', 'search-results-history', 'select', 'send-submit', 'show-last-x-days', 'special-item', 'stacked', 'timesheet', 'unsubscribe', 'update-preview', 'zoom-100', 'zoom-in', 'zoom-out', 'caret-left', 'caret-right'];

      $('svg').each(function () {
        var iconName = $(this).getIconName();

        if (iconName && $.inArray(iconName, icons) !== -1 && $(this).closest('.monthview').length === 0) {
          $(this).addClass('icon-rtl-rotate');
        }
      });
    }
  };

  // Has to delay in order to check if no culture in head since scripts load async
  $(function () {
    setTimeout(function () {
      if (Locale && !Locale.cultureInHead() && !Locale.currentLocale.name) {
        Locale.set('en-US');
      }
    }, 50);
  });

  /**
   * Safely gets the name of a method
   * @param {function|string} method the method to be checked (or method name to be reported)
   * @returns {string} the name of the method
   */
  function methodName(method) {
    if (typeof method !== 'function') {
      if (typeof method === 'string') {
        return method;
      }
      throw new Error((typeof method === 'undefined' ? 'undefined' : _typeof(method)) + ' was provided where a function was expected.');
    }

    // ES6-friendly
    if (typeof method.name === 'string') {
      return method.name + '()';
    }

    // Regex for ES5 (IE11)
    // See https://stackoverflow.com/a/17923727/4024149
    var result = /^function\s+([\w$]+)\s*\(/.exec(method.toString());
    return result ? result[1] + '()' : '(anonymous function)';
  }

  /**
   * Warns about a deprecated property/method via a console warning
   * @param {function|string} newMethod the new method to call
   * @param {function|string} oldMethod the name of the old method
   * @returns {void}
   */
  function warnAboutDeprecation(newMethod, oldMethod) {
    var newMethodName = methodName(newMethod);
    var oldMethodName = methodName(oldMethod);

    if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) !== 'object') {
      return;
    }
    console.warn('IDS Enterprise: "' + oldMethodName + '" is deprecated. Please use "' + newMethodName + '" instead.');
  }

  /**
   * Deprecates a method in the codebase
   * @param {function} newMethod the new method to call
   * @param {function} oldMethod the name of the old method
   * @param {...object} [args] arguments that will be passed to the new function
   * @returns {function} wrapper method
   */
  function deprecateMethod(newMethod, oldMethod) {
    var wrapper = function deprecatedMethodWrapper() {
      warnAboutDeprecation(newMethod, oldMethod);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      newMethod.apply(this, args);
    };
    wrapper.prototype = newMethod.prototype;

    return wrapper;
  }

  /**
   * Provides a global object that detects the existence of a Base Tag,
   * and provides some methods that can be used to get an accurate relative
   * URL using the base tag.
   * @class Base
   * @constructor
   * @param {HTMLElement} element the Base Tag Element
   * @returns {Base} component instance
   */
  function Base(element) {
    this.element = $(element);
    return this;
  }

  Base.prototype = {

    /**
     * @private
     * @returns {string} current page URL
     */
    get url() {
      return window.location.href.replace(window.location.hash, '');
    },

    /**
     * @private
     * @returns {string} the base tag's `href` attribute
     */
    get href() {
      return this.element[0].getAttribute('href');
    },

    /**
     * This method is slated to be removed in a future v4.18.0 or v5.0.0.
     * @deprecated as of v4.12.0. Please use the `url` property instead.
     * @returns {string} current page URL
     */
    getCurrentURL: function getCurrentURL() {
      warnAboutDeprecation('url', 'getCurrentURL');
      return this.url;
    },


    /**
     * Gets a copy of a URL prepended with the contents of the Base Tag's hash.
     * If there's no base tag present, this simply returns the hash provided.
     * @param {string} hash the URL to be checked.
     * @returns {string} the current URL prepended with the Base Tag's ref, if necessary
     */
    getBaseURL: function getBaseURL(hash) {
      // If no valid base tag exists, just return the hash provided.
      if (!this.element.length || !this.href || this.href === '/') {
        if (!hash) {
          return '';
        }
        return hash;
      }

      if (hash) {
        if (hash.indexOf('/') === 0) {
          return hash;
        }

        hash = (hash.indexOf('#') === -1 ? '#' : '') + hash;
        return this.url + hash;
      }

      return this.url;
    }
  };

  // Setup a Base Tag Component instance
  var base = new Base($('base[href]'));

  /**
   * Setup a default function that just returns the contents of the hash,
   * if no base tag is present.
   * @param {string} hash the URL to be checked.
   * @returns {string} the current URL prepended with the Base Tag's ref, if necessary
   */
  $.getBaseURL = function (hash) {
    return base.getBaseURL(hash);
  };

  // Default RenderLoop Settings
  var RENDERLOOP_DEFAULTS = {
    noAutoStart: false
  };

  // Only start the renderloop if it's not disabled by a Global config setting.
  var instanceSettings = {};
  if (_typeof(window.SohoConfig) === 'object' && _typeof(window.SohoConfig.renderLoop) === 'object') {
    instanceSettings = utils.extend({}, RENDERLOOP_DEFAULTS, window.SohoConfig.renderLoop);
  }

  /**
   * Gets an accurate timestamp from
   * @private
   * @returns {number} a current timestamp
   */
  function timestamp() {
    return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
  }

  /**
   * RenderLoop Queue items
   * @param {object} opts options
   * @returns {this} RenderLoopItem
   */
  function RenderLoopItem(opts) {
    // Either ID or a duration is required
    this.id = opts.id;
    this.duration = opts.duration || -1;
    if (this.duration < 1 && (typeof this.id !== 'string' || !this.id.length)) {
      throw new Error('cannot build a RenderLoopItem with no duration and no namespace');
    }
    this.updateDuration = opts.updateDuration || 1;

    // functions
    this.setFuncs(opts);

    // internal state
    this.paused = false;
    this.elapsedTime = 0;
    this.startTime = timestamp();

    return this;
  }

  RenderLoopItem.prototype = {

    /**
     * @private
     * @param {object} opts incoming settings
     */
    setFuncs: function setFuncs(opts) {
      if (typeof opts.updateCallback !== 'function' && typeof opts.timeoutCallback !== 'function') {
        throw new Error('cannot register callback to RenderLoop because callback is not a function');
      }

      if (typeof opts.updateCallback === 'function') {
        this.updateCallback = opts.updateCallback;
      }

      if (typeof opts.timeoutCallback === 'function') {
        this.timeoutCallback = opts.timeoutCallback;
      }
    },
    pause: function pause() {
      this.paused = true;
    },
    resume: function resume() {
      this.paused = false;
    },


    /**
     * @param {boolean} noTimeout causes the item to be destroyed without triggering the `timeoutCallback` function
     */
    destroy: function destroy(noTimeout) {
      if (noTimeout) {
        this.noTimeout = true;
      }
      this.doRemoveOnNextTick = true;
    }
  };

  /**
   * Sets up a timed rendering loop that can be used for controlling animations
   * globally in an application that implements Soho.
   * @constructor
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.noAutoStart] if true, will not auto-start the renderLoop
   */
  function RenderLoop(settings) {
    this.items = [];
    this.element = $('body');
    this.settings = utils.mergeSettings(null, settings, RENDERLOOP_DEFAULTS);

    if (this.settings.noAutoStart !== true) {
      this.start();
    }

    return this;
  }

  RenderLoop.prototype = {

    /**
     * Start the entire render loop
     * @returns {void}
     */
    start: function start() {
      this.doLoop = true;
      this.startTime = timestamp();

      var self = this;
      var last = timestamp();
      var now = void 0;
      var deltaTime = void 0;

      function tick() {
        // Don't continue if the loop is stopped externally
        if (!self.doLoop) {
          return;
        }

        now = timestamp();
        deltaTime = (now - last) / 1000;

        // Iterate through each item stored in the queue and "update" each one.
        // In some cases, items will be removed from the queue automatically.
        // In some cases, `update` events will be triggered on loop items, if they are
        // ready to be externally updated.
        self.items.forEach(function (loopItem) {
          // Remove if we've set the `doRemoveOnNextTick` flag.
          if (loopItem.doRemoveOnNextTick) {
            self.remove(loopItem);
            return;
          }

          // Add to elapsedTime
          if (!loopItem.paused) {
            loopItem.elapsedTime++;
          }

          // Check duration
          if (typeof loopItem.duration === 'number' && loopItem.duration > -1) {
            if (!loopItem.startTime) {
              loopItem.startTime = now;
            }

            if (loopItem.elapsedTime >= loopItem.duration) {
              loopItem.destroy();
              return;
            }
          }

          // Call the updateCallback, if applicable.
          var modifiedArgs = void 0;
          if (typeof loopItem.updateCallback === 'function') {
            // If this item doesn't update on each tick, simply count down.
            // Otherwise, call the update function
            if (loopItem.updateDuration && loopItem.updateDuration > 1) {
              if (isNaN(loopItem.timeUntilNextUpdate)) {
                loopItem.timeUntilNextUpdate = loopItem.updateDuration;
              }

              if (loopItem.timeUntilNextUpdate > 0) {
                --loopItem.timeUntilNextUpdate;
                return;
              }
            }

            // Arguments produced for the updateCallback contain:
            // [0] the current RenderLoopItem
            // [1] overall timing values for the RenderLoop
            modifiedArgs = [loopItem, {
              last: last,
              delta: deltaTime,
              now: now
            }];

            loopItem.updateCallback.apply(null, modifiedArgs);
          }
        });

        // Continue the loop
        last = now;
        requestAnimationFrame(tick);
      }

      tick();
    },


    /**
     * Stops the entire render loop
     * @returns {void}
     */
    stop: function stop() {
      this.doLoop = false;
    },


    /**
     * @returns {number} amount of time that has passed since the RenderLoop was started.
     */
    totalDuration: function totalDuration() {
      return timestamp() - this.startTime;
    },


    /**
     * External method for getting the callback queue contents
     * @returns {array} list of internal RenderLoopItems
     */
    queue: function queue() {
      return this.items;
    },


    /**
     * @private
     * @param {function} updateCallback - (can also be the "updateCallback" function)
     * @param {function} [timeoutCallback] callback function that gets fired at
     *  the end of this item's lifecycle
     * @param {number} [duration] the amount of time in frames that this item should exist
     * @param {string} [namespace] the namespace for this item
     * @returns {RenderLoopItem} the item that was registered
     */
    buildRenderLoopItem: function buildRenderLoopItem(updateCallback, timeoutCallback, duration, namespace) {
      var noNamespace = typeof namespace !== 'string' || !namespace.length;

      // valid for a callback not to have a duration, as long as it's
      // namespaced for future manual removal
      if (typeof duration === 'string') {
        if (noNamespace) {
          namespace = duration;
          duration = -1;
          noNamespace = false;
        } else {
          var numberDuration = Number(duration);
          if (!isNaN(numberDuration)) {
            duration = numberDuration;
          }
        }
      } else if (typeof duration !== 'number') {
        duration = -1;
      }

      if (typeof namespace !== 'string' || !namespace.length) {
        namespace = ''; // TODO: make unique
      }

      var loopItem = new RenderLoopItem({
        id: namespace,
        updateCallback: updateCallback,
        timeoutCallback: timeoutCallback,
        duration: duration
      });

      return loopItem;
    },


    /**
     * @param {RenderLoopItem|function} loopItem - (can also be the "updateCallback" function)
     * @param {function} [timeoutCallback] callback function that gets fired at
     *  the end of this item's lifecycle
     * @param {number} [duration] the amount of time in frames that this item should exist
     * @param {string} [namespace] the namespace for this item
     * @returns {RenderLoopItem} the item that was registered
     */
    register: function register(loopItem, timeoutCallback, duration, namespace) {
      // If we're not working with a RenderLoopItem off the bat, take arguments
      // and convert to a RenderLoopItem.  Consider the first argument
      // to be the "updateCallback" function
      if (!(loopItem instanceof RenderLoopItem)) {
        loopItem = this.buildRenderLoopItem(loopItem, timeoutCallback, duration, namespace);
      }

      this.items.push(loopItem);

      return loopItem;
    },


    /**
     * @param {function} callback callback function to be unregistered
     * @param {string} [namespace] namespace to be unregistered
     * @returns {RenderLoopItem} the item that was unregistered
     */
    unregister: function unregister(callback, namespace) {
      if (typeof callback !== 'function' && typeof callback !== 'string' && typeof namespace !== 'string') {
        throw new Error('must provide either a callback function or a namespace string to remove an entry from the RenderLoop queue.');
      }

      // If callback is defined as a string, simply swap it for the namespace.
      if (typeof callback === 'string') {
        namespace = callback;
        callback = undefined;
      }

      return this.remove({
        cb: callback,
        id: namespace
      });
    },


    /**
     * @private
     * Uses a callback function, or a defined namespace, to grab a RenderLoop item from the queue.
     * @param {function} updateCallback callback function to be retrieved
     * @param {string} [namespace] namespace to be retrieved
     * @returns {RenderLoopItem} the RenderLoopItem that represents the item that was paused.
     */
    getFromQueue: function getFromQueue(updateCallback, namespace) {
      // If callback is defined as a string, simply swap it for the namespace.
      if (typeof callback === 'string') {
        namespace = updateCallback;
        updateCallback = undefined;
      }

      var retreivedItem = void 0;

      if (typeof callback === 'function') {
        // Remove by callback method
        this.items.forEach(function (item) {
          if ('' + item.updateCallback !== '' + updateCallback) {
            return true;
          }
          retreivedItem = item;
          return false;
        });
      } else if (typeof namespace === 'string') {
        // Remove by namespace
        this.items.forEach(function (item) {
          if (item.id !== namespace) {
            return true;
          }
          retreivedItem = item;
          return false;
        });
      }

      return retreivedItem;
    },


    /**
     * @private
     * Actually does the removal of a registered callback from the queue
     * Pulled out into its own function because it can be automatically called by
     * the tick, or manually triggered from an external API call.
     * @param {renderLoopItem|Object} obj the renderLoopItem
     * @returns {RenderLoopItem} reference to the removed renderLoopItem
     */
    remove: function remove(obj) {
      var removedItem = void 0;

      if (obj instanceof RenderLoopItem) {
        removedItem = obj;
        this.items = this.items.filter(function (item) {
          return item !== obj;
        });
      } else if (typeof obj.updateCallback === 'function') {
        // Remove by callback method
        this.items = this.items.filter(function (item) {
          if ('' + item.updateCallback !== '' + obj.updateCallback) {
            return true;
          }
          removedItem = item;
          return false;
        });
      } else if (typeof obj.id === 'string') {
        // Remove by namespace
        this.items = this.items.filter(function (item) {
          if (item.id !== obj.id) {
            return true;
          }
          removedItem = item;
          return false;
        });
      }

      if (typeof removedItem.timeoutCallback === 'function' && !removedItem.noTimeout) {
        removedItem.timeoutCallback.apply(null, removedItem);
      }

      this.element.triggerHandler('remove.renderLoop', [removedItem]);

      // If this is undefined, an item was NOT removed from the queue successfully.
      return removedItem;
    },


    /**
     * @param {function} callback callback function to be paused
     * @param {string} [namespace] namespace to be paused
     * @returns {RenderLoopItem} the RenderLoopItem that represents the item that was paused.
     */
    pause: function pause(callback, namespace) {
      if (typeof callback !== 'function' && typeof callback !== 'string' && typeof namespace !== 'string') {
        throw new Error('must provide either a callback function or a namespace string to pause an entry in the RenderLoop queue.');
      }

      var pausedItem = this.getFromQueue(callback, namespace);

      pausedItem.pause();

      return pausedItem;
    },


    /**
     * @param {function} callback callback function to be resumed
     * @param {string} [namespace] namespace to be resumed
     * @returns {RenderLoopItem} the RenderLoopItem that represents the item that was resumed.
     */
    resume: function resume(callback, namespace) {
      if (typeof callback !== 'function' && typeof callback !== 'string' && typeof namespace !== 'string') {
        throw new Error('must provide either a callback function or a namespace string to pause an entry in the RenderLoop queue.');
      }

      var resumableItem = this.getFromQueue(callback, namespace);

      resumableItem.resume();

      return resumableItem;
    }
  };

  // Setup a single instance of RenderLoop for export.
  var renderLoop = new RenderLoop(instanceSettings);

  // Current "theme" string
  exports.theme = 'light'; //eslint-disable-line

  // Component name as referenced by jQuery/event namespace/etc
  var COMPONENT_NAME = 'personalize';

  // Component Defaults
  var PERSONALIZE_DEFAULTS = {
    colors: '',
    theme: exports.theme,
    font: '',
    blockUI: true
  };

  /**
   * The personalization routines for setting custom company colors.
   *
   * @class Personalize
   * @param {HTMLElement|jQuery[]} element The base element
   * @param {object} [settings] Incoming settings
   * @param {string} [settings.colors]  The list of colors
   * @param {string} [settings.theme='light'] The theme name (light, dark or high-contrast)
   * @param {string} [settings.font='Helvetica'] Use the newer source sans font
   * @param {boolean} [settings.blockUI=true] Cover the UI and animate when changing theme.
  */
  function Personalize(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, PERSONALIZE_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Personalize.prototype = {

    /**
     * Runs on each initialization
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      this.availableThemes = ['light', 'dark', 'high-contrast', 'uplift'];

      // Set the default theme, or grab the theme from an external CSS stylesheet.
      var cssTheme = this.getThemeFromStylesheet();
      this.currentTheme = this.settings.theme || cssTheme;
      this.setTheme(this.currentTheme);

      if (this.settings.colors) {
        this.setColors(this.settings.colors);
      }

      if (this.settings.font) {
        $('html').addClass('font-' + this.settings.font);
      }

      this.handleEvents();

      return this;
    },


    /**
     * Sets up event handlers for this control and its sub-elements
     * @private
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('updated.' + COMPONENT_NAME, function () {
        self.updated();
      }).on('changecolors.' + COMPONENT_NAME, function (e, newColor, noAnimate) {
        self.setColors(newColor, noAnimate);
      }).on('changetheme.' + COMPONENT_NAME, function (e, thisTheme) {
        self.setTheme(thisTheme);
      });

      return this;
    },


    /**
     * Validates a string containing a hexadecimal number
     * @private
     * @param {string} hex A hex color.
     * @returns {string} a validated hexadecimal string.
     */
    validateHex: function validateHex(hex) {
      hex = String(hex).replace(/[^0-9a-f]/gi, '');

      if (hex.length < 6) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
      }

      return '#' + hex;
    },


    /**
     * Create new CSS rules in head and override any existing
     * @private
     * @param {object} cssRules The rules to append.
     */
    appendStyleSheet: function appendStyleSheet(cssRules) {
      var sheet = document.getElementById('soho-personalization');
      if (sheet) {
        sheet.parentNode.removeChild(sheet);
      }

      // Create the <style> tag
      sheet = document.createElement('style');
      sheet.setAttribute('id', 'soho-personalization');
      sheet.appendChild(document.createTextNode(cssRules));

      // Add the <style> element to the page
      document.head.appendChild(sheet);
    },


    /**
     * Generate a style sheet to append in the page.
     * @private
     * @param {array} colors The rules to append.
     * @returns {string} The string of css to append.
     */
    getColorStyleSheet: function getColorStyleSheet(colors) {
      if (!colors) {
        colors = {};
      }

      // Use an incoming `colors` param defined as a string, as the desired
      // "header" color (backwards compatibility)
      if (typeof colors === 'string') {
        colors = {
          header: colors
        };
      }

      if (!colors || colors === '') {
        return this;
      }

      // Default Colors...
      // (Color)07 for the main color (fx headers)
      // (Color)06 for the secondary color (fx sub-headers)
      // Light or Dark (fff or 000) for the contrast color

      // (Color)06 for the vertical borders between module tabs - 133C59
      // (Color)07 for the page header and active module tab - 2578A9 DEFAULT
      // (Color)08 for the inactive module tab - 1d5f8a
      // (Color)09 for the horizontal border - 134D71
      // (Color)10 for the hover state on module tab - 133C59
      var defaultColors = {
        header: '2578A9',
        subheader: '1d5f8a',
        text: 'ffffff',
        verticalBorder: '133C59',
        horizontalBorder: '134D71',
        inactive: '1d5f8a',
        hover: '133C59',
        btnColorHeader: '368AC0',
        btnColorSubheader: '54a1d3'
      };

      // If an event sends a blank string through instead of a hex,
      // reset any color values back to the theme defaults.  Otherwise, get a valid hex value.
      colors.header = this.validateHex(colors.header || defaultColors.header);
      colors.text = this.validateHex(colors.text || defaultColors.text);
      colors.subheader = this.validateHex(colors.subheader || this.getLuminousColorShade(colors.header, 0.2));
      colors.inactive = this.validateHex(colors.inactive || this.getLuminousColorShade(colors.header, -0.22));
      colors.verticalBorder = this.validateHex(colors.verticalBorder || this.getLuminousColorShade(colors.header, 0.1));
      colors.horizontalBorder = this.validateHex(colors.horizontalBorder || this.getLuminousColorShade(colors.header, -0.4));
      colors.hover = this.validateHex(colors.hover || this.getLuminousColorShade(colors.header, -0.5));
      colors.btnColorHeader = this.validateHex(colors.btnColorHeader || this.getLuminousColorShade(colors.subheader, -0.025));
      colors.btnColorSubheader = this.validateHex(colors.btnColorSubheader || this.getLuminousColorShade(colors.header, -0.025));

      // note that the sheet is appended in backwards
      var cssRules = '.tab-container.module-tabs.is-personalizable { border-top: 1px solid ' + colors.horizontalBorder + ' !important; border-bottom: 1px solid ' + colors.horizontalBorder + ' !important}' + (' .module-tabs.is-personalizable .tab:not(:first-child) { border-left: 1px solid ' + colors.verticalBorder + ' !important}') + (' .module-tabs.is-personalizable { background-color: ' + colors.inactive + ' !important}') + (' .module-tabs.is-personalizable .tab.is-selected { background-color: ' + colors.header + ' !important}') + (' .accordion.panel .accordion-header.is-selected { background-color: ' + colors.subheader + ' !important; color: ' + colors.text + ' !important}') + (' .builder-header.is-personalizable{ background-color: ' + colors.subheader + '}') + (' .header.is-personalizable { background-color: ' + colors.header + '}') + (' .header.is-personalizable .title { color: ' + colors.text + '}') + (' .header.is-personalizable h1 { color: ' + colors.text + '}') + (' .header.is-personalizable .go-button.is-personalizable { background-color: ' + colors.btnColorHeader + '; border-color:' + colors.btnColorHeader + ';color: ' + colors.text + '}') + (' .subheader.is-personalizable .go-button.is-personalizable { background-color: ' + colors.btnColorSubheader + '; border-color:' + colors.btnColorSubheader + ';color: ' + colors.text + '}') + (' .module-tabs.is-personalizable .tab-more { border-left: ' + colors.verticalBorder + ' !important}') + (' .module-tabs.is-personalizable .tab-more:hover { background-color: ' + colors.hover + ' !important}') + (' .module-tabs.is-personalizable .tab-more.is-open { background-color: ' + colors.hover + ' !important}') + (' .module-tabs.is-personalizable .tab-more.is-selected { background-color: ' + colors.header + ' !important}') + (' .header .toolbar > .toolbar-searchfield-wrapper.active .searchfield { background-color: ' + colors.hover + ' !important; border-bottom-color: ' + colors.hover + ' !important}') + (' .header .toolbar > .toolbar-searchfield-wrapper.active .searchfield-category-button { background-color: ' + colors.hover + ' !important; border-bottom-color: ' + colors.hover + ' !important}') + (' .subheader.is-personalizable { background-color: ' + colors.subheader + ' !important}') + (' .builder .sidebar .header {border-right: 1px solid ' + colors.hover + ' !important}') + (' .module-tabs.is-personalizable .tab:hover { background-color: ' + colors.hover + ' !important}') + (' .module-tabs.has-toolbar.is-personalizable .tab-list-container + .toolbar { border-left: ' + colors.verticalBorder + ' !important}') + (' .module-tabs.is-personalizable [class^="btn"] { background-color: ' + colors.inactive + ' !important; color: ' + colors.text + ' !important}') + (' .module-tabs.is-personalizable .tab.is-disabled { background-color: ' + colors.inactive + ' !important; color: ' + colors.text + ' !important}') + (' .module-tabs.is-personalizable .tab.is-disabled > svg { fill: ' + colors.text + ' !important}') + (' .module-tabs.is-personalizable .add-tab-button { border-left: ' + colors.verticalBorder + ' !important}') + (' .module-tabs.is-personalizable .add-tab-button:hover { background-color: ' + colors.inactive + ' !important}') + (' .module-tabs.is-personalizable .toolbar-searchfield-wrapper > .searchfield { color: ' + colors.text + ' !important}') + (' .module-tabs.is-personalizable .toolbar-searchfield-wrapper > svg { fill: ' + colors.text + ' !important}') + (' .hero-widget.is-personalizable { background-color: ' + colors.subheader + ' }') + (' .hero-widget.is-personalizable .hero-bottom { background-color: ' + colors.header + ' }') + (' .hero-widget.is-personalizable .hero-footer .hero-footer-nav li::before { color: ' + colors.verticalBorder + ' }') + (' .hero-widget.is-personalizable .chart-container .arc { stroke: ' + colors.subheader + ' }') + (' .hero-widget.is-personalizable .chart-container .bar { stroke: ' + colors.subheader + ' }') + (' .hero-widget.is-personalizable .chart-container.line-chart .dot { stroke: ' + colors.subheader + ' }') + '';

      return cssRules;
    },


    /**
    * Sets the personalization color(s)
    * @param {array} colors The original hex color as a string or an object with all the Colors
    * @returns {this} component instance
    */
    setColors: function setColors(colors) {
      if (!colors) {
        return this;
      }

      this.appendStyleSheet(this.getColorStyleSheet(colors));

      // record state of colors in settings
      this.settings.colors = colors;

      return this;
    },


    /**
    * Takes a color and performs a change in luminosity of that color programatically.
    * @private
    * @param {string} hex  The original Hexadecimal base color.
    * @param {string} lum  A percentage used to set luminosity
    * change on the base color:  -0.1 would be 10% darker, 0.2 would be 20% brighter
    * @returns {string} hexadecimal color.
    */
    getLuminousColorShade: function getLuminousColorShade(hex, lum) {
      // validate hex string
      hex = this.validateHex(hex).substr(1);
      lum = lum || 0;

      // convert to decimal and change luminosity
      var rgb = '#';
      var c = void 0;
      var i = void 0;

      for (i = 0; i < 3; i++) {
        c = parseInt(hex.substr(i * 2, 2), 16);
        c = Math.round(Math.min(Math.max(0, c + c * lum), 255)).toString(16);
        rgb += ('00' + c).substr(c.length);
      }

      return rgb;
    },


    /**
     * Detect the current theme based on the style sheet.
     * @private
     * @returns {string} The current theme.
     */
    getThemeFromStylesheet: function getThemeFromStylesheet() {
      var css = $('#stylesheet, #sohoxi-stylesheet');
      var thisTheme = '';

      if (css.length > 0) {
        var path = css.attr('href');
        thisTheme = path.substring(path.lastIndexOf('/') + 1);
        // trim query string off the end if it exists
        // something like ?v=123 may be used for cache busting or build identifiers
        var queryParamIndex = thisTheme.lastIndexOf('?');
        if (queryParamIndex > -1) {
          thisTheme = thisTheme.slice(0, queryParamIndex);
        }
        // trim the file extensions off the end and drop the -theme portion
        thisTheme = thisTheme.replace('.min.css', '').replace('.css', '').replace('-theme', '');
      }
      return thisTheme;
    },


    /**
    * Sets the current theme, blocking the ui during the change.
    * @param {string} incomingTheme  Represents the file name of a color
    * scheme (can be dark, light or high-contrast)
    */
    setTheme: function setTheme(incomingTheme) {
      if (exports.theme === incomingTheme) {
        if (!$('html').hasClass(exports.theme + '-theme')) {
          $('html').addClass(exports.theme + '-theme');
        }
        return;
      }

      exports.theme = incomingTheme;

      // validate theme
      if (this.availableThemes.indexOf(exports.theme) === -1) {
        return;
      }

      $('html').removeClass('light-theme dark-theme high-contrast-theme').addClass(exports.theme + '-theme');

      this.blockUi();

      var self = this;
      var originalCss = $('#stylesheet, #sohoxi-stylesheet');
      var newCss = $('<link rel="stylesheet">');
      var path = originalCss.attr('href');

      newCss.on('load', function () {
        originalCss.remove();
        self.unBlockUi();
      });

      var themePath = path ? path.substring(0, path.lastIndexOf('/')) : '';
      var isMin = path ? path.indexOf('.min') > -1 : false;

      newCss.attr({
        id: originalCss.attr('id'),
        href: xssUtils.stripTags(themePath + '/' + exports.theme + '-theme' + (isMin ? '.min' : '') + '.css')
      });
      originalCss.removeAttr('id');

      // Add new stylesheet before current stylesheet
      // to give it time to parse/render before revealing it
      originalCss.before(newCss);

      // record state of theme in settings
      this.settings.theme = exports.theme;
    },


    /**
     * Builds a temporary page overlay that prevents end users from experiencing FOUC
     * @private
     * @returns {void}
     */
    blockUi: function blockUi() {
      var self = this;
      if (!self.settings.blockUI) {
        return;
      }

      var backgroundColor = '#bdbdbd';
      switch (exports.theme) {
        case 'light':
          backgroundColor = '#f0f0f0';
          break;
        case 'dark':
          backgroundColor = '#313236';
          break;
        case 'high-contrast':
          backgroundColor = '#d8d8d8';
          break;
        default:
          backgroundColor = '#f0f0f0';
      }

      this.pageOverlay = this.pageOverlay || $('<div class="personalize-overlay"></div>');
      this.pageOverlay.css('background', backgroundColor);
      $('body').append(this.pageOverlay);
    },


    /**
     * Removes a temporary page overlay built by `blockUi()`
     * @private
     * @returns {void}
     */
    unBlockUi: function unBlockUi() {
      var self = this;
      if (!self.settings.blockUI) {
        return;
      }

      self.pageOverlay.fadeOut(300, function () {
        self.pageOverlay.remove();
        self.pageOverlay = undefined;
      });
    },


    /**
     * Handle Updating Settings
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * Ideally this will do non-destructive things that make it possible to easily rebuild
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME);
      return this;
    },


    /**
     * Teardown - Remove added markup and events
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME);
    }
  };

  /**
   * Setup a single instance of the Personalization system on the HTML tag.
   * Personalization is top-level.
   */
  var personalization = new Personalize(document.documentElement, {
    theme: exports.theme
  });

  /**
   * Hooks that match up to methods in the Personalization system,
   * that need to exist on the Soho object for backwards-compatibility reasons.
   * These exported functions end up on the Soho object during the bootstrapping process.
   * TODO: make this not the preferred way of accessing these methods, and instead
   * prefer access to the global `Personalize`
   */

  function setTheme(theme) {
    return personalization.setTheme(theme);
  }

  function setColors(colors) {
    return personalization.setColors(colors);
  }

  function getColorStyleSheet(colors) {
    return personalization.getColorStyleSheet(colors);
  }

  /**
   * jQuery Component Wrapper for Personalize
   * NOTE: One instance of the Personalzation system can exist at any time, and is applied
   * to the <body> tag. When an app developer calls this directly, it's assumed that the
   * personalization system has already been established (during bootstrapping) and simply
   * needs to be updated with current settings.
   * @param {object} [settings] incoming Settings
   * @returns {jQuery[]} elements to be acted on
   */
  $.fn.personalize = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME);
      if (!instance) {
        instance = $.data(this, COMPONENT_NAME, personalization);
      }
      instance.updated(settings);
    });
  };

  // ====================================================
  // Soho Form/Element Utilities
  // ====================================================

  // Note marked these private so the doc generator doesnt work on them.
  // These should be refactored into an ES6 FormUtils component.

  /*
   * Make elements in the jQuery selector disabled if they support the prop disabled.
   * Or has a disable method.
   * @private
   * @returns {jQuery[]} processed, jQuery-wrapped elements
   */
  $.fn.disable = function () {
    $.each(this.data(), function (index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value && value.disable) {
        value.disable();
      }
    });
    this.prop('disabled', true);
    return this;
  };

  /*
   * Make elements in the jQuery selector enabled if they support the prop disabled.
   * Or has a enable method.
   * @private
   * @returns {jQuery[]} processed, jQuery-wrapped elements
   */
  $.fn.enable = function () {
    $.each(this.data(), function (index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value && value.enable) {
        value.enable();
      }
    });
    this.prop({ disabled: false, readonly: false });
    return this;
  };

  /*
   * Make elements in the jQuery selector readonly if they support the prop readonly.
   * Or has a readonly method.
   * @private
   * @returns {jQuery[]} processed, jQuery-wrapped elements
   */
  $.fn.readonly = function () {
    $.each(this.data(), function (index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value && value.readonly) {
        value.readonly();
      }
    });
    this.prop('readonly', true);
    return this;
  };

  // Fix: Labels without the "for" attribute
  $(function () {
    var str = void 0;
    var control = void 0;
    var labelText = $('.label-text');
    var labels = labelText.closest('label, .label');

    labels.each(function () {
      control = $('input, textarea, select', this);
      str = control.attr('class');

      $(this).addClass(function () {
        return (
          // Add "inline" and "inline-{control}" class to label
          // assuming control class is first thing in class string
          'inline' + (str ? ' inline-' + (str.indexOf(' ') === -1 ? str : str.substr(0, str.indexOf(' '))) : '')
        );
      });
    });
  });

  // Fix: Radio buttons was not selecting when click and than use arrow keys on Firefox
  $(function () {
    $('input:radio').on('click.radios', function () {
      this.focus();
    });
  });

  // Add css classes to parent for apply special rules
  $(function () {
    var addCssClassToParent = function addCssClassToParent(elemArray, cssClass) {
      for (var i = 0, l = elemArray.length; i < l; i++) {
        $(elemArray[i]).parent().addClass(cssClass);
      }
    };
    addCssClassToParent($('.field > input:checkbox, .field > .inline-checkbox'), 'field-checkbox');
    addCssClassToParent($('.field > input:radio, .field > .inline-radio'), 'field-radio');
  });

  // Text Highlight/Unhighlight Control
  // Originally called "highlight v5" by Johann Burkard
  // http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html
  //
  // Modified for IDS Enterprise (TODO: bit.ly link to docs)

  function innerHighlight(node, pat) {
    var skip = 0;
    var pos = void 0;
    var spannode = void 0;
    var middlebit = void 0;
    var middleclone = void 0;

    if (node.nodeType === 3) {
      pos = node.data.toUpperCase().indexOf(pat);
      pos -= node.data.substr(0, pos).toUpperCase().length - node.data.substr(0, pos).length;

      if (pos >= 0) {
        spannode = document.createElement('mark');
        spannode.className = 'highlight';
        middlebit = node.splitText(pos);
        middlebit.splitText(pat.length);
        middleclone = middlebit.cloneNode(true);
        spannode.appendChild(middleclone);
        middlebit.parentNode.replaceChild(spannode, middlebit);
        skip = 1;
      }
    } else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName)) {
      for (var i = 0; i < node.childNodes.length; ++i) {
        i += innerHighlight(node.childNodes[i], pat);
      }
    }

    return skip;
  }

  /**
   * Highlight a portion of text inside an element
   * @param {string} pat portion of text that's being highlighted
   * @returns {this} this
   */
  $.fn.highlight = function (pat) {
    if (this.length && pat && pat.length) {
      return this.each(function () {
        innerHighlight(this, pat.toUpperCase());
      });
    }
    return this;
  };

  /**
   * Removes highlighting from portions of text inside an element
   * @returns {this} this
   */
  $.fn.unhighlight = function () {
    return this.find('mark.highlight').each(function () {
      var node = this.parentNode;
      node.replaceChild(this.firstChild, this);
      node.normalize();
    }).end();
  };

  // Component Name
  var COMPONENT_NAME$1 = 'arrange';

  /**
  * The Arrange Component allows touch and drag support to sort UI items.
  * @class Arrange
  * @constructor
  *
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.handle] The CSS class name of the handle element to connect
  * @param {string} [settings.itemsSelector] The CSS selector to match all the sortable elements.
  * @param {string} [settings.connectWith] Optional CSS Selector to connect with when using two lists
  * @param {boolean} [settings.isVisualItems] Use only index of visual items to trigger
  * @param {string} [settings.placeholder] The html for the element that appears while dragging
  * @param {string} [settings.placeholderCssClass='arrange-placeholder'] The class to add to the ghost element that is being dragged.
  */
  var ARRANGE_DEFAULTS = {
    handle: null, // The Class of the handle element
    itemsSelector: null,
    connectWith: false,
    isVisualItems: false,
    placeholder: null,
    placeholderCssClass: 'arrange-placeholder'
  };

  function Arrange(element, settings) {
    this.settings = utils.mergeSettings(element, settings, ARRANGE_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Arrange Methods
  Arrange.prototype = {

    // example from: https://github.com/farhadi/html5arrangeable/blob/master/jquery.arrangeable.js
    init: function init() {
      this.isTouch = Environment.features.touch;
      this.handleEvents();
    },


    /**
     * Get Element By Touch In List
     * @private
     * @param {object} list element.
     * @param {number} x value.
     * @param {number} y value.
     * @returns {object} item found in list
     */
    getElementByTouchInList: function getElementByTouchInList(list, x, y) {
      var returns = false;
      var listJq = $(list);

      for (var i = 0, l = listJq.length; i < l; i++) {
        var item = $(listJq[i]);
        var offset = item.offset();

        if (!(x <= offset.left || x >= offset.left + item.outerWidth() || y <= offset.top || y >= offset.top + item.outerHeight())) {
          returns = item;
        }
      }
      return returns;
    },


    /**
     * Dragg touch element
     * @private
     * @param {object} e as event.
     * @param {object} elm as element.
     * @returns {void}
     */
    dragTouchElement: function dragTouchElement(e, elm) {
      var orig = e.originalEvent.changedTouches[0];
      elm[0].style.top = orig.pageY - this.offset.y + 'px';
      elm[0].style.left = orig.pageX - this.offset.x + 'px';
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.items.removeClass('draggable').removeAttr('draggable').off('selectstart.arrange ' + this.dragStart + ' ' + this.dragEnd + ' ' + this.dragWhileDragging);

      $(this.handle, this.items).removeClass('draggable').off('mousedown.arrange mouseup.arrange touchstart.arrange touchend.arrange');

      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, ARRANGE_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
    * Teardown process for this plugin
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$1);
    },


    /**
     * Find out the visual index to trigger
     * @private
     * @param {object} elem to get index number.
     * @returns {number} the index
     */
    getVisualIndex: function getVisualIndex(elem) {
      var s = this.settings;
      var idx = null;

      if (s.isVisualItems) {
        var items = this.element.children().not('[data-arrange-exclude="true"]');
        if (s.itemsSelector) {
          items = $(s.itemsSelector, this.element).not('[data-arrange-exclude="true"]');
        }
        idx = items.index(elem);
      }

      return idx;
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;
      var s = this.settings;

      var index = void 0;
      var isHandle = void 0;
      var status = {};
      var items = this.element.children().not('[data-arrange-exclude="true"]');
      var placeholder = $('<' + (/^(ul|ol)$/i.test(this.element[0].tagName) ? 'li' : 'div') + '>');

      if (s.itemsSelector) {
        items = $(s.itemsSelector, this.element).not('[data-arrange-exclude="true"]');
        placeholder = $('<' + items.first()[0].tagName + ' />');
      }

      if (s.placeholder) {
        placeholder = $(s.placeholder);
      }

      this.dragStart = 'dragstart.arrange touchstart.arrange gesturestart.arrange';
      this.dragEnd = 'dragend.arrange touchend.arrange touchcancel.arrange gestureend.arrange';
      this.dragWhileDragging = 'dragover.arrange dragenter.arrange drop.arrange touchmove.arrange gesturechange.arrange';

      this.handle = s.handle || this.element.attr('data-arrange-handle');
      this.connectWith = this.element.attr('data-arrange-connectWith');
      this.placeholders = placeholder;

      if (!this.isTouch) {
        this.placeholders.addClass(s.placeholderCssClass + ' draggable');
      }

      // Use Handle if available
      $(this.handle, items).addClass('draggable').on('mousedown.arrange touchstart.arrange', function () {
        isHandle = true;
      }).on('mouseup.arrange touchend.arrange', function () {
        isHandle = false;
      });

      // Add connect with
      if (this.connectWith) {
        items = items.add($(this.connectWith).children().not('[data-arrange-exclude="true"]')).data('connectWith', this.connectWith);
      }

      this.items = items;

      // Draggable Items
      this.items.attr('draggable', true).addClass(this.handle ? '' : 'draggable').add([this, placeholder]).not('a[href], img').on('selectstart.arrange', function () {
        if (this.dragDrop) {
          this.dragDrop(); // ie9
        }
        return false;
      }).end().each(function () {
        $(this)
        // Drag start --------------------------------------------------------------------------
        .on(self.dragStart, function (e) {
          if (self.handle && !isHandle) {
            if (self.isTouch) {
              return;
            }
            return false; // eslint-disable-line
          }
          isHandle = false;
          self.dragging = $(this);

          index = self.dragging.addClass('arrange-dragging').index();
          var idx = s.isVisualItems ? self.getVisualIndex(self.dragging) : index;

          $.extend(status, { start: self.dragging, startIndex: idx });

          /**
          * Fires before moving an element allowing you to access the ui to
           customize the draggable item.
          *
          * @event beforearrange
          * @memberof Arrange
          * @property {object} event - The jquery event object
          * @property {object} status - Status for this item
          */
          var result = self.element.triggerHandler('beforearrange', status);
          if (typeof result === 'boolean' && !result || typeof result === 'string' && result.toLowerCase() === 'false') {
            self.dragging = null;
            return;
          }

          if (self.isTouch) {
            var rect = self.dragging[0].getBoundingClientRect();
            var touch = e.originalEvent.changedTouches[0];

            // Save offset
            self.offset = {
              x: touch.pageX - rect.left,
              y: touch.pageY - rect.top
            };
            self.placeholderTouch = self.dragging.clone().addClass('is-touch').attr('id', 'arrange-placeholder-touch').insertBefore(self.dragging);

            self.dragTouchElement(e, self.placeholderTouch);
          } else {
            var dt = e.originalEvent.dataTransfer;
            dt.effectAllowed = 'move';
            dt.setData('Text', 'dummy');
          }
        })

        // Drag end ----------------------------------------------------------
        .on(self.dragEnd, function () {
          if (!self.dragging) {
            return;
          }

          if (self.isTouch) {
            self.dragging.css('opacity', 1);
            self.placeholderTouch.remove();
          }

          self.placeholders.filter(':visible').after(self.dragging);
          self.dragging.removeClass('arrange-dragging').show();
          self.placeholders.detach();

          if (index !== self.dragging.index()) {
            var idx = s.isVisualItems ? self.getVisualIndex(self.dragging) : self.dragging.index();
            $.extend(status, { end: self.dragging, endIndex: idx });

            /**
            * Fires after moving an element allowing you do any follow up updating.
            *
            * @event arrangeupdate
            * @memberof Arrange
            * @property {object} event - The jquery event object
            * @property {object} status - Status for this item
            */
            self.element.triggerHandler('arrangeupdate', status);
          }
          self.dragging = null;
          self.placeholderTouch = null;
        })

        // While dragging ----------------------------------------------------
        .on(self.dragWhileDragging, function (e) {
          if (!self.dragging) {
            return;
          }
          var overItem = this;
          var overIndex = void 0;
          e.preventDefault();

          /**
          * Fires after finishing an arrange action.
          *
          * @event dragend
          * @memberof ApplicationMenu
          * @param {object} event - The jquery event object
          */
          if (e.type === 'drop') {
            e.stopPropagation();
            self.dragging.trigger('dragend.arrange');
            return false; // eslint-disable-line
          }

          if (self.isTouch) {
            var touch = e.originalEvent.touches[0];
            overItem = self.getElementByTouchInList(items, touch.pageX, touch.pageY) || overItem;
          }
          overItem = $(overItem);

          if (!self.isTouch) {
            e.originalEvent.dataTransfer.dropEffect = 'move';
          }

          if (items.is(overItem) && placeholder.index() !== overItem.index()) {
            if (self.isTouch) {
              self.dragging.css('opacity', 0);
            } else {
              self.dragging.hide();
            }

            var idx = void 0;
            if (placeholder.index() < overItem.index()) {
              placeholder.insertAfter(overItem);
              overIndex = overItem.index();
              idx = s.isVisualItems ? self.getVisualIndex(overItem) : overIndex;
            } else {
              placeholder.insertBefore(overItem);
              overIndex = placeholder.index();
              idx = s.isVisualItems ? self.getVisualIndex(placeholder) : overIndex;
            }

            $.extend(status, { over: overItem, overIndex: idx });
            self.element.triggerHandler('draggingarrange', status);

            // Fix: IE-11 on windows-10 svg was disappering
            utils.fixSVGIcons(overItem);

            self.placeholders.not(placeholder).detach();
          } else if (!self.placeholders.is(this)) {
            self.placeholders.detach();
            self.element.append(placeholder);
          }

          if (self.isTouch) {
            self.dragTouchElement(e, self.placeholderTouch);
            return;
          }
          return false; // eslint-disable-line
        }); //-----------------------------------------------------------------
      }); // end each items
    }
  };

  /**
   * jQuery component wrapper for Arrange
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */
  $.fn.arrange = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1, new Arrange(this, settings));
      }
    });
  };

  /* eslint-disable no-cond-assign */

  // TODO: Resize: http://stackoverflow.com/questions/8258232/resize-an-html-element-using-touches
  // Similar: https://github.com/desandro/draggabilly

  // The name of this plugin
  var COMPONENT_NAME$2 = 'drag';

  /**
   * Drag/Drop functions with touch support.
   * @class Drag
   * @constructor
   *
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.axis]  Constrains dragging to either axis. Possible values: null, 'x', 'y'
   * @param {boolean} [settings.clone=false] Set to true to clone the object to drag. In many situations this is
   *  needed to break out of layout.
   * @param {string} [settings.cloneCssClass='is-clone'] Css class added to clone element (defaults is 'is-clone')
   * @param {boolean} [settings.clonePosIsFixed=false] If true cloned object will use css style "position: fixed"
   * @param {string} [settings.cloneAppendTo] Selector to append to for the clone
   * ['body'|'parent'|'jquery object'] default:'body'
   * @param {boolean} [settings.containment=false] Constrains dragging to within the bounds of the specified element
   *  or region. Possible values: "parent", "document", "window".
   * @param {string} [settings.obstacle] jQuery Selector of object(s) that you cannot drag into,
   * @param {boolean} [settings.underElements=false] If set to true will return list of elements that are
   * underneath the drag element
   * @param {object} [settings.containmentOffset={left: 0, top: 0}] How close to the containment object should we be allowed
   * to drag in position form. `{left: 0, top: 0}`
  */
  var DRAG_DEFAULTS = {
    axis: null,
    clone: false,
    cloneCssClass: 'is-clone',
    clonePosIsFixed: false,
    cloneAppendTo: null,
    containment: false,
    obstacle: false,
    underElements: false,
    containmentOffset: { left: 0, top: 0 }
  };

  function Drag(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, DRAG_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Drag.prototype = {
    init: function init() {
      this.handleEvents();
    },


    /**
    * Trigger events and remove clone
    * @private
    * @param {number} left Current left position
    * @param {number} top Current top position
    */
    finish: function finish(left, top) {
      var pos = { top: top, left: left };

      this.element.off('mouseup.draggable');
      $(document).off('mousemove.draggable mouseup.draggable');
      if (this.settings.underElements) {
        pos.underElements = this.getElementsFromPoint(pos.left, pos.top);
      }

      /**
      * Fires after the drag is completed. Use this to remove / set drag feedback off.
      * @event dragend
      * @memberof Drag
      * @property {object} event - The jquery event object.
      * @property {object} ui - The dialog object
      */
      this.element.trigger('dragend', pos);
      this.element.removeClass('is-dragging');

      if (this.clone) {
        if (this.settings.axis === 'x') {
          delete pos.top;
        }

        if (this.settings.axis === 'y') {
          delete pos.left;
        }
        // this.element.css(pos);
        this.clone.remove();
        this.clone = null;
      }

      // Clear Cached Sizes
      if (this.obstacle) {
        this.obstacle = null;
      }
      if (this.upperYLimit) {
        this.upperYLimit = null;
      }
      if (this.upperXLimit) {
        this.upperXLimit = null;
      }
      $('body').removeClass('disable-select');
    },


    // Move the object from the event coords
    move: function move(left, top) {
      var self = this;

      var css = {
        left: left,
        top: top
      };

      // X-Y Axis
      if (this.settings.axis === 'x') {
        delete css.top;
      }

      if (this.settings.axis === 'y') {
        delete css.left;
      }

      if (this.settings.containment) {
        if (this.settings.containment instanceof jQuery) {
          this.container = this.settings.containment;
        } else if (this.settings.containment === 'parent') {
          this.container = this.element.parent();
        } else if (this.settings.containment === 'window') {
          this.container = $(window);
        } else if (this.settings.containment === 'container') {
          this.container = this.element.closest('.page-container');
        } else {
          this.container = $(document);
        }

        if (!this.upperXLimit) {
          this.upperXLimit = this.container.width() - this.element.outerWidth() + this.settings.containmentOffset.left;
        }
        if (!this.upperYLimit) {
          this.upperYLimit = this.container.height() - this.element.outerHeight() + this.settings.containmentOffset.top;
        }
        if (css.top > this.upperYLimit) {
          css.top = this.upperYLimit;
        }

        if (css.left > this.upperXLimit) {
          css.left = this.upperXLimit;
        }

        if (css.top < 0) {
          css.top = 0;
        }

        if (css.left < 0) {
          css.left = 0;
        }

        if (this.settings.containment === 'container' && css.left <= 1) {
          css.left = 1;
        }
      }

      if (this.settings.obstacle) {
        var elemOffset = this.clone ? this.clone.offset() : this.element.offset();
        var elemWidth = this.clone ? this.clone.outerWidth() : this.element.outerWidth();
        var movingRight = css.left > elemOffset.left;

        // Caching this so drag is not jaggie
        if (!this.obstacle) {
          this.obstacle = $(this.settings.obstacle).not(this.element);
          var obstacleOffset = $(this.obstacle).offset();

          this.constraints = {
            top: obstacleOffset.top,
            left: obstacleOffset.left,
            bottom: obstacleOffset.top + this.obstacle.outerHeight(),
            right: obstacleOffset.left + this.obstacle.outerWidth()
          };
        }

        if (!movingRight && self.originalPos.left > this.constraints.left && css.left <= this.constraints.right) {
          css.left = this.constraints.right;
        }

        if (movingRight && self.originalPos.left + elemWidth <= this.constraints.left && css.left + elemWidth >= this.constraints.left) {
          css.left = this.constraints.left - this.obstacle.outerWidth();
        }

        // TODO: Moving Down
      }

      var applyCssStyle = function applyCssStyle(el, applyCss, prop) {
        if (typeof applyCss[prop] !== 'undefined') {
          el[0].style[prop] = applyCss[prop] + 'px';
        }
      };

      applyCssStyle(this.clone || this.element, css, 'top');
      applyCssStyle(this.clone || this.element, css, 'left');

      if (this.settings.underElements) {
        css.underElements = this.getElementsFromPoint(css.left, css.top);
      }

      /**
      * Fires (many times) while dragging is occuring. Use this for DOM feedback but
      * be careful about what you do in here for performance.
      * @event drag
      * @memberof Drag
      * @property {object} event - The jquery event object.
      * @property {object} ui - The dialog object
      */
      this.element.trigger('drag', css);
    },


    /**
    * Get elements from given point.
    * @param {number} x The x-coordinate of the Point.
    * @param {number} y The y-coordinate of the Point.
    * @Returns {array} List of all elements at the given point.
    */
    getElementsFromPoint: function getElementsFromPoint(x, y) {
      var elements = [];

      if (document.elementsFromPoint) {
        elements = document.elementsFromPoint(x, y);
      } else if (document.msElementsFromPoint) {
        elements = document.msElementsFromPoint(x, y);
      } else {
        var i = void 0;
        var l = void 0;
        var d = void 0;
        var current = void 0;
        var max = 999;
        var pointerEvents = [];

        while ((current = document.elementFromPoint(x, y)) && elements.indexOf(current) === -1 && current !== null && max > -1) {
          max--;

          // push the element and its current style
          elements.push(current);
          pointerEvents.push({
            value: current.style.getPropertyValue('pointer-events') || '',
            priority: current.style.getPropertyPriority('pointer-events')
          });
          // add "pointer-events: none", to get to the underlying element
          current.style.setProperty('pointer-events', 'none', 'important');
        }
        // restore the previous pointer-events values
        for (i = 0, l = elements.length; i < l; i++) {
          d = pointerEvents[i];
          elements[i].style.setProperty('pointer-events', d.value, d.priority);
        }
      }
      return elements;
    },


    /**
     * Update the component and optionally apply new settings.
     * @param  {object} settings the settings to update to.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }
    },


    /**
     * Detach all functionality and events.
     */
    destroy: function destroy() {
      $.removeData(this.element[0], COMPONENT_NAME$2);
      this.element.off('touchstart.draggable MSPointerDown.draggable pointerdown.draggable touchmove.draggable touchend.draggable touchcancel.draggable mousedown.draggable');
    },
    handleEvents: function handleEvents() {
      var self = this;
      self.offset = null;

      // Touch and Drag Support
      self.element.attr('draggable', false);

      if ('onpointerdown' in window || 'onmspointerdown' in window) ; else {
        // Touch-only Drag Support
        self.element.on('touchstart.draggable gesturestart.draggable', function (e) {
          var pos = $(this).position();
          var orig = e.originalEvent;

          self.offset = {
            x: orig.changedTouches[0].pageX - pos.left,
            y: orig.changedTouches[0].pageY - pos.top
          };

          self.originalPos = pos;
          self.element.addClass('is-dragging');

          /**
          * When the dragging is initiated. Use this to customize/style
          * the drag/drop objects in the DOM.
          * @event dragstart
          * @memberof Drag
          * @property {object} event - The jquery event object.
          * @property {object} ui - The dialog object
          */
          self.element.trigger('dragstart', pos);
        })
        // Move
        .on('touchmove.draggable gesturechange.draggable', function (e) {
          e.preventDefault();
          var orig = e.originalEvent;

          // do now allow two touch points to drag the same element
          if (orig.targetTouches.length > 1) {
            return;
          }

          var xpos = orig.changedTouches[0].pageX - self.offset.x;
          var ypos = orig.changedTouches[0].pageY - self.offset.y;
          self.move(xpos, ypos);
        })
        // Finish Touch Dragging
        .on('touchend.draggable gestureend.draggable touchcancel.draggable', function (e) {
          e.preventDefault();
          var touch = e.originalEvent.changedTouches[0];
          self.finish(touch.pageX - self.offset.x, touch.pageY - self.offset.y);
        });
      }

      // Always bind mousedown in either scenario, in the event that a mouse is used
      self.element.on('mousedown.draggable', function (e) {
        e.preventDefault();

        var pos = self.settings.clonePosIsFixed ? self.element[0].getBoundingClientRect() : self.element.position();

        // Save offset
        self.offset = {
          x: e.pageX - pos.left,
          y: e.pageY - pos.top
        };

        self.originalPos = pos;

        // Prevent Text Selection
        $('body').addClass('disable-select');

        // Handle Mouse Press over draggable element
        $(document).on('mousemove.draggable', function (mouseMoveEvent) {
          mouseMoveEvent.preventDefault();
          self.move(mouseMoveEvent.pageX - self.offset.x, mouseMoveEvent.pageY - self.offset.y);
        });

        // Handle Mouse release over draggable element close out events and trigger
        $(document).on('mouseup.draggable', function (docMouseUpEvent) {
          docMouseUpEvent.preventDefault();
          self.finish(e.pageX - self.offset.x, docMouseUpEvent.pageY - self.offset.y);
        });

        self.element.on('mouseup.draggable', function (mouseUpEvent) {
          mouseUpEvent.preventDefault();
          self.finish(mouseUpEvent.pageX - self.offset.x, mouseUpEvent.pageY - self.offset.y);
        });

        // Trigger dragging
        // Clone
        if (!self.clone && self.settings.clone) {
          self.clone = self.element.clone(true);
          if (self.settings.cloneAppendTo === 'parent') {
            self.settings.cloneAppendTo = self.element.parent();
          }
          self.clone.addClass(self.settings.cloneCssClass).appendTo(self.settings.cloneAppendTo || 'body');
        }

        self.element.addClass('is-dragging');
        self.element.trigger('dragstart', [pos, self.clone]);
      });
    }
  };

  /**
   * jQuery Component Wrapper for Drag
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.drag = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$2);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$2, new Drag(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$3 = 'place';

  // Default Component Options
  var DEFAULT_PLACE_SETTINGS = {
    bleedFromContainer: false,
    callback: null,
    container: null,
    parent: null,
    parentXAlignment: 'center',
    parentYAlignment: 'center',
    placement: 'bottom',
    strategies: ['nudge']
  };

  // Constants used throughout
  var PLACE_STRATEGIES = ['nudge', 'clockwise', 'flip', 'shrink', 'shrink-x', 'shrink-y'];
  var PLACE_POSITIONS = ['top', 'left', 'right', 'bottom', 'center'];
  var PLACE_X_ALIGNMENTS = ['left', 'center', 'right'];
  var PLACE_Y_ALIGNMENTS = ['top', 'center', 'bottom'];
  var PLACEMENT_OBJECT_SETTING_KEYS = ['x', 'y', 'container', 'containerOffsetX', 'containerOffsetY', 'callback', 'parent', 'parentXAlignment', 'parentYAlignment', 'useParentWidth', 'useParentHeight', 'placement', 'strategies'];

  /**
   * Object that contains coordinates along with temporary, changeable properties.
   * This object gets passed around the Place Behavior and modified during each phase of positioning.
   * This object is also passed to all callbacks and event listeners for further modification.
   * @private
   * @param {object} [placementOptions] object containing settings for placement
   * @returns {void}
   */
  function PlacementObject(placementOptions) {
    var self = this;

    PLACEMENT_OBJECT_SETTING_KEYS.forEach(function (val) {
      if (placementOptions[val] === null) {
        return;
      }

      if (val === 'x' || val === 'y') {
        self.setCoordinate(val, placementOptions[val]);
        self['original' + val] = placementOptions[val];
        return;
      }

      self[val] = placementOptions[val];
    });

    this.modified = false;

    return this.sanitize();
  }

  PlacementObject.prototype = {
    isReasonableDefault: function isReasonableDefault(setting, limits) {
      return $.inArray(setting, limits) > -1;
    },
    sanitize: function sanitize() {
      var self = this;

      this.bleedFromContainer = this.bleedFromContainer === true;
      this.callback = typeof this.callback === 'function' ? this.callback : DEFAULT_PLACE_SETTINGS.callback;
      this.container = this.container instanceof $ && this.container.length ? this.container : DEFAULT_PLACE_SETTINGS.container;
      this.containerOffsetX = !isNaN(parseInt(this.containerOffsetX, 10)) ? this.containerOffsetX : 0;
      this.containerOffsetY = !isNaN(parseInt(this.containerOffsetY, 10)) ? this.containerOffsetY : 0;
      this.parent = this.parent instanceof $ && this.parent.length ? this.parent : DEFAULT_PLACE_SETTINGS.parent;
      this.parentXAlignment = this.isReasonableDefault(this.parentXAlignment, PLACE_X_ALIGNMENTS) ? this.parentXAlignment : DEFAULT_PLACE_SETTINGS.parentXAlignment;
      this.parentYAlignment = this.isReasonableDefault(this.parentYAlignment, PLACE_Y_ALIGNMENTS) ? this.parentYAlignment : DEFAULT_PLACE_SETTINGS.parentYAlignment;
      this.placement = this.isReasonableDefault(this.placement, PLACE_POSITIONS) ? this.placement : DEFAULT_PLACE_SETTINGS.placement;
      this.useParentHeight = this.useParentHeight === true;
      this.useParentWidth = this.useParentWidth === true;

      if (!$.isArray(this.strategies) || !this.strategies.length) {
        this.strategies = ['nudge'];
      }
      this.strategies.forEach(function (strat, i) {
        self.strategies[i] = self.isReasonableDefault(strat, PLACE_STRATEGIES) ? strat : self.strategies[i];
      });
    },
    setCoordinate: function setCoordinate(coordinate, value) {
      var coordinates = ['x', 'y'];
      if (!this.isReasonableDefault(coordinate, coordinates)) {
        return;
      }

      if (isNaN(value)) {
        value = 0;
      }

      this[coordinate] = Math.round(value);
    }
  };

  /**
   * The Place API which handles internal placement of popups, menus ect.
   * @class Place
   * @param {HTMLElement|jQuery[]} element the base element being placed
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.bleedFromContainer = false] If true, allows positioned content to bleed
   *  outside of a defined container.
   * @param {function} [settings.callback] If defined, provides extra placement adjustments
   *  after the main calculation is performed.
   * @param {HTMLElement} [settings.container] If defined, contains the placement of the
   *  element to the boundaries of a specific container element.
   * @param {HTMLElement} [settings.parent] If defined, will be used as the reference
   *  element for placement this element.
   * @param {string} [settings.parentXAlignment = 'center'] Only used for parent-based placement.
   *  Determines the X-coordinate alignment of the placed element against its parent.
   * @param {string} [settings.parentYAlignment = 'center'] Only used for parent-based placement.
   *  Determines the Y-coordinate alignment of the placed element against its parent.
   * @param {string} [settings.placement = 'bottom'] If defined, changes the direction in which
   *  placement of the element happens
   * @param {string[]} [settings.strategies = ['nudge']] Determines the "strategy" for alternatively
   *  placing the element if it doesn't fit in the defined boundaries.  Only matters
   *  when "parent" is a defined setting.  It's possible to define multiple strategies
   *  and execute them in order.
   */
  function Place(element, settings) {
    this.settings = utils.mergeSettings(element, settings, DEFAULT_PLACE_SETTINGS);
    this.element = $(element);
    this.init();
  }

  Place.prototype = {

    /**
     * Do other init (change/normalize settings, load externals, etc)
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      return this.build().handleEvents();
    },


    /**
     * Add markup to the control
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      if (!this.element.hasClass('placeable')) {
        this.element.addClass('placeable');
      }

      // Setup a hash of original styles that will retain width/height whenever
      // the placement for this element is recalculated.
      this.originalStyles = {};
      var h = this.element[0].style.height;
      var w = this.element[0].style.width;

      if (h) {
        this.originalStyles.height = h;
      }
      if (w) {
        this.originalStyles.width = w;
      }

      return this;
    },


    /**
     * Sets up event handlers for this control and its sub-elements
     * @private
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('place.' + COMPONENT_NAME$3, function (e, x, y) {
        self.place(new PlacementObject({ x: x, y: y }));
      }).on('updated.' + COMPONENT_NAME$3, function () {
        self.updated();
      });

      return this;
    },


    /**
     * Actually renders an element with coordinates inside the DOM
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {void}
     */
    render: function render(placementObj) {
      var unitRegex = /(px|%)/i;

      this.element.offset({
        left: placementObj.x,
        top: placementObj.y
      });

      if (placementObj.height) {
        this.element[0].style.height = placementObj.height + (unitRegex.test('' + placementObj.height) ? '' : 'px');
      }
      if (placementObj.width) {
        this.element[0].style.width = placementObj.width + (unitRegex.test('' + placementObj.width) ? '' : 'px');
      }
    },


    /**
     * Main placement API Method (external)
     * Can either take a PlacementObject as a single argument, or can take 2 coordinates (x, y) and
     * will use the pre-defined settings.
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {void}
     */
    place: function place(placementObj) {
      var curr = [this.element[0].style.left, this.element[0].style.top];

      // Cancel placement with return:false; from a "beforeplace" event
      var canBePlaced = this.element.trigger('beforeplace', [curr]);
      if (!canBePlaced) {
        return curr;
      }

      if (!(placementObj instanceof PlacementObject)) {
        placementObj = new PlacementObject(placementObj);
      }

      // If no values are defined, simply return the current coordinates with a warning.
      if (placementObj.x == null && placementObj.y == null) {
        // TODO: Log a warning about not positioning stuff?
        return curr;
      }

      // Remove any previous placement styles
      this.clearOldStyles();

      // Use different methods if placement against a parent, versus straight-up coordinate placement
      if (placementObj.parent) {
        return this.placeWithParent(placementObj);
      }

      return this.placeWithCoords(placementObj);
    },


    /**
     * Placement Routine that expects a parent to be used as a base placement marking.
     * In this case, "x" and "y" integers are "relative" adjustments to the original
     * numbers generated by the parent. Can be modified by using a callback in the settings.
     * @private
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {PlacementObject} modified placementObject with updated settings
     */
    placeWithParent: function placeWithParent(placementObj) {
      if (!placementObj.parent || !placementObj.parent.length) {
        // can't simply return x and y here because if there is no parent element,
        // these numbers are not coordinates, they are offsets.
        return [undefined, undefined];
      }

      var self = this;
      var parentRect = DOM.getDimensions(placementObj.parent[0]);
      var elRect = DOM.getDimensions(this.element[0]);
      var container = this.getContainer(placementObj);
      var containerIsBody = container.length && container[0] === document.body;
      // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
      // Firefox $('body').scrollTop() will always return zero.
      var scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft();
      var scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();

      if (placementObj.useParentWidth) {
        placementObj.width = parentRect.width;
      }
      if (placementObj.useParentHeight) {
        placementObj.height = parentRect.height;
      }

      function getCoordsFromPlacement(incomingPlacementObj) {
        var p = incomingPlacementObj.placement;
        var aX = incomingPlacementObj.parentXAlignment;
        var aY = incomingPlacementObj.parentYAlignment;
        var cX = void 0;
        var cY = void 0;

        // Set initial placements
        switch (p) {
          case 'top':
            cY = parentRect.top - elRect.height - incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
            break;
          case 'left':
            cX = parentRect.left - elRect.width - incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
            break;
          case 'right':
            cX = parentRect.right + incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
            break;
          default:
            // Bottom
            cY = parentRect.bottom + incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
            break;
        }

        // Set X alignments on bottom/top placements
        if (p === 'top' || p === 'bottom') {
          var cW = containerIsBody ? document.body.offsetWidth : null;
          switch (aX) {
            case 'left':
              if (containerIsBody && cW < parentRect.left + elRect.width) {
                cX = parentRect.right - elRect.width + incomingPlacementObj.x + scrollX;
              } else {
                cX = parentRect.left - incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
              }
              break;
            case 'right':
              if (containerIsBody && parentRect.right - elRect.width < 0) {
                cX = parentRect.left - incomingPlacementObj.x + scrollX;
              } else {
                cX = parentRect.right - elRect.width + incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
              }
              break;
            default:
              // center
              cX = parentRect.left + (parentRect.width - elRect.width) / 2 + incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
              break;
          }
        }

        // Set Y alignments on left/right placements
        if (p === 'right' || p === 'left') {
          switch (aY) {
            case 'top':
              cY = parentRect.top - incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
              break;
            case 'bottom':
              cY = parentRect.bottom - elRect.height + incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
              break;
            default:
              // center
              cY = parentRect.top + (parentRect.height - elRect.height) / 2 + incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
              break;
          }
        }

        return [cX, cY];
      }

      function doPlacementAgainstParent(incomingPlacementObj) {
        var coords = getCoordsFromPlacement(incomingPlacementObj);
        incomingPlacementObj.setCoordinate('x', coords[0]);
        incomingPlacementObj.setCoordinate('y', coords[1]);
        self.render(incomingPlacementObj);
        incomingPlacementObj = self.handlePlacementCallback(incomingPlacementObj);
        return incomingPlacementObj;
      }

      // Simple placement logic
      placementObj = doPlacementAgainstParent(placementObj);

      // Adjusts the placement coordinates based on a defined strategy
      // Will only adjust the current strategy if bleeding outside the
      // viewport/container are detected.
      placementObj.strategies.forEach(function (strat) {
        placementObj = self.checkBleeds(placementObj);

        if (placementObj.bleeds) {
          placementObj = function () {
            switch (strat) {
              case 'nudge':
                return self.nudge(placementObj);
              case 'clockwise':
                return self.clockwise(placementObj);
              case 'flip':
                placementObj = self.flip(placementObj);
                placementObj.setCoordinate('x', placementObj.originalx);
                placementObj.setCoordinate('y', placementObj.originaly);
                placementObj = doPlacementAgainstParent(placementObj);
                return placementObj;
              case 'shrink':
                return self.shrink(placementObj);
              case 'shrink-x':
                return self.shrink(placementObj, 'x');
              case 'shrink-y':
                return self.shrink(placementObj, 'y');
              default:
                return placementObj;
            }
          }(self);

          self.render(placementObj);
        }
      });

      // Trigger an event to notify placement has ended
      this.element.trigger('afterplace', [placementObj]);

      return placementObj;
    },


    /**
     * Basic Placement Routine that simply accepts X and Y coordinates.
     * In this case, "x" and "y" integers are "absolute" and will be the base point for placement.
     * Can be modified by using a callback in the settings.
     * @private
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {PlacementObject} modified placementObject with updated settings
     */
    placeWithCoords: function placeWithCoords(placementObj) {
      this.render(placementObj);

      placementObj = this.handlePlacementCallback(placementObj);

      this.render(placementObj);

      // Coordinate placement can only be "nudged" (strategy is not used in this style of placement).
      placementObj = this.checkBleeds(placementObj);
      if (placementObj.bleeds) {
        placementObj = this.nudge(placementObj);
      }

      // Place again
      this.render(placementObj);

      placementObj = this.checkBleeds(placementObj);
      if (placementObj.bleeds) {
        placementObj = this.shrink(placementObj);
      }

      this.render(placementObj);

      this.element.trigger('afterplace', [placementObj]);

      return placementObj;
    },


    /**
     * Perform callback, if it exists.
     * Callback should return an array containing the modified coordinate values: [x, y];
     * NOTE: These are actual coordinates in all cases.
     * NOTE: They are not relative values - they are absolute.
     * @private
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {PlacementObject} modified placementObject with updated settings
     */
    handlePlacementCallback: function handlePlacementCallback(placementObj) {
      var cb = placementObj.callback || this.settings.callback;

      if (cb && typeof cb === 'function') {
        placementObj = cb(placementObj);
      }

      this.render(placementObj);
      return placementObj;
    },


    /**
     * Detects for elements with fixed positioning, or an absolutely-positioned containment.
     * If either condition is true, this placement should not account for container scrolling.
     * @private
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {boolean} whether or not the values calculated should account for scrolling.
     */
    accountForScrolling: function accountForScrolling(placementObj) {
      var container = placementObj.container;
      var pos = window.getComputedStyle(this.element[0]).position;

      // fixed-positoned, placed elements don't account for scrolling
      if (pos === 'fixed') {
        return false;
      }

      // Check the container element.
      // If we can't find a valid container element, do account for scrolling.
      if (!container || !container.length) {
        container = this.element.parents().filter(function () {
          var containerPos = window.getComputedStyle(this).position;
          return containerPos === 'absolute' || pos === 'fixed';
        });
      }
      if (!container || !container.length) {
        return true;
      }

      if (container[0] === document.body) {
        return false;
      }

      var containerStyle = window.getComputedStyle(container[0]);
      pos = containerStyle.position;
      if (pos === 'fixed') {
        return false;
      }
      if (pos === 'absolute' && containerStyle.overflow === 'hidden') {
        return false;
      }
      return true;
    },


    /**
     * Gets a parent container element.
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {HTMLElement|jQuery[]} container element
     */
    getContainer: function getContainer(placementObj) {
      if (placementObj.container instanceof $ && placementObj.container.length) {
        return placementObj.container;
      }

      var modalParent = this.element.parents('.modal');
      if (modalParent.length) {
        return modalParent;
      }

      return $(document.body);
    },


    /**
     * Re-adjust a previously-placed element to account for bleeding off the edges.
     * Element must fit within the boundaries of the page or it's current scrollable pane.
     * @param {PlacementObject} placementObj settings for the placement routine.
     * @returns {PlacementObject} modified placementObject with updated settings.
     */
    checkBleeds: function checkBleeds(placementObj) {
      var containerBleed = this.settings.bleedFromContainer;
      var container = this.getContainer(placementObj);
      var containerIsBody = container.length && container[0] === document.body;
      var BoundingRect = this.element[0].getBoundingClientRect();
      var rect = {};
      var containerRect = container ? container[0].getBoundingClientRect() : {};
      // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
      // Firefox $('body').scrollTop() will always return zero.
      var scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft();
      var scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();
      var windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      var windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      var d = void 0;

      rect.width = BoundingRect.width;
      rect.height = BoundingRect.height;
      rect.top = BoundingRect.top;
      rect.right = BoundingRect.right;
      rect.bottom = BoundingRect.bottom;
      rect.left = BoundingRect.left;

      function getBoundary(edge) {
        switch (edge) {
          case 'top':
            return (containerBleed ? 0 : containerRect.top) - (!containerIsBody ? 0 : scrollY * -1); // 0 === top edge of viewport
          case 'left':
            return (containerBleed ? 0 : containerRect.left) - (!containerIsBody ? 0 : scrollX * -1); // 0 === left edge of viewport
          case 'right':
            return (containerBleed ? windowW : containerRect.right) - (!containerIsBody ? 0 : scrollX * -1);
          default:
            // bottom
            return (containerBleed ? windowH : containerRect.bottom) - (!containerIsBody ? 0 : scrollY * -1);
        }
      }

      // If element width is greater than window width, shrink to fit
      var rightViewportEdge = getBoundary('right');
      if (rect.width >= rightViewportEdge) {
        d = rect.width - rightViewportEdge;
        var newWidth = rect.width - d;
        placementObj.width = newWidth;

        this.element[0].style.width = newWidth + 'px';
        rect.width = newWidth; // reset the rect because the size changed
      }

      // If element height is greater than window height, shrink to fit
      var bottomViewportEdge = getBoundary('bottom');
      if (rect.height >= bottomViewportEdge) {
        d = rect.height - bottomViewportEdge;
        var newHeight = rect.height - d;
        placementObj.height = newHeight;

        this.element[0].style.height = newHeight + 'px';
        rect.height = newHeight; // reset the rect because the size changed
      }

      // build conditions
      var offRightEdge = rect.right > getBoundary('right');
      var offLeftEdge = rect.left < getBoundary('left');
      var offTopEdge = rect.top < getBoundary('top');
      var offBottomEdge = rect.bottom > getBoundary('bottom');

      // Return if no bleeding is detected (no need to fix anything!)
      if (!offRightEdge && !offLeftEdge && !offTopEdge && !offBottomEdge) {
        placementObj.bleeds = undefined;
        return placementObj;
      }

      // Keep a record of bleeds that need to be adjusted, and by what values
      placementObj.bleeds = {};
      placementObj.bleeds.right = offRightEdge ? rect.right - getBoundary('right') : null;
      placementObj.bleeds.left = offLeftEdge ? -(rect.left - getBoundary('left')) : null;
      placementObj.bleeds.top = offTopEdge ? -(rect.top - getBoundary('top')) : null;
      placementObj.bleeds.bottom = offBottomEdge ? rect.bottom - getBoundary('bottom') : null;

      return placementObj;
    },


    // Bumps the element around in each direction
    nudge: function nudge(placementObj) {
      if (!placementObj.nudges) {
        placementObj.nudges = { x: 0, y: 0 };
      }

      var d = 0;
      if (placementObj.bleeds.right) {
        d = Math.abs(placementObj.bleeds.right) + Math.abs(placementObj.containerOffsetX);
        placementObj.setCoordinate('x', placementObj.x - d);
        placementObj.nudges.x -= d;
      }
      if (placementObj.bleeds.left) {
        d = Math.abs(placementObj.bleeds.left) + Math.abs(placementObj.containerOffsetX);
        placementObj.setCoordinate('x', placementObj.x + d);
        placementObj.nudges.x += d;
      }
      if (placementObj.bleeds.top) {
        d = Math.abs(placementObj.bleeds.top) + Math.abs(placementObj.containerOffsetY);
        placementObj.setCoordinate('y', placementObj.y + d);
        placementObj.nudges.y += d;
      }
      if (placementObj.bleeds.bottom) {
        d = Math.abs(placementObj.bleeds.bottom) + Math.abs(placementObj.containerOffsetY);
        placementObj.setCoordinate('y', placementObj.y - d);
        placementObj.nudges.y -= d;
      }

      placementObj.wasNudged = true;
      placementObj.bleeds = undefined;

      return placementObj;
    },
    flip: function flip(placementObj) {
      // Don't attempt to flip if there was no bleeding on the edge we're attempting to leave from.
      if (!placementObj.bleeds[placementObj.placement]) {
        return placementObj;
      }

      if (!placementObj.attemptedFlips) {
        placementObj.attemptedFlips = [];
      }
      placementObj.attemptedFlips.push(placementObj.placement);

      // If we've tried flipping in all directions, give up and use the default placement.
      if (placementObj.attemptedFlips.length > 3) {
        placementObj = this.giveup(placementObj);
        return placementObj;
      }

      var accountForScrolling = this.accountForScrolling(placementObj);
      var isXCoord = ['left', 'right'].indexOf(placementObj.placement) > -1;
      var containerBleed = this.settings.bleedFromContainer;
      var container = this.getContainer(placementObj);
      var containerIsBody = container.length && container[0] === document.body;
      var containerRect = container ? container[0].getBoundingClientRect() : {};
      var parentRect = placementObj.parent[0].getBoundingClientRect();
      // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
      // Firefox $('body').scrollTop() will always return zero.
      var scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft();
      var scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();
      var windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      var windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);

      function getOppositeDir(dir) {
        switch (dir) {
          case 'left':
            return 'right';
          case 'right':
            return 'left';
          case 'top':
            return 'bottom';
          default:
            // bottom
            return 'top';
        }
      }

      // Gets the distance between an edge on the target element, and its opposing viewport border
      function getDistance(dir) {
        var d = 0;

        switch (dir) {
          case 'left':
            d = (containerBleed ? 0 : containerRect.left) - (accountForScrolling ? scrollX : 0) - parentRect.left + placementObj.containerOffsetX;
            break;
          case 'right':
            d = (containerBleed ? windowW : containerRect.right) - (accountForScrolling ? scrollX : 0) - parentRect.right - placementObj.containerOffsetX;
            break;
          case 'top':
            d = (containerBleed ? 0 : containerRect.top) - (accountForScrolling ? scrollY : 0) - parentRect.top + placementObj.containerOffsetY;
            break;
          default:
            // bottom
            d = (containerBleed ? windowH : containerRect.bottom) - (accountForScrolling ? scrollY : 0) - parentRect.bottom - placementObj.containerOffsetY;
            break;
        }

        return Math.abs(d);
      }

      function tried(placement) {
        return $.inArray(placement, placementObj.attemptedFlips) > -1;
      }

      function performFlip(originalDir) {
        var newDir = getOppositeDir(originalDir);
        var perpendicularDir = isXCoord ? 'top' : 'left';
        var oppPerpendicularDir = getOppositeDir(perpendicularDir);
        var originalDistance = getDistance(originalDir);
        var targetDistance = getDistance(newDir);

        if (!tried(newDir)) {
          if (originalDistance >= targetDistance) {
            return originalDir;
          }

          placementObj.wasFlipped = true;
          return newDir;
        }

        // switch the coordinate definitions
        // since the axis for placement is flipped, our coordinate offsets should also flip
        var tmp = placementObj.originalx;
        placementObj.originalx = placementObj.originaly;
        placementObj.originaly = tmp;

        var perpendicularDistance = getDistance(perpendicularDir);
        var oppPerpendicularDistance = getDistance(oppPerpendicularDir);

        if (!tried(perpendicularDir)) {
          if (perpendicularDistance >= oppPerpendicularDistance) {
            return perpendicularDir;
          }

          if (!tried(oppPerpendicularDir)) {
            return oppPerpendicularDir;
          }
        }

        return originalDir;
      }

      placementObj.placement = performFlip(placementObj.placement);

      return placementObj;
    },


    // TODO: Move Clockwise
    clockwise: function clockwise(placementObj) {
      return placementObj;
    },


    // If element height/width is greater than window height/width, shrink to fit
    shrink: function shrink(placementObj, dimension) {
      var accountForScrolling = this.accountForScrolling(placementObj);
      var containerBleed = this.settings.bleedFromContainer;
      var container = this.getContainer(placementObj);
      var containerRect = container ? container[0].getBoundingClientRect() : {};
      var containerIsBody = container.length && container[0] === document.body;
      var rect = this.element[0].getBoundingClientRect();
      var useX = dimension === undefined || dimension === null || dimension === 'x';
      var useY = dimension === undefined || dimension === null || dimension === 'y';
      // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
      // Firefox $('body').scrollTop() will always return zero.
      var scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft();
      var scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();
      var windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      var windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      var leftViewportEdge = (accountForScrolling ? scrollX : 0) + (containerBleed ? 0 : containerRect.left) + placementObj.containerOffsetX;
      var topViewportEdge = (accountForScrolling ? scrollY : 0) + (containerBleed ? 0 : containerRect.top) + placementObj.containerOffsetY;
      var rightViewportEdge = (accountForScrolling ? scrollX : 0) + (containerBleed ? windowW : containerRect.right) - placementObj.containerOffsetX;
      var bottomViewportEdge = (accountForScrolling ? scrollY : 0) + (containerBleed ? windowH : containerRect.bottom) - placementObj.containerOffsetY;
      var d = void 0;

      // Shrink in each direction.
      // The value of the "containerOffsets" is "factored out" of each calculation,
      // if for some reason the element is larger than the viewport/container space allowed.
      placementObj.nudges = placementObj.nudges || {};

      if (useX) {
        // Left
        if (rect.left < leftViewportEdge) {
          d = Math.abs(leftViewportEdge - rect.left);
          if (rect.right >= rightViewportEdge) {
            d -= placementObj.containerOffsetX;
          }
          placementObj.width = rect.width - d;
          placementObj.setCoordinate('x', placementObj.x + d);
          placementObj.nudges.x += d;
        }

        // Right
        if (rect.right > rightViewportEdge) {
          d = Math.abs(rect.right - rightViewportEdge);
          if (rect.left <= leftViewportEdge) {
            d -= placementObj.containerOffsetX;
          }
          placementObj.width = rect.width - d;
        }
      }

      if (useY) {
        // Top
        if (rect.top < topViewportEdge) {
          d = Math.abs(topViewportEdge - rect.top);
          if (rect.bottom >= bottomViewportEdge) {
            d -= placementObj.containerOffsetY;
          }
          placementObj.height = rect.height - d;
          placementObj.setCoordinate('y', placementObj.y + d);
          placementObj.nudges.y += d;
        }

        // Bottom
        if (rect.bottom > bottomViewportEdge) {
          d = Math.abs(rect.bottom - bottomViewportEdge);
          if (rect.top <= topViewportEdge) {
            d -= placementObj.containerOffsetY;
          }
          placementObj.height = rect.height - d;
        }
      }

      return placementObj;
    },


    // Giving up causes all the placementObj settings to revert
    giveup: function giveup(placementObj) {
      placementObj.giveup = true;
      placementObj.strategy = this.settings.strategy;
      placementObj.placement = this.settings.placement;
      return placementObj;
    },


    // Clears the old styles that may be present
    clearOldStyles: function clearOldStyles() {
      this.element[0].style.left = '';
      this.element[0].style.top = '';
      this.element[0].style.width = '';
      this.element[0].style.height = '';

      var os = this.originalStyles;
      if (os) {
        if (os.width) {
          this.element[0].style.width = os.width;
        }

        if (os.height) {
          this.element[0].style.height = os.height;
        }
      }

      return this;
    },


    // Built-in method for handling positon of optional arrow elements.
    // Used for tooltip/popovers/popupmenus
    setArrowPosition: function setArrowPosition(e, placementObj, element) {
      var target = placementObj.parent;
      var arrow = element.find('div.arrow');
      var dir = placementObj.placement;
      var isXCoord = ['left', 'right'].indexOf(dir) > -1;
      var targetRect = {};
      var elementRect = element[0].getBoundingClientRect();
      var arrowRect = {};
      var newArrowRect = {};
      var hideArrow = false;

      if (!target || !target.length || !arrow.length) {
        return;
      }

      arrow[0].removeAttribute('style');

      // if (placementObj.attemptedFlips) { TJM Removed for pager bug. Seems to work.
      element.removeClass('top right bottom left').addClass(dir);
      // }

      // Flip the arrow if we're in RTL mode
      if (this.isRTL && isXCoord) {
        var opposite = dir === 'right' ? 'left' : 'right';
        element.removeClass('right left').addClass(opposite);
      }

      // Custom target for some scenarios
      if (target.is('.colorpicker')) {
        target = target.next('.trigger');
      }
      if (target.is('.datepicker, .timepicker')) {
        target = target.next('.icon');
      }
      if (target.is('.btn-split-menu, .btn-menu, .btn-actions, .btn-filter, .tab, .tab-more')) {
        target = target.find('.icon').last();
      }
      if (target.is('.searchfield-category-button')) {
        target = target.find('.icon.icon-dropdown');
      }
      if (target.is('.colorpicker-editor-button')) {
        target = target.find('.trigger .icon');
      }

      // reset if we borked the target
      if (!target.length) {
        target = placementObj.parent;
      }

      targetRect = target.length ? target[0].getBoundingClientRect() : targetRect;
      arrowRect = arrow.length ? arrow[0].getBoundingClientRect() : arrowRect;
      newArrowRect = {};

      function getMargin(placement) {
        return placement === 'right' || placement === 'left' ? 'margin-top' : 'margin-left';
      }

      function getDistance() {
        var targetCenter = 0;
        var currentArrowCenter = 0;
        var d = 0;

        if (dir === 'left' || dir === 'right') {
          targetCenter = targetRect.top + targetRect.height / 2;
          currentArrowCenter = arrowRect.top + arrowRect.height / 2;
          d = targetCenter - currentArrowCenter;
          newArrowRect.top = arrowRect.top + d;
          newArrowRect.bottom = arrowRect.bottom + d;

          if (newArrowRect.top <= elementRect.top || newArrowRect.bottom >= elementRect.bottom) {
            hideArrow = true;
          }
        }
        if (dir === 'top' || dir === 'bottom') {
          targetCenter = targetRect.left + targetRect.width / 2;
          currentArrowCenter = arrowRect.left + arrowRect.width / 2;
          d = targetCenter - currentArrowCenter;
          newArrowRect.left = arrowRect.left + d;
          newArrowRect.right = arrowRect.right + d;

          if (newArrowRect.left <= elementRect.left || newArrowRect.right >= elementRect.right) {
            hideArrow = true;
          }
        }

        return d;
      }

      // line the arrow up with the target element's "dropdown icon", if applicable
      var positionOpts = {};
      positionOpts[getMargin(dir)] = getDistance();
      if (hideArrow) {
        positionOpts.display = 'none';
      }
      arrow.css(positionOpts);
    },


    // Handle Updating Settings
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },


    // Simple Teardown - remove events & rebuildable markup.
    teardown: function teardown() {
      this.clearOldStyles();
      this.element.removeClass('placeable');

      this.element.off('updated.' + COMPONENT_NAME$3 + ' place.' + COMPONENT_NAME$3);

      this.element.trigger('afterteardown');
      return this;
    },


    // Teardown - Remove added markup and events
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$3);
    }
  };

  /**
   * jQuery Component Wrapper for Place
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.place = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$3);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$3, new Place(this, settings));
      }
    });
  };

  // component name
  var COMPONENT_NAME$4 = 'icon';

  // Default Options
  var ICON_DEFAULTS = {
    use: 'user-profile', // Match this to one of the IDS Enterprise icons, prefixed with an ID of '#icon-'
    focusable: false
  };

  /**
   * Icon Control
   * Wraps SVG Icons with a Javascript control that can change the icon type, reference
   * relative or absolute URLs, and clean up after itself.  Works with the Base tag.
   * @constructor
   * @param {jQuery[]|HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   * @param {string} [settings.use = 'user-profile'] the type of icon that will appear.
   *  (gets added to the `<use>` tag's `xlink:href` property)
   * @param {boolean} [settings.focusable = false] whether or not this icon gets a `tabIndex` and
   *  becomes a focusable element on the page.
   */
  function Icon(element, settings) {
    this.settings = utils.mergeSettings(element, settings, ICON_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Icon.prototype = {

    /**
     * @private
     * @chainable
     * @returns {this} component instance
     */
    init: function init() {
      this.getExistingUseTag();

      // Do other init (change/normalize settings, load externals, etc)
      return this.render().handleEvents();
    },


    /**
     * Add markup to the control
     * @private
     * @chainable
     * @returns {this} component instance
     */
    render: function render() {
      var self = this;
      this.element.addClass('icon');

      if (!this.element.is('svg')) {
        // TODO: Possibly work with span-based icons here?
        return this;
      }

      // Get a "base-tag-proof" version of the Use tag's definition.
      // jQuery can't work with SVG elements, so we just modify it with regular DOM APIs
      var use = this.element[0].getElementsByTagName('use')[0];
      if (!use) {
        return this;
      }

      if (use.getAttribute('xlink:href') !== self.getBasedUseTag()) {
        use.setAttribute('xlink:href', self.getBasedUseTag());
      }

      return this;
    },


    /**
     * Gets the currently used base tag.
     * @returns {string} a version of this icon's definition prefixed with the current base tag's URL.
     */
    getBasedUseTag: function getBasedUseTag() {
      return base.getBaseURL('#icon-' + this.settings.use);
    },


    /**
     * Changes this icon instance's `use` setting to match an existing `<use> tag's
     * `xlink:href` attribute. In the event that a <use> tag pre-exists on an icon,
     * we want to retain it, and simply replace the settings.
     * @chainable
     * @returns {this} component instance
     */
    getExistingUseTag: function getExistingUseTag() {
      if (!this.element.is('svg')) {
        return this;
      }

      var useTag = this.element.children('use');
      if (!useTag.length) {
        return this;
      }

      var xlinkHref = useTag.attr('xlink:href');
      this.settings.use = xlinkHref.replace('#icon-', '');

      return this;
    },


    /**
     * Sets up event handlers for this control and its sub-elements
     * @private
     * @chainable
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('updated.' + COMPONENT_NAME$4, function () {
        self.updated();
      });

      return this;
    },


    /**
     * Handle Updating Settings
     * @chainable
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @chainable
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$4);
      return this;
    },


    /**
     * Teardown - Remove added markup and events
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$4);
    }
  };

  /**
   * jQuery component wrappers
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on.
   */
  $.fn.icon = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$4);
      if (!instance) {
        instance = $.data(this, COMPONENT_NAME$4, new Icon(this, settings));
      } else {
        instance.updated(settings);
      }
    });
  };

  /**
   * Factory Function for instantly building icons.
   * Use this for building icons that don't exist yet.
   * Scoped Privately on purpose...
   */
  (function () {
    function normalizeIconOptions(options) {
      var defaults = {
        icon: 'user-profile', // omit the "icon-" if you want; this code strips it out.
        classes: ['icon']
      };
      options = options || $.extend({}, defaults);

      if (typeof options === 'string') {
        options = $.extend({}, defaults, {
          icon: options.replace('icon-', '')
        });
      }

      // reroute "options.class" if that exists
      if (!options.classes && options.class) {
        options.classes = options.class;
        delete options.class;
      }

      if (!options.classes) {
        options.classes = [].concat(defaults.classes);
      }

      if (typeof options.classes === 'string') {
        options.classes = options.classes.split(' ');
      }

      if (options.classes.indexOf('icon') === -1) {
        options.classes.push('icon');
      }

      return options;
    }

    // Returns the RAW HTML for creating a new icon in string form
    $.createIcon = function createIcon(options) {
      options = normalizeIconOptions(options);

      return ['<svg class="' + options.classes.join(' ') + '" focusable="false" aria-hidden="true" role="presentation">' + ('<use xlink:href="#icon-' + options.icon + '"></use>') + '</svg>'].join('');
    };

    // Returns a jQuery-wrapped element containing a new icon
    $.createIconElement = function createIconElement(options) {
      return $($.createIcon(options));
    };

    // Returns just the path part
    $.createIconPath = function createIconElement(options) {
      options = normalizeIconOptions(options);
      return $.getBaseURL('#icon-' + options.icon.replace('icon-', ''));
    };

    // Toggle the use or entire svg icon in the case of the polyfill
    $.fn.changeIcon = function (icon) {
      $(this).find('use').attr('xlink:href', $.createIconPath({ icon: icon }));
    };

    $.fn.getIconName = function () {
      var svg = $(this);
      var use = svg.find('use');

      if (use.length === 1) {
        return use.attr('xlink:href').substr(use.attr('xlink:href').indexOf('#icon-') + 6);
      }
      return svg.attr('data-icon');
    };
  })();

  // The name of this component.
  var COMPONENT_NAME$5 = 'button';

  /**
   * Soho Button Element
   * @class Button
   * @param {string} element The component element.
   * @param {string} [settings] The component settings.
   * @param {string} [settings.toggleOnIcon=null]  The icon to use for on state on toggle buttons
   * @param {string} [settings.toggleOffIcon=null]  The icon to use for off state on toggle buttons
   * @param {string} [settings.replaceText=false]  If true the selection will be used to replace the content
   */
  var BUTTON_DEFAULTS = {
    toggleOnIcon: null,
    toggleOffIcon: null,
    hideMenuArrow: null,
    replaceText: false
  };

  function Button(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings, BUTTON_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Button.prototype = {
    init: function init() {
      var self = this;

      this.isTouch = Environment.features.touch;
      this.isSafari = $('html').is('.is-safari');
      this.isFirefox = $('html').is('.is-firefox');

      if (this.element.hasClass('no-ripple')) {
        return;
      }

      if (this.element.hasClass('btn-menu') && !this.element.hasClass('btn-icon') && !this.element.hasClass('btn-actions')) {
        var ddIcon = this.element.children('svg.icon');
        var use = ddIcon.find('use');
        var hasIcon = false;

        if (ddIcon.length > 0 && use.length === 1) {
          hasIcon = use.attr('xlink:href').indexOf('#icon-dropdown') > -1;
        }

        if (!hasIcon) {
          ddIcon = $.createIconElement({ icon: 'dropdown', classes: ['icon-dropdown'] });
          this.element.append(ddIcon);
        }

        if (!ddIcon.hasClass('icon-dropdown')) {
          ddIcon.addClass('icon-dropdown');
        }

        if (this.settings.replaceText) {
          this.element.on('selected.content', function (e, a) {
            $(this).find('span').text(a.text());
          });
        }

        if (this.settings.hideMenuArrow) {
          ddIcon.remove();
        }
      }

      if (this.element.hasClass('btn-toggle') || this.element.hasClass('icon-favorite')) {
        this.element.on('click.favorite', function () {
          var elem = $(this);
          var svg = elem.find('svg:not(.ripple-effect)');
          var isPressed = elem.attr('aria-pressed') === 'true';

          elem.attr('aria-pressed', isPressed ? 'false' : 'true');
          if (self.settings.toggleOffIcon && self.settings.toggleOnIcon) {
            svg.changeIcon(isPressed ? self.settings.toggleOffIcon : self.settings.toggleOnIcon);
          } else {
            elem.toggleClass('is-pressed');
          }

          if (elem.hasClass('icon-favorite') && !elem.hasClass('btn-toggle') && svg.find('use').attr('xlink:href') === '#icon-star-filled') {
            svg.changeIcon('star-outlined');
          } else if (elem.hasClass('icon-favorite') && !elem.hasClass('btn-toggle')) {
            svg.changeIcon('star-filled');
          }
        });

        if (!this.element.attr('aria-pressed')) {
          this.element.attr('aria-pressed', 'false');
        }
      }

      // Standalone action buttons need a "More Actions" tooltip.
      // This is handled internally on most components that implement an action button.
      if (this.element.hasClass('btn-actions') && !this.element.parents('.field').length && !this.element.parents('.toolbar').length) {
        if (!this.element.data('tooltip')) {
          this.element.attr('title', Locale.translate('More')).tooltip({
            content: Locale.translate('More')
          });
        }
      }

      this.element.hideFocus();

      this.element.on('touchstart.button click.button', function (e) {
        if (self.element.attr('disabled') || self.element.is('.is-disabled') || !self.isTouch && e.which !== 1 || $('.ripple-effect', this).length || self.isTouch && e.type !== 'touchstart') {
          return;
        }

        var element = $(this);
        var btnOffset = element.offset();
        var xPos = e.pageX - btnOffset.left;
        var yPos = e.pageY - btnOffset.top;
        var ripple = $('<svg class="ripple-effect" focusable="false" aria-hidden="true" role="presentation"><circle r="0" class="ripple-circle"></circle></svg>');

        if (self.isTouch) {
          // Make sure the user is using only one finger and then get the touch position relative
          // to the ripple wrapper
          e = e.originalEvent;
          if (e && e.touches && e.touches.length === 1) {
            xPos = e.touches[0].pageX - btnOffset.left;
            yPos = e.touches[0].pageY - btnOffset.top;
          }
        }

        // Using keyboard to click
        xPos = xPos < 0 ? self.element.outerWidth() / 2 : xPos;
        yPos = yPos < 0 ? self.element.outerHeight() / 2 : yPos;

        $('svg.ripple-effect', element).remove();
        ripple[0].style.left = xPos + 'px';
        ripple[0].style.top = yPos + 'px';
        element.prepend(ripple);

        // Start the JS Animation Loop if IE9
        // Or Safari/Firefox has bug with combination like: animation, overflow, position,
        // border-radius etc.)
        if (!$.fn.cssPropSupport('animation') || self.isSafari && !Environment.features.touch || self.isFirefox) {
          ripple.removeClass('is-animation');
          self.animateWithJS(ripple);
        } else {
          var elem = $('svg.ripple-effect', element);
          elem.addClass('is-animation');
        }

        setTimeout(function () {
          ripple.remove();
        }, 1000);
      });
    },


    // Browsers that don't support CSS-based animation can still show the animation
    animateWithJS: function animateWithJS(el) {
      var scale = 200;
      var elStyle = el[0].style;
      var xPos = parseFloat(elStyle.left) - scale / 2 + 'px';
      var yPos = parseFloat(elStyle.top) - scale / 2 + 'px';

      el[0].style.opacity = '0.4';
      el.animate({
        opacity: 0,
        left: xPos,
        top: yPos,
        width: scale,
        height: scale
      }, 1000);
    },


    /**
     * Update the component with new settings.
     * @param  {object} settings The settings you would like to modify.
     * @returns {object} The api.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.extend({}, this.settings, settings);
      }
      return this;
    },


    /**
    * Teardown and remove any added markup and events.
    * @returns {void}
    */
    destroy: function destroy() {
      this.element.off('click.button touchstart.button focusin.hide-focus focusout.hide-focus mousedown.hide-focus touchstart.hide-focus');

      var moreTooltip = this.element.data('tooltip');
      if (this.element.hasClass('btn-actions') && moreTooltip) {
        moreTooltip.destroy();
      }

      $.removeData(this.element[0], COMPONENT_NAME$5);
    }
  };

  /**
   * jQuery Component Wrapper for the Soho Button Element
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */
  $.fn.button = function jQueryButton(settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$5);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$5, new Button(this, settings));
      }
    });
  };

  var COMPONENT_NAME$6 = 'hyperlink';

  /**
   * Soho component wrapper for Hyperlinks.
   * @class Hyperlink
   *
   * @param {HTMLElement} element the base Hyperlink element
   * @param {object} [settings] incoming settings
   * @returns {this} component instance
   */

  var HYPERLINK_DEFAULTS = {};

  function Hyperlink(element, settings) {
    return this.init(element, settings);
  }

  Hyperlink.prototype = {
    init: function init(element, settings) {
      if (!this.element && element instanceof HTMLElement) {
        this.element = element;
      }

      if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {
        var previousSettings = this.settings || HYPERLINK_DEFAULTS;
        this.settings = utils.mergeSettings(this.element, settings, previousSettings);
      }

      if (!this.focusBehavior) {
        this.focusBehavior = new HideFocus(this.element);
      }

      return this;
    },


    /**
     * Attach Events used by the Hyperlinks
     * @private
     * @returns {this} The component api for chaining.
     */
    handleEvents: function handleEvents() {
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
     * Removes the events and pseudo-markup created by the hyperlinks
     * @returns {this} component instance
     */
    teardown: function teardown() {
      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Hyperlink
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */
  $.fn.hyperlink = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$6);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$6, new Hyperlink(this, settings));
        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, COMPONENT_NAME$6);
        };
      }
    });
  };

  /**
   * Contains various Mask-related utilities, settings, masking functions, etc.
   * Available globally under `Soho.masks`.
   * @property {string} EMPTY_STRING just an empty string
   * @property {string} PLACEHOLDER_CHAR the default placeholder used in guides
   * @property {string} CARET_TRAP the string of characters representing a caret trap in mask arrays
   * @property {regexp} NON_DIGITS_REGEX regular expression that matches non-digit characters
   * @property {regexp} DIGITS_REGEX regular expression that matches digit characters
   * @property {regexp} ALPHAS_REGEX regular expression that matches alphabetic, non-special characters
   * @property {regexp} ANY_REGEX regular expression that matches any non-special characters
   * @property {object} LEGACY_DEFS mask definitions used by the old Soho Mask component.
   *  Will be translated to RegExp when a string-based pattern is convered to an array in the new Mask.
   * @property {object} DEFAULT_API_OPTIONS base options passed to a Mask API.
   * @property {object} DEFAULT_CONFORM_OPTIONS default set of options that get passed to `maskAPI.conformToMask()`
   */
  var masks = {

    EMPTY_STRING: '',

    PLACEHOLDER_CHAR: '_',

    CARET_TRAP: '[]',

    NON_DIGITS_REGEX: /[^\u0660-\u06690-9\u0966-\u096F\u2E80-\u2FD5\u3190-\u319f\u3400-\u4DBF\u4E00-\u9FCC\uF900-\uFAAD]/g,

    DIGITS_REGEX: /[\u0660-\u06690-9\u0966-\u096F\u2E80-\u2FD5\u3190-\u319f\u3400-\u4DBF\u4E00-\u9FCC\uF900-\uFAAD]/,

    ALPHAS_REGEX: /[\u00C0-\u017Fa-zA-Z]/,

    ANY_REGEX: /[\u00C0-\u017Fa-zA-Z0-9]/,

    DEFAULT_API_OPTIONS: {
      locale: 'en-US',
      pattern: undefined,
      pipe: undefined
    }

  };

  // Legacy Mask pattern definitions.
  // The New Mask works based on an array of RegExps and Strings.
  masks.LEGACY_DEFS = {
    '#': masks.DIGITS_REGEX,
    0: masks.DIGITS_REGEX,
    x: masks.ALPHAS_REGEX,
    '*': masks.ANY_REGEX,
    '?': /./,
    '~': /[-0-9]/,
    a: /[APap]/,
    m: /[Mm]/
  };

  // Default options that get passed for the _conformToMask()_ method.
  masks.DEFAULT_CONFORM_OPTIONS = {
    caretTrapIndexes: [],
    guide: true,
    previousMaskResult: masks.EMPTY_STRING,
    placeholderChar: masks.PLACEHOLDER_CHAR,
    placeholder: masks.EMPTY_STRING,
    selection: {
      start: 0
    },
    keepCharacterPositions: true
  };

  // Default Number Mask Options
  var DEFAULT_NUMBER_MASK_OPTIONS = {
    prefix: masks.EMPTY_STRING,
    suffix: masks.EMPTY_STRING,
    allowThousandsSeparator: true,
    symbols: {
      currency: '$',
      decimal: '.',
      negative: '-',
      thousands: ','
    },
    allowDecimal: true,
    decimalLimit: 2,
    requireDecimal: false,
    allowNegative: false,
    allowLeadingZeroes: false,
    integerLimit: null
  };

  // Converts a string representing a formatted number into a Number Mask.
  // @param {string} strNumber incoming string
  // @returns {array} contains strings representing character literals and regex patterns.
  function convertToMask(strNumber) {
    return strNumber.split(masks.EMPTY_STRING).map(function (char) {
      return masks.DIGITS_REGEX.test(char) ? masks.DIGITS_REGEX : char;
    });
  }

  // Adds thousands separators to the correct spot in a formatted number string.
  // @param {string} n - the string
  // @param {string} thousands - the thousands separator.
  // @returns {string} the incoming string formatted with a thousands separator.
  // http://stackoverflow.com/a/10899795/604296
  function addThousandsSeparator(n, thousands) {
    return n.replace(/\B(?=(\d{3})+(?!\d))/g, thousands);
  }

  // Gets an array of Regex objects matching the number of digits present in a source string
  // @param {string} part string representing the mark part.
  // @param {string} type 'any', 'digits', or 'alphas'
  // @returns {array} regex representing the part that was passed in.
  function getRegexForPart(part, type) {
    var types = {
      any: masks.ANY_REGEX,
      digits: masks.DIGITS_REGEX,
      alphas: masks.ALPHAS_REGEX
    };

    if (!types[type]) {
      type = 'any';
    }

    var size = part.toString().length;
    var arr = [];

    while (size > 0) {
      arr.push(types[type]);
      size -= 1;
    }
    return arr;
  }

  /**
   * Soho Number Mask Function
   * @param {string} rawValue the un-formatted value that will eventually be masked.
   * @param {object} options masking options
   * @returns {array} representing a mask that will match a formatted number.
   */
  masks.numberMask = function sohoNumberMask(rawValue, options) {
    options = utils.mergeSettings(undefined, options, DEFAULT_NUMBER_MASK_OPTIONS);

    var PREFIX = options.prefix;
    var SUFFIX = options.suffix;
    var DECIMAL = options.symbols.decimal;
    var THOUSANDS = options.symbols.thousands;
    var prefixLength = PREFIX && PREFIX.length || 0;
    var suffixLength = SUFFIX && SUFFIX.length || 0;
    var thousandsSeparatorSymbolLength = THOUSANDS && THOUSANDS.length || 0;

    function numberMask(thisRawValue) {
      if (typeof thisRawValue !== 'string') {
        thisRawValue = masks.EMPTY_STRING;
      }

      var rawValueLength = thisRawValue.length;

      if (thisRawValue === masks.EMPTY_STRING || thisRawValue[0] === PREFIX[0] && rawValueLength === 1) {
        return PREFIX.split(masks.EMPTY_STRING).concat([masks.DIGITS_REGEX]).concat(SUFFIX.split(masks.EMPTY_STRING));
      } else if (thisRawValue === DECIMAL && options.allowDecimal) {
        return PREFIX.split(masks.EMPTY_STRING).concat(['0', DECIMAL, masks.DIGITS_REGEX]).concat(SUFFIX.split(masks.EMPTY_STRING));
      }

      var indexOfLastDecimal = thisRawValue.lastIndexOf(DECIMAL);
      var hasDecimal = indexOfLastDecimal !== -1;
      var isNegative = thisRawValue[0] === options.symbols.negative && options.allowNegative;
      var integer = void 0;
      var fraction = void 0;
      var mask = void 0;

      // remove the suffix
      if (thisRawValue.slice(suffixLength * -1) === SUFFIX) {
        thisRawValue = thisRawValue.slice(0, suffixLength * -1);
      }

      if (hasDecimal) {
        integer = thisRawValue.slice(thisRawValue.slice(0, prefixLength) === PREFIX ? prefixLength : 0, indexOfLastDecimal);

        fraction = thisRawValue.slice(indexOfLastDecimal + 1, rawValueLength);
        fraction = convertToMask(fraction.replace(masks.NON_DIGITS_REGEX, masks.EMPTY_STRING));
      } else if (thisRawValue.slice(0, prefixLength) === PREFIX) {
        integer = thisRawValue.slice(prefixLength);
      } else {
        integer = thisRawValue;
      }

      if (options.integerLimit && typeof options.integerLimit === 'number') {
        var thousandsSeparatorRegex = THOUSANDS === '.' ? '[.]' : '' + THOUSANDS;
        var numberOfThousandSeparators = (integer.match(new RegExp(thousandsSeparatorRegex, 'g')) || []).length;

        integer = integer.slice(0, options.integerLimit + (isNegative ? 1 : 0) + numberOfThousandSeparators * thousandsSeparatorSymbolLength);
      }

      integer = integer.replace(masks.NON_DIGITS_REGEX, masks.EMPTY_STRING);

      if (!options.allowLeadingZeroes) {
        integer = integer.replace(/^0+(0$|[^0])/, '$1');
      }

      integer = options.allowThousandsSeparator ? addThousandsSeparator(integer, THOUSANDS) : integer;

      mask = convertToMask(integer);

      if (hasDecimal && options.allowDecimal || options.requireDecimal === true) {
        if (thisRawValue[indexOfLastDecimal - 1] !== DECIMAL) {
          mask.push(masks.CARET_TRAP);
        }

        mask.push(DECIMAL, masks.CARET_TRAP);

        if (fraction) {
          if (typeof options.decimalLimit === 'number') {
            fraction = fraction.slice(0, options.decimalLimit);
          }

          mask = mask.concat(fraction);
        }

        if (options.requireDecimal === true && thisRawValue[indexOfLastDecimal - 1] === DECIMAL) {
          mask.push(masks.DIGITS_REGEX);
        }
      }

      if (prefixLength > 0) {
        mask = PREFIX.split(masks.EMPTY_STRING).concat(mask);
      }

      if (isNegative) {
        // If user is entering a negative number, add a mask placeholder spot to
        // attract the caret to it.
        // TODO: Allow the negative symbol as the suffix as well (SOHO-3259)
        if (mask.length === prefixLength) {
          mask.push(masks.DIGITS_REGEX);
        }

        mask = [/-/].concat(mask);
      }

      if (SUFFIX.length > 0) {
        mask = mask.concat(SUFFIX.split(masks.EMPTY_STRING));
      }

      return mask;
    }

    numberMask.instanceOf = 'createNumberMask';

    return numberMask(rawValue);
  };

  // Default Date Mask Options
  var DEFAULT_DATETIME_MASK_OPTIONS = {
    format: 'M/d/yyyy',
    symbols: {
      timeSeparator: ':',
      dayPeriodSeparator: ' ',
      dateSeparator: '/'
    }
  };

  // Maximum Values for various section maps of date strings.
  var DATE_MAX_VALUES = {
    dd: 31,
    d: 31,
    MMM: undefined,
    MM: 12,
    M: 12,
    yy: 99,
    yyyy: 9999,
    h: 12,
    hh: 12,
    H: 24,
    HH: 24,
    mm: 60,
    ss: 60,
    a: undefined
  };

  /**
   * Soho Date Mask Function
   * @param {string} rawValue the un-formatted value that will eventually be masked.
   * @param {object} options masking options
   * @returns {array} representing a mask that will match a formatted date.
   */
  masks.dateMask = function dateMask(rawValue, options) {
    options = utils.mergeSettings(undefined, options, DEFAULT_DATETIME_MASK_OPTIONS);

    var mask = [];
    var digitRegex = masks.DIGITS_REGEX;
    var format = options.format;
    var splitterStr = stringUtils.removeDuplicates(format.replace(/[dMyHhmsa]+/g, ''));
    var splitterRegex = new RegExp('[' + splitterStr + ']+');
    var formatArray = format.split(/[^dMyHhmsa]+/);
    var rawValueArray = rawValue.split(splitterRegex);
    var maxValue = DATE_MAX_VALUES;

    formatArray.forEach(function (part, i) {
      var value = maxValue[part];
      var size = void 0;

      if (part === 'a') {
        // Match the day period
        mask.push(/[aApP]/, /[Mm]/);
      } else if (!value) {
        mask = mask.concat(getRegexForPart(part, 'alphas'));
      } else if (rawValueArray[i]) {
        // Detect based on the size of a pre-existing formatted value, if possible.
        var rawValueStr = rawValueArray[i].toString();
        var rawValueFirstDigit = parseInt(rawValueStr.substr(0, 1), 10);
        var maxFirstDigit = parseInt(maxValue[part].toString().substr(0, 1), 10);

        if (part.length === 1 && rawValueFirstDigit > maxFirstDigit) {
          mask.push(digitRegex);
        } else if (rawValueStr !== '0' && rawValueStr.length === 1 && rawValueFirstDigit <= maxFirstDigit && rawValueArray[i + 1] !== undefined && part.toUpperCase() !== 'HH') {
          mask.push(digitRegex);
        } else {
          mask = mask.concat(getRegexForPart(value, 'digits'));
        }
      } else {
        // If NOT possible, pass back the maximum digit length that can be entered here
        size = value.toString().length;
        while (size > 0) {
          mask.push(digitRegex);
          size -= 1;
        }
      }

      // If this is not the last part, add whatever literals come after this part,
      // but before the next part.
      var nextPart = formatArray[i + 1];
      if (nextPart !== undefined) {
        var thisPartSize = part.toString().length;
        var start = format.indexOf(part) + thisPartSize;
        var end = format.indexOf(nextPart);
        var literals = format.substring(start, end).split(masks.EMPTY_STRING);

        mask = mask.concat(literals);
      }
    });

    return mask;
  };

  /**
   * Soho Range Date Mask Function
   * @param {string} rawValue the un-formatted value that will eventually be masked.
   * @param {object} options masking options
   * @returns {array} representing a mask that will match a formatted date.
   */
  masks.rangeDateMask = function (rawValue, options) {
    var parts = rawValue.split(options.delimeter);
    var delimiterArr = options.delimeter.split('');
    var firstDate = masks.dateMask(parts[0], options);
    var secondDate = [];

    if (parts[1]) {
      secondDate = masks.dateMask(parts[1], options);
    }

    return firstDate.concat(delimiterArr.concat(secondDate));
  };

  /**
   * Generates a pipe function that can be applied to a Mask API that will correct
   * shorthand numeric dates.
   * NOTE: DOES NOT WORK FOR DATES WITH ALPHABETIC CONTENT. Do not use this if your
   * dates contain "MMM" or the full month name.
   * @param {object} processResult the results object of a mask process
   * @param {object} options settings for the date pipe function
   * @returns {object} the result of the piping function's changes
   */
  masks.autocorrectedDatePipe = function autoCorrectedDatePipe(processResult, options) {
    if (!options.dateFormat) {
      options.dateFormat = Locale.calendar().dateFormat.short;
    }

    var indexesOfPipedChars = [];
    var dateFormatArray = options.dateFormat.split(/[^dMy]+/);
    var maxValue = { d: 31, M: 12, yy: 99, yyyy: 9999 };
    var minValue = { d: 1, M: 1, yy: 0, yyyy: 1 };
    var conformedValueArr = processResult.conformedValue.split('');

    // Check first digit
    dateFormatArray.forEach(function (format) {
      var position = options.dateFormat.indexOf(format);
      var maxFirstDigit = parseInt(maxValue[format].toString().substr(0, 1), 10);

      if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {
        conformedValueArr[position + 1] = conformedValueArr[position];
        conformedValueArr[position] = 0;
        indexesOfPipedChars.push(position);
      }
    });

    var placeholderRegex = new RegExp('[^' + processResult.placeholderChar + ']');
    var maskPieces = processResult.placeholder.split(placeholderRegex);
    var conformedPieces = processResult.conformedValue.split(/\D/g);

    // Check for invalid date
    var isInvalid = dateFormatArray.some(function (format, i) {
      var length = maskPieces[i].length > format.length ? maskPieces[i].length : format.length;
      var textValue = conformedPieces[i] || '';
      var value = parseInt(textValue, 10);

      return value > maxValue[format] || textValue.length === length && value < minValue[format];
    });

    if (isInvalid) {
      return false;
    }

    return {
      value: conformedValueArr.join(''),
      characterIndexes: indexesOfPipedChars
    };
  };

  /* eslint-disable no-continue, no-underscore-dangle, no-restricted-syntax, no-labels */

  /**
   * @class MaskAPI
   * @constructor
   * @param {object} [settings] incoming settings
   */
  function MaskAPI(settings) {
    this.configure(settings);
    return this;
  }

  MaskAPI.prototype = {

    /**
     * Configure the API for an incoming mask request.
     * Set up patterns, change locale, basically 'pre-render'
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    configure: function configure(settings) {
      if (!this.settings) {
        this.settings = {};
      }

      if (!settings) {
        return this;
      }

      if (settings.locale) {
        // TODO: store references to thousands sep, decimal, currency symbols,
        // etc for the specified locale.
        this.locale = settings.locale;
      }

      // Pre-define a stored Mask pattern.
      // In cases where the mask is a string (Legacy Soho Mask), the string is automatically converted
      // to an array containing regex patterns.
      // In cases where the mask is a function, the function call is stored and called when the mask
      // needs to be processed.
      if (settings.pattern) {
        if (Array.isArray(settings.pattern) || typeof settings.pattern === 'function') {
          this.pattern = settings.pattern;
        } else if (typeof settings.pattern === 'string') {
          var defs = utils.mergeSettings(undefined, settings.definitions || {}, masks.LEGACY_DEFS);
          this.pattern = this._convertPatternFromString(settings.pattern, defs);
        }
      }

      if (settings.patternOptions) {
        this.patternOptions = settings.patternOptions;
      }

      return this;
    },


    /**
     * Process a string against the masking algorithm
     * @param {string} rawValue the original, unmasked value
     * @param {object} [opts] process options
     * @returns {object} containing the processed mask along with some meta-data
     */
    process: function process(rawValue, opts) {
      if (typeof rawValue !== 'string') {
        throw new Error('No string provided');
      }

      var providedMask = void 0;
      var processResult = {
        originalValue: rawValue,
        caretPos: opts.selection.start,
        maskResult: false
      };

      // Setup the pattern if it's a function.
      if (typeof this.pattern === 'function') {
        if (!opts.patternOptions) {
          opts.patternOptions = {};
        }

        // Merge incoming settings
        var maskOpts = utils.extend({}, this.patternOptions, opts.patternOptions, {
          caretPos: opts.selection.start,
          previousMaskResult: opts.previousMaskResult
        });

        // Get a processed mask pattern from the function
        providedMask = this.pattern(rawValue, maskOpts);

        // mask functions can setup caret traps to have some control over how the caret
        // moves. We need to process the mask for any caret traps. `processCaretTraps`
        // will remove the caret traps from the mask and return the indexes of the caret traps.
        var caretTrapInfo = this._processCaretTraps(providedMask);

        // The processed mask is what we're interested in
        providedMask = caretTrapInfo.maskWithoutCaretTraps;

        // And we need to store these indexes because they're needed by `adjustCaretPosition`
        opts.caretTrapIndexes = caretTrapInfo.indexes;
      } else {
        // Use a provided array
        providedMask = this.pattern;
      }

      // As a convenience, setting the mask to false will cause it to return without processing.
      if (providedMask === false) {
        return processResult;
      }

      try {
        processResult = this._conformToMask(rawValue, providedMask, opts);
      } catch (e) {
        // console.error('Couldn\'t complete masking process: "'+ e.message +'"');
        return processResult;
      }

      // Handle the optional "pipe" cleanup method, if applicable.
      if (typeof opts.pipe === 'function') {
        var pipeResult = {};

        // `pipe` receives the entire `processResult` object and the configurations with which
        // `conformToMask` was called.
        try {
          pipeResult = opts.pipe(processResult, opts);
        } catch (e) {
          // console.error('Couldn\'t complete mask\'s pipe function: "'+ e.message +'"');
          pipeResult = false;
        }

        // `pipeResults` should be an object. But as a convenience, we allow the pipe
        // author to just return `false` to indicate rejection. Or return just a string when there
        // are no piped characters.
        // If the `pipe` returns `false` or a string, the block below turns it into an
        // object that the rest of the code can work with.
        if (pipeResult === false) {
          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`,
          // and set `rejected` to `true`.
          processResult.pipeResult = false;
          processResult.pipedValue = opts.previousMaskResult;
        } else if (utils.isString(pipeResult)) {
          processResult.pipeResult = true;
          processResult.pipedValue = pipeResult;
          processResult.pipedCharIndexes = [];
        } else {
          processResult = utils.extend({}, processResult, {
            pipeResult: pipeResult.result,
            pipedValue: pipeResult.value,
            pipedCharIndexes: pipeResult.characterIndexes
          });
        }
      }

      return processResult;
    },


    /**
     * Processes a raw string value against a masking algorithm and removes unfavorable chracters.
     * @private
     * @param {string} rawValue incoming full text string to process.
     * @param {array} mask the mask to be used for modifying the raw value.
     * @param {object} [settings] incoming settings for mask parsing.
     * @returns {object} containing the conformation result and some meta-data
     */
    _conformToMask: function _conformToMask(rawValue, mask, settings) {
      // Set default settings
      settings = utils.mergeSettings(undefined, settings, masks.DEFAULT_CONFORM_OPTIONS);

      // Setup the placeholder version of the mask
      settings.placeholder = this._convertMaskToPlaceholder(mask, settings.placeholderChar);

      // Setup booleans and numbers for various settings (speed)
      var charactersRejected = false;
      var suppressGuide = settings.guide === false && settings.previousMaskResult !== undefined;
      var rawValueLength = rawValue.length;
      var prevMaskResultLength = settings.previousMaskResult.length;
      var maskLength = this.pattern.length;
      var placeholderLength = settings.placeholder.length || 0;
      var placeholderChar = settings.placeholderChar;
      var caretPos = settings.selection.start;
      var resultStr = masks.EMPTY_STRING;

      var editDistance = rawValueLength - prevMaskResultLength;
      var isAddition = editDistance > 0;
      var indexOfFirstChange = caretPos + (isAddition ? -editDistance : 0);
      var indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);

      // If `_conformToMask()` is configured to keep character positions, that is,
      // for mask 111, previous value _2_ and raw value 3_2_, the new conformed value
      // should be 32_, not 3_2 (default behavior). That's in the case of addition.
      // And in the case of deletion, previous value _23, raw value _3, the new conformed
      // string should be __3, not _3_ (default behavior)
      //
      // The next block of logic handles keeping character positions for the case
      // of deletion. (Keeping character positions for the case of addition is further
      // down since it is handled differently.)
      // To do this, we want to compensate for all characters that were deleted
      if (settings.keepCharacterPositions === true && !isAddition) {
        // We will be storing the new placeholder characters in this variable.
        var compensatingPlaceholderChars = masks.EMPTY_STRING;

        // For every character that was deleted from a placeholder position, we add a placeholder char
        for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {
          if (settings.placeholder[i] === placeholderChar) {
            compensatingPlaceholderChars += placeholderChar;
          }
        }

        // Now we trick our algorithm by modifying the raw value to make it contain
        // additional placeholder characters. That way when the we start laying the
        // characters again on the mask, it will keep the non-deleted characters
        // in their positions.
        rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);
      }

      // Convert `rawValue` string to an array, and mark characters based on whether
      // they are newly added or have existed in the previous conformed value. Identifying new
      // and old characters is needed for `_conformToMask()` to work if it is configured
      // to keep character positions.
      function markAddedChars(char, j) {
        return {
          char: char,
          isNew: j >= indexOfFirstChange && j < indexOfLastChange
        };
      }
      var rawValueArr = rawValue.split(masks.EMPTY_STRING).map(markAddedChars);

      // The loop below removes masking characters from user input. For example, for mask
      // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below
      // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm
      // then would lay `234` on top of the available placeholder positions in the mask.
      for (var k = rawValueLength - 1; k >= 0; k--) {
        var char = rawValueArr[k];

        if (char !== settings.placeholderChar) {
          var shouldOffset = k >= indexOfFirstChange && prevMaskResultLength === maskLength;

          if (char === settings.placeholder[shouldOffset ? k - editDistance : k]) {
            rawValueArr.splice(k, 1);
          }
        }
      }

      // Loop through the placeholder string to find characters that need to be filled.
      placeholderLoop: for (var l = 0; l < placeholderLength; l++) {
        var charInPlaceholder = settings.placeholder[l];

        // We see one. Let's find out what we can put in it.
        if (charInPlaceholder === placeholderChar) {
          // But before that, do we actually have any user characters that need a place?
          if (rawValueArr.length > 0) {
            // We will keep chipping away at user input until either we run out of characters
            // or we find at least one character that we can map.
            while (rawValueArr.length > 0) {
              // Let's retrieve the first user character in the queue of characters we have left
              var rawValueChar = rawValueArr.shift();

              // If the character we got from the user input is a placeholder character (which happens
              // regularly because user input could be something like (540) 90_-____, which includes
              // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,
              // then we map this placeholder character to the current spot in the placeholder
              if (rawValueChar.char === placeholderChar && suppressGuide !== true) {
                resultStr += placeholderChar;

                // And we go to find the next placeholder character that needs filling
                continue placeholderLoop;

                // Else if, the character we got from the user input is not a placeholder, let's see
                // if the current position in the mask can accept it.
              } else if (mask[l].test(rawValueChar.char)) {
                // we map the character differently based on whether we are keeping character
                // positions or not. If any of the conditions below are met, we simply map the
                // raw value character to the placeholder position.
                if (settings.keepCharacterPositions !== true || rawValueChar.isNew === false || settings.previousMaskResult === masks.EMPTY_STRING || settings.guide === false || !isAddition) {
                  resultStr += rawValueChar.char;
                } else {
                  // We enter this block of code if we are trying to keep character positions and
                  // none of the conditions above is met. In this case, we need to see if there's
                  // an available spot for the raw value character to be mapped to. If we couldn't
                  // find a spot, we will discard the character.
                  //
                  // For example, for mask `1111`, previous conformed value `_2__`, raw value
                  // `942_2__`. We can map the `9`, to the first available placeholder position,
                  // but then, there are no more spots available for the `4` and `2`. So, we
                  // discard them and end up with a conformed value of `92__`.
                  var rawValueArrLength = rawValueArr.length;
                  var indexOfNextAvailablePlaceholderChar = null;

                  // Let's loop through the remaining raw value characters. We are looking for
                  // either a suitable spot, ie, a placeholder character or a non-suitable spot,
                  // ie, a non-placeholder character that is not new. If we see a suitable spot
                  // first, we store its position and exit the loop. If we see a non-suitable spot
                  // first, we exit the loop and our `indexOfNextAvailablePlaceholderChar`
                  // will stay as `null`.
                  for (var x = 0; x < rawValueArrLength; x++) {
                    var charData = rawValueArr[x];

                    if (charData.char !== placeholderChar && charData.isNew === false) {
                      break;
                    }

                    if (charData.char === placeholderChar) {
                      indexOfNextAvailablePlaceholderChar = x;
                      break;
                    }
                  }

                  // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the
                  // character is not blocked. We can map it. And to keep the character positions,
                  // we remove the placeholder character from the remaining characters
                  if (indexOfNextAvailablePlaceholderChar !== null) {
                    resultStr += rawValueChar.char;
                    rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);

                    // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the
                    // character is blocked. We have to discard it.
                  } else {
                    l--;
                  }
                }

                // Since we've mapped this placeholder position. We move on to the next one.
                continue placeholderLoop;
              } else {
                charactersRejected = true;
              }
            }
          }

          // We reach this point when we've mapped all the user input characters to placeholder
          // positions in the mask. In *guide* mode, we append the left over characters in the
          // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.
          //
          // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.
          if (suppressGuide === false) {
            resultStr += settings.placeholder.substr(l, placeholderLength);
          }

          // And we break
          break;

          // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it
          // with user input. So we just map it to the final output
        } else {
          resultStr += charInPlaceholder;
        }
      }

      // The following logic is needed to deal with the case of deletion in *no guide* mode.
      //
      // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder
      // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.
      // That's why the logic below finds the last filled placeholder character,
      // and removes everything from that point on.
      if (suppressGuide && isAddition === false) {
        var indexOfLastFilledPlaceholderChar = null;

        // Find the last filled placeholder position and substring from there
        for (var m = 0; m < resultStr.length; m++) {
          if (settings.placeholder[m] === placeholderChar) {
            indexOfLastFilledPlaceholderChar = m;
          }
        }

        if (indexOfLastFilledPlaceholderChar !== null) {
          // We substring from the beginning until the position after the last filled
          // placeholder char.
          resultStr = resultStr.substr(0, indexOfLastFilledPlaceholderChar + 1);
        } else {
          // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted
          // the first character in the mask. So we return an empty string.
          resultStr = masks.EMPTY_STRING;
        }
      }

      return {
        caretPos: caretPos,
        caretTrapIndexes: settings.caretTrapIndexes,
        conformedValue: resultStr,
        charactersRejected: charactersRejected,
        placeholder: settings.placeholder,
        placeholderChar: placeholderChar,
        maskResult: true
      };
    },


    /**
     * Detects Caret Traps inside of a Mask Array and identifies them with a rich object
     * @private
     * @param {array} mask the mask being checked
     * @returns {object} containing a modified Mask array without caret traps, and an array of
     *  indices with locations of the caret traps.
     */
    _processCaretTraps: function _processCaretTraps(mask) {
      var indexes = [];
      var indexOfCaretTrap = mask.indexOf(masks.CARET_TRAP);

      while (indexOfCaretTrap !== -1) {
        indexes.push(indexOfCaretTrap);
        mask.splice(indexOfCaretTrap, 1);
        indexOfCaretTrap = mask.indexOf(masks.CARET_TRAP);
      }

      return {
        maskWithoutCaretTraps: mask,
        indexes: indexes
      };
    },


    /**
     * Converts an array-based mask into a placeholder string.
     * @private
     * @param {array} mask - contains string "literal" characters and Regex matchers.
     * @param {string} placeholderChar - a character that will be used as the placeholder.
     * @returns {string} representing the placeholder
     */
    _convertMaskToPlaceholder: function _convertMaskToPlaceholder(mask, placeholderChar) {
      if (!Array.isArray(mask)) {
        mask = [];
      }
      if (!placeholderChar) {
        placeholderChar = masks.PLACEHOLDER_CHAR;
      }

      if (mask.indexOf(placeholderChar) !== -1) {
        throw new Error('' + ('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.\n\n' + 'The placeholder character that was received is:') + JSON.stringify(placeholderChar) + '\n\n' + ('The mask that was received is: ' + JSON.stringify(mask)));
      }

      var ret = mask.map(function (char) {
        return char instanceof RegExp ? placeholderChar : char;
      }).join(masks.EMPTY_STRING);

      return ret;
    },


    /**
     * Takes an index representing a caret and changes it based on mask modifications
     * @private
     * @param {object} opts information about the caret placement.
     * @returns {number} the index of the text caret.
     */
    adjustCaretPosition: function adjustCaretPosition(opts) {
      //eslint-disable-line
      if (opts.caretPos === 0) {
        return 0;
      }

      function nonPlaceholderFilter(char) {
        return char !== nonPlaceholderFilter;
      }

      // Store lengths for faster performance?
      var rawValueLength = opts.rawValue.length;
      var previousConformedValueLength = opts.previousMaskResult.length;
      var placeholderLength = opts.placeholder ? opts.placeholder.length : 0;
      var conformedValueLength = opts.conformedValue ? opts.conformedValue.length : 0;

      // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,
      // we know the user in this instance pasted two characters
      var editLength = rawValueLength - previousConformedValueLength;

      // If the edit length is positive, that means the user is adding characters, not deleting.
      var isAddition = editLength > 0;

      // This is the first raw value the user entered that needs to be conformed to mask
      var isFirstRawValue = previousConformedValueLength === 0;

      // A partial multi-character edit happens when the user makes a partial selection in their
      // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by
      // selecting the first 3 digits and pressing backspace.
      //
      // Such cases can also happen when the user presses the backspace while holding down the ALT
      // key.
      var isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;

      // This algorithm doesn't support all cases of multi-character edits, so we just return
      // the current caret position.
      //
      // This works fine for most cases.
      if (isPartialMultiCharEdit) {
        return opts.caretPos;
      }

      // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter
      // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the
      // same as the original `previousConformedValue`. We handle this case differently for caret
      // positioning.
      var possiblyHasRejectedChar = isAddition && (opts.previousMaskResult === opts.conformedValue || opts.conformedValue === opts.placeholder);

      var startingSearchIndex = 0;
      var trackRightCharacter = void 0;
      var targetChar = void 0;

      if (possiblyHasRejectedChar) {
        startingSearchIndex = opts.caretPos - editLength;
      } else {
        // At this point in the algorithm, we want to know where the caret is right
        // before the raw input has been conformed, and then see if we can find that
        // same spot in the conformed input.
        //
        // We do that by seeing what character lies immediately before the caret,
        // and then look for that same character in the conformed input and place
        // the caret there.
        //
        // First, we need to normalize the inputs so that letter capitalization between raw input and
        // conformed input wouldn't matter.
        var normalizedConformedValue = opts.conformedValue.toLowerCase();
        var normalizedRawValue = opts.rawValue.toLowerCase();

        // Then we take all characters that come before where the caret currently is.
        var leftHalfChars = normalizedRawValue.substr(0, opts.caretPos).split(masks.EMPTY_STRING);

        // Now we find all the characters in the left half that exist in the conformed
        // input. This step ensures that we don't look for a character that was filtered
        // out or rejected by `conformToMask`.
        var intersection = leftHalfChars.filter(function (char) {
          return normalizedConformedValue.indexOf(char) !== -1;
        });

        // The last character in the intersection is the character we want to
        // look for in the conformed value and the one we want to adjust the caret close to
        targetChar = intersection[intersection.length - 1];

        // Calculate the number of mask characters in the previous placeholder
        // from the start of the string up to the place where the caret is
        var previousLeftMaskChars = opts.previousPlaceholder.substr(0, intersection.length).split(masks.EMPTY_STRING).filter(nonPlaceholderFilter).length;

        // Calculate the number of mask characters in the current placeholder
        // from the start of the string up to the place where the caret is
        var leftMaskChars = opts.placeholder.substr(0, intersection.length).split(masks.EMPTY_STRING).filter(nonPlaceholderFilter).length;

        // Has the number of mask characters up to the caret changed?
        var masklengthChanged = leftMaskChars !== previousLeftMaskChars;

        // Detect if `targetChar` is a mask character and has moved to the left
        var targetIsMaskMovingLeft = opts.previousPlaceholder[intersection.length - 1] !== undefined && opts.placeholder[intersection.length - 2] !== undefined && opts.previousPlaceholder[intersection.length - 1] !== opts.placeholderChar && opts.previousPlaceholder[intersection.length - 1] !== opts.placeholder[intersection.length - 1] && //eslint-disable-line
        opts.previousPlaceholder[intersection.length - 1] === opts.placeholder[intersection.length - 2] //eslint-disable-line
        ;

        // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true
        // or the mask is moving to the left, we can't use the selected `targetChar` any longer
        // if we are not at the end of the string.
        // In this case, change tracking strategy and track the character to the right of the caret.
        if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && opts.placeholder.indexOf(targetChar) > -1 && opts.rawValue[opts.caretPos] !== undefined) {
          trackRightCharacter = true;
          targetChar = opts.rawValue[opts.caretPos];
        }

        // It is possible that `targetChar` will appear multiple times in the conformed value.
        // We need to know not to select a character that looks like our target character
        // from the placeholder or the piped characters, so we inspect the piped characters
        // and the placeholder to see if they contain characters that match our target character.

        // If the `conformedValue` got piped, we need to know which characters were piped in so
        // that when we look for our `targetChar`, we don't select a piped char by mistake.
        var pipedChars = [];
        if (opts.indexesOfPipedChars) {
          pipedChars = opts.indexesOfPipedChars.map(function (index) {
            return normalizedConformedValue[index];
          });
        }

        // We need to know how many times the `targetChar` occurs in the piped characters.
        var countTargetCharInPipedChars = pipedChars.filter(function (char) {
          return char === targetChar;
        }).length;

        // We need to know how many times it occurs in the intersection
        var countTargetCharInIntersection = intersection.filter(function (char) {
          return char === targetChar;
        }).length;

        // We need to know if the placeholder contains characters that look like
        // our `targetChar`, so we don't select one of those by mistake.
        var countTargetCharInPlaceholder = opts.placeholder.substr(0, opts.placeholder.indexOf(opts.placeholderChar)).split(masks.EMPTY_STRING).filter(function (char, index) {
          return (
            // Check if `char` is the same as our `targetChar`, so we account for it
            char === targetChar &&

            // but also make sure that both the `rawValue` and placeholder don't have the same
            // character at the same index because if they are equal, that means we are already
            // counting those characters in `countTargetCharInIntersection`
            opts.rawValue[index] !== char
          );
        }).length;

        // The number of times we need to see occurrences of the `targetChar` before we
        // know it is the one we're looking for is:
        var requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + (
        // The character to the right of the caret isn't included in `intersection`
        // so add one if we are tracking the character to the right
        trackRightCharacter ? 1 : 0);

        // Now we start looking for the location of the `targetChar`.
        // We keep looping forward and store the index in every iteration. Once we have encountered
        // enough occurrences of the target character, we break out of the loop
        // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.
        var numberOfEncounteredMatches = 0;
        for (var i = 0; i < conformedValueLength; i++) {
          var conformedValueChar = normalizedConformedValue[i];

          startingSearchIndex = i + 1;

          if (conformedValueChar === targetChar) {
            numberOfEncounteredMatches++;
          }

          if (numberOfEncounteredMatches >= requiredNumberOfMatches) {
            break;
          }
        }
      }

      // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,
      // most cases would be handled. However, we want to fast forward or rewind the caret to the
      // closest placeholder character if it happens to be in a non-editable spot.
      // That's what the next logic is for.
      //
      // In case of addition, we fast forward.
      if (isAddition) {
        // We want to remember the last placeholder character encountered so that if the mask
        // contains more characters after the last placeholder character, we don't forward the caret
        // that far to the right. Instead, we stop it at the last encountered placeholder character.
        var lastPlaceholderChar = startingSearchIndex;

        for (var j = startingSearchIndex; j <= placeholderLength; j++) {
          if (!opts.placeholder) {
            return lastPlaceholderChar;
          }

          if (opts.placeholder[j] === opts.placeholderChar) {
            lastPlaceholderChar = j;
          }

          if (
          // If we're adding, we can position the caret at the next placeholder character.
          opts.placeholder[j] === opts.placeholderChar ||

          // If a caret trap was set by a mask function, we need to stop at the trap.
          opts.caretTrapIndexes.indexOf(j) !== -1 ||

          // This is the end of the placeholder. We cannot move any further.
          // Let's put the caret there.
          j === placeholderLength) {
            return lastPlaceholderChar;
          }
        }
      } else {
        // In case of deletion, we rewind.
        if (trackRightCharacter) {
          //eslint-disable-line
          // Searching for the character that was to the right of the caret
          // We start at `startingSearchIndex` - 1 because it includes one character
          // extra to the right
          for (var k = startingSearchIndex - 1; k >= 0; k--) {
            // If tracking the character to the right of the cursor, we move to the left until
            // we found the character and then place the caret right before it

            if (
            // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just
            // to the right of the caret
            opts.conformedValue[k] === targetChar ||

            // If a caret trap was set by a mask function, we need to stop at the trap.
            opts.caretTrapIndexes.indexOf(k) !== -1 ||

            // This is the beginning of the placeholder. We cannot move any further.
            // Let's put the caret there.
            k === 0) {
              return k;
            }
          }
        } else {
          // Searching for the first placeholder or caret trap to the left

          for (var l = startingSearchIndex; l >= 0; l--) {
            // If we're deleting, we stop the caret right before the placeholder character.
            // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user
            // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret
            // right after the first `6`

            if (
            // If we're deleting, we can position the caret right before the placeholder character
            opts.placeholder[l - 1] === opts.placeholderChar ||

            // If a caret trap was set by a mask function, we need to stop at the trap.
            opts.caretTrapIndexes.indexOf(l) !== -1 ||

            // This is the beginning of the placeholder. We cannot move any further.
            // Let's put the caret there.
            l === 0) {
              return l;
            }
          }
        }
      }
    },


    /**
     * Converts the legacy Soho Mask pattern format from a string into an array.
     * If character is a defined pattern matcher, the corresponding item at the
     * array index is converted to its regex form.
     * @private
     * @param {string} pattern a legacy Soho Mask Pattern
     * @param {object} [defs] mask conversion definitions
     * @returns {array} contains string "literal" characters and Regex matchers
     */
    _convertPatternFromString: function _convertPatternFromString(pattern, defs) {
      var arr = [];
      var legacyKeys = Object.keys(defs);

      function getRegex(char) {
        var idx = legacyKeys.indexOf(char);

        if (idx > -1) {
          char = defs[legacyKeys[idx]];
        }
        return char;
      }

      for (var i = 0; i < pattern.length; i++) {
        arr.push(getRegex(pattern[i]));
      }

      // TODO: Attach an object here that contains an analysis of the original mask
      // that can be used to configure the new API accordingly.

      return arr;
    }
  };

  /* eslint-disable no-underscore-dangle, new-cap */

  // The name of this component
  var COMPONENT_NAME$7 = 'mask';

  /**
   * Component Wrapper for input elements that gives them the ability to become "masked".
   * @class MaskInput
   * @constructor
   * @param {HTMLInputElement} element regular HTML Input Element (not wrapped with jQuery)
   * @param {MaskInputOptions} [settings] incoming settings
   *
   * @param {object} [settings.definitions=false] if defined, passes additional string-based pattern match "types".
   * @param {boolean} [settings.guide=false] if true, causes a guide to show inside the input field, represented by the placeholder,
   *  that demonstrates how the mask can be filled in.
   * @param {boolean} [settings.keepCharacterPositions=false] if defined alongside of `settings.guide`, will allow indiviual characters
   *  to be removed from the mask without moving the positions of other characters that have been written into the field.
   *  Works well with things like credit card or phone numbers, which have sections that are separate from each other.
   * @param {array|function|string} [settings.pattern] the pattern that is used by the mask for determining input to keep or throw out.
   *  Arrays of strings representing individual characters, and regex matching individual characters, is the perferred way of supplying a pattern.
   *  For some `settings.process` types (date/time/number), a function that dynamically generates a mask is automatically used.
   *  It's also possible to define a custom mask function and supply it here. The legacy string style is also supported.
   * @param {object} [settings.patternOptions] If using a function to define `settings.pattern`, any options that must be passed
   *  to the masking function can be supplied in this object.
   * @param {string} [settings.patternOptions.format] [date/time masks only] contains a basic date format string that will be used to properly display a date mask.
   * @param {string} [settings.patternOptions.prefix] [number masks only] will be automatically prepended to the beginning of the masked value, but will not be counted as part of the masked value.
   * @param {string} [settings.patternOptions.suffix] [number masks only] will be automatically appended to the end of the masked value, but will not be counted as part of the masked value.
   * @param {boolean} [settings.patternOptions.allowThousandsSeparator] [number masks only] If true, displays a localized thousands separator in the masked value
   * @param {object} [settings.patternOptions.symbols] [number masks only] contains default, localized special characters used in numbers
   * @param {string} [settings.patternOptions.symbols.currency] [number masks only]
   * @param {string} [settings.patternOptions.symbols.decimal] [number masks only]
   * @param {string} [settings.patternOptions.symbols.negative] [number masks only]
   * @param {string} [settings.patternOptions.symbols.thousands] [number masks only]
   * @param {boolean} [settings.patternOptions.allowDecimal] [number masks only] allows the entry of a decimal point into a number mask with a decimal limit defined (negated when using `requireDecimal` to force its placement)
   * @param {boolean} [settings.patternOptions.requireDecimal] [number masks only] forces the placement of a decimal point in a number mask with a decimal limit defined.
   * @param {number} [settings.patternOptions.decimalLimit] [number masks only] defines the number of characters allowed after the decimal point.
   * @param {number} [settings.patternOptions.integerLimit] [number masks only] defines the number of characters allowed before the decimal point.
   * @param {boolean} [settings.patternOptions.allowNegative] [number masks only] allows a number to be negative (adds/retains a "minus" symbol at the beginning of the value)
   * @param {boolean} [settings.patternOptions.allowLeadingZeroes] [number masks only] allows a zero be placed before a decimal or other numbers.
   * @param {string} [settings.placeholderChar='_'] If using the `settings.guide`, will be used as the placeholder
   *  for characters that are not yet typed.
   * @param {function} [settings.pipe] provides a way of adjusting the masked content, caret position,
   *  etc after the input field has been processed by the mask API.
   * @param {string} [settings.process=undefined] can be defined as a quick way to create certain complex masks.  Defaults to the regular pattern mask,
   *  but can automatically configure the field for "date", "time", and "number"
   * @param {boolean} [settings.processOnBlur=true] if defined, causes the mask API to process this input field whenever it becomes blurred.
   * @param {boolean} [settings.processOnInitialize=true] if defined, causes the mask API to process this input field when the component is initialized.
   * @returns {MaskInput} component instance
   */
  var DEFAULT_MASK_INPUT_OPTIONS = {
    definitions: undefined,
    guide: false,
    maskAPI: MaskAPI,
    keepCharacterPositions: false,
    pattern: undefined,
    patternOptions: undefined,
    placeholderChar: '_',
    pipe: undefined,
    process: undefined,
    processOnBlur: true,
    processOnInitialize: true
  };

  function MaskInput(element, settings) {
    this.element = element;

    if (!settings) {
      settings = {};
    }

    return this.init(settings);
  }

  MaskInput.prototype = {

    /**
     * Initialization/things that need to be called on `updated()` in addition to initialization
     * @private
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    init: function init(settings) {
      // Define internal settings
      if (!this.settings) {
        this.settings = utils.mergeSettings(this.element, settings, DEFAULT_MASK_INPUT_OPTIONS);
      } else {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }
      if (!this.settings.patternOptions) {
        this.settings.patternOptions = {};
      }

      // TODO: Deprecate legacy settings in v4.4.0, remove in v4.5.0
      this._replaceLegacySettings();

      var styleClasses = ['is-number-mask'];

      // If the 'process' setting is defined, connect a pre-defined Soho Mask/Pattern
      if (typeof this.settings.process === 'string') {
        switch (this.settings.process) {
          case 'number':
            {
              this.settings.pattern = masks.numberMask;
              this.element.classList.add('is-number-mask');
              break;
            }
          case 'date':
            {
              // Check for an instance of a Datepicker/Timepicker Component, and grab the date format
              var datepicker = $(this.element).data('datepicker');
              if ($.fn.datepicker && $(this.element).data('datepicker')) {
                if (!this.settings.patternOptions && !this.settings.patternOptions.format) {
                  this.settings.patternOptions.format = datepicker.settings.dateFormat;
                }
              }
              this.settings.pattern = masks.dateMask;
              break;
            }
          case 'rangeDate':
            {
              var _datepicker = $(this.element).data('datepicker');
              if ($.fn.datepicker && $(this.element).data('datepicker')) {
                this.settings.patternOptions.format = _datepicker.settings.dateFormat;
              }
              this.settings.pattern = masks.rangeDateMask;
              break;
            }
          default:
            {
              this.element.classList.remove(styleClasses.join(' '));
              break;
            }
        }
      }

      this.mask = new this.settings.maskAPI(this.settings);
      this.state = {
        previousMaskResult: ''
      };

      this.handleEvents();

      if (this.settings.processOnInitialize) {
        this.process();
      }

      return this;
    },


    /**
     * Sets up events
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      // Store an initial value on focus
      this.focusEventHandler = function () {
        self.state.initialValue = self.element.value;
      };
      this.element.addEventListener('focus', this.focusEventHandler);

      // Handle all masking on the `input` event
      this.inputEventHandler = function () {
        return self.process();
      };
      this.element.addEventListener('input', this.inputEventHandler);

      // Remove an initial value from the state object on blur
      this.blurEventHandler = function (e) {
        // Handle mask processing on blur, if settings allow.  Otherwise, return out.
        if (self.settings.processOnBlur) {
          if (self.element.readOnly) {
            e.preventDefault();
            return false;
          }

          // in IE11 or Edge, change event doesn't fire for some unknown reason.
          // Added this for backwards compatility with this OS/Browser combo.
          // See http://jira.infor.com/browse/SOHO-6895
          if (self._hasChangedValue() && self._isEdgeIE()) {
            $(self.element).trigger('change');
          }
        }

        delete self.state.initialValue;
        return self.process();
      };
      this.element.addEventListener('blur', this.blurEventHandler);

      return this;
    },


    /**
     * Main Process for conforming a mask against the API.
     * @returns {boolean} whether or not the mask process was successful
     */
    process: function process() {
      // If no pattern's defined, act as if no mask component is present.
      if (!this.settings.pattern) {
        return true;
      }

      // Get a reference to the desired Mask API (by default, the one setup
      // during Soho initialization).
      var api = this.mask;
      if (!api.pattern) {
        api.configure({
          pattern: this.settings.pattern,
          patternOptions: this.settings.patternOptions
        });
      }

      // Get all necessary bits of data from the input field.
      var rawValue = this.element.value;

      // Don't continue if there was no change to the input field's value
      if (rawValue === this.state.previousMaskResult) {
        return false;
      }

      var posBegin = this.element.selectionStart;
      var posEnd = this.element.selectionEnd;

      // On Android, the first character inserted into a field is automatically
      // selected when it shouldn't be. This snippet fixes that problem.
      if (this._isAndroid() && this.state.previousMaskResult === '' && posBegin !== posEnd) {
        utils.safeSetSelection(rawValue.length, rawValue.length);
        posBegin = rawValue.length;
        posEnd = rawValue.length;
      }

      // Attempt to make the raw value safe to use.  If it's not in a viable format
      // this will throw an error.
      rawValue = this._getSafeRawValue(rawValue);

      var opts = {
        guide: this.settings.guide,
        keepCharacterPositions: this.settings.keepCharacterPositions,
        patternOptions: this.settings.patternOptions,
        placeholderChar: this.settings.placeholderChar,
        previousMaskResult: this.state.previousMaskResult,
        selection: {
          start: posBegin,
          end: posEnd
        }
      };

      if (posBegin !== posEnd) {
        opts.selection.contents = rawValue.substring(posBegin, posEnd);
      }
      if (typeof this.settings.pipe === 'function') {
        opts.pipe = this.settings.pipe;
      }

      // Perform the mask processing.
      var processed = api.process(rawValue, opts);
      if (!processed.maskResult) {
        // Error during masking.  Simply return out and don't mask this field.
        return processed.maskResult;
      }

      // Use the piped value, if applicable.
      var finalValue = processed.pipedValue ? processed.pipedValue : processed.conformedValue;
      var patternOptions = this.settings.patternOptions;
      if (finalValue !== '' && patternOptions && patternOptions.suffix && finalValue.indexOf(patternOptions.suffix) < 0) {
        finalValue += this.settings.patternOptions.suffix;
      }

      // Setup values for getting corrected caret position
      // TODO: Improve this by eliminating the need for an extra settings object.
      var adjustCaretOpts = {
        previousMaskResult: this.state.previousMaskResult || '',
        previousPlaceholder: this.state.previousPlaceholder || '',
        conformedValue: finalValue,
        placeholder: processed.placeholder,
        rawValue: rawValue,
        caretPos: processed.caretPos,
        placeholderChar: this.settings.placeholderChar
      };
      if (processed.pipedCharIndexes) {
        adjustCaretOpts.indexesOfPipedChars = processed.pipedCharIndexes;
      }
      if (processed.caretTrapIndexes) {
        adjustCaretOpts.caretTrapIndexes = processed.caretTrapIndexes;
      }

      // Get a corrected caret position.
      processed.caretPos = api.adjustCaretPosition(adjustCaretOpts);

      var previousValue = this.state.previousMaskResult;

      // Set the internal component state
      this.state.previousMaskResult = finalValue;
      this.state.previousPlaceholder = processed.placeholder;

      // Set state of the input field
      this.element.value = finalValue;
      utils.safeSetSelection(this.element, processed.caretPos);

      // Return out if there was no visible change in the conformed result
      // (causes state not to change, events not to fire)
      if (previousValue !== finalValue) {
        return false;
      }

      /**
       * Fire the 'write' event
       * @event write
       * @memberof MaskInput
       * @param {jQuery.Event} e the event object
       * @param {string} finalValue the final, masked value
       */
      $(this.element).trigger('write.mask', [finalValue]);

      // return event handler true/false
      return processed.maskResult;
    },


    /**
     * Obfuscates the operating system/browser check from Soho.env into internal methods
     * NOTE: Helps compartmentalize us from using calls to global "Soho" object until we can
     * properly setup import/export for unit tests.
     * TODO: deprecate eventually (v4.4.0?)
     * @private
     * @returns {boolean} whether or not the current device is running the Android OS.
     */
    _isAndroid: function _isAndroid() {
      var os = Environment && Environment.os && Environment.os.name ? Environment.os.name : '';
      return os === 'android';
    },


    /**
     * Determine if browser is IE11 or Edge
     * @private
     * @returns {boolean} whether or not the current device is running Windows 7
     *  using the IE11 browser.
     */
    _isEdgeIE: function _isEdgeIE() {
      var browser = Environment && Environment.browser && Environment.browser.name ? Environment.browser.name : '';
      return browser === 'ie' || browser === 'edge';
    },


    /**
     * Checks the current value of this masked input against it's stored "previousMaskResult"
     *  state to see if the value changed.
     * @private
     * @returns {boolean} whether or not the previous mask state matches the current one.
     */
    _hasChangedValue: function _hasChangedValue() {
      if (!this.state || !this.state.previousMaskResult) {
        return true;
      }

      return this.state.previousMaskResult !== this.state.initialValue;
    },


    /**
     * Gets the safe raw value of an input field
     * @private
     * @param {?} inputValue the original value that came from an input field or other source
     * @returns {string} the string-ified version of the original value
     */
    _getSafeRawValue: function getSafeRawValue(inputValue) {
      if (utils.isString(inputValue)) {
        return inputValue;
      } else if (utils.isNumber(inputValue)) {
        return String(inputValue);
      } else if (inputValue === undefined || inputValue === null) {
        return '';
      }
      throw new Error('' + ('The "value" provided to the Masked Input needs to be a string or a number. The value ' + 'received was:\n\n') + JSON.stringify(inputValue));
    },

    /**
     * Changes a bunch of "legacy" setting definitions into more apt names.  Additionally handles
     * the old data-attribute system that is still occasionally used.
     * @private
     * @returns {void}
     */
    _replaceLegacySettings: function _replaceLegacySettings() {
      var modes = ['group', 'number', 'date', 'time'];

      // pre-set a bunch of objects if they don't already exist
      this.settings.patternOptions = this.settings.patternOptions || {};
      this.settings.patternOptions.symbols = this.settings.patternOptions.symbols || {};

      //= =====================================
      // Deprecated as of v4.3.2
      //= =====================================
      // Order of operations when choosing pattern strings:
      // HTML5 'data-mask' attribute > Generic pattern string based on "type" attribute > nothing.
      //
      // if no pattern is provided in settings, use a pre-determined pattern based
      // on element type, or grab the pattern from the element itself.
      var html5DataMask = this.element.getAttribute('data-mask') || false;
      if (typeof html5DataMask === 'string' && html5DataMask.length) {
        this.settings.pattern = html5DataMask;
      }

      // If a "mode" is defined, special formatting rules may apply to this mask.
      // Otherwise, the standard single-character pattern match will take place.
      var html5DataMaskMode = this.element.getAttribute('data-mask-mode') || false;
      if (html5DataMaskMode && modes.indexOf(html5DataMaskMode) > -1) {
        this.settings.mode = html5DataMaskMode;
      }

      // map deprecated "mode" setting to "process".  Triggers additional settings in
      // some cases.
      if (this.settings.mode) {
        if (modes.indexOf(this.settings.mode) === -1) {
          delete this.settings.mode;
        }

        if (this.settings.mode === 'group') {
          this.settings.process = undefined;
        } else if (this.settings.mode === 'date') {
          this.settings.process = 'date';
        } else {
          this.settings.process = this.settings.mode;
        }

        delete this.settings.mode;
      }

      if (this.settings.process === 'number') {
        // map deprecated "thousandsSeparator" to "patternOptions.allowThousandsSeparator"
        if (this.settings.thousandsSeparator) {
          this.settings.patternOptions.allowThousandsSeparator = this.settings.thousandsSeparator;
          delete this.settings.thousandsSeparator;
        }

        // If "thousands" is defined, the thousands separator for numbers (comma or decimal, based on
        // localization) will be inserted wherever necessary during typing. Will automatically set to
        // "true" if the localized thousands separator is detected inside the mask.
        var html5DataThousands = this.element.getAttribute('data-thousands') || false;
        if (html5DataThousands) {
          this.settings.patternOptions.allowThousandsSeparator = html5DataThousands === 'true';
        }

        if (typeof this.settings.pattern === 'string') {
          // If "negative" is defined, you can type the negative symbol in front of the number.
          // Will automatically set to "true" if a negative symbol is detected inside the mask.
          var allowNegative = this.settings.pattern.indexOf('-') !== -1;
          if (allowNegative) {
            this.settings.patternOptions.allowNegative = allowNegative;
            this.settings.patternOptions.symbols.negative = '-';
          }

          // Detect the thousands separator and see if we use it.
          var group = Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',';
          var thousandsSep = this.settings.patternOptions && this.settings.patternOptions.symbols && this.settings.patternOptions.symbols.thousands ? this.settings.patternOptions.symbols.thousands : group;

          var hasThousandsInPattern = this.settings.pattern.indexOf(thousandsSep) !== -1;
          this.settings.patternOptions.allowThousandsSeparator = hasThousandsInPattern;
          if (hasThousandsInPattern) {
            this.settings.patternOptions.symbols.thousands = thousandsSep;
          }

          // The new masking algorithm requires an "integerLimit" defined to function.
          // This grabs the number of items currently inside this part of the mask, and sets it.
          var decimal = typeof this.settings.patternOptions.symbols.decimal === 'string' ? this.settings.patternOptions.symbols.decimal : '.';
          var decimalParts = this.settings.pattern.split(decimal);

          this.settings.patternOptions.integerLimit = decimalParts[0].replace(/[^#0]/g, '').length;

          if (decimalParts[1]) {
            this.settings.patternOptions.allowDecimal = true;
            this.settings.patternOptions.decimalLimit = decimalParts[1].toString().replace(/[^#0]/g, '').length;
            if (!this.settings.patternOptions.symbols.decimal) {
              this.settings.patternOptions.symbols.decimal = decimal;
            }
          }
        }
      }

      // If 'mustComplete' is defined, you MUST complete the full mask, or the mask
      // will revert to empty once the field is blurred.
      var html5DataMustComplete = this.element.getAttribute('data-must-complete') || false;
      if (html5DataMustComplete) {
        this.settings.mustComplete = html5DataMustComplete;
      }

      // Backwards compat with the old "data-show-currency"
      var html5DataCurrency = this.element.getAttribute('data-show-currency');
      if (html5DataCurrency) {
        this.settings.showSymbol = 'currency';
      }

      // Handle the currency/percent symbols automatically
      var symbolSetting = this.settings.showSymbol;
      var symbolTypes = ['currency', 'percent'];
      var symbol = void 0;

      if (symbolTypes.indexOf(symbolSetting) > -1) {
        symbol = function (s) {
          if (s === 'currency') {
            return {
              char: Locale.currentLocale.data.currencySign,
              format: Locale.currentLocale.data.currencyFormat
            };
          }
          if (s === 'percent') {
            return {
              char: Locale.currentLocale.data.numbers.percentSign,
              format: Locale.currentLocale.data.numbers.percentFormat
            };
          }
          return {};
        }(this.settings.showSymbol);

        // derive the location of the symbol
        var detectableSymbol = symbolSetting === 'currency' ? '' : symbol.char;
        var symbolRegex = new RegExp(detectableSymbol, 'g');
        var match = symbolRegex.exec(symbol.format);
        var replacementRegex = void 0;
        var symbolWithWhitespace = void 0;
        var index = -1;
        var placementType = void 0;

        if (match && match.length) {
          index = symbol.format.indexOf(match[0]);
          if (index === 0) {
            placementType = 'prefix';
            replacementRegex = new RegExp('[^' + detectableSymbol + ']\\S', 'g');
            symbolWithWhitespace = symbol.format.replace(replacementRegex, '');
          } else if (index > 0) {
            placementType = 'suffix';
            replacementRegex = new RegExp('\\S[^' + detectableSymbol + ']', 'g');

            while (/\s/.test(symbol.format.charAt(index - 1))) {
              --index;
            }
            symbolWithWhitespace = symbol.format.substr(index).replace(replacementRegex, '');
          }

          if (symbolSetting === 'currency') {
            symbolWithWhitespace = symbolWithWhitespace.replace('', symbol.char);
          }
          this.settings.patternOptions[placementType] = symbolWithWhitespace;
        }
      }
    },


    /**
     * Updates the component instance with new settings.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      return this.teardown().init(settings);
    },


    /**
     * Tears down the current component instance
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.element.removeEventListener('focus', this.focusEventHandler);
      delete this.focusEventHandler;

      this.element.removeEventListener('input', this.inputEventHandler);
      delete this.inputEventHandler;

      if (this.blurEventHandler) {
        this.element.removeEventListener('blur', this.blurEventHandler);
        delete this.blurEventHandler;
      }

      return this;
    }
  };

  /**
   * Wrap Mask as a jQuery component, and attach the factory function to $.fn
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements to be acted on.
   */
  $.fn.maskinput = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$7);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$7, new MaskInput(this, settings));
        instance.destroy = function () {
          this.teardown();
          $.removeData(this.element, COMPONENT_NAME$7);
        };
      }
    });
  };

  /**
   * Backwards Compatibility with the old Mask
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements to be acted on.
   */
  $.fn.maskedinput = $.fn.maskinput;
  $.fn.mask = $.fn.maskinput;

  // Component Name
  var COMPONENT_NAME$8 = 'popupmenu';

  /**
   * Responsive Popup Menu Control aka Context Menu when doing a right click action.
   * @class PopupMenu
   * @param {jquery[]|htmlelement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.menu]  Menu's ID Selector, or a jQuery object representing a menu.
   * @param {string} [settings.trigger='click']  Action on which to trigger a menu can be: click, rightClick, immediate ect.
   * @param {boolean} [settings.autoFocus=true]  If false the focus will not focus the first list element. (At the cost of accessibility).
   * @param {boolean} [settings.mouseFocus=true]  If false the focus will not highlight the first list element. (At the cost of accessibility).
   * @param {boolean} [settings.attachToBody=false]  If true the menu will be moved out to the body. To be used in certin overflow situations.
   * @param {function} [settings.beforeOpen]  Callback that can be used for populating the contents of the menu.
   * @param {string} [settings.ariaListbox=false]   Switches aria to use listbox construct instead of menu construct (internal).
   * @param {string} [settings.eventObj]  Can pass in the event object so you can do a right click with immediate.
   * @param {string} [settings.triggerSelect]  If false select event will not be triggered.
   * @param {string} [settings.removeOnDestroy] Dispose of the menu from the DOM on destroy
   * @param {string} [settings.showArrow]  If true you can explicitly set an arrow on the menu.
   * @param {boolean|function} [settings.returnFocus]  If set to false, focus will not be
    returned to the calling element. Can also be defined as a callback that can determine how
    to return focus.  It usually should be for accessibility purposes.
   * @param {object} [settings.placementOpts=new PlacementObject({
     containerOffsetX: 10,
     containerOffsetY: 10,
     strategies: ['flip', 'shrink']
  })] Gets passed to this control's Place behavior.
   * @param {object} [settings.offset={x: 0, y: 0}] Can tweak the menu position in the x and y direction. Takes an object of form: `{x: 0, y: 0}`.
   * @param {jQuery[]} [settings.predefined=$()] containing references to menu items that should be passed to the "predefined" hash.
   */

  var POPUPMENU_DEFAULTS = {
    menu: null,
    trigger: 'click',
    autoFocus: true,
    mouseFocus: true,
    attachToBody: false,
    removeOnDestroy: false,
    beforeOpen: null,
    ariaListbox: false,
    eventObj: undefined,
    returnFocus: true,
    showArrow: null,
    triggerSelect: true,
    placementOpts: new PlacementObject({
      containerOffsetX: 10,
      containerOffsetY: 10,
      strategies: ['flip', 'shrink']
    }),
    offset: {
      x: 0,
      y: 0
    },
    predefined: $(),
    duplicateMenu: null
  };

  function PopupMenu(element, settings) {
    this.settings = utils.mergeSettings(element, settings, POPUPMENU_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  PopupMenu.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup();
      this.addMarkup();
      this.handleEvents();
      this.iconFilteringSetup();

      // Allow for an external click event to be passed in from outside this code.
      // This event can be used to pass clientX/clientY coordinates for mouse cursor positioning.
      if (this.settings.trigger === 'immediate') {
        this.open(this.settings.eventObj);
      }

      // Use some css rules on submenu parents
      if (this.menu.find('.submenu').length) {
        this.menu.addClass('has-submenu');
      }
    },


    /**
     * Checks whether or not Right-To-Left reading mode is active.
     * @private
     * @returns {boolean} whether or not the reading/writing direction is RTL
     */
    isRTL: function isRTL() {
      return Environment.rtl;
    },


    /**
     * @returns {boolean} whether or not the popupmenu is currently open
     */
    get isOpen() {
      return DOM.hasClass(this.element[0], 'is-open');
    },

    /**
     * @private
     * @returns {void}
     */
    setup: function setup() {
      if (this.element.attr('data-popupmenu') && !this.settings.menu) {
        this.settings.menu = this.element.attr('data-popupmenu').replace(/#/g, '');
      }
      // Backwards compatibility for "menuId" menu options coming from other controls
      // that utilize the Popupmenu.
      if (this.settings.menuId) {
        this.settings.menu = this.settings.menuId;
        this.settings.menuId = undefined;
      }

      // keep track of how many popupmenus there are with an ID.
      // Used for managing events that are bound to $(document)
      if (!this.id) {
        this.id = (parseInt($('.popupmenu-wrapper').length, 10) + 1).toString();
      }

      // Set a reference collection for containing "pre-defined" menu items that should never
      // be replaced during an AJAX call.
      this.predefinedItems = $().add(this.settings.predefined);
    },


    /**
     * Add markip including Aria
     * @private
     * @returns {void}
     */
    addMarkup: function addMarkup() {
      var id = void 0;
      var duplicateMenu = void 0;
      var triggerId = void 0;

      switch (_typeof(this.settings.menu)) {
        case 'string':
          // ID Selector
          id = this.settings.menu;
          this.menu = $('#' + this.settings.menu);

          // duplicate menu if shared by multiple triggers
          if (this.settings.duplicateMenu && this.settings.attachToBody && this.menu.parent().not('body').length > 0) {
            this.menu.data('trigger', this.element);
            triggerId = this.menu.data('trigger')[0].id;
            duplicateMenu = this.menu.clone();
            duplicateMenu.detach().appendTo('body');

            // add data-id attr to menus
            duplicateMenu.attr('data-trigger', triggerId);
            this.menu.attr('data-trigger', triggerId);
          }
          break;
        case 'object':
          // jQuery Object
          if (this.settings.menu === null) {
            this.menu = this.element.next('.popupmenu, .popupmenu-wrapper');
          } else {
            this.menu = $(this.settings.menu);
          }

          id = this.menu.attr('id');
          if (!id || id === '') {
            this.menu.attr('id', 'popupmenu-' + this.id);
            id = this.menu.attr('id');
          }
          break;
        default:
          break;
      }

      // If markup already exists for the wrapper, use that instead of rebuilding.
      if (this.menu.is('.popupmenu-wrapper')) {
        this.preExistingWrapper = true;
        this.wrapper = this.menu;
        this.menu = this.wrapper.children('.popupmenu').first();
      }

      // Similar check as above, assuming the menu wasn't a popupmenu wrapper.
      if (this.menu.parent().is('.popupmenu-wrapper')) {
        this.preExistingWrapper = true;
        this.wrapper = this.menu.parent();
      }

      // If we still don't have a menu reference at this point, fail gracefully by returning out
      // and simply acting like a button.
      if (this.menu.length === 0) {
        return;
      }

      // if the menu is deeply rooted inside the markup, detach it and append it to the <body> tag
      // to prevent containment issues. (Now a Preference)
      if (this.settings.attachToBody && this.menu.parent().not('body').length > 0) {
        this.originalParent = this.menu.prev();
        this.menu.detach().appendTo('body');
        if (this.settings.duplicateMenu) {
          this.menu.attr('id', this.settings.menu + '-original');
        }
      }

      if (!this.menu.is('.popupmenu')) {
        this.menu.addClass('popupmenu').attr('role', this.settings.ariaListbox ? 'listbox' : 'menu');
      }

      // Always store a reference to the trigger element under jQuery data.
      this.menu.data('trigger', this.element);

      this.wrapper = this.menu.parent('.popupmenu-wrapper');
      if (!this.wrapper.length) {
        this.wrapper = this.menu.wrap('<div class="popupmenu-wrapper"></div>');
      }

      // Invoke all icons as icons
      this.wrapper.find('svg').each(function () {
        if (!$(this).data('icon')) {
          $(this).icon();
        }
      });

      // Enforce Correct Modality
      this.menu.parent('.popupmenu-wrapper').attr('role', 'application').attr('aria-hidden', 'true');

      // Use "absolute" positioning on the menu insead of "fixed", only when the
      // menu lives <body> tag and we have a <body> element that is tall enough to
      // scroll and is allowed to scroll.
      function scrollableFilter() {
        var c = this ? this.style.overflow : null;
        return c !== 'auto' && c !== 'visible' && c !== 'scroll';
      }
      if (this.wrapper.parents().filter(scrollableFilter).length === 0) {
        this.wrapper[0].style.position = 'absolute';
      }

      // Wrap submenu ULs in a 'wrapper' to help break it out of overflow.
      this.menu.find('.popupmenu').each(function (i, elem) {
        var popup = $(elem);

        if (!popup.parent().hasClass('wrapper')) {
          popup.wrap('<div class="wrapper"></div>');
        }
      });

      // If the trigger element is a button with no border append arrow markup
      var containerClass = this.element.parent().attr('class');
      if (this.element.hasClass('btn-menu') || this.element.hasClass('btn-actions') || this.element.hasClass('btn-icon') && this.element.find('use').attr('xlink:href') === '#icon-more' || this.settings.menu === 'colorpicker-menu' || this.element.closest('.toolbar').length > 0 || this.element.closest('.masthead').length > 0 || this.element.is('.searchfield-category-button') || containerClass && containerClass.indexOf('more') >= 0 || containerClass && containerClass.indexOf('btn-group') >= 0 || this.settings.showArrow) {
        var arrow = $('<div class="arrow"></div>');
        var wrapper = this.menu.parent('.popupmenu-wrapper');

        wrapper.addClass('bottom').append(arrow);
      }

      // If inside of a ".field-short" container, make smaller
      var addFieldShort = this.element.closest('.field-short').length;
      this.menu[addFieldShort ? 'addClass' : 'removeClass']('popupmenu-short');

      // If button is part of a header/masthead or a container using the "alternate"
      // UI color, add the "alternate" class.
      if (containerClass !== undefined && this.element.closest('.masthead').not('.search-results .masthead').length > 0) {
        this.menu.parent('.popupmenu-wrapper').addClass('inverse');
      }

      this.element.attr('aria-haspopup', true);
      this.element.attr('aria-controls', id);

      this.markupItems();

      // Unhide the menu markup, if hidden
      if (this.menu.is('.hidden')) {
        this.menu.removeClass('hidden');
      }
    },


    /**
     * Renders a menu item in the UI.
     * @private
     * @param {object|object[]} settings JSON-friendly object that represents a popupmenu item, or array of items.
     * @param {string} [settings.id] adds an ID to the item's anchor tag
     * @param {boolean} [settings.separator=false] causes this menu item to be a separator (overrides everything else)
     * @param {string} [settings.heading=""] Produces a heading element after a separator with text content.
     * @param {string} [settings.nextSectionSelect] can be null, "single", or "multiple"
     * @param {string} settings.text contains the text that will be displayed.
     * @param {string|null} [settings.icon=null] applies an icon to the menu item
     * @param {string|null} [settings.selectable] can be null, "single", or "multiple"
     * @param {boolean} [settings.disabled=false] causes the item to be disabled.
     * @param {object[]} [settings.submenu] array of settings object contstructed just like this one, that represent submenu items.
     * @param {boolean} [settings.noMenuWrap=false] if true, causes multiple top-level menu items not to be wrapped by a `<ul class="popupmenu"></ul>`
     * @returns {string} HTML representing a Popupmenu item with the settings passed.
     */
    renderItem: function renderItem(settings) {
      if (settings === undefined) {
        return '';
      }

      var self = this;
      function wrapMenuItems(settingsArr) {
        var items = '';
        settingsArr.forEach(function (menuObj) {
          items += self.renderItem(menuObj);
        });
        return items;
      }

      // Top-level arrays run this method on each sub-item.
      if (Array.isArray(settings)) {
        var items = wrapMenuItems(settings);
        var template = '<ul class="popupmenu">' + items + '</ul>';
        return stringUtils.stripWhitespace(template);
      }

      var headingText = '';
      var sectionSelectClass = '';

      // separators get rendered out first
      if (settings.separator !== undefined) {
        if (settings.heading) {
          headingText += '<li class="heading">' + settings.heading + '</li>';
        }
        if (settings.nextSectionSelect === 'single' || settings.nextSectionSelect === 'multiple') {
          sectionSelectClass = ' ' + settings.nextSectionSelect;
        }

        return stringUtils.stripWhitespace('\n        <li class="separator' + sectionSelectClass + '"></li>\n        ' + headingText + '\n      ');
      }

      // Top-level Menus can have settings.
      // Handle an object-based settings with a `menu` definition here
      if (settings.menu) {
        var menuId = '';
        if (settings.menuId) {
          menuId = ' id="' + settings.menuId + '"';
        }

        var iconsClass = '';
        if (settings.hasIcons) {
          iconsClass += ' has-icons';
        }

        var _items = '';
        if (Array.isArray(settings.menu)) {
          _items = wrapMenuItems(settings.menu);
        }

        if (settings.noMenuWrap) {
          return _items;
        }

        return stringUtils.stripWhitespace('\n        <ul' + menuId + ' class="popupmenu' + iconsClass + '">\n          ' + _items + '\n        </ul>\n      ');
      }

      var disabledClass = '';
      var hiddenClass = '';
      var icon = '';
      var id = '';
      var selectableClass = '';
      var submenuClass = '';
      var submenu = '';
      var ddicon = '';

      if (settings.disabled) {
        disabledClass += ' is-disabled';
      }

      if (settings.visible === false) {
        hiddenClass += ' hidden';
      }

      if (settings.id) {
        id = ' id="' + settings.id + '"';
      }

      if (settings.selectable === 'single') {
        selectableClass += ' is-selectable';
      }

      if (settings.selectable === 'multiple') {
        selectableClass += ' is-multiselectable';
      }

      if (settings.icon) {
        icon = '<svg class="icon" focusable="false" aria-hidden="true" role="presentation">\n        <use xlink:href="#icon-' + settings.icon + '"></use>\n      </svg>';
      }

      if (Array.isArray(settings.submenu)) {
        submenuClass += ' submenu';
        submenu += this.renderItem(settings.submenu);
        ddicon += '<svg class="arrow icon-dropdown icon" focusable="false" aria-hidden="true" role="presentation">\n        <use xlink:href="#icon-dropdown"></use>\n      </svg>';
      }

      return stringUtils.stripWhitespace('<li' + id + ' class="popupmenu-item' + disabledClass + hiddenClass + selectableClass + submenuClass + '">\n      <a' + id + ' href="#">\n        ' + icon + '\n        <span>' + settings.text + '</span>\n        ' + ddicon + '\n      </a>\n      ' + submenu + '\n    </li>');
    },


    /**
     * Converts the contents of a popupmenu or submenu to a JSON-friendly object structure.
     * @private
     * @param {object} [settings={}] incoming conversion settings
     * @param {jQuery[]|HTMLElement} [settings.contextElement] the top-most element that will
     *  be modified (defaults to the top-level menu).
     * @param {boolean} [settings.noMenuWrap] if true, will pass an array as the top-level data instead
     *  of an object with a `menu` property.
     * @returns {object|object[]} an object representation of this popupmenu's current state.
     */
    toData: function toData(settings) {
      var data = {};
      var menu = [];

      settings = settings || {};

      // Figure out Context Element
      if (!settings.contextElement) {
        settings.contextElement = this.menu;
      }
      if (settings.contextElement instanceof HTMLElement) {
        settings.contextElement = $(settings.contextElement);
      }
      if (settings.contextElement.is('.popupmenu-wrapper')) {
        settings.contextElement = settings.contextElement.children('ul');
      }

      var menuId = '' + settings.contextElement.attr('id');
      if (menuId) {
        data.menuId = menuId;
      }

      var hasIcons = settings.contextElement.hasClass('has-icons');
      data.hasIcons = hasIcons;

      if (settings.noMenuWrap) {
        data = menu;
      } else {
        data.menu = menu;
      }

      function decodeListItem(item) {
        var li = $(item);
        var liData = {};

        // Ignore headings, which are included as part of separators inside data
        if (li.hasClass('heading')) {
          return undefined;
        }

        // separators include different metadata
        if (li.hasClass('separator')) {
          liData.separator = true;

          if (li.hasClass('single-selectable-section')) {
            liData.nextSectionSelect = 'single';
          }
          if (li.hasClass('multi-selectable-section')) {
            liData.nextSectionSelect = 'multiple';
          }

          var next = li.next();
          if (next.hasClass('heading')) {
            liData.heading = next.text().trim();
          }

          return liData;
        }

        var a = li.children('a');
        var icon = a.children('.icon:not(.close):not(.icon-dropdown)');
        var id = a.attr('id');

        liData.text = a.text().trim();
        liData.disabled = li.hasClass('is-disabled');
        liData.visible = !li.hasClass('hidden');

        if (typeof id === 'string' && id.length) {
          liData.id = id;
        }

        if (icon.length && icon[0] instanceof SVGElement) {
          liData.icon = icon[0].querySelector('use').getAttribute('xlink:href').replace('#icon-', '');
        }

        if (li.hasClass('is-selectable')) {
          liData.selectable = 'single';
        } else if (li.hasClass('is-multiselectable')) {
          liData.selectable = 'multiple';
        }

        var submenu = li.find('.popupmenu');
        if (submenu.length) {
          liData.submenu = [];
          submenu.first().children().each(function (i, submenuItem) {
            var submenuLiData = decodeListItem(submenuItem);
            if (!submenuLiData) {
              return;
            }
            liData.submenu.push(submenuLiData);
          });
        }

        return liData;
      }

      var lis = settings.contextElement.children('li');
      lis.each(function (i, item) {
        var liData = decodeListItem(item);
        if (!liData) {
          return;
        }
        menu.push(liData);
      });

      return data;
    },


    /**
     * Marks up menu items in the UI
     * @private
     * @param {jQuery[]|HTMLElement} [contextElement] the top-most element that will
     *  be modified (defaults to the top-level menu).
     * @returns {void}
     */
    markupItems: function markupItems(contextElement) {
      var self = this;

      if (!contextElement) {
        contextElement = this.menu;
      } else if (contextElement instanceof HTMLElement) {
        contextElement = $(contextElement);
      }

      var lis = contextElement.find('li:not(.heading):not(.separator)');
      var hasIcons = false;

      lis.each(function (i, li) {
        var a = $(li).children('a')[0]; // TODO: do this better when we have the infrastructure
        var span = $(a).children('span')[0];
        var submenu = $(li).children('ul')[0];
        var icon = $(li).find('.icon:not(.close):not(.icon-dropdown)');
        var submenuWrapper = $(li).children('.wrapper')[0];

        li.setAttribute('role', 'presentation');

        if (a) {
          a.setAttribute('tabindex', '-1');
          a.setAttribute('role', self.settings.ariaListbox ? 'option' : 'menuitem');

          // disabled menu items, by prop and by className
          var $a = $(a);
          var $li = $(li);

          if ($li.hasClass('is-disabled') || a.getAttribute('disabled') === 'true' || a.getAttribute('disabled') === 'disabled') {
            $li.addClass('is-disabled');
            a.setAttribute('aria-disabled', 'true');
            a.setAttribute('disabled', true);
          } else {
            $li.removeClass('is-disabled');
            $a.removeAttr('aria-disabled');
            a.removeAttribute('disabled');
          }

          // menu items that contain submenus
          if (submenu instanceof HTMLElement) {
            submenu.classList.add('popupmenu');
          }
          if (submenuWrapper instanceof HTMLElement) {
            li.className += (DOM.classNameExists(li) ? ' ' : '') + 'submenu';
            submenu = $(submenuWrapper).children('ul')[0];
            submenu.classList.add('popupmenu');
          }
          if (DOM.hasClass(li, 'submenu')) {
            // Add a span
            if (!span) {
              a.innerHTML = '<span>' + a.innerHTML + '</span>';
              span = $a.children('span')[0];
            }

            if ($a.find('svg.arrow').length === 0) {
              $a.append($.createIconElement({ classes: ['arrow', 'icon-dropdown'], icon: 'dropdown' }));
            }
            a.setAttribute('aria-haspopup', 'true');

            // Check for existing menus, and if present, apply a `.popupmenu` class automatically.
          }

          // is-checked
          if (DOM.hasClass(li, 'is-checked')) {
            a.setAttribute('role', 'menuitemcheckbox');
            a.setAttribute('aria-checked', true);
          }

          // is-not-checked
          if (DOM.hasClass(li, 'is-not-checked')) {
            li.className = li.className.replace('is-not-checked', '');
            a.setAttribute('role', 'menuitemcheckbox');
            a.removeAttribute('aria-checked');
          }
        }

        if (icon && icon.length > 0) {
          hasIcons = true;
        }
      });

      if (hasIcons) {
        contextElement.addClass('has-icons');
      } else {
        contextElement.removeClass('has-icons');
      }
    },


    /**
     * Takes a pre-existing menu item and refreshes its state.
     * @private
     * @param {HTMLElement} item the menu item to be refreshed
     * @param {object} data representing a Popupmenu data structure, containing updated state information
     * @param {function} [callback] runs on completion of the item refresh.  Can be used for adding additional
     *  important flags/properties to the Menu Item for a specific implementation.
     * @returns {void}
     */
    refreshMenuItem: function refreshMenuItem(item, data, callback) {
      if (!item || !(item instanceof HTMLElement) || !data) {
        return;
      }

      // Don't refresh the menu item if it doesn't belong to this menu
      if (!$(this.menu)[0].contains(item)) {
        return;
      }

      var itemA = item.querySelector('a');
      var itemIcon = item.querySelector('.icon:not(.close):not(.icon-dropdown)');
      var itemIconUse = void 0;

      if (data.text) {
        if (itemA.innerText.trim() !== data.text) {
          itemA.innerText = '' + data.text;
        }
      }

      if (data.disabled === true) {
        if (item.className.indexOf('hidden') === -1) {
          item.classList.add('is-disabled');
        }
      } else if (item.className.indexOf('is-disabled') > -1) {
        item.classList.remove('is-disabled');
      }

      if (data.visible === true) {
        if (item.className.indexOf('hidden') > -1) {
          item.classList.remove('hidden');
        }
      } else if (item.className.indexOf('hidden') === -1) {
        item.classList.add('visible');
      }

      if (data.icon) {
        // TODO: fragile?
        if (itemIcon) {
          itemIconUse = itemIcon.querySelector('use');
          if (itemIconUse && itemIconUse.getAttribute('xlink:href').replace('#icon-', '') !== data.icon) {
            itemIcon.remove();
          }
          itemIconUse.setAttribute('xlink:href', '#icon-' + data.icon);
        }
      } else if (itemIcon) {
        itemIcon.remove();
      }

      // TODO: Submenus
      // Build so the submenu data structure is used to rerun this method against each submenu item.
      if (data.submenu) {
        var submenuItems = item.querySelector('.popupmenu').children;
        for (var i = 0; i < data.submenu.length; i++) {
          data.submenu[i].isSubmenuItem = true;
          this.refreshMenuItem(submenuItems.item(i), data.submenu[i], callback);
        }
      }

      // Run callback to apply additional refresh changes, if applicable.
      if (typeof callback === 'function') {
        callback.apply(this, [item, data]);
      }
    },


    /**
     * Sets up the event listener structure for the popupmenu
     * @private
     * @listens dragstart
     * @listens contextmenu
     * @listens keydown
     * @listens updated
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;
      var leftClick = this.settings.trigger !== 'rightClick';
      var immediate = this.settings.trigger === 'immediate';

      function disableBrowserContextMenu(e) {
        e.stopPropagation();
        e.preventDefault();
        return false;
      }

      function doOpen(e) {
        if (self.element.hasClass('is-disabled')) {
          e.stopPropagation();
          e.preventDefault();
          return;
        }

        var rightClick = self.settings.trigger === 'rightClick';

        e.stopPropagation();
        e.preventDefault();

        if (rightClick && self.menu.hasClass('is-open')) {
          self.close();
          self.open(e);
          return;
        }

        if (self.menu.hasClass('is-open')) {
          self.close();
        } else {
          self.open(e);
        }
      }

      function contextMenuHandler(e, isLeftClick) {
        e.preventDefault();

        if (self.keydownThenClick) {
          delete self.keydownThenClick;
          return;
        }

        var btn = isLeftClick === true ? 0 : 2;
        if (e.button > btn || self.element.is(':disabled')) {
          return;
        }

        var allowedOS = ['android', 'ios'];
        if (allowedOS.indexOf(Environment.os.name) > -1) {
          self.holdingDownClick = true;
        }

        doOpen(e);
      }

      if (!immediate) {
        // Left-Click activation
        if (leftClick) {
          this.element.on('click.popupmenu', function (e) {
            contextMenuHandler(e, true);
          });
        }

        // Right-Click activation
        if (!leftClick) {
          this.menu.parent().on('contextmenu.popupmenu', disableBrowserContextMenu);

          var disallowedOS = ['android', 'ios'];
          if (disallowedOS.indexOf(Environment.os.name) === -1) {
            // Normal desktop operation
            this.element.on('contextmenu.popupmenu', function (e) {
              disableBrowserContextMenu(e);
              contextMenuHandler(e);
            });
          } else {
            // Touch-based operation on a mobile device
            this.element.on('touchstart.popupmenu', function (e) {
              // iOS needs this prevented to prevent its own longpress feature in Safari
              if (Environment.os.name === 'ios') {
                e.preventDefault();
              }
              $(e.target).addClass('longpress-target');
            }).on('touchend.popupmenu', function (e) {
              $(e.target).removeClass('longpress-target');
            }).on('longpress.popupmenu', function (e, originalE) {
              self.openedWithTouch = true;
              contextMenuHandler(originalE);
            });
          }
        }
      }

      // Disable dragging text to a new browser tab
      this.menu.off('dragstart.popupmenu').on('dragstart.popupmenu', 'a', function () {
        return false;
      });

      // Setup these next events no matter what trigger type is
      this.element.not('.autocomplete, ul').on('keydown.popupmenu', function (e) {
        switch (e.which) {
          case 13:
          case 32:
            if (self.settings.trigger === 'click') {
              self.keydownThenClick = true;
              self.open(e);
            }
            break;
          case 121:
            if (e.shiftKey) {
              // Shift F10
              self.open(e);
            }
            break;
          default:
            break;
        }
      }).on('updated.popupmenu', function (e, settings) {
        e.stopPropagation();
        self.updated(settings);
      });
    },
    handleKeys: function handleKeys() {
      var self = this;
      // http://access.aol.com/dhtml-style-guide-working-group/#popupmenu

      // Handle Events in Anchors
      this.menu.on('click.popupmenu', 'li', function (e) {
        var a = $(this).find('a');
        self.handleItemClick(e, a);
      });

      var excludes = 'li:not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled):not(.is-placeholder)';

      // Select on Focus
      if (this.settings.mouseFocus) {
        this.menu.on('mouseenter.popupmenu', 'li', function () {
          self.highlight($(this).children('a'));
        });
      }

      setTimeout(function () {
        $(document).off('keydown.popupmenu.' + this.id).on('keydown.popupmenu.' + this.id, function (e) {
          var key = e.which;

          // Close on escape
          if (key === 27) {
            e.stopPropagation();
            e.stopImmediatePropagation();
            self.close(true);
            return false;
          }

          // Close on tab
          if (key === 9) {
            e.stopPropagation();
            self.close(true);
          }

          // Select Checkboxes
          if (key === 32) {
            e.stopPropagation();

            var target = $(e.target);
            var checkbox = target.find('input:checkbox');

            if (checkbox.length) {
              checkbox.trigger('click');
              return true;
            }

            var a = $();

            // Return here and let Tabs control handle the spacebar
            if (target.is('.tab') || target.parent().is('.tab') || target.is('.tab-more')) {
              // Spacebar acts like Enter if there aren't any checkboxes (trigger links, etc)
              e.preventDefault();
              return true;
            }

            if (target.is('li')) {
              a = target.children('a');
            }

            if (target.is('a')) {
              a = target;
            }

            if (a.length) {
              a.trigger('click');
              return true;
            }
          }

          var focus = self.menu.find(':focus');

          // Sets focus for functional testing
          if (!focus[0]) {
            focus = $(self.menu[0].querySelector('.is-focused a'));
          }

          var isPicker = self.settings.menu === 'colorpicker-menu';
          var isAutocomplete = self.element.is('.autocomplete');

          // Close Submenu
          if (key === 37 && !isAutocomplete) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.closest('.popupmenu')[0] !== self.menu[0] && focus.closest('.popupmenu').length > 0) {
              focus.closest('.popupmenu').removeClass('is-open').parent().parent().removeClass('is-submenu-open');
              self.highlight(focus.closest('.popupmenu').parent().prev('a'));
            }
          }

          var getPrev = void 0;
          var getNext = void 0;
          var getLast = void 0;
          var getFirst = void 0;

          getPrev = function getPrev(a) {
            //eslint-disable-line
            var prevs = a.parent().prevAll(excludes);
            var prev = void 0;

            prevs.each(function () {
              if (prev) {
                return;
              }

              var li = $(this);
              var targetA = li.children('a');

              if (li.is('.is-disabled') || targetA.prop('disabled') === true) {
                return;
              }
              prev = targetA;
            });

            if (!prev) {
              return getFirst(a);
            }

            return prev;
          };

          getFirst = function getFirst(a) {
            //eslint-disable-line
            var first = a.parent().prevAll(excludes).last();
            var targetA = first.children('a');

            if (first.is('.is-disabled') || targetA.prop('disabled') === true) {
              return getNext(targetA);
            }

            return targetA;
          };

          getNext = function getNext(a) {
            //eslint-disable-line
            var nexts = a.parent().nextAll(excludes);
            var next = void 0;

            nexts.each(function () {
              if (next) {
                return;
              }

              var li = $(this);
              var targetA = li.children('a');

              if (li.is('.is-disabled') || targetA.prop('disabled') === true) {
                return;
              }
              next = targetA;
            });

            if (!next) {
              return getFirst(a);
            }

            return next;
          };

          getLast = function getLast(a) {
            //eslint-disable-line
            var last = a.parent().nextAll(excludes).last();
            var targetA = last.children('a');

            if (last.is('.is-disabled') || targetA.prop('disabled') === true) {
              return getPrev(targetA);
            }

            return targetA;
          };

          // Count number of rows in picker
          var rowCount = 0;
          var colors = self.menu.children(excludes);
          var colorsLength = colors.length;
          var currentOffsetTop = 0;

          for (var i = 0; i < colorsLength; i++) {
            var colorItem = colors[i];

            if (currentOffsetTop === 0) {
              currentOffsetTop = colorItem.offsetTop;
            }

            if (colorItem.offsetTop === currentOffsetTop) {
              rowCount++;
            } else {
              break;
            }
          }

          // Up on Up
          if (!isPicker && key === 38 || isPicker && key === 37) {
            e.stopPropagation();
            e.preventDefault();

            // Go back to Top on the last one
            if (focus.parent().prevAll(excludes).length === 0) {
              if (focus.length === 0) {
                self.highlight(self.menu.children(excludes).last().find('a'));
              } else {
                self.highlight(getLast(focus));
              }
              return undefined;
            }
            self.highlight(getPrev(focus));
          }

          // Up a square
          if (isPicker && key === 38) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.parent().prevAll(excludes).length > 0) {
              self.highlight($(focus.parent().prevAll(excludes)[rowCount - 1]).find('a'));
            }
          }

          // Right Open Submenu
          if (key === 39 && !isAutocomplete) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.parent().hasClass('submenu')) {
              self.openSubmenu(focus.parent());
              self.highlight(focus.parent().find('.popupmenu a:first'));
            }
          }

          // Down
          if (!isPicker && key === 40 || isPicker && key === 39 && !isAutocomplete) {
            e.stopPropagation();
            e.preventDefault();

            // Go back to Top on the last one
            if (focus.parent().nextAll(excludes).length === 0) {
              if (focus.length === 0) {
                self.highlight(self.menu.children(excludes).first().find('a'));
              } else {
                self.highlight(getFirst(focus));
              }
              return undefined;
            }
            self.highlight(getNext(focus));
          }

          // Down a square
          if (isPicker && key === 40) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.parent().nextAll(excludes).length > 0) {
              self.highlight($(focus.parent().nextAll(excludes)[rowCount - 1]).find('a'));
            }
          }
          return undefined;
        });
      }, 1);
    },


    /**
     * Handles the action of clicking items in the popupmenu.
     * @private
     * @param {jQuery.Event} e jQuery `click` event
     * @param {jQuery[]} anchor the anchor tag element that was clicked
     * @returns {boolean} whether or not the click handler successfully passed.
     */
    handleItemClick: function handleItemClick(e, anchor) {
      var href = anchor.attr('href');
      var selectionResult = [anchor];

      if (!e && !anchor) {
        return false;
      }

      if (anchor.parent().is('.submenu, .hidden, .is-disabled') || anchor[0].disabled) {
        // Do not close parent items of submenus on click
        e.preventDefault();
        return false;
      }

      if (anchor.find('input[checkbox]').length > 0) {
        return false;
      }

      if (this.element.hasClass('btn-filter')) {
        this.iconFilteringUpdate(anchor);
        e.preventDefault();
      }

      if (this.isInSelectableSection(anchor) || this.menu.hasClass('is-selectable') || this.menu.hasClass('is-multiselectable')) {
        selectionResult = this.select(anchor);
      }

      // Single toggle on off of checkbox class
      if (anchor.parent().hasClass('is-toggleable')) {
        anchor.parent().toggleClass('is-checked');
      }

      // Trigger a selected event containing the anchor that was selected
      // If an event object is not passed to `handleItemClick()`, assume it was due to this
      // event being triggered already, making it not necessary to re-trigger it.
      if (e && this.settings.triggerSelect) {
        if (selectionResult.length === 1) {
          selectionResult.push(undefined);
        }

        selectionResult.push(true);
        /**
         * Fires on selected.
         *
         * @event selected
         * @memberof PopupMenu
         * @property {object} event - The jquery event object
         * @property {object} selected anchor
         */
        this.element.triggerHandler('selected', selectionResult);
      }

      // MultiSelect Lists should act like other "multiselect" items and not
      // close the menu when options are chosen.
      if (this.menu.hasClass('is-multiselectable') || this.isInMultiselectSection(anchor)) {
        return true;
      }

      this.close();

      if (this.element.is('.autocomplete')) {
        return true;
      }

      if (href && href.charAt(0) !== '#') {
        if (anchor.attr('target') === '_blank') {
          window.open(href, '_blank');
        } else {
          window.location.href = href;
        }
        return true;
      }

      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }

      return true;
    },


    /**
     * Filtering icon initial setup
     * @private
     * @param {jQuery[]} [alink] menu item to be targeted
     * @returns {void}
     */
    iconFilteringSetup: function iconFilteringSetup(alink) {
      if (this.element.hasClass('btn-filter')) {
        var svg = this.element.find('svg.icon-dropdown');
        var link = alink || $('li.is-checked a', this.menu) || $('li:first a', this.menu);
        var audibleText = link.find('span').text();

        if (svg.length === 1) {
          this.element.append($.createIconElement({ classes: 'icon-dropdown', icon: 'dropdown' }));
        }

        svg.first().changeIcon(link.find('svg').getIconName());
        this.element.find('.audible').text(audibleText);
      }
    },


    /**
     * Filtering icon update
     * @private
     * @param {jQuery[]} [alink] menu item to be targeted
     * @returns {void}
     */
    iconFilteringUpdate: function iconFilteringUpdate(alink) {
      if (this.element.hasClass('btn-filter')) {
        var link = alink || $('li.is-checked a', this.menu) || $('li:first a', this.menu);
        var audibleText = link.find('span').text();

        this.element.find('.audible').text(audibleText);
        this.element.find('svg:not(.ripple-effect):first').changeIcon(link.find('svg').getIconName());
      }
    },


    /**
     * Get the event position, handling browser cases (IE,FF) as well as SVG
     * @private
     * @param {jQuery.Event} e the mouse event to be checked for pageX/pageY
     * @returns {object} containing x/y coordinates
     */
    getPositionFromEvent: function getPositionFromEvent(e) {
      var x = 0;
      var y = 0;

      if (!e) {
        e = window.event;
      }

      if (!e) {
        return {};
      }

      if (e.changedTouches) {
        var touch = e.changedTouches[0];
        x = touch.pageX;
        y = touch.pageY;
      } else if (e.pageX || e.pageY) {
        x = e.pageX;
        y = e.pageY;
      } else if (e.clientX || e.clientY) {
        x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
      }

      return {
        x: x,
        y: y
      };
    },


    /**
     * Sets the position of the context menu.
     * @private
     * @param {jQuery.Event} e jQuery Event that caused the menu to open (can be several types)
     * @returns {void}
     */
    position: function position(e) {
      var self = this;
      var target = this.element;
      var isRTL = this.isRTL();
      var wrapper = this.menu.parent('.popupmenu-wrapper');
      var mouse = this.getPositionFromEvent(e);
      var menuDimensions = {
        width: this.menu[0].offsetWidth,
        height: this.menu[0].offsetHeight
      };

      if (!wrapper.length) {
        return;
      }

      // Make the field the same size
      var elemWidth = this.element[0].offsetWidth;
      if (this.settings.trigger === 'click' && elemWidth > menuDimensions.width) {
        this.menu.width(elemWidth);
      }

      if (target.is('svg, .icon') && target.closest('.tab').length) {
        target = target.closest('.tab');
      }

      function getCoordinates(thisE, axis) {
        axis = axis === 'x' || axis === 'y' ? axis : 'x';
        return mouse[axis]; // use mouseX/mouseY if this doesn't work
      }

      // Reset the arrow
      wrapper.find('.arrow').removeAttr('style');

      var opts = $.extend({}, this.settings.placementOpts);
      var strategies = ['flip'];

      /*
      if (!target.is('.autocomplete, .searchfield')) {
        strategies.push('nudge');
      }
      */
      strategies.push('shrink-y');
      opts.strategies = strategies;

      // If right-click or immediate (with an incoming event object), use coordinates from the event
      if (this.settings.trigger === 'immediate' && this.settings.eventObj || this.settings.trigger === 'rightClick') {
        opts.x = getCoordinates(e, 'x') - (isRTL ? menuDimensions.width : 0) + (isRTL ? -1 : 1) * this.settings.offset.x;
        opts.y = getCoordinates(e, 'y') + this.settings.offset.y;

        if (opts.x === 0 && opts.y === 0) {
          opts.x = this.settings.offset.x || 0;
          opts.y = this.settings.offset.y || 0;
          opts.parent = this.element;
          opts.placement = 'bottom';
          opts.parentXAlignment = isRTL ? 'right' : 'left';
        }
      } else {
        opts.x = this.settings.offset.x || 0;
        opts.y = this.settings.offset.y || 0;
        opts.parent = this.element;
        opts.placement = 'bottom';
        opts.strategies.push('nudge');
      }

      //= ======================================================
      // BEGIN Temporary stuff until we sort out passing these settings
      // from the controls that utilize them
      //= ======================================================

      var toolbarParent = target.parents('.toolbar');
      var insideToolbar = toolbarParent.length > 0;
      var insideToolbarTitle = target.parents('.title').length > 0;
      var isNotFullToolbar = insideToolbar && toolbarParent.children('.buttonset, .title').length > 1;
      var isPagerMenu = target.parents('.pager-pagesize').length > 0;

      function alignLeft() {
        opts.parentXAlignment = isRTL ? 'right' : 'left';
      }

      function alignRight() {
        opts.parentXAlignment = isRTL ? 'left' : 'right';
      }

      function shiftDown() {
        opts.y += 15;
      }

      // Change the alignment of the popupmenu based on certain conditions
      (function doAlignment() {
        if (target.is('.btn-menu')) {
          if (isPagerMenu) {
            return alignRight();
          }

          if (insideToolbar) {
            if (!isNotFullToolbar) {
              return alignLeft();
            }
            if (insideToolbarTitle) {
              return alignLeft();
            }
            return alignRight();
          }

          return alignLeft();
        }

        if (target.is('.btn-actions')) {
          return alignRight();
        }

        if (target.is('.tab-more')) {
          return alignRight();
        }

        if (target.is('.btn-split-menu, .tab, .searchfield-category-button') && !target.parent('.pager-pagesize').length) {
          return alignLeft();
        }

        return undefined;
      })();

      if (target.parents('.masthead').length > 0) {
        shiftDown();
      }

      // If inside a "page-container" element, constrain the popupmenu to that element
      // (fixes SOHO-6223)
      var container = this.element.parents('.page-container:not(.tab-container)');
      if (container.length) {
        opts.container = container.first();
      }

      //= ======================================================
      // END Temporary stuff until we sort out passing these settings
      // from the controls that utilize them
      //= ======================================================

      wrapper.one('afterplace.popupmenu', function (thisE, positionObj) {
        self.handleAfterPlace(thisE, positionObj);
      });

      this.wrapperPlace = new Place(wrapper, opts);
      this.wrapperPlace.place(opts);
    },
    handleAfterPlace: function handleAfterPlace(e, placementObj) {
      var wrapper = this.menu.parent('.popupmenu-wrapper');
      this.wrapperPlace.setArrowPosition(e, placementObj, wrapper);

      if (placementObj.height) {
        wrapper[0].style.height = '';
        this.menu[0].style.height = placementObj.height + (/(px|%)/i.test('' + placementObj.height) ? '' : 'px');
      }
      if (placementObj.width) {
        wrapper[0].style.width = '';
        this.menu[0].style.width = placementObj.width + (/(px|%)/i.test('' + placementObj.width) ? '' : 'px');
      }

      wrapper.triggerHandler('popupmenuafterplace', [placementObj]);
      return placementObj;
    },


    /**
     * Calls an external source.
     * @private
     * @param {jQuery.Event} [e] an event that triggered the Popupmenu to open
     *  (could be several types)
     * @param {boolean} [doOpen] causes the menu to re-open once the data has been reloaded.
     * @param {jQuery[]|HTMLElement} [contextElement] if passed, represents a submenu
     *  as the actionable, replaceable menu element instead of the main menu.
     * @param {boolean} [isSubmenu] Note that the request is a submenu for the callback.
    */
    callSource: function callSource(e, doOpen, contextElement, isSubmenu) {
      if (typeof this.settings.beforeOpen !== 'function') {
        return;
      }

      var self = this;
      var targetMenu = this.menu;

      // Use a different menu, if applicable
      if (DOM.isElement(contextElement) && $(contextElement).is('.popupmenu, .submenu')) {
        targetMenu = $(contextElement);
        // Skip calling external source if submenu is already open
        if (contextElement.hasClass('is-open')) {
          return;
        }
      }

      var response = function response(content) {
        var existingMenuItems = targetMenu.children();

        existingMenuItems.filter(function (i, item) {
          return self.predefinedItems.index(item) === -1;
        }).off().remove();

        if (content === false) {
          return false;
        }

        var newContent = $(content);
        targetMenu.append(newContent);

        var wrapper = targetMenu.parent('.wrapper, .popupmenu-wrapper');
        if (!wrapper.length) {
          wrapper = targetMenu.wrap('<div class="wrapper">').parent();
        }
        wrapper.removeAttr('style');
        self.markupItems(targetMenu);

        if (doOpen) {
          if (!targetMenu.is(self.menu)) {
            self.openSubmenu(wrapper.parent('li'), true);
          } else {
            self.open(e, true);
          }
        }
        return true;
      };

      var callbackOpts = {};
      if (!targetMenu.is(this.menu)) {
        callbackOpts.contextElement = targetMenu;
      }

      callbackOpts.element = this.element;
      callbackOpts.isSubmenu = isSubmenu;

      if (typeof this.settings.beforeOpen === 'string') {
        window[this.settings.beforeOpen](response, callbackOpts);
        return;
      }

      this.settings.beforeOpen(response, callbackOpts);
    },


    /**
     * Opens the popupmenu, including repopulating data and setting up visual delays, if necessary.
     * @param {jQuery.Event} e the event that caused the menu to open
     * @param {boolean} ajaxReturn set to true if the open routine should not include a source call
     * @param {boolean} useDelay set to true if the menu should open on a delay (used in mobile environments where a software keybord is present)
     * @returns {void}
     */
    open: function open(e, ajaxReturn, useDelay) {
      var self = this;
      /**
       * Fires before open.
       *
       * @event beforeopen
       * @memberof PopupMenu
       * @property {object} event - The jquery event object
       * @property {object} this menu instance
       */
      var canOpen = true;
      if (!this.element.hasClass('autocomplete')) {
        canOpen = this.element.triggerHandler('beforeopen', [this.menu]);
        if (canOpen === false) {
          return;
        }
      }

      // Check external AJAX source, if applicable
      if (!ajaxReturn) {
        canOpen = this.callSource(e, true);

        if (this.settings.beforeOpen) {
          return;
        }
      }

      // If there's no explicit run of this method without this flag, setup a delay and re-run the open method
      if (!useDelay) {
        if (Environment.os.name === 'ios') {
          setTimeout(function () {
            self.open(e, ajaxReturn, true);
          }, 400);
          return;
        }
      }

      var otherMenus = $('.popupmenu.is-open').filter(function () {
        return $(this).parents('.popupmenu').length === 0;
      }).not(this.menu); // close others.

      otherMenus.each(function () {
        var trigger = $(this).data('trigger');
        if (!trigger || !trigger.length) {
          return;
        }

        var api = $(this).data('trigger').data('popupmenu');
        if (api && typeof api.close === 'function') {
          api.close();
        }
      });

      // Close open tooltips associated with this menu's trigger element
      var tooltipAPI = this.element.data('tooltip');
      if (tooltipAPI && tooltipAPI.visible) {
        tooltipAPI.hide();
      }

      // Close open dropdowns
      var openDropdown = $('.dropdown.is-open');
      if (openDropdown.length > 0) {
        var dropDownApi = openDropdown.parent().prev().data('dropdown');
        if (dropDownApi) {
          dropDownApi.closeList('cancel');
        }
      }

      this.element.addClass('is-open');
      this.menu.addClass('is-open').attr('aria-hidden', 'false');

      if (this.element.hasClass('inverse')) {
        this.menu.parent('.popupmenu-wrapper').addClass('inverse');
      }

      this.position(e);
      utils.fixSVGIcons(this.menu);

      if (this.element.closest('.header').length > 0) {
        this.menu.parent()[0].style.zIndex = '9001';
      }

      // Check every anchor tag to see if it should be disabled.
      // Use the CSS class on its parent to determine whether or not to disable.
      this.menu.find('a').each(function () {
        var a = $(this);
        var li = a.parent();

        if (li.hasClass('is-disabled')) {
          li.addClass('is-disabled');
          a.attr('aria-disabled', 'true');
          a.attr('disabled', 'disabled');
        } else {
          li.removeClass('is-disabled');
          a.removeAttr('aria-disabled');
          a.removeAttr('disabled');
        }
      });

      // Close on Document Click ect..
      setTimeout(function () {
        $(document).on('touchend.popupmenu.' + self.id + ' click.popupmenu.' + self.id, function (thisE) {
          var isPicker = self.settings.menu === 'colorpicker-menu';

          if (thisE.button === 2) {
            return;
          }

          if (self.holdingDownClick) {
            delete self.holdingDownClick;
            return;
          }

          // Click functionality will toggle the menu - otherwise it closes and opens
          if ($(thisE.target).is(self.element) && !isPicker) {
            return;
          }

          if ($(thisE.target).closest('.popupmenu').length === 0) {
            self.close(true, self.settings.trigger === 'rightClick');
          }

          if ($(thisE.target).hasClass('colorpicker')) {
            self.close();
          }
        });

        // in desktop environments, close the list on viewport resize
        if (window.orientation === undefined) {
          $('body').on('resize.popupmenu', function () {
            self.handleCloseEvent();
          });
        }

        $(window).on('scroll.popupmenu', function () {
          self.close();
        });

        $('.scrollable, .modal.is-visible .modal-body-wrapper').on('scroll.popupmenu', function () {
          self.close();
        });

        /**
         * Fires on open.
         *
         * @event open
         * @memberof PopupMenu
         * @property {object} event - The jquery event object
         * @property {object} this menu instance
         */
        self.element.triggerHandler('open', [self.menu]);
      }, 300);

      // Hide on iFrame Clicks - only works if on same domain
      $('iframe').each(function () {
        var frame = $(this);
        frame.ready(function () {
          try {
            frame.contents().find('body').on('click.popupmenu', function () {
              self.close();
            });
          } catch (thisE) {
            // Ignore security errors on out of iframe
          }
        });
      });

      this.handleKeys();

      // hide and decorate submenus - we use a variation on
      var tracker = 0;
      var startY = void 0;
      var menuToClose = void 0;
      var timeout = void 0;

      self.menu.find('.popupmenu').removeClass('is-open');
      self.menu.on('mouseenter.popupmenu touchstart.popupmenu', '.submenu', function (thisE) {
        var menuitem = $(this);
        startY = thisE.pageX;

        clearTimeout(timeout);
        timeout = setTimeout(function () {
          self.openSubmenu(menuitem);
        }, 300);

        $(document).on('mousemove.popupmenu.' + this.id, function (documentE) {
          tracker = documentE.pageX;
        });
      }).on('mouseleave.popupmenu', '.submenu', function () {
        $(document).off('mousemove.popupmenu.' + this.id);

        menuToClose = $(this).find('ul');

        var hasWrapper = menuToClose.parent('.wrapper').length > 0;
        var isLeft = (hasWrapper ? parseInt(menuToClose.parent('.wrapper')[0].style.left, 10) : 0) < 0;
        var canClose = tracker - startY < 3.5;

        if (isLeft) {
          canClose = tracker - startY >= 0;
        }

        if (canClose) {
          // We are moving slopie to the menu
          menuToClose.removeClass('is-open').removeAttr('style');
          menuToClose.parent('.wrapper').removeAttr('style');
          menuToClose.parent().parent().removeClass('is-submenu-open');
          menuToClose = null;
        }
        clearTimeout(timeout);
      });

      if (self.settings.autoFocus) {
        setTimeout(function () {
          var excludes = ':not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)';
          var selection = self.menu.children(excludes).find('.is-selected').children('a');

          if (!selection.length) {
            selection = self.menu.children(excludes).first().children('a');
          }

          self.highlight(selection);
          /**
           * Fires after open.
           *
           * @event afteropen
           * @memberof PopupMenu
           * @property {object} event - The jquery event object
           * @property {object} this menu instance
           */
          self.element.triggerHandler('afteropen', [self.menu]);
        }, 1);
      }
    },


    /**
     * Only allows a menu to close if a key is no longer being pressed
     * @private
     * @returns {void}
     */
    handleCloseEvent: function handleCloseEvent() {
      if (this.holdingDownClick) {
        return;
      }

      this.close();
    },


    /**
     * Opens a top-level menu item's submenu, if applicable
     * @private
     * @param {jQuery[]} li the list item that needs to be opened.
     * @param {boolean} [ajaxReturn] if defined, prevents an external source from
     *  re-populating the menu before it opens.
     * @returns {void}
     */
    openSubmenu: function openSubmenu(li, ajaxReturn) {
      if (DOM.hasClass(li, 'is-disabled') || li[0].disabled) {
        return;
      }

      var submenu = li.children('.wrapper, .popupmenu');
      if (submenu.length && submenu.is('.wrapper')) {
        submenu = submenu.children('.popupmenu');
      }

      var canOpen = this.element.triggerHandler('beforeopen', [submenu]);
      if (canOpen === false) {
        return;
      }

      // Check external AJAX source, if applicable
      if (!ajaxReturn) {
        canOpen = this.callSource(null, true, submenu, true);
        if (this.settings.beforeOpen) {
          return;
        }
      }

      this.showSubmenu(li);
    },


    /**
     * Opens a top-level menu item's submenu, if applicable
     * @private
     * @param {jQuery[]} li the list item that needs to be opened.
     * @returns {void}
     */
    showSubmenu: function showSubmenu(li) {
      // Trigger an event so other components can listen to this element as a popupmenu trigger.
      this.element.triggerHandler('show-submenu', [li]);

      var wrapper = li.children('.wrapper').filter(':first');
      var isRTL = this.isRTL();
      var rtlPadding = 30;

      // Wrap if not wrapped (dynamic menu situation)
      if (wrapper.length === 0) {
        var ul = li.children('ul').filter(':first');
        ul.wrap('<div class="wrapper"></div>');
        wrapper = ul.parent();
      }

      var menu = wrapper.children('.popupmenu');
      var wrapperLeft = li.position().left + li.outerWidth();
      var wrapperWidth = 0;

      li.parent().find('.popupmenu').removeClass('is-open').removeAttr('style');

      wrapper.children('.popupmenu').addClass('is-open');
      wrapperWidth = wrapper.outerWidth();

      if (isRTL) {
        wrapperLeft = li.position().left - wrapperWidth;
      }
      wrapper[0].style.left = wrapperLeft + 'px';
      wrapper[0].style.top = parseInt(li.position().top, 10) - 5 + 'px';

      // Handle Case where the menu is off to the right
      var menuWidth = menu.outerWidth();
      if (wrapper.offset().left + menuWidth > $(window).width() + $(document).scrollLeft() || isRTL && wrapper.offset().left < 0) {
        wrapper[0].style.left = '-9999px';
        menuWidth = menu.outerWidth();
        wrapperLeft = li.position().left - menuWidth;

        if (isRTL) {
          var parentMenuWidth = wrapper.closest('.popupmenu').outerWidth();
          wrapperLeft = parentMenuWidth - 4; // Move back across the parent menu
        }
        wrapper[0].style.left = wrapperLeft + 'px';

        // Did it fit?
        if (wrapper.offset().left < 0 || isRTL && wrapper.offset().left + menuWidth > $(window).width() + $(document).scrollLeft()) {
          // No. Push the menu's left offset onto the screen.
          wrapperLeft = li.position().left - menuWidth + Math.abs(wrapper.offset().left) + 40;
          if (isRTL) {
            wrapperLeft = li.position().left - menuWidth - rtlPadding;
          }
          wrapper[0].style.left = wrapperLeft + 'px';
          menuWidth = menu.outerWidth();
        }

        // Do one more check to see if the right edge bleeds off the screen.
        // If it does, shrink the menu's X size.
        if (wrapper.offset().left + menuWidth > $(window).width() + $(document).scrollLeft() || isRTL && wrapper.offset().left < 0) {
          var differenceY = wrapper.offset().left + menuWidth - ($(window).width() + $(document).scrollLeft());
          menuWidth -= differenceY;
          menu[0].style.width = menuWidth + 'px';
        }
      }

      // Handle Case where menu is off bottom
      var menuHeight = menu.outerHeight();
      if (wrapper.offset().top + menuHeight > $(window).height() + $(document).scrollTop()) {
        // First try bumping up the menu to sit just above the bottom edge of the window.
        var bottomEdgeCoord = wrapper.offset().top + menuHeight;
        var differenceFromBottomY = bottomEdgeCoord - ($(window).height() + $(document).scrollTop());

        wrapper[0].style.top = wrapper.position().top - differenceFromBottomY + 'px';

        // Does it fit?
        if (wrapper.offset().top + menuHeight > $(window).height() + $(document).scrollTop()) {
          // No. Bump the menu up higher based on the menu's height and the extra
          // space from the main wrapper.
          var mainWrapperOffset = li.parents('.popupmenu-wrapper:first').offset().top;
          wrapper[0].style.top = $(window).height() + $(document).scrollTop() - menuHeight - mainWrapperOffset + 'px';
        }

        // Does it fit now?
        if (wrapper.offset().top - $(document).scrollTop() < 0) {
          // No. Push the menu down onto the screen from the top of the window edge.
          wrapper[0].style.top = 0;
          wrapper[0].style.top = wrapper.offset().top * -1 + 'px';
          menuHeight = menu.outerHeight();
        }

        // Do one more check to see if the bottom edge bleeds off the screen.
        // If it does, shrink the menu's Y size and make it scrollable.
        if (wrapper.offset().top + menuHeight > $(window).height() + $(document).scrollTop()) {
          var differenceX = wrapper.offset().top + menuHeight - ($(window).height() + $(document).scrollTop());
          menuHeight = menuHeight - differenceX - 32;
          menu[0].style.height = menuHeight + 'px';
        }
      }

      li.parent().find('.is-submenu-open').removeClass('is-submenu-open');
      li.addClass('is-submenu-open');
    },


    /**
     * Places a highlighted visual state on an item inside the menu
     * @private
     * @param {jQuery[]} anchor the anchor tag representing the menu item.
     * @returns {void}
     */
    highlight: function highlight(anchor) {
      if (!anchor || !anchor.length) {
        return;
      }

      var li = anchor.parent();

      li.parent().children('li').removeClass('is-focused');
      li.addClass('is-focused');

      // Prevent chrome from scrolling - toolbar
      anchor.focus();
      li.closest('.header').scrollTop(0);
    },


    /**
     * Adds/removes checkmarks that are in selectable groups inside the Popupmenu
     * @param {jQuery[]} anchor the anchor tag representing the menu item.
     * @returns {array} updated references to the anchor and its state.
     */
    select: function select(anchor) {
      var singleMenu = this.menu.is('.is-selectable');
      var multipleMenu = this.menu.is('.is-multiselectable');
      var singleSection = this.isInSingleSelectSection(anchor);
      var multipleSection = this.isInMultiselectSection(anchor);
      var parent = anchor.parent();
      var returnObj = [anchor];

      // If the entire menu is "selectable", place the checkmark where it's supposed to go.
      if (singleMenu || singleSection) {
        parent.prevUntil('.heading, .separator').add(parent.nextUntil('.heading, .separator')).removeClass('is-checked');
        parent.addClass('is-checked');
        returnObj.push('selected');
        return returnObj;
      }

      if (multipleMenu || multipleSection) {
        if (parent.hasClass('is-checked')) {
          parent.removeClass('is-checked');
          returnObj.push('deselected');
          return returnObj;
        }
        parent.addClass('is-checked');
        returnObj.push('selected');
        return returnObj;
      }

      return returnObj;
    },


    /**
     * Gets references to top-level menu items that are currently selected.
     * @returns {jQuery[]} elements inside the top-level menu that are selected.
     */
    getSelected: function getSelected() {
      if (!this.menu.is('.is-selectable, .is-multiselectable')) {
        return $();
      }

      return this.menu.children('.is-checked').children('a');
    },


    /**
     * Determines whether or not an anchor resides inside of a selectable Popupmenu section.
     * @param {jQuery[]} anchor the anchor tag being checked.
     * @returns {jQuery[]} elements inside the top-level menu that are selected.
     */
    isInSelectableSection: function isInSelectableSection(anchor) {
      var separator = anchor.parent().prevAll().filter('.separator').first();
      return separator.hasClass('multi-selectable-section') || separator.hasClass('single-selectable-section');
    },


    /**
     * Determines whether or not an anchor resides inside of a single-selectable Popupmenu section.
     * @param {jQuery[]} anchor the anchor tag being checked.
     * @returns {jQuery[]} elements inside the top-level menu that are selected
     *  within a single-selectable section.
     */
    isInSingleSelectSection: function isInSingleSelectSection(anchor) {
      return anchor.parent().prevAll().filter('.separator').first().hasClass('single-selectable-section');
    },


    /**
     * Determines whether or not an anchor resides inside of a multi-selectable Popupmenu section.
     * @param {jQuery[]} anchor the anchor tag being checked.
     * @returns {jQuery[]} elements inside the top-level menu that are selected
     *  within a multi-selectable section.
     */
    isInMultiselectSection: function isInMultiselectSection(anchor) {
      return anchor.parent().prevAll().filter('.separator').first().hasClass('multi-selectable-section');
    },


    /**
     * Removes event listeners from all popupmenu elements.
     * @private
     * @returns {void}
     */
    detach: function detach() {
      $(document).off('touchend.popupmenu.' + this.id + ' click.popupmenu.' + this.id + ' keydown.popupmenu');
      $(window).off('scroll.popupmenu orientationchange.popupmenu');
      $('body').off('resize.popupmenu');
      $('.scrollable').off('scroll.popupmenu');

      this.menu.off('click.popupmenu touchend.popupmenu touchcancel.popupmenu');

      $('iframe').each(function () {
        var frame = $(this);
        try {
          frame.contents().find('body').off('click.popupmenu touchend.popupmenu touchcancel.popupmenu');
        } catch (e) {
          // Ignore security errors on out of iframe
        }
      });
    },


    /**
     * Close the open menu
     * @param {boolean} isCancelled Internally set option used if the operation is a cancel.
     *  Wont matter for manual api call.
     * @param {boolean} [noFocus] Do not return focus to the calling element (fx a button)
     */
    close: function close(isCancelled, noFocus) {
      if (!isCancelled || isCancelled === undefined) {
        isCancelled = false;
      }

      if (!this.menu.hasClass('is-open')) {
        return;
      }

      var wrapper = this.menu.parent('.popupmenu-wrapper');
      var menu = this.menu.find('.popupmenu');

      this.menu.removeClass('is-open').attr('aria-hidden', 'true');
      if (this.menu[0]) {
        this.menu[0].style.height = '';
        this.menu[0].style.width = '';
      }

      if (wrapper[0]) {
        wrapper[0].style.left = '-999px';
        wrapper[0].style.height = '';
        wrapper[0].style.width = '';
      }

      this.menu.find('.submenu').off(['mouseenter.popupmenu', 'mouseleave.popupmenu'].join(' ')).removeClass('is-submenu-open');

      if (menu[0]) {
        menu[0].style.left = '';
        menu[0].style.top = '';
        menu[0].style.height = '';
        menu[0].style.width = '';
      }

      this.menu.find('.is-focused').removeClass('is-focused');

      // Close all events
      $(document).off(['keydown.popupmenu.' + this.id, 'click.popupmenu.' + this.id, 'mousemove.popupmenu.' + this.id, 'touchend.popupmenu.' + self.id].join(' '));

      this.menu.off(['click.popupmenu', 'touchend.popupmenu', 'touchcancel.popupmenu', 'mouseenter.popupmenu', 'mouseleave.popupmenu'].join(' '));

      // Get rid of internal flags that check for how the menu was opened
      delete this.keydownThenClick;
      delete this.holdingDownClick;

      /**
       * Fires when close.
       *
       * @event close
       * @memberof PopupMenu
       * @property {object} event - The jquery event object
       * @property {object} close by cancelled
       */
      this.element.removeClass('is-open').triggerHandler('close', [isCancelled]);
      this.detach();

      if (this.settings.trigger === 'immediate') {
        this.destroy();
      }

      // On text input targets, don't refocus the input if the opening event was called by a touch
      if (this.element[0].tagName === 'INPUT' && this.openedWithTouch) {
        this.element.removeClass('longpress-target');
        delete this.openedWithTouch;
        return;
      }

      delete this.openedWithTouch;

      if (noFocus || !this.settings.returnFocus || Environment.features.touch) {
        return;
      }

      if (typeof this.settings.returnFocus === 'function') {
        this.settings.returnFocus(this, {
          triggerElement: this.element[0],
          menuElement: this.menu[0]
        });
        return;
      }

      if (document.activeElement && document.activeElement.tagName === 'INPUT') {
        return;
      }
      this.element.focus();
    },


    /**
     * Removes bound events and generated markup from this component
     * @private
     * @returns {void}
     */
    teardown: function teardown() {
      var self = this;
      var wrapper = this.menu.parent('.popupmenu-wrapper');

      if (this.ajaxContent) {
        this.ajaxContent.off().remove();
      }

      this.predefinedItems = $();

      this.menu.parent().off('contextmenu.popupmenu');
      if (this.element.hasClass('btn-actions')) {
        this.menu.parent().removeClass('bottom').find('.arrow').remove();
      }

      this.menu.off('dragstart.popupmenu');

      // TODO: Fix when we have time - shouldn't be referencing other controls here
      var insertTarget = this.element;
      var searchfield = this.element.parent().children('.searchfield');

      if (searchfield.length) {
        insertTarget = searchfield.first();
      }
      if (this.settings.attachToBody && insertTarget) {
        this.menu.unwrap();

        if (this.settings.removeOnDestroy) {
          this.menu.off().remove();
        }
      }
      if (this.menu && insertTarget && !this.settings.attachToBody) {
        this.menu.insertAfter(insertTarget);
      }

      this.menu.find('.submenu').children('a').each(function (i, item) {
        var spantext = $(item).find('span').text();
        var text = spantext || $(item).text();
        $(item).find('span, svg').remove();
        $(item).text(text);
      });
      this.menu.find('.submenu').removeClass('submenu');

      function unwrapPopup(menu) {
        var thisWrapper = menu.parent();
        if (thisWrapper.is('.popupmenu-wrapper, .wrapper')) {
          menu.unwrap();
        }
      }

      // Unwrap submenus
      this.menu.find('.popupmenu').each(function () {
        unwrapPopup($(this));
      });

      if (self.wrapperPlace) {
        self.wrapperPlace.destroy();
        delete self.wrapperPlace;
      }
      wrapper.off().remove();

      if (this.menu[0]) {
        $.removeData(this.menu[0], 'trigger');
      }

      this.detach();
      this.element.removeAttr('aria-controls').removeAttr('aria-haspopup').off('touchend.popupmenu touchcancel.popupmenu click.popupmenu keydown.popupmenu keypress.popupmenu contextmenu.popupmenu updated.popupmenu');

      return this;
    },


    /**
     * Updates this Popupmenu instance with new settings
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      return this.teardown().init();
    },


    /**
     * Teardown markup and detach all events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.close();
      this.teardown();
      this.menu.trigger('destroy');
      $.removeData(this.element[0], COMPONENT_NAME$8);
    }
  };

  /**
   * jQuery Component Wrapper for Popupmenu
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.popupmenu = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$8);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$8, new PopupMenu(this, settings));
      }
    });
  };

  var COMPONENT_NAME$9 = 'about';

  /**
   * The About Dialog Component is displays information regarding the application.
   * @class About
   * @param {object} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.appName='Infor Application Name'] The Main Application Name to display in the header.
   * @param {string} [settings.content] Additional text content to display at the top.
   * @param {string} [settings.copyrightYear=new Date().getFullYear()] The year displayed in the copyright, defaults to current year.
   * @param {boolean} [settings.deviceSpecs=true] Determines whether or not to display device information.
   * This information includes Browser, Platform, Locale and if Cookies are Enabled.
   * @param {string} [settings.productName] Additional product name information to display.
   * @param {boolean} [settings.useDefaultCopyright=true] Add the Legal Approved Infor Copyright Text.
   * @param {string} [settings.version] Semantic Version Number for example (4.0.0).
   */
  var ABOUT_DEFAULTS = {
    appName: 'Infor Application Name',
    content: undefined,
    copyrightYear: new Date().getFullYear(),
    deviceSpecs: true,
    productName: undefined,
    useDefaultCopyright: true,
    version: undefined
  };

  function About(element, settings) {
    this.settings = utils.mergeSettings(element, settings, ABOUT_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  About.prototype = {
    init: function init() {
      return this.setup().build().handleEvents();
    },
    setup: function setup() {
      var appName = this.element.attr('data-appname');

      this.isBody = $(this.element).is('body');
      this.settings.appName = appName !== undefined ? appName.toString() : this.settings.appName;

      var content = this.element.attr('data-about-content');
      this.settings.content = content !== undefined ? content.toString() : this.settings.content;

      var copyrightYear = this.element.attr('data-copyright-year');
      this.settings.copyrightYear = copyrightYear !== undefined ? copyrightYear.toString() : this.settings.copyrightYear;

      var deviceSpecs = this.element.attr('data-device-specs');
      if (deviceSpecs) {
        this.settings.deviceSpecs = deviceSpecs === 'true';
      }

      var productName = this.element.attr('data-product-name');
      this.settings.productName = productName !== undefined ? productName.toString() : this.settings.productName;

      var useDefaultCopyright = this.element.attr('data-use-default');
      if (useDefaultCopyright !== undefined) {
        this.settings.useDefaultCopyright = useDefaultCopyright === 'true';
      }

      var version = this.element.attr('data-version');
      this.settings.version = version !== undefined ? version.toString() : this.settings.version;

      // Get the default copyright text and cut in the current year
      this.defaultCopyright = Locale.translate('AboutText') + ' <a class="hyperlink" href="http://www.infor.com" target="_blank">www.infor.com</a>.';
      this.defaultCopyright = this.defaultCopyright.replace('{0}', this.settings.copyrightYear);

      return this;
    },
    build: function build() {
      this.modal = $('<div class="modal about" id="about-modal"></div>');
      $('<div class="modal-content"></div>').appendTo(this.modal);

      var header = $('<div class="modal-header"></div>').appendTo(this.modal.find('.modal-content'));
      $('<div class="close-container"></div>').append($('<button name="close" type="button" class="btn-icon hide-focus"></button>').append($.createIconElement({ icon: 'close', classes: 'icon-close' })).append('<span>' + Locale.translate('Close') + '\'</span>')).appendTo(header);

      $.createIconElement({ icon: 'logo-trademark', classes: ['icon', 'about-logo'] }).attr({ viewBox: '0 0 44 44' }).appendTo(header);
      this.title = $('<h1 class="title"></h1>').text(this.settings.appName).appendTo(this.modal.find('.modal-header'));

      var body = $('<div class="modal-body"></div>').appendTo(this.modal.find('.modal-content'));

      if (this.settings.version || this.settings.productName) {
        var productAndVersion = this.settings.productName ? this.settings.productName + ' ' + this.settings.version : '' + this.settings.version;

        $('<p></p>').text(productAndVersion).appendTo(body);
      }

      if (this.settings.content) {
        $('<div class="additional-content"></div>').html(this.settings.content).appendTo(body);
      }

      if (this.settings.useDefaultCopyright || !this.settings.content) {
        $('<p></p>').html(this.defaultCopyright).appendTo(body);
      }

      if (this.settings.deviceSpecs) {
        var specs = this.getDeviceSpecs();
        var text = '<span class="browser">' + Locale.translate('Browser') + ' : ' + Environment.devicespecs.currentBrowser + ' ' + Environment.devicespecs.browserMajorVersion + ' (' + Environment.devicespecs.browserVersion + ')</span><br>\n        <span class="ds">' + Locale.translate('OperatingSystem') + ' : ' + Environment.devicespecs.os + ' ' + Environment.devicespecs.currentOSVersion + '</span><br>\n        <span class="platform">' + Locale.translate('Platform') + ' : ' + specs.os + '</span><br>\n        <span class="ds">' + Locale.translate('Mobile') + ' : ' + Environment.devicespecs.isMobile + '</span><br>\n        <span class="locale">' + Locale.translate('Locale') + ' : ' + specs.locale + '</span><br>\n        <span class="cookiesEnabled">' + Locale.translate('CookiesEnabled') + ' : ' + specs.cookiesEnabled + '</span><br>\n        <span class="version">' + Locale.translate('Version') + ' : ' + $('html').attr('data-sohoxi-version') + '</span><br>';

        $('<p></p>').html(text).appendTo(body);
      }

      this.buttons = this.modal.find('button');

      this.modal.find('.hide-focus').one('blur', function () {
        $(this).removeClass('hide-focus');
      });

      this.element.attr('data-modal', 'about-modal');

      $('.modal-body', this.modal)[0].tabIndex = 0;

      this.modal.appendTo('body');
      this.modal.modal({ trigger: this.isBody ? 'immediate' : 'click' });
      return this;
    },


    /**
     * Return the browser specs. Currently returns browse, os, cookiesEnabled and locale
     * @returns {string} The specs of the browser.
     */
    getDeviceSpecs: function getDeviceSpecs() {
      var locale = navigator.appName === 'Microsoft Internet Explorer' ? navigator.userLanguage : navigator.language;
      var browser = function () {
        var ua = navigator.userAgent;
        var result = [];
        var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

        if (/trident/i.test(M[1])) {
          result = /\brv[ :]+(\d+)/g.exec(ua) || [];
          return 'IE \'' + result[1];
        }

        if (M[1] === 'Chrome') {
          result = ua.match(/\b(OPR|Edge)\/(\d+)/);
          if (result != null) {
            return result.slice(1).join(' ').replace('OPR', 'Opera');
          }
        }

        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
        result = ua.match(/version\/(\d+)/i);
        if (result !== null) {
          M.splice(1, 1, result[1]);
        }

        return M.join(' ');
      }();

      return {
        browser: browser,
        os: navigator.platform,
        cookiesEnabled: navigator.cookieEnabled,
        locale: locale
      };
    },


    /**
     * Update the component and optionally apply new settings.
     *
     * @param  {object} settings the settings to update to.
     * @returns {object} The plugin api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      return this;
    },


    /**
     * Progamatically close the About dialog.
     * @returns {void}
     */
    close: function close() {
      var modalApi = this.modal.data('modal');

      /**
      * Fires when the dialog is closing.
      * @event close
      * @memberof About
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      if (modalApi) {
        modalApi.close();
      }

      /**
      * Fires after the dialog is done closing and removed.
      * @event afterclose
      * @memberof About
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */

      if (this.isBody) {
        this.destroy();
      }
    },


    /**
     * Teardown and remove any added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      var modalApi = this.modal.data('modal');

      if (modalApi) {
        modalApi.element.off('beforeopen.about');
        modalApi.destroy();
      }

      this.buttons.off();
      this.element.off('open.about');

      if (this.element.length > 0) {
        $.removeData(this.element[0], COMPONENT_NAME$9);
      }
    },


    /**
     * Add component event handlers.
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('open.about', function (e) {
        e.stopPropagation();
        _this.element.trigger('click');
      });

      this.buttons.filter('[name="done"], [name="close"]').on('click.about', function () {
        _this.close();
      });

      /**
      * Fires when the about dialog is opening, allowing you to veto by returning false.
      *
      * @event beforeopen
      * @memberof About
      * @property {object} event The jquery event object.
      * @property {object} ui The dialog object
      */
      this.modal.data('modal').element.on('beforeopen.about', function () {
        _this.modal.find('.modal-body').scrollTop(0);
      });

      $(document).on('keydown.about', function (e) {
        // Close on Escape.
        if (e.which === 0 || e.which === 27) {
          _this.close();
        }
      });

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for About.
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} Elements being acted on.
   */
  $.fn.about = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$9);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$9, new About(this, settings));
      }
    });
  };

  // Height Animation Controls
  // Adapted from: http://n12v.com/css-transition-to-from-auto/
  // Contains a handful of animation helper methods that attempt
  // to DRY up CSS-powered sliding animations.

  /**
   * animateOpen default settings
   * @namespace
   * @property {string} direction horizontal or vertical
   * @property {string|number} distance in pixels that the animation covers. defaults to 'auto',
   *  or can pixel value size.
   * @property {number} timing delay in Miliseconds
   * @property {string} transition settings for the CSS Transition Timing Function
   */
  var ANIMATE_OPEN_DEFAULTS = {
    direction: 'vertical',
    distance: 'auto',
    timing: 300,
    transition: 'cubic-bezier(.17, .04, .03, .94)'
  };

  // Use CSS Transitions to animate from "0" to "auto" widths
  $.fn.animateOpen = function (settings) {
    var eventName = $.fn.transitionEndName();
    settings = utils.mergeSettings(undefined, settings, ANIMATE_OPEN_DEFAULTS);

    // Initialize the plugin (Once)
    return this.each(function () {
      var self = this;
      var $self = $(this);
      var dim = settings.direction === 'horizontal' ? 'width' : 'height';
      var cDim = dim.charAt(0).toUpperCase() + dim.slice(1);
      var distance = !isNaN(settings.distance) ? parseInt(settings.distance, 10) + 'px' : 'auto';
      var timeout = void 0;

      function transitionEndCallback() {
        if (timeout) {
          clearTimeout(timeout);
        }

        if ($self.data('ignore-animation-once')) {
          $.removeData($self[0], 'ignore-animation-once');
        }

        if ($self.data('is-animating')) {
          $.removeData($self[0], 'is-animating');
        }

        $self.off(eventName + '.animateopen');
        self.style.transition = '';
        self.style[dim] = distance;
        $self.trigger('animateopencomplete');
      }

      // Clear any previous attempt at this animation when the animation starts new
      $self.one('animateopenstart.animation', function (e) {
        e.stopPropagation();
        $self.off(eventName + '.animateopen');
      });
      $self.trigger('animateopenstart');

      // Trigger the callback either by Timeout or by TransitionEnd
      if (eventName) {
        $self.one(eventName + '.animateopen', transitionEndCallback);
      }

      // Animate
      $self.data('is-animating', true);
      var prevVal = this.style[dim];
      this.style[dim] = distance;
      var endVal = getComputedStyle(this)[dim];
      this.style[dim] = prevVal;
      // next line forces a repaint
      this['offset' + cDim]; // eslint-disable-line
      this.style.transition = dim + ' ' + settings.timing + 'ms ' + settings.transition;

      timeout = setTimeout(transitionEndCallback, settings.timing);
      this.style[dim] = endVal;

      // Trigger immediately if this element is invisible or has the 'no-transition' class
      if ($self.is(':hidden') || $self.is('.no-transition') || $self.data('ignore-animation-once')) {
        transitionEndCallback();
      }
    });
  };

  /**
   * Animate closed defaults
   * @namespace
   * @property {string} direction horizontal or vertical
   * @property {number} timing delay in Miliseconds
   * @property {string} transition settings for the CSS Transition Timing Function
   */
  var ANIMATE_CLOSED_DEFAULTS = {
    direction: 'vertical',
    timing: 300,
    transition: 'cubic-bezier(.17, .04, .03, .94)'
  };

  // Use CSS Transitions to animate from "auto" to "0" widths
  $.fn.animateClosed = function (settings) {
    var eventName = $.fn.transitionEndName();
    settings = utils.mergeSettings(undefined, settings, ANIMATE_CLOSED_DEFAULTS);

    // Initialize the plugin (Once)
    return this.each(function () {
      var self = this;
      var $self = $(this);
      var dim = settings.direction === 'horizontal' ? 'width' : 'height';
      var cDim = dim.charAt(0).toUpperCase() + dim.slice(1);
      var timeout = void 0;

      function transitionEndCallback() {
        if (timeout) {
          clearTimeout(timeout);
        }

        if ($self.data('ignore-animation-once')) {
          $.removeData($self[0], 'ignore-animation-once');
        }

        if ($self.data('is-animating')) {
          $.removeData($self[0], 'is-animating');
        }

        $self.off(eventName + '.animatedclosed');
        self.style.transition = '';
        self.style[dim] = '0px';
        $self.trigger('animateclosedcomplete');
      }

      // Clear any previous attempt at this animation when the animation starts new
      $self.one('animateclosedstart', function (e) {
        e.stopPropagation();
        $self.off(eventName + '.animatedclosed');
      });
      $self.trigger('animateclosedstart');

      // Trigger the callback either by Timeout or by TransitionEnd
      if (eventName) {
        $self.one(eventName + '.animatedclosed', transitionEndCallback);
      }

      // Animate
      $self.data('is-animating', true);
      this.style[dim] = getComputedStyle(this)[dim];
      // next line forces a repaint
      this['offset' + cDim]; // eslint-disable-line
      this.style.transition = dim + ' ' + settings.timing + 'ms ' + settings.transition;

      timeout = setTimeout(transitionEndCallback, settings.timing);
      this.style[dim] = '0px';

      // Trigger immediately if this element is invisible or has the 'no-transition' class
      if ($self.is(':hidden') || $self.is('.no-transition') || $self.data('ignore-animation-once')) {
        transitionEndCallback();
      }
    });
  };

  // Chainable jQuery plugin that checks if an element is in the process of animating
  $.fn.isAnimating = function () {
    return this.each(function () {
      return $(this).data('is-animating') === true;
    });
  };

  /* eslint-disable consistent-return */

  // Component Name
  var COMPONENT_NAME$a = 'accordion';

  /**
   * The Accordion is a grouped set of collapsible panels used to navigate sections of
   * related content. Each panel consists of two levels: the top level identifies the
   * category or section header, and the second level provides the associated options.
   *
   * @class Accordion
   * @param {object} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.allowOnePane=true] If set to true, allows only one pane of the Accordion to be open at a
   * time.  If an Accordion pane is open, and that pane contains sub-headers only one of the pane's sub-headers can be open at a time. (default true)
   * @param {string} [settings.displayChevron=true]  Displays a "Chevron" icon that sits off to the right-most
   * @param {boolean} [settings.enableTooltips=true] If false, does not run logic to apply tooltips to elements with truncated text.
   * side of a top-level accordion header. Used in place of an Expander (+/-) if enabled.
   * @param {string} [settings.rerouteOnLinkClick=true]  Can be set to false if routing is externally handled
   * @param {boolean} [settings.source=null]  A callback function that when implemented provided a call back for "ajax loading" of tab contents on open.
   */
  var ACCORDION_DEFAULTS = {
    allowOnePane: true,
    displayChevron: true,
    enableTooltips: true,
    rerouteOnLinkClick: true,
    source: null
  };

  function Accordion(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, ACCORDION_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Accordion.prototype = {

    /**
    * Initialization kickoff point
    * @private
    * @param {jQuery[]} [headers] - if provided, only attempts to build the specified headers and
    * their related anchors/panes
    */
    init: function init(headers) {
      this.build(headers).handleEvents(headers).setupTooltips();
    },


    /**
     * Takes a barebones Accordion markup definition and fleshes out any missing parts,
     * as well as storing references to headers, anchors, and panes.
     * @private
     * @param {jQuery[]} [headers] if provided, only attempts to build the specified headers and
     *  their related anchors/panes
     * @param {boolean} [noFilterReset] if provided, will not reset the contents of the
     * `currentlyFiltered` property.
     * @returns {object} The component api for chaining.
     */
    build: function build(headers, noFilterReset) {
      var _this = this;

      var anchors = void 0;
      var panes = void 0;
      var self = this;
      var isGlobalBuild = true;

      if (!headers || !(headers instanceof jQuery)) {
        this.headers = this.element.find('.accordion-header');
        headers = this.element.find('.accordion-header');
        this.anchors = headers.children('a');
        anchors = headers.children('a');
        this.panes = headers.next('.accordion-pane');
        panes = headers.next('.accordion-pane');
      } else {
        anchors = headers.children('a');
        panes = headers.next('.accordion-pane');
        isGlobalBuild = false;

        // update internal refs
        this.headers = this.headers.add(headers);
        this.anchors = this.anchors.add(anchors);
        this.panes = this.panes.add(panes);
      }

      var headersHaveIcons = false;

      // Accordion Headers that have an expandable pane need to have an
      // expando-button added inside of them
      headers.each(function addExpander() {
        var header = $(this);
        var hasIcons = false;
        var containerPane = header.parent();
        var isTopLevel = containerPane.is('.accordion');

        function checkIfIcons() {
          if (isTopLevel) {
            return;
          }

          if (!hasIcons) {
            header.addClass('no-icon');
            return;
          }

          containerPane.addClass('has-icons');
        }

        header.attr('role', 'presentation').hideFocus();

        // For backwards compatibility:  If an icon is found inside an anchor, bring it up to the
        // level of the header.
        header.children('a').find('svg').detach().insertBefore(header.children('a'));

        var outerIcon = header.children('.icon, svg');
        outerIcon.addClass('icon').attr({ role: 'presentation', 'aria-hidden': 'true', focusable: 'false' });
        if (isTopLevel && outerIcon.length) {
          headersHaveIcons = true;
        }

        if (header.is('.list-item') || !isTopLevel && header.find('button').length || !isTopLevel && header.find('svg').length) {
          hasIcons = true;
        }

        // Enable/Disable
        if (header.hasClass('is-disabled')) {
          header.children('a, button').attr('tabindex', '-1');
        }

        // Don't continue if there's no pane
        if (!header.next('.accordion-pane').length) {
          checkIfIcons();
          return;
        }

        hasIcons = true;

        var expander = header.children('.btn');
        if (!expander.length) {
          expander = $('<button class="btn" type="button"></button>');

          var method = 'insertBefore';
          if (self.settings.displayChevron && isTopLevel) {
            header.addClass('has-chevron');
            method = 'insertAfter';
          }
          expander[method](header.children('a'));
          header.data('addedExpander', expander);
        }

        // Hide Focus functionality
        expander.hideFocus();

        // If Chevrons are turned off and an icon is present, it becomes the expander
        if (outerIcon.length && !self.settings.displayChevron) {
          outerIcon.appendTo(expander);
        }

        var expanderIcon = expander.children('.icon, .svg, .plus-minus');
        if (!expanderIcon.length) {
          if (self.settings.displayChevron && isTopLevel) {
            expanderIcon = $.createIconElement({ icon: 'caret-down', classes: ['chevron'] });
          } else {
            var isActive = self.isExpanded(header) ? ' active' : '';
            expanderIcon = $('<span class="icon plus-minus' + isActive + '" aria-hidden="true" role="presentation"></span>');
          }
          expanderIcon.appendTo(expander);
        }
        var expanderIconOpts = {
          role: 'presentation',
          'aria-hidden': 'true'
        };
        if (!expanderIcon.is('span')) {
          expanderIconOpts.focusable = 'false';
        }
        expanderIcon.attr(expanderIconOpts);

        // Move around the Expander depending on whether or not it's a chevron
        if (expanderIcon.is('.chevron')) {
          header.addClass('has-chevron');
          expander.insertAfter(header.children('a'));
        } else {
          header.removeClass('has-chevron');
          expander.insertBefore(header.children('a'));
        }

        // Double check to see if we have left-aligned expanders or icons present,
        // so we can add classes that do alignment
        if (!self.settings.displayChevron && isTopLevel) {
          headersHaveIcons = true;
        }
        checkIfIcons();

        // Add an Audible Description to the button
        var description = expander.children('.audible');
        if (!description.length) {
          description = $('<span class="audible"></span>').appendTo(expander);
        }
        description.text(Locale.translate('Expand'));
      });

      if (headersHaveIcons) {
        this.element.addClass('has-icons');
      }

      // Setup correct ARIA for accordion panes, and auto-collapse them
      panes.each(function addPaneARIA() {
        var pane = $(this);
        var header = pane.prev('.accordion-header');

        header.children('a').attr({ 'aria-haspopup': 'true', role: 'button' });

        if (!self.isExpanded(header)) {
          pane.data('ignore-animation-once', true);
          self.collapse(header);
        }
      });

      // Expand to the current accordion header if we find one that's selected
      if (isGlobalBuild && !this.element.data('updating')) {
        var targetsToExpand = headers.filter('.is-selected, .is-expanded');
        targetsToExpand.next('.accordion-pane').addClass('no-transition');

        if (this.settings.allowOnePane) {
          targetsToExpand = targetsToExpand.first();
          this.expand(targetsToExpand);
        } else {
          targetsToExpand.each(function (idx) {
            _this.expand($(targetsToExpand[idx]));
          });
        }

        this.select(targetsToExpand.last());
        targetsToExpand.next('.accordion-pane').removeClass('no-transition');
      }

      // Retain an internal storage of available filtered accordion headers.
      if (!noFilterReset) {
        this.currentlyFiltered = $();
      }

      return this;
    },


    /**
     * Header Click Handler
     * @private
     * @param {jQuery.Event} e The click event object
     * @param {jQuery[]} header The header query object
     * @returns {boolean} Returns false is the event should be ignored.
     */
    handleHeaderClick: function handleHeaderClick(e, header) {
      if (!header || !header.length || this.isDisabled(header) || this.isFiltered(header) || header.data('is-animating')) {
        e.preventDefault();
        return;
      }

      // Check that we aren't clicking the expando button.  If we click that, this listener dies
      if ($(e.target).is('[class^="btn"]')) {
        e.preventDefault();
        return;
      }

      var anchor = header.children('a');
      return this.handleAnchorClick(e, anchor);
    },


    /**
     * Anchor Click Handler
     * @private
     * @param {object} e The click event object.
     * @param {object} anchor The anchor jQuery object.
     * @returns {boolean} Returns false is the event should be ignored.
     */
    handleAnchorClick: function handleAnchorClick(e, anchor) {
      var self = this;
      var header = anchor.parent('.accordion-header');
      var pane = header.next('.accordion-pane');
      var ngLink = anchor.attr('ng-reflect-href');

      if (e && !ngLink) {
        e.preventDefault();
      }

      if (!header.length || this.isDisabled(header) || this.isFiltered(header)) {
        return false;
      }

      var canSelect = this.element.triggerHandler('beforeselect', [anchor]);
      if (canSelect === false) {
        return;
      }

      // Set the original element for DOM traversal by keyboard
      this.originalSelection = anchor;

      this.select(anchor);

      function followLink() {
        var href = anchor.attr('href');
        if (href && href !== '' && href !== '#') {
          if (!self.settings.rerouteOnLinkClick) {
            return true;
          }

          window.location.href = href;
          return true;
        }
        return false;
      }

      // Stop propagation here because we don't want to bubble up to the Header and
      // potentially click the it twice
      if (e) {
        e.stopPropagation();
      }

      this.closePopups();

      /**
       * If the anchor is a real link, follow the link and die here.
       * This indicates the link has been followed.
       *
       * @event followlink
       * @memberof Accordion
       * @param {array} anchor - The anchor in an array
       */
      if (followLink()) {
        this.element.trigger('followlink', [anchor]);
        return true;
      }

      // If it's not a real link, try and toggle an expansion pane.
      if (pane.length) {
        self.toggle(header);
        return true;
      }

      // This flag is set by the List/Detail Pattern Wrapper.
      // If this component is controlling a detail area, the anchor shouldn't focus,
      // and it should trigger an event that will bubble to the pattern to give
      // context to the detail area.
      if (this.isControllingDetails) {
        if (!pane.length) {
          self.element.trigger('drilldown', [header[0]]);
        }
      } else {
        anchor.focus();
      }

      /**
      * Fires when an accordion header is truly selected.
      *
      * @event selected
      * @memberof Accordion
      * @param {object} event - The jquery event object
      * @param {object} header - The header object
      */
      this.element.trigger('selected', header);

      return true;
    },


    /**
    * Close any open popup menus.
    * @private
    * @param {object} e The click event object.
    */
    closePopups: function closePopups(e) {
      var openPopup = $('.popupmenu.is-open');
      if (openPopup.length) {
        var headers = this.element.find('.accordion-header[aria-haspopup="true"]');
        headers.each(function () {
          var api = $(this).data('popupmenu');
          api.close();
          e.stopPropagation();
          e.stopImmediatePropagation();
          return false;
        });
      }
    },


    /**
    * Expander-Button Click Handler
    * @private
    * @param {object} e The click event object.
    * @param {object} expander The jquery expander DOM element.
    * @returns {boolean} Returns false in some cases if the event should stop propagating.
    */
    handleExpanderClick: function handleExpanderClick(e, expander) {
      var header = expander.parent('.accordion-header');
      if (!header.length || this.isDisabled(header) || this.isFiltered(header) || header.data('is-animating')) {
        return;
      }

      // Set the original element for DOM traversal by keyboard
      this.originalSelection = expander;

      // Don't propagate when clicking the expander.  Propagating can cause the link to be clicked in
      // cases where it shouldn't be clicked.
      if (e) {
        e.stopPropagation();
      }

      this.closePopups(e);

      var pane = header.next('.accordion-pane');
      if (pane.length) {
        this.toggle(header);
        this.select(header);
        expander.focus();
        return;
      }

      // If there's no accordion pane, attempt to simply follow the link.
      return this.handleAnchorClick(e, header.children('a'));
    },


    /**
    * Keypress Event Handler for expanders and anchors
    * @private
    * @param {jQuery.Event} e The click event object.
    * @returns {boolean} Returns false in some cases if the event should stop propagating.
    */
    handleKeys: function handleKeys(e) {
      var self = this;
      var key = e.which;
      // will be either an anchor or expando button.  Should NEVER be the header itself.
      var target = $(e.target);
      var header = target.parent();
      var expander = header.children('[class^="btn"]').first();
      var anchor = header.children('a');

      function setInitialOriginalSelection(selection) {
        if (!selection) {
          selection = target;
        }

        if (!self.originalSelection) {
          self.originalSelection = selection;
        }
      }

      if (key === 9) {
        // Tab (also triggered by Shift + Tab)
        this.headers.removeClass('is-selected');

        if (target.is('a') && expander.length) {
          setInitialOriginalSelection(expander);
        } else {
          setInitialOriginalSelection(anchor);
        }
      }

      if (key === 32) {
        // Spacebar
        e.preventDefault();

        // Don't let this propagate and run against the header element, if it's a button
        if (target.is('[class^="btn"]')) {
          e.stopPropagation();
          e.stopImmediatePropagation();

          // Firefox will attempt to run this twice, despite the fact that we're stopping propagation.
          // Just cancel the whole thing if Firefox is running this method.
          if ($('html').hasClass('is-firefox')) {
            return;
          }
        }

        if (expander.length) {
          setInitialOriginalSelection(expander);
          return this.handleExpanderClick(null, target);
        }
        setInitialOriginalSelection(anchor);
        return this.handleAnchorClick(null, target);
      }

      if (key === 37 || key === 38) {
        // Left Arrow/Up Arrow
        e.preventDefault();
        setInitialOriginalSelection();
        if (e.shiftKey) {
          return this.ascend(header);
        }
        return this.prevHeader(header);
      }

      if (key === 39 || key === 40) {
        // Right Arrow/Down Arrow
        e.preventDefault();
        setInitialOriginalSelection();
        if (e.shiftKey) {
          return this.descend(header);
        }
        return this.nextHeader(header);
      }
    },


    /**
     * Translates all existing markup inside the accordion to a JSON-compatible object structure.
     * @param {boolean} flatten If true, places all accordion headers in the root array.
     * @param {boolean} addElementReference - if true, includes a reference to the original
     * header element inside the structure (NOT valid JSON).
     * @returns {object} The data the represents the accodion structure
     */
    toData: function toData(flatten, addElementReference) {
      var data = [];
      var topHeaders = this.element.children('.accordion-header');

      function buildHeaderJSON(el, index, parentNesting, parentArr) {
        var $el = $(el);
        var pane = $(el).next('.accordion-pane');
        var headerData = {
          text: $(el).children('a, span').text().trim(),
          index: '' + (parentNesting !== undefined ? parentNesting + '.' : '') + index
        };

        if (el.getAttribute('id')) {
          headerData.id = el.getAttribute('id');
        }

        var icon = $el.children('.icon');
        if (icon.length) {
          headerData.icon = icon[0].tagName.toLowerCase() === 'svg' ? icon[0].getElementsByTagName('use')[0].getAttribute('xlink:href') : '';
        }

        if (addElementReference) {
          headerData.element = el;
        }

        if ($el.hasClass('is-disabled')) {
          headerData.disabled = true;
        }

        if (pane.length) {
          var content = pane.children('.accordion-content');
          var subheaders = pane.children('.accordion-header');
          var subheaderData = [];

          if (content.length) {
            headerData.content = '' + content.html();
          }

          if (subheaders.length) {
            // Normally this will nest.
            // If "flatten" is true, don't nest and add straight to the parent array.
            var targetArray = subheaderData;
            if (flatten) {
              targetArray = parentArr;
            }

            subheaders.each(function (j, subitem) {
              buildHeaderJSON(subitem, j, headerData.index, targetArray);
            });

            headerData.children = subheaderData;
          }
        }

        parentArr.push(headerData);
      }

      // Start traversing the accordion
      topHeaders.each(function (i, item) {
        buildHeaderJSON(item, i, undefined, data);
      });

      return data;
    },


    /**
    * Makes a header "selected" if its expander button or anchor tag is focused.
    * @param {object} element - a jQuery object containing either an expander button or an anchor tag.
    * @returns {void}
    */
    select: function select(element) {
      if (!element || !element.length) {
        return;
      }

      // Make sure we select the anchor
      var anchor = element;
      var header = anchor.parent();

      if (element.is('.accordion-header')) {
        header = element;
        anchor = header.children('a');
      }

      if (anchor.is('[class^="btn"]')) {
        anchor = element.next('a');
      }

      if (this.isDisabled(header) || this.isFiltered(header)) {
        return;
      }

      this.headers.removeClass('child-selected').removeClass('is-selected');

      header.addClass('is-selected');

      var items = header.parentsUntil(this.element, '.accordion-pane').prev('.accordion-header');

      items.addClass('child-selected');
    },


    /**
     * Gets the currently-selected Accordion Header, if applicable.
     * @returns {jQuery[]} the currently selected Accoridon Header, or an empty jQuery selector
     *  if there are currently no headers selected.
     */
    getSelected: function getSelected() {
      return this.element.find('.is-selected');
    },


    /**
    * Checks if a particular header is disabled, or if the entire accordion is disabled..
    * @param {object} header The jquery header element
    * @returns {boolean} Whether or not the element is enabled.
    */
    isDisabled: function isDisabled(header) {
      if (this.element.hasClass('is-disabled')) {
        return true;
      }

      if (!header) {
        return false;
      }

      return header.hasClass('is-disabled');
    },


    /**
     * Checks if the header is filtered out or not
     * @param {object} header  The jquery header element
     * @returns {boolean} Whether or not the element is filtered.
     */
    isFiltered: function isFiltered(header) {
      if (!header || !header.length) {
        return false;
      }

      var cl = header[0].classList;
      return cl.contains('filtered') && !cl.contains('has-filtered-children');
    },


    /**
    * Checks if an Accordion Section is currently expanded.
    * @param {object} header The jquery header element
    * @returns {boolean} Whether or not the element is expanded.
    */
    isExpanded: function isExpanded(header) {
      if (header && header instanceof Element) {
        header = $(header);
      }

      if (!header || !header.length) {
        return;
      }

      return header.children('a').attr('aria-expanded') === 'true';
    },


    /**
    * Toggle the given Panel on the Accordion between expanded and collapsed.
    * @param {object} header The jquery header element.
    * @returns {void}
    */
    toggle: function toggle(header) {
      var _this2 = this;

      if (!header || !header.length || this.isDisabled(header) || this.isFiltered(header) || this.isAnimating) {
        return;
      }

      this.isAnimating = true;

      setTimeout(function () {
        _this2.isAnimating = false;
      }, 500);

      if (this.isExpanded(header)) {
        this.collapse(header);
        return;
      }
      this.expand(header);
    },


    /**
    * Expand the given Panel on the Accordion.
    * @param {object} header The jquery header element.
    * @param {boolean} dontCollapseHeaders if defined, will not collapse any open accordion headers
    *  (generally used while filtering)
    * @returns {$.Deferred} resolved on the completion of an accoridon pane's
    *  collapse animation (or immediately, if animation is disabled).
    */
    expand: function expand(header, dontCollapseHeaders) {
      if (!header || !header.length) {
        return;
      }

      var self = this;
      var pane = header.next('.accordion-pane');
      var a = header.children('a');
      var dfd = $.Deferred();

      var canExpand = this.element.triggerHandler('beforeexpand', [a]);
      if (canExpand === false) {
        return dfd.reject();
      }

      function continueExpand() {
        // Change the expander button into "collapse" mode
        var expander = header.children('.btn');
        if (expander.length) {
          expander.children('.plus-minus, .chevron').addClass('active');
          expander.children('.audible').text(Locale.translate('Collapse'));
        }

        var headerParents = header.parentsUntil(self.element).filter('.accordion-pane').prev('.accordion-header').add(header);

        // If we have the correct settings defined, close other accordion
        // headers that are not parents of this one.
        var collapseDfds = [];
        if (self.settings.allowOnePane && !dontCollapseHeaders) {
          self.headers.not(headerParents).each(function () {
            var h = $(this);
            if (self.isExpanded(h)) {
              collapseDfds.push(self.collapse(h));
            }
          });
        }

        // Expand all headers that are parents of this one, if applicable
        var expandDfds = [];
        headerParents.not(header).each(function () {
          var h = $(this);
          if (!self.isExpanded(h)) {
            expandDfds.push(self.expand(h));
          }
        });

        pane.addClass('is-expanded');

        /**
        * Fires when expanding a pane is initiated.
        *
        * @event expand
        * @memberof Accordion
        * @param {object} event - The jquery event object
        * @param {array} anchor - The anchor tag in an array.
        */
        self.element.trigger('expand', [a]);

        /**
         * Fires after a pane is expanded.
         *
         * @event afterexpand
         * @memberof Accordion
         * @param {jQuery.Event} [e] - The jquery event object
         * @param {array} anchor - The anchor tag in an array.
         */
        function handleAfterExpand(e) {
          var _$;

          if (e) {
            e.stopPropagation();
          }
          header.children('a').attr('aria-expanded', 'true');
          pane.triggerHandler('afterexpand', [a]);
          self.element.trigger('afterexpand', [a]);
          (_$ = $).when.apply(_$, expandDfds.concat(collapseDfds)).done(function () {
            dfd.resolve();
          });
        }

        if (pane.hasClass('no-transition')) {
          for (var i = 0; i < pane.length; i++) {
            pane[i].style.display = 'block';
            pane[i].style.height = 'auto';
          }
          handleAfterExpand();
        } else {
          pane.one('animateopencomplete', handleAfterExpand).css('display', 'block').animateOpen();
        }
      }

      // Load from an external source, if applicable
      if (!this.callSource(a, continueExpand)) {
        continueExpand.apply(this);
      }

      return dfd;
    },


    /**
     * Expands all accordion headers, if possible.
     * @returns {$.Deferred} resolved when all the accordion panes being expanded
     *  complete their animations.
     */
    expandAll: function expandAll() {
      var _$2;

      if (this.settings.allowOnePane === true) {
        return;
      }

      var self = this;
      var dfd = $.Deferred();
      var dfds = [];

      this.headers.each(function () {
        var h = $(this);
        if (!self.isExpanded(h)) {
          dfds.push(self.expand(h));
        }
      });

      (_$2 = $).when.apply(_$2, dfds).always(function () {
        dfd.resolve();
      });

      return dfd;
    },


    /**
    * Collapse the given Panel on the Accordion.
    * @param {object} header The jquery header element.
    * @returns {$.Deferred} resolved on the completion of an accoridon pane's
    *  collapse animation (or immediately, if animation is disabled).
    */
    collapse: function collapse(header) {
      if (!header || !header.length) {
        return;
      }

      var self = this;
      var pane = header.next('.accordion-pane');
      var a = header.children('a');
      var dfd = $.Deferred();

      var canExpand = this.element.triggerHandler('beforecollapse', [a]);
      if (canExpand === false) {
        return dfd.reject();
      }

      // Change the expander button into "expand" mode
      var expander = header.children('.btn');
      if (expander.length) {
        expander.children('.plus-minus, .chevron').removeClass('active');
        expander.children('.audible').text(Locale.translate('Expand'));
      }

      pane.removeClass('is-expanded').closeChildren();
      a.attr('aria-expanded', 'false');

      /**
      *  Fires when collapsed a pane is initiated.
      *
      * @event collapse
      * @memberof Accordion
      * @param {jQuery.Event} event - The jquery event object
      * @param {array} anchor - The anchor tag in an array.
      */
      self.element.trigger('collapse', [a]);

      /**
       * Fires after a pane is collapsed.
       *
       * @event aftercollapse
       * @memberof Accordion
       * @param {jQuery.Event} [e] - The jquery event object
       */
      function handleAfterCollapse(e) {
        if (e) {
          e.stopPropagation();
        }
        pane[0].style.display = 'none';
        pane[0].style.height = '0px';
        pane.triggerHandler('aftercollapse', [a]);
        self.element.trigger('aftercollapse', [a]);
        dfd.resolve();
      }

      if (pane.hasClass('no-transition')) {
        handleAfterCollapse();
      } else {
        pane.one('animateclosedcomplete', handleAfterCollapse).animateClosed();
      }

      return dfd;
    },


    /**
    * Collapses all accordion headers.
    * @returns {void}
    * @returns {$.Deferred} resolved when all the accordion panes being collapsed
    *  complete their animations.
    */
    collapseAll: function collapseAll() {
      var _$3;

      var self = this;
      var dfd = $.Deferred();
      var dfds = [];

      this.headers.each(function () {
        var h = $(this);
        if (self.isExpanded(h)) {
          dfds.push(self.collapse(h));
        }
      });

      (_$3 = $).when.apply(_$3, dfds).always(function () {
        dfd.resolve();
      });

      return dfd;
    },


    /**
     * Uses a function (this.settings.source()) to call out to an external API to fill the
     * inside of an accordion pane.
     * @param {jQuery[]} anchor The anchor element
     * @param {Function} animationCallback The call back function
     * @returns {Function} The call back function
     */
    callSource: function callSource(anchor, animationCallback) {
      if (!this.settings.source || typeof this.settings.source !== 'function') {
        return false;
      }

      var self = this;
      var header = anchor.parent();
      var pane = header.next('.accordion-pane');
      var ui = {
        anchor: anchor,
        header: header,
        pane: pane
      };

      function response() {
        self.updated();
        setTimeout(function () {
          animationCallback.apply(self);
        }, 1);
      }

      // Trigger the external method and wait for a response.
      return this.settings.source(ui, response);
    },


    /**
    * Prepares a handful of references for dealing with a specific accordion header
    * @param {object} eventTarget The event we are working with.
    * @returns {object} An object with the accordion dom elements in it.
    */
    getElements: function getElements(eventTarget) {
      var target = $(eventTarget);
      var header = void 0;
      var anchor = void 0;
      var expander = void 0;
      var pane = null;

      if (target.is('.accordion-header')) {
        header = target;
        expander = target.children('[class^="btn"]');
        anchor = target.children('a');
      }

      if (target.is('.btn')) {
        expander = target;
        header = expander.parent();
        anchor = header.children('a');
      }

      if (target.is('a')) {
        anchor = target;
        header = anchor.parent();
        expander = header.children('.btn');
      }

      pane = header.next('.accordion-pane');

      return {
        header: header,
        expander: expander,
        anchor: anchor,
        pane: pane
      };
    },


    /**
    * Selects an adjacent Accordion Header that sits directly before the currently selected
    * Accordion Header.
    * @param {object} element - a jQuery object containing either an expander button or an anchor tag.
    * @param {boolean} noDescend - if it's normally possible to descend into a sub-accordion, prevent
    * against descending.
    * @returns {void}
    */
    prevHeader: function prevHeader(element, noDescend) {
      var elem = this.getElements(element);
      var adjacentHeaders = elem.header.parent().children();
      var currentIndex = adjacentHeaders.index(elem.header);
      var target = $(adjacentHeaders.get(xssUtils.ensureAlphaNumeric(currentIndex) - 1));

      if (!adjacentHeaders.length || currentIndex === 0) {
        if (elem.header.parent('.accordion-pane').length) {
          return this.ascend(elem.header);
        }
        target = adjacentHeaders.last();
      }

      while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
        if (target.is(':only-child') || target.is(':first-child')) {
          return this.ascend(elem.header);
        }
        target = target.prev();
      }

      if (target.is('.accordion-pane')) {
        var prevHeader = target.prev('.accordion-header');
        if (this.isExpanded(prevHeader)) {
          var descendantChildren = prevHeader.next('.accordion-pane').children(':not(.accordion-content)');
          if (descendantChildren.length && !noDescend) {
            return this.descend(prevHeader, -1);
          }
        }
        target = prevHeader;

        // if no target's available here, we've hit the end and need to wrap around
        if (!target.length) {
          if (elem.header.parent('.accordion-pane').length) {
            return this.ascend(elem.header);
          }

          target = adjacentHeaders.last();
          while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
            target = target.prev();
          }
        }
      }

      this.focusOriginalType(target);
    },


    /**
    * Selects an adjacent Accordion Header that sits directly after the currently selected
    * Accordion Header.
    * @param {jQuery[]} element - a jQuery object containing either an expander button
    * or an anchor tag.
    * @param {boolean} noDescend - if it's normally possible to descend into a sub-accordion,
    * prevent against descending.
    * @returns {void}
    */
    nextHeader: function nextHeader(element, noDescend) {
      var elem = this.getElements(element);
      var adjacentHeaders = elem.header.parent().children();
      var currentIndex = adjacentHeaders.index(elem.header);
      var target = $(adjacentHeaders.get(xssUtils.ensureAlphaNumeric(currentIndex) + 1));

      if (!adjacentHeaders.length || currentIndex === adjacentHeaders.length - 1) {
        if (elem.header.parent('.accordion-pane').length) {
          return this.ascend(elem.header, -1);
        }
        target = adjacentHeaders.first();
      }

      while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
        if (target.is(':only-child') || target.is(':last-child')) {
          return this.ascend(elem.header);
        }
        target = target.next();
      }

      if (target.is('.accordion-pane')) {
        var prevHeader = target.prev('.accordion-header');
        if (this.isExpanded(prevHeader)) {
          var descendantChildren = prevHeader.next('.accordion-pane').children(':not(.accordion-content)');
          if (descendantChildren.length && !noDescend) {
            return this.descend(prevHeader);
          }
        }
        target = $(adjacentHeaders.get(xssUtils.ensureAlphaNumeric(currentIndex) + 2));

        // if no target's available here, we've hit the end and need to wrap around
        if (!target.length) {
          if (elem.header.parent('.accordion-pane').length) {
            return this.ascend(elem.header, -1);
          }

          target = adjacentHeaders.first();
          while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
            target = target.next();
          }
        }
      }

      this.focusOriginalType(target);
    },


    /**
    * Selects the first Accordion Header in the parent container of the current Accordion Pane.
    * If we're at the top level, jump out of the accordion to the last focusable element.
    * @param {object} header A jQuery object containing an Accordion header.
    * @param {number} direction If -1, sets the position to be at the end of this set of
    * headers instead of at the beginning.
    * @returns {void}
    */
    ascend: function ascend(header, direction) {
      if (!direction) {
        direction = 0;
      }

      var pane = header.parent('.accordion-pane');
      var target = pane.prev();

      if (direction === -1) {
        target = pane.next('.accordion-header');
        if (!target.length) {
          if (pane.parent('.accordion').length) {
            return this.nextHeader(pane.prev().children('a'), true);
          }

          return this.ascend(pane.prev(), -1);
        }
      }

      this.focusOriginalType(target);
    },


    /**
    * Selects the first Accordion Header in the child container of the current Accordion Header.
    * @param {jQuery[]} header - a jQuery object containing an Accordion header.
    * @param {integer} direction - if -1, sets the position to be at the end of this set of
    * headers instead of at the beginning.
    * @returns {void}
    */
    descend: function descend(header, direction) {
      if (!direction) {
        direction = 0;
      }

      var pane = header.next('.accordion-pane');
      var target = pane.children('.accordion-header').first();

      if (direction === -1) {
        target = pane.children('.accordion-header').last();
      }

      // No headers may be present.  In which case, it may be necessary to simply focus
      // the header for the current pane.
      if (!target.length) {
        return this.focusOriginalType(header);
      }

      if (this.isExpanded(target)) {
        return this.descend(target, -1);
      }

      this.focusOriginalType(target);
    },


    /**
    * Selects an Accordion Header, then focuses either an expander button or an anchor.
    * Governed by the property "this.originalSelection".
    * @param {object} header - a jQuery object containing an Accordion header.
    * @returns {void}
    */
    focusOriginalType: function focusOriginalType(header) {
      // this.select(header.children('a'));

      if (this.originalSelection.is('.btn') && header.children('.btn').length) {
        header.children('.btn').focus();
      } else {
        header.children('a').focus();
      }
    },


    /**
     * @param {jQuery[]} headers element references representing accordion headers.
     * @param {boolean} [doReset] if defined, causes the filtering system to reset.
     */
    filter: function filter(headers, doReset) {
      var _this3 = this;

      if (!headers || !headers.length) {
        return;
      }

      var self = this;

      if (doReset) {
        var collapsePromise = this.collapseAll();
        this.headers.removeClass('filtered has-filtered-children hide-focus');

        $.when(collapsePromise).then(function () {
          _this3.currentlyFiltered = $();
          _this3.build(undefined, true);
          _this3.filter(headers);
        });
        return;
      }

      // If headers are included in the currentlyFiltered storage, removes the ones that
      // have previously been filtered
      var toFilter = headers.not(this.currentlyFiltered);
      var panes = toFilter.next('.accordion-pane');

      // Store a list of all modified parent headers
      var allParentHeaders = $();

      // Perform filtering
      this.headers.not(toFilter).addClass('filtered');
      toFilter.each(function (i, header) {
        var parentPanes = $(header).parents('.accordion-pane');
        if (parentPanes.length) {
          panes = panes.add(parentPanes.filter(function (j, item) {
            return panes.index(item) === -1;
          }));
          // only add headers that weren't already in the collection
          var parentHeaders = parentPanes.prev('.accordion-header').filter(function (j, item) {
            return allParentHeaders.index(item) === -1;
          });
          allParentHeaders = allParentHeaders.add(parentHeaders);
        }
      });

      allParentHeaders.addClass('has-filtered-children');
      var expandPromise = this.expand(allParentHeaders.add(panes.prev('.accordion-header')), true);

      $.when(expandPromise).done(function () {
        _this3.currentlyFiltered = _this3.currentlyFiltered.add(toFilter);
        self.build(undefined, true);
      });
    },


    /**
     * @param {jQuery[]} [headers] element references representing accordion headers.
     *  If provided, will cause only specific items to become unfiltered.  If not
     *  provided, removes all filtering from the accordion.
     */
    unfilter: function unfilter(headers) {
      var _this4 = this;

      if (!this.currentlyFiltered.length) {
        return;
      }

      if (!headers || !headers.length) {
        headers = this.currentlyFiltered;
      }

      // Store a list of all modified parent headers
      var allParentHeaders = $();

      this.headers.removeClass('filtered');
      headers.each(function (i, header) {
        var parentPanes = $(header).parents('.accordion-pane');
        if (parentPanes.length) {
          var parentHeaders = parentPanes.prev('.accordion-header').filter(function (j, item) {
            return allParentHeaders.index(item) === -1;
          });
          allParentHeaders = allParentHeaders.add(parentHeaders);
        }
      });

      allParentHeaders.removeClass('has-filtered-children');

      var collapseDfds = [this.collapse(headers), this.collapse(allParentHeaders)];

      $.when(collapseDfds).done(function () {
        _this4.currentlyFiltered = _this4.currentlyFiltered.not(headers);
        _this4.build(undefined, true);
      });
    },


    /**
    * Disable an accordion from events
    * @returns {void}
    */
    disable: function disable() {
      this.element.addClass('is-disabled');

      this.anchors.add(this.headers.children('[class^="btn"]')).attr('tabindex', '-1');
    },


    /**
    * Enable a disabled accordion.
    * @returns {void}
    */
    enable: function enable() {
      this.element.removeClass('is-disabled');

      this.anchors.add(this.headers.children('[class^="btn"]')).removeAttr('tabindex');
    },


    /**
       * Updates an entire accordion, or specific portion(s).
       * @param {jQuery[]} [headers] Optional jQuery object containing accordion headers whose
       * contents need to be torndown/rebound
       * @param {object} settings The current settings.
       * @returns {this} The api object
       */
    updated: function updated(headers, settings) {
      this.element.data('updating', true);

      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      var currentFocus = $(document.activeElement);
      if (!$.contains(this.element[0], currentFocus[0])) {
        currentFocus = undefined;
      }

      // If accordion headers are passed in, simply teardown/rebind events only for those sections.
      // Otherwise, re-init the entire accordion.
      if (headers && headers instanceof jQuery) {
        this.teardown(headers).init(headers);
      } else {
        this.teardown().init();
      }

      if (currentFocus && currentFocus.length) {
        currentFocus.focus();
      }

      $.removeData(this.element[0], 'updating');
      return this;
    },


    /**
    * Teardown process for accordion elements
    * @param {jQuery} [headers] The header elements to tear down (optional).
    * @returns {void}
    */
    teardown: function teardown(headers) {
      var globalEventTeardown = false;
      var headerElems = headers;

      if (this.currentlyFiltered) {
        this.unfilter(this.currentlyFiltered);
      }

      if (!headers || !(headers instanceof jQuery)) {
        headerElems = this.headers;
        globalEventTeardown = true;
      }
      var anchors = headerElems.find('a');

      headerElems.off('touchend.accordion click.accordion focusin.accordion focusout.accordion keydown.accordion mousedown.accordion mouseup.accordion').each(function () {
        var header = $(this);
        var icon = header.children('.icon');

        var hideFocus = header.data('hidefocus');
        if (hideFocus) {
          hideFocus.destroy();
        }

        if (icon.length) {
          var iconAPI = icon.data('icon');
          if (iconAPI) {
            iconAPI.destroy();
          }
        }

        var expander = header.data('addedExpander');
        if (expander) {
          expander.remove();
          $.removeData(this, 'addedExpander');
        }
      });

      anchors.off('touchend.accordion keydown.accordion click.accordion');

      headerElems.children('[class^="btn"]').off('touchend.accordion click.accordion keydown.accordion');

      if (globalEventTeardown) {
        this.element.off('updated.accordion selected.accordion');
      }

      return this;
    },


    /**
    * Teardown and remove any added markup and events.
    * @returns {void}
    */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], 'accordion');
    },


    /**
     * Teardown and remove any events.
     * @private
     * @param  {object} headers The headers to destroy
     * @returns {void}
     */
    handleEvents: function handleEvents(headers) {
      var self = this;
      var headerWhereMouseDown = null;
      var headerElems = headers;
      var globalEventSetup = false;

      // If no header elements are passed in, simply default to ALL headers.
      if (!headers || !(headers instanceof jQuery)) {
        headerElems = this.headers;
        globalEventSetup = true;
      }
      var anchors = headerElems.find('a');

      // Returns "Header", "Anchor", or "Expander" based on the element's tag
      function getElementType(element) {
        var elementType = 'Header';
        if (element.is('a')) {
          elementType = 'Anchor';
        }
        if (element.is('button')) {
          elementType = 'Expander';
        }
        return elementType;
      }

      // Intercepts a 'click' event in order to either prevent a link from being followed,
      // or allows it to continue.
      function clickInterceptor(e, element) {
        var type = getElementType(element);

        // Trigger a document click since we stop propgation, to close any open menus/popups.
        $('body').children().not('.application-menu, .modal-page-container, .page-container').closeChildren();

        return self['handle' + type + 'Click'](e, element);
      }

      headerElems.on('click.accordion', function (e) {
        return clickInterceptor(e, $(this));
      }).on('focusin.accordion', function (e) {
        var target = $(e.target);

        if (!self.originalSelection) {
          self.originalSelection = target;
        }

        if (target.is(':not(.btn)')) {
          $(this).addClass('is-focused').removeClass('hide-focus');
        }
      }).on('focusout.accordion', function () {
        if (!$.contains(this, headerWhereMouseDown) || $(this).is($(headerWhereMouseDown))) {
          $(this).removeClass('is-focused');
        }
      }).on('keydown.accordion', function (e) {
        self.handleKeys(e);
      }).on('mousedown.accordion', function (e) {
        $(this).addClass('is-focused').removeClass('hide-focus');
        headerWhereMouseDown = e.target;
      }).on('mouseup.accordion', function () {
        headerWhereMouseDown = null;
      });

      anchors.on('click.accordion', function (e) {
        return clickInterceptor(e, $(this));
      });

      headerElems.children('[class^="btn"]').on('click.accordion', function (e) {
        return clickInterceptor(e, $(this));
      }).on('keydown.accordion', function (e) {
        self.handleKeys(e);
      });

      if (globalEventSetup) {
        this.element.on('selected.accordion', function (e) {
          // Don't propagate this event above the accordion element
          e.stopPropagation();
        }).on('updated.accordion', function (e, settings) {
          // Don't propagate just in case this is contained by an Application Menu
          e.stopPropagation();
          self.updated(settings);
        });
      }

      return this;
    },


    /**
     * Hide the visible tooltip.
     * @private
     * @returns {void}
     */
    hideTooltip: function hideTooltip() {
      var _this5 = this;

      var self = window;

      if (self.tooltip) {
        this.removeTooltipData(self.tooltip); // Remove flag as spantooltip
        self.tooltip.classList.add('is-hidden');
        self.tooltip.classList.remove('content-tooltip');
      }

      // Remove scroll events
      $('body, .scrollable').off('scroll.spantooltip', function () {
        _this5.hideTooltip();
      });
    },


    /**
     * Remove the tooltip data from given node
     * @private
     * @param {object} elem The DOM element to remove data
     * @returns {void}
     */
    removeTooltipData: function removeTooltipData(elem) {
      elem = elem instanceof jQuery ? elem : $(elem);
      if (elem.data('spantooltip')) {
        $.removeData(elem[0], 'spantooltip');
      }
    },


    /**
     * Setup tooltips on truncated text elements.
     * @private
     * @returns {void}
     */
    setupTooltips: function setupTooltips() {
      if (!this.settings.enableTooltips) {
        return;
      }

      var self = this;
      var selector = '.accordion-header a span';
      var delay = 400;
      var tooltipTimer = void 0;

      // Handle tooltip to show
      var handleShow = function handleShow(elem) {
        if (elem.offsetWidth > elem.parentElement.offsetWidth - parseInt($(elem).parent().css('padding-left'), 10)) {
          tooltipTimer = setTimeout(function () {
            $(elem).tooltip({
              trigger: 'immediate',
              content: '' + elem.innerText,
              extraClass: 'tooltip-accordion-style'
            });
          }, delay);
        }
      };

      // Handle tooltip to hide
      var handleHide = function handleHide(elem) {
        if (elem.offsetWidth > elem.parentElement.offsetWidth - parseInt($(elem).parent().css('padding-left'), 10)) {
          self.hideTooltip();
          clearTimeout(tooltipTimer);
        }
      };

      // Bind events
      this.element.off('mouseenter.spantooltip', selector).on('mouseenter.spantooltip', selector, function () {
        handleShow(this);
      }).off('mouseleave.spantooltip click.spantooltip', selector).on('mouseleave.spantooltip click.spantooltip', selector, function () {
        handleHide(this);
      });
    }
  };
  /* eslint-enable no-multi-assign */

  /**
   * jQuery component wrapper for the Accordion
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.accordion = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$a);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$a, new Accordion(this, settings));
      }
    });
  };

  // Lifecycle Methods for jQuery Controls
  // Recursive methods that "globally" call certain methods on large groups of controls
  var EXCLUDED_FROM_CLOSE_CHILDREN = ['.expandable-area', '.accordion', ['soho-busyindicator'], '.busyindicator'];
  var EXCLUDED_FROM_HANDLE_RESIZE = [];

  // Used by several of these plugins to detect whether or not the "data" property in question
  // is a valid IDS Enterprise Control.
  function canAccessAPI(prop) {
    return prop && !(prop instanceof jQuery);
  }

  // Used by several of these plugins to detect whether or not there is a method on a "data" api
  // that can be called.
  function canCall(prop, method) {
    var api = canAccessAPI(prop);
    if (!api) {
      return false;
    }

    return prop[method] && typeof prop[method] === 'function';
  }

  // Actually triggers the method on the control if it's possible
  function triggerAPIMethod(prop, method) {
    if (canCall(prop, method)) {
      prop[method]();
      return true;
    }
    return false;
  }

  // Tracks each element that attempts to trigger an API method.
  // If a trigger is successful, it stores it in an array that's used later.
  function findControlsOnElements(elems, method) {
    var foundControls = [];

    $.each(elems, function (index, elem) {
      $.each($(elem).data(), function (i, dataEntry) {
        if (triggerAPIMethod(dataEntry, method)) {
          foundControls.push({ elem: $(elem), control: dataEntry });
        }
      });
    });

    return foundControls;
  }

  // Kicks it all off
  function siftFor(rootElem, method, filteredOutElements) {
    if (!rootElem || !method) {
      return undefined;
    }

    rootElem = $(rootElem);
    var DOMelements = rootElem.find('*').add(rootElem);

    if (filteredOutElements) {
      DOMelements = DOMelements.not(filteredOutElements.join(', '));
    }
    var siftedControls = findControlsOnElements(DOMelements, method);

    rootElem.trigger('sift-' + method + '-complete', [siftedControls]);
    return rootElem;
  }

  // =========================================================
  // Actual Control Plugins
  // =========================================================

  $.fn.destroy = function () {
    return siftFor($(this), 'destroy');
  };

  $.fn.closeChildren = function () {
    return siftFor($(this), 'close', EXCLUDED_FROM_CLOSE_CHILDREN);
  };

  $.fn.handleResize = function () {
    return siftFor($(this), 'handleResize', EXCLUDED_FROM_HANDLE_RESIZE);
  };

  /**
   * @this {Promise}
   */
  function finallyConstructor(callback) {
    var constructor = this.constructor;
    return this.then(
      function(value) {
        return constructor.resolve(callback()).then(function() {
          return value;
        });
      },
      function(reason) {
        return constructor.resolve(callback()).then(function() {
          return constructor.reject(reason);
        });
      }
    );
  }

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}

  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function() {
      fn.apply(thisArg, arguments);
    };
  }

  /**
   * @constructor
   * @param {Function} fn
   */
  function Promise(fn) {
    if (!(this instanceof Promise))
      throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    /** @type {!number} */
    this._state = 0;
    /** @type {!boolean} */
    this._handled = false;
    /** @type {Promise|undefined} */
    this._value = undefined;
    /** @type {!Array<!Function>} */
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function() {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self)
        throw new TypeError('A promise cannot be resolved with itself.');
      if (
        newValue &&
        (typeof newValue === 'object' || typeof newValue === 'function')
      ) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  /**
   * @constructor
   */
  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(
        function(value) {
          if (done) return;
          done = true;
          resolve(self, value);
        },
        function(reason) {
          if (done) return;
          done = true;
          reject(self, reason);
        }
      );
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function(onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function(onFulfilled, onRejected) {
    // @ts-ignore
    var prom = new this.constructor(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.prototype['finally'] = finallyConstructor;

  Promise.all = function(arr) {
    return new Promise(function(resolve, reject) {
      if (!arr || typeof arr.length === 'undefined')
        throw new TypeError('Promise.all accepts an array');
      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(
                val,
                function(val) {
                  res(i, val);
                },
                reject
              );
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function(value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function(resolve) {
      resolve(value);
    });
  };

  Promise.reject = function(value) {
    return new Promise(function(resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function(values) {
    return new Promise(function(resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn =
    (typeof setImmediate === 'function' &&
      function(fn) {
        setImmediate(fn);
      }) ||
    function(fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  // Possible Filter Modes
  var filterModes = ['startsWith', 'contains'];

  /**
   * Abstracted search/filter for use in other controls
   * @class ListFilter
   * @constructor
   *
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.caseSensitive=false]  Set to true if searches ARE case sensitive
   * @param {string} [settings.filterMode='startsWith']  Type of search can current be either 'startsWith' or 'contains'
   * @param {function} [settings.searchableTextCallback] If defined, will take each
    filterable item passed and return user-defined, searchable text content
   */

  var LISTFILTER_DEFAULTS = {
    caseSensitive: false,
    filterMode: filterModes[0],
    searchableTextCallback: undefined
  };

  function ListFilter(settings) {
    this.settings = utils.mergeSettings(undefined, settings, LISTFILTER_DEFAULTS);
    this.init();
  }

  ListFilter.prototype = {

    /**
     * Sanitize Incoming Options
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      function setReasonableDefaults(setting, limits, preset) {
        if ($.inArray(setting, limits) === -1) {
          setting = preset;
        }
      }

      var checks = [{
        setting: this.settings.filterMode,
        limits: filterModes,
        preset: LISTFILTER_DEFAULTS.filterMode
      }];

      for (var i = 0; i < checks.length; i++) {
        setReasonableDefaults(checks[i].setting, checks[i].limits, checks[i].preset);
      }

      return this;
    },


    /**
     * Run the filter on the list for the given search term.
     * @param {array} list The array to search.
     * @param {string} term The term to look for.
     * @returns {boolean|array|jquery[]} false if filtering failed,
     *  or an array/jQuery of items that matched the filter.
     */
    filter: function filter(list, term) {
      if (!list) {
        return false;
      }

      // Check incoming list type
      if (!$.isArray(list) && !(list instanceof jQuery)) {
        return false;
      }

      // Search term must exist and must not be nothing
      if (!term || typeof term !== 'string' || !term.length) {
        return false;
      }

      var self = this;
      var items = [];
      var isJQuery = false;

      // make search term lowercase if the search is not case-senstive
      if (!this.settings.caseSensitive) {
        term = term.toLowerCase();
      }

      // If it's not an array, build an array of the incoming object(s) for iterating through
      if (!$.isArray(list)) {
        if (list instanceof jQuery || (typeof list === 'undefined' ? 'undefined' : _typeof(list)) === 'object') {
          list = $.makeArray(list);
          isJQuery = true;
        }
      }

      // Gets the properties of an object and splices them into text
      function getObjectPropsAsText(thisItem) {
        var text = '';
        var props = Object.keys(thisItem);
        props.forEach(function (prop) {
          var pad = text.length ? ' ' : '';
          text += '' + pad + thisItem[prop];
        });
        return text;
      }

      // If a custom callback for getting searchable content is defined, return a
      // string result from that callback. Otherwise, perform the standard method
      // of grabbing text content.
      function getSearchableContent(item) {
        if (typeof self.settings.searchableTextCallback === 'function') {
          return self.settings.searchableTextCallback(item);
        }

        var targetContent = void 0;
        if (typeof item === 'string') {
          targetContent = item;
        } else if (item instanceof $) {
          targetContent = $(item).text();
        } else if (item instanceof HTMLElement) {
          targetContent = item.innerText;
        } else {
          // Object
          targetContent = getObjectPropsAsText(item);
        }

        return xssUtils.sanitizeHTML(targetContent);
      }

      // Iterates through each list item and attempts to find the provided search term.
      function searchItemIterator(item) {
        var text = getSearchableContent(item);
        if (!self.settings.caseSensitive) {
          text = text.toLowerCase();
        }

        var parts = text.split(' ');
        var match = false;

        if (self.settings.filterMode === 'startsWith') {
          for (var a = 0; a < parts.length; a++) {
            if (parts[a].indexOf(term) === 0) {
              match = true;
              break;
            }
          }

          // Direct Match
          if (text.indexOf(term) === 0) {
            match = true;
          }

          // Partial dual word match
          if (term.indexOf(' ') > 0 && text.indexOf(term) > 0) {
            match = true;
          }
        }

        if (self.settings.filterMode === 'contains') {
          if (text.indexOf(term) >= 0) {
            match = true;
          }
        }

        if (self.settings.filterMode === 'keyword') {
          var keywords = term.split(' ');
          for (var i = 0; i < keywords.length; i++) {
            var keyword = keywords[i];
            if (text.indexOf(keyword) >= 0) {
              match = true;
              break;
            }
          }
        }

        // assume filtered server side
        if (self.settings.filterMode === null) {
          match = true;
        }

        if (match) {
          items.push(item);
        }
      }

      // Run the iterator
      list.forEach(searchItemIterator);

      // If we originally took in a jQuery selector, rebuild that jQuery selector
      // with the relevant results.
      if (isJQuery) {
        items = $(items);
      }

      // If we're not dealing with jQuery, an empty array shouldn't be returned.
      if (!isJQuery && !items.length) {
        return false;
      }

      return items;
    },


    /**
     * Updates the ListFilter with new settings
     * @param {object} [settings] incoming settings
     * @returns {object} component instance
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(undefined, settings, this.settings);

      return this.teardown().init();
    },


    /**
     * @private
     * @returns {object} component instance
     */
    teardown: function teardown() {
      return this;
    },


    /**
     * @returns {object} component instance
     */
    destroy: function destroy() {
      return this.teardown();
    }
  };

  var Tmpl = {};

  /**
   * Recursive compile function for minimal mustache templates.
   * @param  {string} template The template string.
   * @param  {object} self The data / datacontext
   * @param  {object} parent When running recursively this is the parents data when nested.
   * @param  {boolean} invert An inverted expression.
   * @returns {string} The markup
   */
  Tmpl.compile = function compile(template, self, parent, invert) {
    var render = compile;
    var output = '';
    var i = void 0;

    function get(ctx, path) {
      path = path.pop ? path : path.split('.');
      ctx = ctx[path.shift()] || '';
      return 0 in path ? get(ctx, path) : ctx;
    }

    self = Array.isArray(self) ? self : self ? [self] : []; // eslint-disable-line
    self = invert ? 0 in self ? [] : [1] : self; // eslint-disable-line

    var _loop = function _loop() {
      var childCode = '';
      var depth = 0;
      var inverted = void 0;
      var ctx = _typeof(self[i]) === 'object' ? self[i] : {};
      ctx = utils.extend({}, parent, ctx); // Same as Object.assign({}, parent, ctx); but safe on IE
      ctx[''] = { '': self[i] };

      template.replace(/([\s\S]*?)({{((\/)|(\^)|#)(.*?)}}|$)/g, function (match, code, y, z, close, invert, name) {
        //eslint-disable-line
        if (!depth) {
          output += code.replace(/{{{(.*?)}}}|{{(!?)(&?)(>?)(.*?)}}/g, function (match, raw, comment, isRaw, partial, name) {
            return raw ? get(ctx, raw) //eslint-disable-line
            : isRaw ? get(ctx, name) //eslint-disable-line
            : partial ? render(get(ctx, name), ctx) //eslint-disable-line
            : !comment ? new Option(get(ctx, name)).innerHTML : '';
          });
          inverted = invert;
        } else {
          childCode += depth && !close || depth > 1 ? match : code;
        }
        if (close) {
          if (! --depth) {
            name = get(ctx, name);
            if (/^f/.test(typeof name === 'undefined' ? 'undefined' : _typeof(name))) {
              output += name.call(ctx, childCode, function (template) {
                return render(template, ctx);
              }); //eslint-disable-line
            } else {
              output += render(childCode, name, ctx, inverted);
            }
            childCode = '';
          }
        } else {
          ++depth;
        }
      });
    };

    for (i = 0; i < self.length; i++) {
      _loop();
    }
    return output;
  };

  /* eslint-disable no-nested-ternary, prefer-template */

  // The Name of this components
  var COMPONENT_NAME$b = 'autocomplete';

  /*
   * Default Autocomplete Result Item Template.  This can be modified to add data points that
   * will be populated by adding properties to the object created
   * in `DEFAULT_AUTOCOMPLETE_RESULT_ITERATOR_CALLBACK`.
   */
  var DEFAULT_AUTOCOMPLETE_TEMPLATE = '<li id="{{listItemId}}" data-index="{{index}}" {{#hasValue}}data-value="{{value}}"{{/hasValue}} role="listitem">\n <a href="#" tabindex="-1">\n   <span>{{{label}}}</span>\n </a>\n</li>';

  /*
  * Autocomplete's method for obtaining the string that will be tested against a provided search
  * term for a match. This is configurable in the event that the component you attach this to
  * needs a specific part of it searched (instead of the whole thing).
  * @param {String|Object} item - text string, or an object containing a 'label'.
  * @returns {string} The item or item label.
  */
  var DEFAULT_AUTOCOMPLETE_SEARCHABLE_TEXT_CALLBACK = function DEFAULT_AUTOCOMPLETE_SEARCHABLE_TEXT_CALLBACK(item) {
    var isString = typeof item === 'string';
    return isString ? item : item.label;
  };

  /*
  * Autocomplete provides a method that will be run on every result that is passed back from the
  * filtering API. This method can be replaced, allowing developers to customize the output of the
  * returned dataset to add values that can also be displayed on each list item with a modified
  * `DEFAULT_AUTOCOMPLETE_TEMPLATE`.
  */
  var DEFAULT_AUTOCOMPLETE_RESULT_ITERATOR_CALLBACK = function resultIterator(item, index) {
    // For standard autocompletes with a popupmenu, build the dataset that
    // will be submitted to the template.
    var isString = typeof item === 'string';
    var dataset = {
      highlightTarget: 'label',
      index: index,
      listItemId: 'ac-list-option' + index
    };

    if (!isString) {
      dataset = utils.extend({}, dataset, item);
    } else {
      dataset.label = item;
    }

    dataset.hasValue = item.value !== undefined;
    if (dataset.hasValue) {
      dataset.value = item.value;
    }

    return dataset;
  };

  var DEFAULT_AUTOCOMPLETE_HIGHLIGHT_CALLBACK = function highlightMatch(item, options) {
    var targetProp = item;
    var hasAlias = false;

    // If this is an object and we need to replace text within a specific property,
    // look for an "alias" property to use instead of the item itself.
    if (typeof options.alias === 'string' && item[options.alias] !== undefined) {
      hasAlias = true;
      targetProp = item[options.alias];
    }

    // Easy match for 'contains'-style filterMode.
    if (options.filterMode === 'contains') {
      targetProp = targetProp.replace(new RegExp('(' + options.term + ')', 'ig'), '<i>$1</i>');
    } else if (options.filterMode === 'keyword') {
      // Handle "keyword" filterMode
      var keywords = options.term.split(' ');
      for (var i = 0; i < keywords.length; i++) {
        var keyword = keywords[i];

        if (keyword) {
          targetProp = targetProp.replace(new RegExp('(' + keyword + ')', 'ig'), '<i>$1</i>');
        }
      }
    } else {
      // Handle "startsWith" filterMode highlighting a bit differently.
      var originalItem = targetProp;
      var testContent = '' + originalItem;
      if (!options.caseSensitive) {
        testContent = Locale.toLowerCase(testContent);
      }
      var pos = testContent.indexOf(options.term);

      if (pos > 0) {
        targetProp = originalItem.substr(0, pos) + '<i>' + originalItem.substr(pos, options.term.length) + '</i>' + originalItem.substr(options.term.length + pos);
      } else if (pos === 0) {
        targetProp = '<i>' + originalItem.substr(0, options.term.length) + '</i>' + originalItem.substr(options.term.length);
      }
    }

    // place result back
    if (hasAlias) {
      item[options.alias] = targetProp;
    } else {
      item = targetProp;
    }

    return item;
  };

  /**
  * The Autocomplete control provides an easier means of searching through a large amount of data by filtering
  * down the results based on keyboard input from the user.
  * @class Autocomplete
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.source=[]] Defines the data to use, must be specified.
  * @param {string} [settings.sourceArguments={}] If a source method is defined, this flexible object can be passed
  * into the source method, and augmented with parameters specific to the implementation.
  * @param {boolean} [settings.template If defined, use this to draw the contents of each search result instead of the default draw routine.
  * @param {boolean} [settings.caseSensitive=false] if true, causes filter results that don't match case to be thrown out
  * @param {string} [settings.filterMode='startsWith'] The matching algorithm, startsWith, keyword and contains are supported - false will not filter client side
  * @param {boolean} [settings.delay=300] The delay between key strokes on the keypad before it thinks you stopped typing
  * @param {string} [settings.width=null] Width of the open auto complete menu
  * @param {string} [settings.offset=null] For the open menu, the left or top offset
  * @param {string} [settings.autoSelectFirstItem=false] Whether or not to select he first item in the list to be selected
  * @param {boolean} [settings.highlightMatchedText=true] The highlightMatchText property.
  * @param {function} [settings.highlightCallback] The highlightCallback property.
  * @param {function} [settings.resultIteratorCallback] The resultIteratorCallback property.
  * @param {function} [settings.clearResultsCallback] the clearResultsCallback property.
  * @param {function} [settings.displayResultsCallback] The displayResultsCallback property.
  * @param {function} [settings.searchableTextCallback] The searchableTextCallback property.
  */
  var AUTOCOMPLETE_DEFAULTS = {
    source: [],
    sourceArguments: {},
    template: undefined,
    filterMode: 'startsWith',
    caseSensitive: false,
    delay: 300,
    width: null,
    offset: null,
    autoSelectFirstItem: false,
    highlightMatchedText: true,
    highlightCallback: DEFAULT_AUTOCOMPLETE_HIGHLIGHT_CALLBACK,
    resultIteratorCallback: DEFAULT_AUTOCOMPLETE_RESULT_ITERATOR_CALLBACK,
    clearResultsCallback: undefined,
    displayResultsCallback: undefined,
    searchableTextCallback: DEFAULT_AUTOCOMPLETE_SEARCHABLE_TEXT_CALLBACK
  };

  function Autocomplete(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, AUTOCOMPLETE_DEFAULTS);
    this.init();
  }

  // Plugin Object
  Autocomplete.prototype = {
    init: function init() {
      // data-autocomplete can be a url, 'source' or an array
      var data = this.element.attr('data-autocomplete');
      if (data && data !== 'source') {
        this.settings.source = data;
        this.element.removeAttr('data-autocomplete');
      }

      var listFilterSettings = {
        filterMode: this.settings.filterMode,
        caseSensitive: this.settings.caseSensitive,
        highlightMatchedText: this.settings.highlightMatchedText,
        searchableTextCallback: this.settings.searchableTextCallback
      };
      if (!this.listFilter) {
        this.listFilter = new ListFilter(listFilterSettings);
      } else {
        this.listFilter.updated(listFilterSettings);
      }

      this.addMarkup();
      this.handleEvents();
    },
    addMarkup: function addMarkup() {
      this.element.addClass('autocomplete').attr({
        role: 'combobox',
        autocomplete: 'off'
      });
    },
    isLoading: function isLoading() {
      return this.element.hasClass('is-loading') && this.element.hasClass('is-blocked');
    },
    openList: function openList(term, items) {
      if (this.element.is('[disabled], [readonly]') || this.isLoading()) {
        return;
      }

      if (!this.element.hasClass('searchfield')) {
        var canOpen = this.element.triggerHandler('beforeopen.autocomplete', { elem: this.element, value: this.element.val() });
        if (canOpen === false) {
          return;
        }
      }

      var self = this;
      if (!this.settings.caseSensitive) {
        term = Locale.toLowerCase(term);
      }

      // append the list
      this.list = $('#autocomplete-list');
      if (this.list.length === 0) {
        this.list = $('<ul id="autocomplete-list" aria-expanded="true"></ul>').appendTo('body');
      }

      this.list[0].style.height = 'auto';
      this.list[0].style.width = this.element.outerWidth() + 'px';
      this.list.addClass('autocomplete');
      this.list.empty();

      if (this.settings.width) {
        this.list[0].style.width = this.settings.width + (/(px|%)/i.test('' + this.settings.width) ? '' : 'px');
      }

      // Pre-compile template.
      // Try to get an element first, and use its contents.
      // If the string provided isn't a selector, attempt to use it as a string, or fall back
      // to the default template.
      var templateAttr = $(this.element.attr('data-tmpl'));
      this.tmpl = $(templateAttr).length ? $(templateAttr).text() : typeof templateAttr === 'string' ? templateAttr : $(this.settings.template).length ? $(this.settings.template).text() : typeof this.settings.template === 'string' ? this.settings.template : DEFAULT_AUTOCOMPLETE_TEMPLATE;

      // Send full item list to the ListFilter for filtering.
      var filterResult = this.listFilter.filter(items, term);
      var modifiedFilterResults = [];

      // Modify filtered results for a specific template with a `resultIteratorCallback`,
      // if applicable. Each of these results is deep-copied.
      if (filterResult !== false) {
        filterResult.forEach(function (val, index) {
          if (typeof val === 'string') {
            val = { label: val, value: val };
          }

          var result = utils.extend(true, {}, val);
          result = self.settings.resultIteratorCallback(result, index);

          if (self.settings.highlightMatchedText) {
            var filterOpts = {
              filterMode: self.settings.filterMode,
              caseSensitive: self.settings.caseSensitive,
              term: term
            };
            if (result.highlightTarget) {
              filterOpts.alias = result.highlightTarget;
            }
            result = self.settings.highlightCallback(result, filterOpts);
          }

          modifiedFilterResults.push(result);
        });
      }

      this.currentDataSet = modifiedFilterResults;

      // If a "resultsCallback" method is defined, pipe the filtered items to that method and skip
      // building a popupmenu.
      if (typeof this.settings.displayResultsCallback === 'function') {
        this.settings.displayResultsCallback(modifiedFilterResults, function () {
          self.element.trigger('listopen', [modifiedFilterResults]);
        });
        return;
      }

      this.handleListResults(term, items, modifiedFilterResults);
    },
    handleListResults: function handleListResults(term, items, filterResult) {
      var self = this;

      var afterPlaceCallback = function afterPlaceCallback(placementObj) {
        if (placementObj.wasFlipped === true) {
          self.list.add(self.element).addClass('is-ontop');
          placementObj.y += 1;
        }
        return placementObj;
      };

      var popupOpts = {
        menuId: 'autocomplete-list',
        ariaListbox: true,
        mouseFocus: false,
        trigger: 'immediate',
        attachToBody: true,
        autoFocus: false,
        returnFocus: false,
        triggerSelect: false,
        placementOpts: {
          parent: this.element,
          callback: afterPlaceCallback
        }
      };

      filterResult.forEach(function (dataset) {
        if (typeof Tmpl !== 'undefined') {
          var renderedTmpl = Tmpl.compile(self.tmpl, dataset);
          DOM.append(self.list, renderedTmpl, '*');
        }
      });

      this.element.addClass('is-open').popupmenu(popupOpts).one('close.autocomplete', function () {
        self.closeList(true);
      });

      // Adjust the widths of the LIs to the longest
      var lis = self.list.find('li');
      var width = $(lis[0]).find('span').outerWidth() + 20;
      if (width > parseInt(this.element.outerWidth(), 10)) {
        for (var i = 0; i < lis.length; i++) {
          lis.width(width + 'px');
        }
        this.maxWidth = width;
      }

      // Optionally select the first item in the list
      if (self.settings.autoSelectFirstItem) {
        self.list.children().filter(':not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)').first().addClass('is-selected');
      }

      this.noSelect = true;
      /**
      * Fires after the menu is populated with its contents.
      *
      * @event populated
      * @memberof Autocomplete
      * @param {object} event - The jquery event object
      * @param {object} filterResult - The results of the filtering
      */
      this.element.trigger('populated', [filterResult]).focus();

      // Overrides the 'click' listener attached by the Popupmenu plugin
      self.list.on('touchend.' + COMPONENT_NAME$b + ' click.' + COMPONENT_NAME$b, 'a', function (e) {
        self.select(e);
      }).on('focusout.' + COMPONENT_NAME$b, function () {
        self.checkActiveElement();
      });

      // Highlight anchors on focus
      var all = self.list.find('a').on('focus.' + COMPONENT_NAME$b + ' touchend.' + COMPONENT_NAME$b, function () {
        self.highlight($(this), all);
      });

      if (this.settings.offset) {
        var domListParent = this.list.parent()[0];

        if (this.settings.offset.left) {
          domListParent.style.left = parseInt(domListParent.style.left, 10) + this.settings.offset.left + 'px';
        }
        if (this.settings.offset.top) {
          domListParent.style.top = parseInt(domListParent.style.top, 10) + this.settings.offset.top + 'px';
        }
      }

      // As chars are typed into the edit field, nothing was announced to indicate
      // that a value has been suggested, for the non-sighted user an offscreen span
      // added and will remove soon popup close that includes aria-live="polite"
      // which have the first suggested item automatically announced when it
      // appears without moving focus.
      self.list.parent('.popupmenu-wrapper').append('' + ('' + '<span id="ac-is-arialive" aria-live="polite" class="audible">') + $.trim(this.list.find('>li:first-child').text()) + '</span>');

      this.noSelect = true;
      this.element.trigger('listopen', [filterResult]);
    },
    closeList: function closeList(dontClosePopup) {
      // Remove events
      this.list.off(['click.' + COMPONENT_NAME$b, 'touchend.' + COMPONENT_NAME$b, 'focusout.' + COMPONENT_NAME$b].join(' '));
      this.list.find('a').off('focus.' + COMPONENT_NAME$b + ' touchend.' + COMPONENT_NAME$b);

      this.element.trigger('listclose');

      if (typeof this.settings.clearResultsCallback === 'function') {
        this.settings.clearResultsCallback();
        return;
      }

      var popup = this.element.data('popupmenu');
      if (!popup) {
        return;
      }
      if (!dontClosePopup) {
        popup.close();
      }

      $('#autocomplete-list').parent('.popupmenu-wrapper').remove();
      $('#autocomplete-list').remove();
      this.element.add(this.list).removeClass('is-open is-ontop');
    },
    listIsOpen: function listIsOpen() {
      return this.list instanceof $ && this.list.length && this.list.is(':visible');
    },


    // Handles the Autocomplete's "keydown" event
    handleAutocompleteKeydown: function handleAutocompleteKeydown(e) {
      var self = this;

      if (this.isLoading()) {
        e.preventDefault();
        return false;
      }

      if (!this.listIsOpen()) {
        return null;
      }

      function getHighlighted(items) {
        return items.filter('.is-selected');
      }

      function unhighlight(item) {
        item.removeClass('is-selected is-focused');
      }

      function highlight(item) {
        item.addClass('is-selected').find('a').focus();
      }

      var excludes = 'li:not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)';
      var items = this.list.find(excludes);
      var highlighted = getHighlighted(items);

      // Down - select next
      if (e.keyCode === 40 && this.listIsOpen()) {
        if (highlighted.length) {
          self.noSelect = true;
          unhighlight(highlighted);
          highlight(items.eq(items.index(highlighted) + 1));
          e.preventDefault();
          e.stopPropagation();
        }
      }

      // Up select prev
      if (e.keyCode === 38 && this.listIsOpen()) {
        if (highlighted.length) {
          self.noSelect = true;
          unhighlight(highlighted);
          highlight(items.eq(items.index(highlighted) - 1));
          e.preventDefault();
          e.stopPropagation();
        }
      }

      // Enter/Tab - apply selected item
      if ((e.keyCode === 9 || e.keyCode === 13) && this.listIsOpen()) {
        // Apply selection if an item is selected, otherwise close list and
        // allow default tab/enter behavior to happen
        if (highlighted.length) {
          e.stopPropagation();
          e.preventDefault();
          self.noSelect = true;
          self.select(highlighted);
        } else {
          self.closeList();
        }
      }

      return null;
    },


    // Handles the Autocomplete's "input" event
    handleAutocompleteInput: function handleAutocompleteInput(e) {
      var self = this;

      if (self.isLoading()) {
        e.preventDefault();
        return false;
      }

      // Makes a new AJAX call every time a key is pressed.
      var waitForSource = this.getDataFromSource();
      waitForSource.done(function (term, response) {
        self.currentDataSet = response;
        self.openList(term, response);
      });

      return null;
    },


    /**
     * Check to see whether or not the currently-focused element resides within
     * the Autocomplete's field or list, and if not, fires a "safe-blur" event on the element.
     *
     * @private
     * @param {object} e The event object passed in from the jQuery `.on()` listener.
     * @returns {void}
     */
    checkActiveElement: function checkActiveElement() {
      var self = this;
      setTimeout(function () {
        var activeElem = document.activeElement;

        if (self.listIsOpen() && $.contains(self.list[0], activeElem) || self.element.is(activeElem)) {
          return;
        }

        /**
        *  Fires after the input (and menu) both loose focus
        *
        * @event safe-blur
        * @memberof Autocomplete
        * @param {object} event The input event object
        */
        self.element.trigger('safe-blur');
      }, 0);
    },
    getDataFromSource: function getDataFromSource() {
      var self = this;

      // Don't attempt to load if we're already loading.
      if (self.isLoading()) {
        return false;
      }

      var field = this.element;
      var dfd = $.Deferred();
      var buffer = void 0;

      clearTimeout(this.loadingTimeout);

      function done(searchTerm, response, deferredStatus) {
        self.element.triggerHandler('complete'); // For Busy Indicator

        /**
        *  Fires when the ajax request (source option) is completed
        *
        * @event requestend
        * @memberof Autocomplete
        * @param {object} event The input event object
        * @param {array} An array containing the searchTerm and call back function
        */
        self.element.trigger('requestend', [searchTerm, response]);

        if (deferredStatus === false) {
          return dfd.reject(searchTerm);
        }
        return dfd.resolve(xssUtils.stripTags(searchTerm), response);
      }

      this.loadingTimeout = setTimeout(function () {
        if (self.isLoading()) {
          return;
        }

        buffer = field.val();

        if (buffer === '') {
          if (self.element.data('popupmenu')) {
            self.element.data('popupmenu').close();
          }
          return;
        }

        var sourceType = _typeof(self.settings.source);
        self.element.triggerHandler('start'); // For Busy Indicator

        /**
        * Fires when the ajax request (source option) is initiated
        *
        * @event requeststart
        * @memberof Autocomplete
        * @param {object} event The input event object
        * @param {array} event An array with the buffer in it
        */
        self.element.trigger('requeststart', [buffer]);

        if (sourceType === 'function') {
          // Call the 'source' setting as a function with the done callback.
          self.settings.source(buffer, done, self.settings.sourceArguments);
        } else if (sourceType === 'object') {
          // Use the 'source' setting as pre-existing data.
          // Sanitize accordingly.
          var sourceData = $.isArray(self.settings.source) ? self.settings.source : [self.settings.source];
          done(buffer, sourceData, true);
        } else if (!self.settings.source) {
          dfd.reject(buffer);
        } else if (self.settings.filterMode === 'keyword') {
          var keywordData = [];
          var mergeData = function mergeData(data) {
            if (keywordData.length === 0) {
              keywordData = data;
            } else {
              // Check for duplicate entries
              for (var i = 0; i < data.length; i++) {
                var dataItem = data[i];

                var isExists = false;

                for (var ii = 0; ii < keywordData.length; ii++) {
                  var keywordItem = keywordData[ii];

                  for (var iii = 0; iii < Object.getOwnPropertyNames(keywordItem).length; iii++) {
                    var dataPropVal = dataItem[Object.getOwnPropertyNames(dataItem)[iii]];
                    var keywordPropVal = keywordItem[Object.getOwnPropertyNames(keywordItem)[iii]];

                    if (dataPropVal === keywordPropVal) {
                      isExists = true;
                      break;
                    }
                  }
                }

                if (!isExists) {
                  keywordData.push(dataItem);
                }
              }
            }
          };

          var doneData = function doneData(data) {
            mergeData(data);

            done(buffer, keywordData, true);
          };

          var keywords = buffer.split(' ');
          if (keywords[keywords.length - 1] === '') {
            keywords.splice(-1, 1);
          }

          for (var i = 0; i < keywords.length; i++) {
            var keyword = keywords[i];

            if (keyword.length > 0) {
              var sourceURL = self.settings.source.toString();
              var request = $.getJSON(sourceURL + keyword);

              if (i < keywords.length - 1) {
                request.done(mergeData).fail(mergeData);
              } else {
                request.done(doneData).fail(doneData);
              }
            }
          }
        } else {
          // Attempt to resolve source as a URL string.  Do an AJAX get with the URL
          var _sourceURL = self.settings.source.toString();
          var _request = $.getJSON(_sourceURL + buffer);

          _request.done(function (data) {
            done(buffer, data, true);
          }).fail(function () {
            done(buffer, [], false);
          });
        }
      }, self.settings.delay);

      return dfd;
    },


    /**
    * Resets a filtered autocomplete back to its original state.
    * @returns {void}
    */
    resetFilters: function resetFilters() {
      this.openList('', this.currentDataSet);
    },


    // Handles the Autocomplete's "focus" event
    handleAutocompleteFocus: function handleAutocompleteFocus() {
      var self = this;
      if (this.noSelect) {
        this.noSelect = false;
        return;
      }

      // select all text (after a delay since works better across browsers), but only if element is
      // still focused to avoid flashing cursor focus trap (since select causes focus event to
      // fire if no longer focused)
      self.element.select();
    },


    /**
     * Highlights (and focuses) an Autocomplete list option
     * @param {jQuery} anchor the anchor to be highlighted
     * @param {jQuery[]} [allAnchors=null] optional list of anchors to deselect when the new one becomes selected.
     * @returns {void}
     */
    highlight: function highlight(anchor, allAnchors) {
      var text = anchor.text().trim();

      if (anchor.find('.display-value').length > 0) {
        text = anchor.find('.display-value').text().trim();
      }

      if (allAnchors && allAnchors.length) {
        allAnchors.parent('li').removeClass('is-selected');
      }
      anchor.parent('li').addClass('is-selected');

      this.noSelect = true;
      this.element.val(text).focus();
    },


    /**
     * Selects an Autocomplete result.
     * @param {jQuery|jQuery.Event} anchorOrEvent either a reference to a jQuery-wrapped HTMLElement, or a jQuery Event object with a target.
     * @param {object[]} [items=this.currentDataSet] an array of objects representing autocomplete options.
     * @returns {object} contains information about the selected item.
     */
    select: function select(anchorOrEvent, items) {
      var a = void 0;
      var li = void 0;
      var ret = {};
      var isEvent = false;

      // Initial Values
      if (anchorOrEvent instanceof $.Event) {
        isEvent = true;
        a = $(anchorOrEvent.currentTarget);
      } else {
        a = anchorOrEvent;
      }

      if (a.is('li')) {
        li = a;
        a = a.children('a');
      }

      li = a.parent('li');
      var dataIndex = li.attr('data-index');
      var dataValue = li.attr('data-value');

      this.element.attr('aria-activedescendant', li.attr('id'));

      if (!items || !items.length) {
        items = this.currentDataSet;
      }

      // If the data-index attr is supplied, use it to get the item
      // (since two items could have same value)
      if (dataIndex) {
        ret = items[parseInt(dataIndex, 10)];
      } else if (dataValue) {
        // Otherwise use data-value to get the item (a custom template may not supply data-index)
        for (var i = 0, value; i < items.length; i++) {
          if (_typeof(items[i]) === 'object' && items[i].value !== undefined) {
            value = items[i].value.toString();
          } else {
            value = items[i].toString();
          }

          if (value === dataValue) {
            if (_typeof(items[i]) === 'object') {
              ret = items[i];
            }
            ret.value = value;
          }
        }
      }

      // Use the label as the value, if we're not working from a true dataset
      if (!ret.value || !ret.value.length === 0) {
        ret.value = a.text().trim();
      }

      this.highlight(a);

      this.noSelect = true;

      // Update the data for the event
      ret.label = xssUtils.stripHTML(ret.label);

      // Add these elements for key down vs click consistency
      if (!ret.highlightTarget) {
        ret.highlightTarget = 'label';
        ret.index = parseInt(dataIndex, 10);
        ret.listItemId = 'ac-list-option' + ret.index;
        ret.hasValue = true;
      }

      /**
      *  Fires when an element is selected from the list.
      *
      * @event selected
      * @memberof Autocomplete
      * @param {array} args An array containing the link and the return object.
      */
      this.element.trigger('selected', [a, ret]);

      if (isEvent) {
        anchorOrEvent.preventDefault();
      }

      this.closeList();
      this.element.focus();

      return ret;
    },


    /*
    * Handle after list open.
    */
    handleAfterListOpen: function handleAfterListOpen() {
      // Fix one pixel off list by element
      if (this.element.offset().left > this.list.offset().left) {
        this.list.width(this.list.width() + 1);
      }

      return this;
    },


    /**
     * Update the component with new settings.
     * @param {object} settings The new settings object to use.
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      if (settings && settings.source) {
        this.settings.source = settings.source;
      }

      this.teardown().init();
      return this;
    },


    /**
    * Enable the input from readonly or disabled state.
    * @returns {void}
    */
    enable: function enable() {
      this.element.prop('disabled', false);
    },


    /**
    * Disable the input from editing
    * @returns {void}
    */
    disable: function disable() {
      this.element.prop('disabled', true);
    },
    teardown: function teardown() {
      var popup = this.element.data('popupmenu');
      if (popup) {
        popup.destroy();
      }

      this.element.off(['focus.' + COMPONENT_NAME$b, 'focusout.' + COMPONENT_NAME$b, 'input.' + COMPONENT_NAME$b, 'keydown.' + COMPONENT_NAME$b, 'listopen.' + COMPONENT_NAME$b, 'requestend.' + COMPONENT_NAME$b, 'resetfilter.' + COMPONENT_NAME$b, 'updated.' + COMPONENT_NAME$b].join(' '));
      return this;
    },


    /**
    * Teardown and remove any added markup and events.
    * @returns {void}
    */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$b);
    },


    /**
    * Setup the event handlers.
    * @private
    * @returns {void}
    */
    handleEvents: function handleEvents() {
      // similar code as dropdown but close enough to be dry
      var self = this;

      this.element.on('updated.' + COMPONENT_NAME$b, function () {
        self.updated();
      }).on('keydown.' + COMPONENT_NAME$b, function (e) {
        self.handleAutocompleteKeydown(e);
      }).on('input.' + COMPONENT_NAME$b, function (e) {
        self.handleAutocompleteInput(e);
      }).on('focus.' + COMPONENT_NAME$b, function () {
        self.handleAutocompleteFocus();
      }).on('focusout.' + COMPONENT_NAME$b, function () {
        self.checkActiveElement();
      })
      /**
      * Fires when the menu is opened.
      * @event listopen
      * @memberof Autocomplete
      * @param {object} event - The jquery event object
      * @param {object} ui - The dialog object
      */
      .on('listopen.' + COMPONENT_NAME$b, function () {
        self.handleAfterListOpen();
      })
      /**
      * Comes from Searchfields wrapping an autocomplete - resets
      * a filtered autocomplete back to normal.
      * @event listopen
      * @memberof Autocomplete
      * @param {object} event - The jquery event object
      */
      .on('resetfilter.' + COMPONENT_NAME$b, function () {
        self.resetFilters();
      });
    }
  };

  /**
   * jQuery Component Wrapper for Autocomplete
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */
  $.fn.autocomplete = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$b);

      // NOTE: This is modified due to a conflict between a legacy Soho attribute, `data-autocomplete`,
      // having the same value as jQuery's `$.data('autocomplete')`.
      if (typeof instance === 'string') {
        var stringSource = '' + instance;
        var modifiedSettings = utils.extend({}, settings, {
          source: stringSource || settings.source
        });
        instance = $.data(this, COMPONENT_NAME$b, new Autocomplete(this, modifiedSettings));
      } else if (!instance) {
        instance = $.data(this, COMPONENT_NAME$b, new Autocomplete(this, settings));
      } else {
        instance.updated(settings);
      }
    });
  };

  // Name of this component
  var COMPONENT_NAME$c = 'searchfield';

  // Types of collapse modes
  var SEARCHFIELD_COLLAPSE_MODES = [false, 'mobile', true];

  // Search Field Defaults
  var SEARCHFIELD_DEFAULTS = {
    resultsCallback: undefined,
    allResultsCallback: undefined,
    showAllResults: true,
    showGoButton: false,
    goButtonCopy: undefined,
    goButtonAction: undefined,
    categories: undefined,
    categoryMultiselect: false,
    showCategoryText: false,
    source: undefined,
    template: undefined,
    clearable: false,
    collapsible: SEARCHFIELD_COLLAPSE_MODES[0]
  };

  // Used throughout:
  var TOOLBARSEARCHFIELD_EXPAND_SIZE = 280;
  var MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE = 450;

  /**
   * The search field component.
   * @class SearchField
   * @param {jQuery[]|HTMLElement} element the base searchfield element
   * @param {object} [settings] incoming settings
   * @param {function} [settings.resultsCallback] Callback function for getting typahead results on search.
   * @param {function} [settings.allResultsCallback] Callback function for getting "all results".
   * @param {boolean} [settings.showAllResults = true] If true the show all results link is showin in the list.
   * @param {boolean} [settings.showGoButton = false] If true a go button is associated.
   * @param {string} [settings.goButtonCopy] The text to use on the go button.
   * @param {function} [settings.goButtonAction] If defined as a function, will fire this callback on the Go Button "click"
   * @param {array} [settings.categories] If defined as an array, displays a dropdown containing categories that can be used to filter results.
   * @param {boolean} [settings.categoryMultiselect = false]  If true, creates a multiselectable categories list.
   * @param {boolean} [settings.showCategoryText = false]  If true, will show any available categories that are selected
   * to the left of the Dropdown field.
   * @param {function} [settings.source] Callback function for getting type ahead results.
   * @param {string} [settings.template] The html template to use for the search list
   * @param {boolean} [settings.clearable = true] If "true", provides an "x" button on the right edge that clears the field
   * @param {boolean} [settings.collapsible = true] If "true", allows the field to expand/collapse on larger breakpoints when
   * focused/blurred respectively
   * @param {boolean} [settings.collapsibleOnMobile = true] If true, overrides `collapsible` only on mobile settings.
   */
  function SearchField(element, settings) {
    this.element = $(element);

    // Backwards compatibility for old toolbars that had `collapsible` and `clearable` as the defaults
    if (this.toolbarParent && !this.isContainedByFlexToolbar && settings !== undefined) {
      if (settings.clearable === undefined) {
        settings.clearable = true;
      }
      if (settings.collapsible === undefined) {
        settings.collapsible = true;
      }
    }

    this.settings = utils.mergeSettings(element, settings, SEARCHFIELD_DEFAULTS);
    this.init();
  }

  SearchField.prototype = {

    /**
     * @returns {HTMLElement} a toolbar parent element, or `undefined`
     */
    get toolbarParent() {
      var toolbarParents = this.element.parents('.toolbar');
      var toolbarFlexParents = this.element.parents('.flex-toolbar');

      if (toolbarParents.add(toolbarFlexParents).length < 1) {
        return undefined;
      }

      if (toolbarFlexParents.length > 0) {
        return toolbarFlexParents.first()[0];
      }

      return toolbarParents.first()[0];
    },

    /**
     * @returns {HTMLElement} a buttonset element, or `undefined`
     */
    get buttonsetElem() {
      if (!this.toolbarParent) {
        return undefined;
      }
      return this.toolbarParent.querySelector('.buttonset');
    },

    /**
     * @returns {HTMLElement} a toolbar `.title` area, if one is present.
     */
    get titleElem() {
      if (!this.toolbarParent) {
        return undefined;
      }
      return this.toolbarParent.querySelector('.title');
    },

    /**
     * @returns {HTMLElement} a toolbar parent element, or `undefined`
     */
    get containmentParent() {
      var moduleTabs = this.element.closest('.module-tabs');
      if (moduleTabs.length) {
        return moduleTabs.first()[0];
      }
      return this.toolbarParent;
    },

    /**
     * @returns {HTMLElement} a reference to the input field
     */
    get input() {
      return this.element[0];
    },

    /**
      @returns {HTMLElement} a reference to an optional button with an attached Category selection menu
     */
    get categoryButton() {
      return this.wrapper.find('.searchfield-category-button');
    },

    /**
     * @returns {boolean} whether or not the searchfield can ever be collapsible.
     */
    get isCollapsible() {
      return this.settings.collapsible !== false;
    },

    /**
     * @returns {boolean} whether or not the searchfield is currently able to be collapsed.
     */
    get isCurrentlyCollapsible() {
      return this.settings.collapsible === true || this.settings.collapsible === 'mobile' && this.shouldBeFullWidth();
    },

    /**
     * @private
     * @returns {boolean} whether or not the parent toolbar is a Flex Toolbar
     */
    get isContainedByFlexToolbar() {
      if (!this.containmentParent) {
        return false;
      }

      return this.containmentParent.className.indexOf('flex-toolbar') > -1;
    },

    /**
     * @private
     * @returns {ToolbarFlexItem|undefined} if inside a Flex Toolbar, returns a reference to the corresponding Toolbar Flex Item API
     */
    get toolbarFlexItem() {
      var item = void 0;
      if (this.isContainedByFlexToolbar) {
        item = $(this.element).data('toolbarflexitem');
      }

      return item;
    },

    /**
     * @private
     * @returns {Autocomplete|undefined} a reference to the Searchfield's optional Autocomplete API
     */
    get autocompleteAPI() {
      return $(this.element).data('autocomplete');
    },

    /**
     * @returns {boolean} whether or not this is a context searchfield.
     */
    get isContextSearch() {
      return this.wrapper[0].className.indexOf('context') > -1;
    },

    /**
     * Initialization Kickoff
     * @private
     * @returns {void}
     */
    init: function init() {
      this.coerceBooleanSettings();
      this.build();
      this.setupEvents();
    },


    /**
     * Builds the markup for this component.
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      // Used for managing events that are bound to $(document)
      if (!this.id) {
        this.id = utils.uniqueId(this.element, COMPONENT_NAME$c);
      }

      this.label = this.element.prev('label, .label');
      this.inlineLabel = this.element.closest('label');
      this.isInlineLabel = this.element.parent().is('.inline');

      // Invoke Autocomplete and store references to that and the popupmenu created by autocomplete.
      // Autocomplete settings are fed the same settings as Searchfield
      // NOTE: The `source` setting can be modified due to a conflict between a legacy Soho attribute,
      // `data-autocomplete`, having the same value as jQuery's `$.data('autocomplete')`.
      var autocompleteDataAttr = this.element.attr('data-autocomplete');
      if (autocompleteDataAttr && autocompleteDataAttr !== 'source') {
        this.settings.source = autocompleteDataAttr;
        this.element.removeAttr('data-autocomplete');
        $.removeData(this.element, 'autocomplete');
      }

      if (this.settings.source) {
        this.autocomplete = this.element.data('autocomplete');
        if (!this.autocomplete) {
          this.element.autocomplete(this.settings);
          this.autocomplete = this.element.data('autocomplete');
        } else {
          this.autocomplete.updated(this.settings);
        }
      }

      // Prevent browser typahead
      this.element.attr('autocomplete', 'off');

      // Setup ARIA
      var label = this.element.attr('placeholder') || this.element.prev('label, .label').text().trim();
      if (!label || label === '') {
        label = Locale.translate('Keyword');
      }
      this.element.attr({
        'aria-label': label
      });

      // Build the wrapper
      this.wrapper = this.element.parent('.searchfield-wrapper');
      if (!this.wrapper || !this.wrapper.length) {
        if (this.isInlineLabel) {
          this.wrapper = this.inlineLabel.addClass('searchfield-wrapper');
        } else {
          this.wrapper = this.element.wrap('<span class="searchfield-wrapper"></span>').parent();
        }
      }

      this.checkContents();

      // Label for toolbar-inlined searchfields needs to be inside the
      // wrapper to help with positioning.
      if (this.toolbarParent) {
        this.label.prependTo(this.wrapper);
      }

      var customClasses = ['context', 'alternate'];
      var c = void 0;

      for (var i = 0; i < customClasses.length; i++) {
        if (this.element.hasClass(customClasses[i])) {
          c = customClasses[i];
          this.wrapper.addClass(c);
          this.element.removeClass(c);
        }
      }

      // Backwards compatibility with collapsibleOnMobile
      // TODO: Remove in v4.9.0
      if (this.settings.collapsibleOnMobile === true) {
        this.settings.collapsible = SEARCHFIELD_COLLAPSE_MODES[1];
      }

      // Add/remove the collapsible functionality
      this.wrapper[0].classList[!this.settings.collapsible === true ? 'add' : 'remove']('non-collapsible');

      // Add/remove `toolbar-searchfield-wrapper` class based on existence of Toolbar Parent
      this.wrapper[0].classList[this.toolbarParent ? 'add' : 'remove']('toolbar-searchfield-wrapper');

      // Initially disable animations on toolbar searchfields
      // An event listener on Toolbar's `rendered` event removes these at the correct time
      if (this.toolbarParent && !this.isContainedByFlexToolbar) {
        this.element.add(this.wrapper).addClass('no-transition no-animation');
      }

      // Add Icon
      var icon = this.wrapper.find('.icon:not(.icon-dropdown)');
      if (!icon || !icon.length) {
        icon = $.createIconElement('search');
      }

      // Swap icon position to in-front if we have "context/has-categories" CSS class.
      var insertIconInFront = this.wrapper.hasClass('context') || this.wrapper.hasClass('has-categories');
      icon[insertIconInFront ? 'insertBefore' : 'insertAfter'](this.element).icon();

      // Change icon to a trigger button if we're dealing with categories
      if (this.hasCategories()) {
        this.wrapper.addClass('has-categories');

        if (!this.categoryButton.length) {
          $('<button type="button" class="btn searchfield-category-button"></button>').insertBefore(this.element);
        }
        icon.appendTo(this.categoryButton);
        icon = this.categoryButton;

        if (this.settings.showCategoryText) {
          this.wrapper.addClass('show-category');
        }

        var ddIcon = icon.find('.icon-dropdown');
        if (!ddIcon.length) {
          ddIcon = $.createIconElement({ classes: 'icon-dropdown', icon: 'dropdown' }).icon();
        }
        ddIcon.appendTo(icon);

        var popupAPI = this.categoryButton.data('popupmenu');
        if (!popupAPI) {
          this.list = this.wrapper.find('ul.popupmenu');
          if (!this.list || !this.list.length) {
            this.list = $('<ul class="popupmenu"></ul>');
          }

          // Handle Single vs Multi-Selectable Lists
          var categoryListType = this.settings.categoryMultiselect ? 'is-multiselectable' : 'is-selectable';
          this.list.addClass(categoryListType);
          var removeListType = 'is-selectable';
          if (!this.settings.categoryMultiselect) {
            removeListType = 'is-multiselectable';
          }
          this.list.removeClass(removeListType);

          this.setCategories(this.settings.categories);

          this.list.insertAfter(this.element);

          var _self = this;
          this.categoryButton.popupmenu({
            menu: this.list,
            offset: {
              y: 10
            },
            returnFocus: function returnFocus() {
              if (_self.isFocused) {
                _self.element.focus();
              }
            }
          });
        } else {
          this.setCategories(this.settings.categories);
        }

        this.setCategoryButtonText();
      }

      // Flex Toolbar Searchfields contain an extra button for use as a closing trigger
      if (this.isContainedByFlexToolbar) {
        if (!this.collapseButton || !this.collapseButton.length) {
          this.collapseButton = $('\n          <button class="btn-secondary collapse-button" type="button">\n            <svg class="icon" focusable="false" aria-hidden="true" role="presentation">\n              <use xlink:href="#icon-exit-fullview"></use>\n            </svg>\n            <span class="audible">' + Locale.translate('Collapse') + '</span>\n          </button>\n        ');
        }
        this.wrapper[0].classList.add('has-collapse-button');
        this.element.after(this.collapseButton);
      } else {
        this.wrapper[0].classList.remove('has-collapse-button');
      }

      // Pull a Go Button from markup, if applicable.
      var goButton = this.wrapper.next('.go-button');
      if (!goButton.length) {
        goButton = this.wrapper.find('.go-button');
      }

      if (goButton.length) {
        this.settings.showGoButton = true;
        this.goButton = goButton;
        this.element.after(this.goButton);
      }

      // Add a "Go" Button from scratch if we enable the setting
      if (this.settings.showGoButton) {
        if (!this.goButton || !this.goButton.length) {
          this.goButton = $('\n          <button class="btn-secondary go-button">\n            <span>' + (this.settings.goButtonCopy || Locale.translate('Go')) + '</span>\n          </button>\n        ');
        }
        this.goButton.attr('id', utils.uniqueId(this.goButton, 'searchfield-go-button-'));
        this.wrapper.addClass('has-go-button');
        this.element.after(this.goButton);
      } else {
        this.wrapper.removeClass('has-go-button');
      }

      if (this.settings.clearable) {
        this.element.clearable();
        this.xButton = this.wrapper.children('.icon.close');
      }

      // Stagger a calculation for setting the size of the Searchfield element, if applicable
      var self = this;
      var resizeTimer = new RenderLoopItem({
        duration: 1,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: function timeoutCallback() {
          self.calculateSearchfieldWidth();
        }
      });
      renderLoop.register(resizeTimer);

      if (this.settings.collapsible === false || this.settings.collapsible === 'mobile' && breakpoints.isAbove('phone-to-tablet')) {
        this.expand(true);
      }

      return this;
    },


    /**
     * Simpler version of `adjustOnBreakpoint` for non-collapsible Toolbar Flex searchfields
     */
    simpleAdjustOnBreakpoint: function simpleAdjustOnBreakpoint() {
      if (this.shouldBeFullWidth()) {
        if (!this.isFocused) {
          this.wrapper[0].classList.remove('is-open');
        }
        return;
      }

      this.wrapper[0].classList.add('is-open');
    },


    /**
     * Makes necessary adjustments to the DOM surrounding the Searchfield element to accommodate
     * breakpoint changes.
     * @private
     * @returns {void}
     */
    adjustOnBreakpoint: function adjustOnBreakpoint() {
      // On smaller form-factor (tablet/phone)
      if (this.shouldBeFullWidth()) {
        this.wrapper.removeAttr('style');
        this.input.removeAttribute('style');

        if (this.isFocused) {
          this.appendToParent();

          this.calculateOpenWidth();
          this.setOpenWidth();

          if (this.isExpanded) {
            return;
          }

          this.expand(true);
          return;
        }

        if (this.isCurrentlyCollapsible && this.isExpanded) {
          this.collapse();
        }

        if (this.isContainedByFlexToolbar) {
          this.wrapper[0].classList.remove('is-open');
        }

        return;
      }

      // On larger form-factor (desktop)
      this.appendToButtonset();

      if (this.isFocused || this.settings.collapsible === 'mobile') {
        if (!this.isExpanded) {
          this.expand(true);
        }
        return;
      }

      if (this.isExpanded) {
        this.collapse();
      }
    },


    /**
     * If focused, we need to store a reference to the element with focus
     * (for example: searchfield, internal buttons, etc) because once the element
     * becomes removed from the DOM, focus is lost.
     * @private
     * @returns {void}
     */
    saveFocus: function saveFocus() {
      if (!this.isFocused) {
        return;
      }
      this.focusElem = document.activeElement;
    },


    /**
     * Restores focus to an element reference that was previously focused.
     * @private
     * @returns {void}
     */
    restoreFocus: function restoreFocus() {
      if (!this.focusElem) {
        return;
      }

      var self = this;

      var focusTimer = new RenderLoopItem({
        duration: 1,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: function timeoutCallback() {
          if (!self.focusElem) {
            return;
          }
          self.focusElem.focus();
          delete self.focusElem;
        }
      });
      renderLoop.register(focusTimer);
    },


    /**
     * Appends this searchfield to the `containmentParent` element
     * Used when the small-form-factor searchfield needs to be established.
     * @private
     * @returns {void}
     */
    appendToParent: function appendToParent() {
      if (!this.containmentParent || this.wrapper.parent().is($(this.containmentParent))) {
        return;
      }

      if (this.isContainedByFlexToolbar) {
        return;
      }

      this.saveFocus();

      this.elemBeforeWrapper = this.wrapper.prev();
      $(this.containmentParent).find('.buttonset').prepend(this.wrapper);

      utils.fixSVGIcons(this.wrapper);

      this.restoreFocus();
    },


    /**
     * Removes this searchfield from the `containmentParent` element,
     * and places it back into the buttonset. Used when the small-form-factor
     * searchfield needs to be established.
     * @private
     * @returns {void}
     */
    appendToButtonset: function appendToButtonset() {
      if (!this.containmentParent || !this.wrapper.parent().is($(this.containmentParent))) {
        return;
      }

      if (this.isContainedByFlexToolbar) {
        return;
      }

      this.saveFocus();

      if (!(this.elemBeforeWrapper instanceof $) || !this.elemBeforeWrapper.length) {
        this.wrapper.prependTo($(this.buttonsetElem));
      } else {
        this.wrapper.insertAfter(this.elemBeforeWrapper);
        this.elemBeforeWrapper = null;
      }

      $(this.toolbarParent).triggerHandler('scrollup');
      utils.fixSVGIcons(this.wrapper);

      this.restoreFocus();
    },


    /**
     * Determines whether or not, when the Searchfield is expanded, the Searchfield should be placed
     *  over top of its sibling Toolbar elements, and take up 100% of its container's space.
     * @private
     * @returns {boolean} whether or not the Toolbar should be full width.
     */
    shouldBeFullWidth: function shouldBeFullWidth() {
      var header = this.wrapper.closest('.header');
      var headerCondition = false;

      if (header.length) {
        headerCondition = header.width() < breakpoints.phone;
      }

      return headerCondition || breakpoints.isBelow('phone-to-tablet');
    },


    /**
     * Determines whether or not the Searchfields should expand on the Mobile breakpoint.
     * @private
     * @returns {boolean} whether or not the searchfield should expand on mobile.
     */
    shouldExpandOnMobile: function shouldExpandOnMobile() {
      if (this.settings.collapsible === true) {
        return false;
      }
      if (this.settings.collapsible === 'mobile') {
        return true;
      }
      return this.shouldBeFullWidth();
    },


    /**
     * Set boolean value if strings
     * @private
     * @returns {void}
     */
    coerceBooleanSettings: function coerceBooleanSettings() {
      var arr = ['showAllResults', 'categoryMultiselect', 'showCategoryText', 'clearable'];
      this.settings = utils.coerceSettingsToBoolean(this.settings, arr);
    },


    /**
     * Reveals whether or not categories are active on this searchfield.
     * @returns {boolean} whether or not categories are active on this searchfield.
     */
    hasCategories: function hasCategories() {
      return this.settings.categories && $.isArray(this.settings.categories) && this.settings.categories.length > 0;
    },


    /**
     * Detects the existence of a "Go" button added to the main searchfield API
     * @returns {boolean} whether or not a "Go" button is present
     */
    hasGoButton: function hasGoButton() {
      return this.settings.showGoButton && this.goButton && this.goButton.length;
    },


    /**
    * Fires when the searchfield is focused.
    * @event focusin
    * @memberof ToolbarSearchfield
    * @property {object} event - The jquery event object
    * /
    /**
    * Fires when a key is pressed inside of the searchfield.
    * @event keydown
    * @memberof ToolbarSearchfield
    * @property {object} event - The jquery event object
    */
    /**
    *  Fires when a `collapse` event is triggered externally on the searchfield.
    * @event collapse
    * @memberof ToolbarSearchfield
    * @property {object} event - The jquery event object
    */
    /**
    *  Fires when a `beforeopen` event is triggered on the searchfield's optional categories menubutton.
    * @event beforeopen
    * @memberof ToolbarSearchfield
    * @property {object} event - The jquery event object
    */
    /**
    * Fires when a `navigate` event is triggered on the searchfield's parent toolbar.
    * @event navigate
    * @memberof ToolbarSearchfield
    * @property {object} event - The jquery event object
    */
    /**
    * Fires when a `keydown` event is triggered at the `document` level.
    * @event keydown
    * @memberof ToolbarSearchfield
    * @property {object} event - The jquery event object
    */
    /**
     * Fires when a `resize` event is triggered at the `body` level.
     * @event resize
     * @memberof ToolbarSearchfield
     * @property {object} event - The jquery event object
     */

    /**
     * Sets up the event-listening structure for this component instance.
     * @private
     * @returns {this} component instance
     */
    setupEvents: function setupEvents() {
      var _this = this;

      var self = this;

      self.element.on('updated.' + this.id, function (e, settings) {
        self.updated(settings);
      }).on('focus.' + this.id, function (e) {
        self.handleFocus(e);
      }).on('blur.' + this.id, function (e) {
        if (self.isContainedByFlexToolbar) {
          self.handleSafeBlur(e);
        }
      }).on('click.' + this.id, function (e) {
        self.handleClick(e);
      }).on('keydown.' + this.id, function (e) {
        self.handleKeydown(e);
      }).on('beforeopen.' + this.id, function (e, menu) {
        // propagates from Autocomplete's Popupmenu
        self.handlePopupBeforeOpen(e, menu);
      }).on('safe-blur.' + this.id, function () {
        // Triggered by Autocomplete
        self.handleSafeBlur();
      }).on('listclose.' + this.id, function () {
        // Triggered by Autocomplete
        self.handleSafeBlur();
      }).on('input.' + this.id, function () {
        self.checkContents();
      });

      self.wrapper.on('mouseenter.' + this.id, function () {
        $(this).addClass('is-hovered');
      }).on('mouseleave.' + this.id, function () {
        $(this).removeClass('is-hovered');
      });

      if (this.hasCategories()) {
        this.categoryButton.on('selected.' + this.id, function (e, anchor) {
          self.handleCategorySelected(e, anchor);
        }).on('focus.' + this.id, function (e) {
          self.handleCategoryFocus(e);
        }).on('blur.' + this.id, function () {
          self.handleSafeBlur();
        }).on('close.' + this.id, function () {
          // Popupmenu Close
          self.handleSafeBlur();
        }).on('beforeopen.' + this.id, function (e, menu) {
          // Popupmenu beforeOpen
          self.handlePopupBeforeOpen(e, menu);
        });
      }

      if (self.hasGoButton()) {
        self.goButton.on('click.' + this.id, function (e) {
          return self.handleGoButtonClick(e);
        }).on('click.' + this.id, function (e) {
          return self.handleGoButtonFocus(e);
        }).on('blur.' + this.id, function () {
          return self.handleSafeBlur();
        });
      }

      if (this.isCollapsible) {
        this.wrapper.on('focusin.' + this.id, function (e) {
          self.handleFocus(e);
        }).on('focusout.' + this.id, function (e) {
          self.handleBlur(e);
        }).on('keydown.' + this.id, function (e) {
          self.handleKeydown(e);
        }).on('collapse.' + this.id, function () {
          self.collapse();
        });

        $('body').on('resize.' + this.id, function () {
          self.adjustOnBreakpoint();
        });
        self.adjustOnBreakpoint();
      } else {
        $('body').on('resize.' + this.id, function () {
          self.simpleAdjustOnBreakpoint();
        });
        self.simpleAdjustOnBreakpoint();
      }

      if (this.collapseButton && this.collapseButton.length) {
        this.collapseButton.on('keydown.' + this.id, function (e) {
          self.collapseResponsive(e);
        }).on('click.' + this.id, function (e) {
          self.collapseResponsive(e);
        }).on('blur.' + this.id, function () {
          return self.handleSafeBlur();
        });
      }

      if (this.toolbarParent) {
        $(this.toolbarParent).on('navigate.' + this.id, function () {
          if (self.isFocused || !self.isCurrentlyCollapsible) {
            return;
          }
          self.collapse();
        }).on('rendered.' + this.id, function () {
          self.element.removeClass('no-transition no-animation');
          self.wrapper.removeClass('no-transition no-animation');
        });
      }

      // Insert the "view more results" link on the Autocomplete control's "populated" event
      self.element.on('populated.' + this.id, function (e, items) {
        if (items.length > 0) {
          if (self.settings.showAllResults) {
            self.addMoreLink();
          }
        } else {
          self.addNoneLink();
        }
      });

      // Setup a listener for the Clearable behavior, if applicable
      if (self.settings.clearable) {
        self.element.on('cleared.' + this.id, function () {
          if (self.autocomplete) {
            self.autocomplete.closeList();
          }
        });

        self.xButton.on('blur.' + this.id, function (e) {
          self.handleSafeBlur(e);
        });
      }

      // Override the 'click' listener created by Autocomplete (which overrides the
      // default Popupmenu method) to act differntly when the More Results link is activated.
      self.element.on('listopen.' + this.id, function () {
        var list = $('#autocomplete-list');

        // Visual indicator class
        self.wrapper.addClass('popup-is-open');

        // Trigger the `allResultsCallback` if one is defined
        self.element.on('selected.' + _this.id, function (thisE, a, ret) {
          var isMoreLink = a.hasClass('more-results');
          if (!isMoreLink) {
            return;
          }

          var callback = self.settings.allResultsCallback;
          if (callback && typeof callback === 'function') {
            callback(ret);
          }
        });

        // Override the focus event created by the Autocomplete control to make the more link
        // and no-results link blank out the text inside the input.
        list.find('.more-results, .no-results').on('focus.' + _this.id, function () {
          var anchor = $(this);
          list.find('li').removeClass('is-selected');
          anchor.parent('li').addClass('is-selected');
          self.element.val('');
        });
      }).on('listclose.' + this.id, function () {
        var list = $('#autocomplete-list');

        self.element.off('selected.' + _this.id);
        list.off('focus.' + _this.id);
      });

      return this;
    },


    /**
     * Activates a toolbar-based searchfield and keeps it "open".  Instead of closing
     * it on blur, sets up an explicit, out-of-bounds click/tap that will serve to close
     * it when the user acts.
     * @private
     * @param {boolean} force ignore any attempt to return out first
     * @param {boolean} doFocus focus the searchfield element.
     * @returns {void}
     */
    setAsActive: function setAsActive(force, doFocus) {
      var _this2 = this;

      if (!force && this.wrapper.hasClass('active')) {
        return;
      }

      this.addDocumentDeactivationEvents();

      var wrapperClasses = ['has-focus', 'active'];

      if (this.isCurrentlyCollapsible || this.isContainedByFlexToolbar) {
        this.expand(true);

        if (this.isContainedByFlexToolbar) {
          wrapperClasses.push('is-open');
        }
      }

      // Activate
      wrapperClasses.forEach(function (cssClass) {
        // IE11 compatibility doesn't allow for multiple arguments for `classList.add()`
        _this2.wrapper[0].classList.add(cssClass);
      });

      if (this.toolbarParent) {
        this.toolbarParent.classList.add('searchfield-active');
      }

      if (this.isExpanded) {
        return;
      }

      if (doFocus === true) {
        this.element.focus();
      }
    },


    /**
     * @returns {boolean} whether or not one of elements inside the Searchfield wrapper has focus.
     */
    get isFocused() {
      var active = document.activeElement;
      var wrapperElem = this.wrapper[0];

      // If another element inside the Searchfield Wrapper is focused, the entire component
      // is considered "focused".
      if (wrapperElem.contains(active)) {
        return true;
      }

      // Retain focus if the autocomplete menu is focused
      if (this.autocomplete) {
        var autocompleteListElem = this.autocomplete.list;
        if (autocompleteListElem && autocompleteListElem[0].contains(active)) {
          return true;
        }
      }

      // Retain focus if a category is being selected from a category menu
      if (this.categoryButton && this.categoryButton.length) {
        var menu = this.categoryButton.data('popupmenu').menu;
        if (menu.has(active).length) {
          return true;
        }
      }

      // Clearable button
      if (this.xButton && this.xButton.length) {
        if (this.xButton.has(active).length) {
          return true;
        }
      }

      return false;
    },

    /**
     * Detects whether or not the Searchfield has focus.
     * @deprecated in v4.8.0.  Please use the `isFocused` property instead.
     * @returns {boolean} whether or not the Searchfield has focus.
     */
    hasFocus: function hasFocus() {
      warnAboutDeprecation('isFocused', 'hasFocus');
      return this.isFocused;
    },


    /**
     * Focus event handler
     * @private
     * @returns {void}
     */
    handleFocus: function handleFocus() {
      this.setAsActive(true);
    },


    /**
     * Blur event handler
     * @private
     * @returns {void}
     */
    handleBlur: function handleBlur() {
      var self = this;

      if (Environment.os.name === 'ios') {
        $('head').triggerHandler('disable-zoom');
      }

      self.handleSafeBlur();
    },


    /**
     * Custom event handler for Autocomplete's `safe-blur` and `listclose` events.
     * Fired on the base element when any Autocomplete-related focusable element loses focus to
     * something outside the Autocomplete's wrapper
     * @private
     * @returns {void}
     */
    handleSafeBlur: function handleSafeBlur() {
      var self = this;
      function safeBlurHandler() {
        // Do a check for searchfield-specific elements
        if (self.isFocused) {
          return;
        }

        var wrapperElem = self.wrapper[0];
        wrapperElem.classList.remove('has-focus', 'active');

        self.removeDocumentDeactivationEvents();
        self.clearResponsiveState();

        if (self.isCurrentlyCollapsible) {
          self.collapse();
        } else if (self.isContainedByFlexToolbar) {
          self.wrapper[0].classList.remove('is-open');
        }
      }

      // Stagger the check for the activeElement on a timeout in order to accurately detect focus.
      if (this.blurTimer) {
        this.blurTimer.destroy(true);
      }
      this.blurTimer = new RenderLoopItem({
        duration: 1,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: safeBlurHandler
      });
      renderLoop.register(this.blurTimer);
    },


    /**
     * @private
     * @returns {void}
     */
    clearResponsiveState: function clearResponsiveState() {
      if (!this.toolbarParent) {
        return;
      }
      this.toolbarParent.classList.remove('searchfield-active');
    },


    /**
     * Click event handler
     * @private
     * @returns {void}
     */
    handleClick: function handleClick() {
      this.setAsActive();
    },


    /**
     * Sets up event listeners that need to be handled at the global (document) level, since they deal
     * with general keystrokes.
     * @private
     * @returns {void}
     */
    addDocumentDeactivationEvents: function addDocumentDeactivationEvents() {
      if (this.hasDeactivationEvents === true) {
        return;
      }

      var self = this;
      $(document).on('click.' + this.id, function (e) {
        self.handleOutsideClick(e);
      }).on('keydown.' + this.id, function (e) {
        self.handleOutsideKeydown(e);
      });

      this.hasDeactivationEvents = true;
    },


    /**
     * Removes global (document) level event handlers.
     * @private
     * @returns {void}
     */
    removeDocumentDeactivationEvents: function removeDocumentDeactivationEvents() {
      $(document).off('click.' + this.id + ' keydown.' + this.id);
      this.hasDeactivationEvents = false;
    },


    /**
     * Event Handler for dealing with global (document) level clicks.
     * @private
     * @param {jQuery.Event} e `click` event
     * @returns {void}
     */
    handleOutsideClick: function handleOutsideClick(e) {
      var target = e.target;
      if (this.isSearchfieldElement(target)) {
        return;
      }
      this.handleSafeBlur();
    },


    /**
     * Keydown event handler
     * @private
     * @param {jQuery.Event} e jQuery `keydown`
     * @returns {void}
     */
    handleKeydown: function handleKeydown(e) {
      var key = e.which;
      var keyName = e.key;

      if (key === 27 && Environment.browser.isIE11()) {
        e.preventDefault();
      }

      if (e.ctrlKey && key === 8) {
        this.element.val('');
      }

      if (key === 9) {
        // Tab
        this.handleSafeBlur();
      }

      if (this.isContainedByFlexToolbar) {
        var yKeys = ['ArrowUp', 'Up', 'ArrowDown', 'Down'];
        if (yKeys.indexOf(keyName) > -1) {
          this.collapse();
        }
      }
    },


    /**
     * Handles global (document) level keydown events that are established to help
     * collapse/de-highlight searchfields on a timer.
     * @private
     * @param {jQuery.Event} e jQuery-wrapped Keydown event
     * @returns {void}
     */
    handleOutsideKeydown: function handleOutsideKeydown(e) {
      var key = e.which;
      var target = e.target;

      if (key === 9 && !this.isSearchfieldElement(target)) {
        this.handleSafeBlur();
      }
    },


    /**
     * Modifies the menu at $('#autocomplete-list') to propagate/remove style
     *  classes on the Searchfield element.
     * @private
     * @param {jQuery.Event} e custom jQuery `beforeopen` event from the Popupmenu Component.
     * @param {jQuery[]} menu element that represents the popupmenu that is being opened.
     * @returns {boolean} the ability to cancel the menu's opening.
     */
    handlePopupBeforeOpen: function handlePopupBeforeOpen(e, menu) {
      if (this.isCollapsible && (this.isExpanding || !this.isExpanded) || !menu) {
        return false;
      }

      var contextClassMethod = this.wrapper.hasClass('context') ? 'addClass' : 'removeClass';
      var altClassMethod = this.wrapper.hasClass('alternate') ? 'addClass' : 'removeClass';

      menu[contextClassMethod]('context');
      menu[altClassMethod]('alternate');

      if (!this.isExpanded) {
        this.categoryButton.focus();
        return false;
      }

      return true;
    },


    /**
     * @private
     * @param {jQuery.Event} e jQuery `click` event
     * @returns {void}
     */
    handleGoButtonClick: function handleGoButtonClick(e) {
      var action = this.settings.goButtonAction;
      if (typeof action !== 'function') {
        return undefined;
      }

      var searchfieldValue = this.element.val();
      var categorySelection = void 0;

      if (this.hasCategories()) {
        categorySelection = this.getCategoryData();
      }

      // gives access to the current searchfield value, and category data if applicable.
      return action(e, searchfieldValue, categorySelection);
    },


    /**
     * @private
     * @returns {void}
     */
    handleGoButtonFocus: function handleGoButtonFocus() {
      this.setAsActive(true);
    },


    /**
     * Sets the text content on the category button.  Will either display a single category
     * name, or a translated "[x] Selected." string.
     * @param {string} [textContent] Optional incoming text that will be subtituted for the
     * selected element count.
     * @returns {undefined}
     */
    setCategoryButtonText: function setCategoryButtonText(textContent) {
      if (!this.settings.showCategoryText || !this.categoryButton.length) {
        return;
      }

      var text = '';
      var button = this.wrapper.find('.btn');
      var span = button.find('span');

      if (!span || !span.length) {
        span = $('<span class="category"></span>').insertAfter(button.find('.icon').first());
      }

      span.empty();

      // incoming text takes precedent
      if (typeof textContent === 'string' && textContent.length) {
        span.text(textContent.trim());
        return;
      }

      // Otherwise, grab currently selected categories and set text
      // (or clear, if no options are selected).
      var item = this.getSelectedCategories();
      if (!item.length) {
        return;
      }

      if (item.length > 1) {
        text = item.length + ' ' + Locale.translate('Selected');
      } else {
        text = item.text().trim();
      }

      span.text(text);
    },


    /**
     * Detects whether or not an element is part of this instance of the Searchfield component
     * @private
     * @param {HTMLElement} element the element being checked.
     * @returns {boolean} whether or not the element provided is part of this Searchfield component
     */
    isSearchfieldElement: function isSearchfieldElement(element) {
      if ($.contains(this.wrapper[0], element)) {
        return true;
      }

      // Don't close if a category is being selected from a category menu
      if (this.categoryButton && this.categoryButton.length) {
        var menu = this.categoryButton.data('popupmenu').menu;
        if (menu.has(element).length) {
          return true;
        }
      }

      return false;
    },


    /**
     * Retrieves the distance between a left and right boundary.
     * Used on controls like Lookup, Contextual Panel, etc. to fill the space remaining in a toolbar.
     * @private
     * @param {Number|jQuery[]} leftBoundary left boundary in pixels
     * @param {Number|jQuery[]} rightBoundary right boundary in pixels
     * @returns {number} the fill size area
     */
    getFillSize: function getFillSize(leftBoundary, rightBoundary) {
      var leftBoundaryNum = 0;
      var rightBoundaryNum = 0;

      function sanitize(boundary) {
        if (!boundary) {
          return 0;
        }

        // Return out if the boundary is just a number
        if (!isNaN(parseInt(boundary, 10))) {
          return parseInt(boundary, 10);
        }

        if (boundary instanceof jQuery) {
          if (!boundary.length) {
            return 0;
          }

          if (boundary.is('.title')) {
            boundary = boundary.next('.buttonset');
          }

          boundary = boundary[0];
        }

        return boundary;
      }

      function getEdgeFromBoundary(boundary, edge) {
        if (!isNaN(boundary)) {
          return boundary === null || boundary === undefined ? 0 : boundary;
        }

        if (!edge || typeof edge !== 'string') {
          edge = 'left';
        }

        var edges = ['left', 'right'];
        if ($.inArray(edge, edges) === -1) {
          edge = edges[0];
        }

        var rect = void 0;

        if (boundary instanceof HTMLElement || boundary instanceof SVGElement) {
          rect = boundary.getBoundingClientRect();
        }

        return rect[edge];
      }

      leftBoundary = sanitize(leftBoundary);
      rightBoundary = sanitize(rightBoundary);

      function whichEdge() {
        var e = 'left';
        if (leftBoundary === rightBoundary || $(rightBoundary).length && $(rightBoundary).is('.buttonset')) {
          e = 'right';
        }

        return e;
      }

      leftBoundaryNum = getEdgeFromBoundary(leftBoundary);
      rightBoundaryNum = getEdgeFromBoundary(rightBoundary, whichEdge());

      if (!leftBoundaryNum && !rightBoundaryNum) {
        return TOOLBARSEARCHFIELD_EXPAND_SIZE;
      }

      var distance = rightBoundaryNum - leftBoundaryNum;

      // TODO: Remove this once we figure out how to definitively fix the searchfield sizing.
      // Toolbar Searchfield needs a way to demand that the parent toolbar increase
      // the size of its buttonset and decrease the size of its title under this condition
      // -- currently there is no way.
      if (distance <= TOOLBARSEARCHFIELD_EXPAND_SIZE) {
        return TOOLBARSEARCHFIELD_EXPAND_SIZE;
      }

      if (distance >= MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE) {
        return MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE;
      }

      return distance;
    },


    /**
     * @private
     * @returns {void}
     */
    setClosedWidth: function setClosedWidth() {
      var closedWidth = 0;

      // If the searchfield category button exists, change the width of the
      // input field on the inside to provide space for the (variable) size of the currently-selected
      // category (or categories)
      if (this.categoryButton instanceof $ && this.categoryButton.length) {
        var buttonStyle = window.getComputedStyle(this.categoryButton[0]);
        var buttonWidth = this.categoryButton.width();
        var buttonBorder = parseInt(buttonStyle.borderLeftWidth, 10) * 2;
        var buttonPadding = parseInt(buttonStyle.paddingLeft, 10) + parseInt(buttonStyle.paddingRight, 10);

        closedWidth += buttonWidth + buttonBorder + buttonPadding + 4;
      }

      if (this.wrapper[0]) {
        this.wrapper[0].style.width = closedWidth + 'px';
      }
    },


    /**
     * @private
     * @returns {void}
     */
    setOpenWidth: function setOpenWidth() {
      var subtractWidth = 0;

      if (this.wrapper[0]) {
        this.wrapper[0].style.width = this.openWidth;
      }

      // If the searchfield category button exists, change the width of the
      // input field on the inside to provide space for the (variable) size of the currently-selected
      // category (or categories)
      if (this.hasCategories()) {
        var categoryButtonStyle = window.getComputedStyle(this.categoryButton[0]);
        var categoryButtonWidth = this.categoryButton.width();
        var categoryButtonPadding = parseInt(categoryButtonStyle.paddingLeft, 10) + parseInt(categoryButtonStyle.paddingRight, 10);
        var categoryButtonBorder = parseInt(categoryButtonStyle.borderLeftWidth, 10) * 2;

        subtractWidth += categoryButtonWidth + categoryButtonPadding + categoryButtonBorder;
      }

      if (this.hasGoButton()) {
        var goButtonStyle = window.getComputedStyle(this.goButton[0]);
        var goButtonWidth = this.goButton.width();
        var goButtonPadding = parseInt(goButtonStyle.paddingLeft, 10) + parseInt(goButtonStyle.paddingRight, 10);
        var goButtonBorder = parseInt(goButtonStyle.borderLeftWidth, 10) * 2;

        subtractWidth += goButtonWidth + goButtonPadding + goButtonBorder;
      }

      if (subtractWidth > 0) {
        this.input.style.width = 'calc(100% - ' + subtractWidth + 'px)';
      }

      delete this.openWidth;
    },


    /**
     * @private
     * @returns {void}
     */
    calculateOpenWidth: function calculateOpenWidth() {
      var buttonset = this.element.parents('.toolbar').children('.buttonset');
      var nextElem = this.wrapper.next();
      var width = void 0;

      if (!buttonset.length) {
        return;
      }
      // If small form factor, use the right edge
      if (nextElem.is('.title')) {
        nextElem = buttonset;
      }

      if (this.shouldBeFullWidth()) {
        width = '100%';

        if ($(this.toolbarParent).closest('.header').length) {
          width = 'calc(100% - 40px)';
        }
        if ($(this.toolbarParent).closest('.tab-container.module-tabs').length) {
          width = 'calc(100% - 1px)';
        }

        this.openWidth = width;
        return;
      }

      // Figure out boundaries
      // +10 on the left boundary reduces the likelyhood that the toolbar pushes other elements
      // into the spillover menu whenever the searchfield opens.
      var leftBoundary = buttonset.offset().left + 10;
      var rightBoundary = nextElem;

      // If the search input sits alone, just use the other side of the buttonset to measure
      if (!rightBoundary.length) {
        rightBoundary = buttonset.offset().left + 10 + buttonset.outerWidth(true);
      }

      width = this.getFillSize(leftBoundary, rightBoundary);
      this.openWidth = width - 6 + 'px';
    },


    /**
     * Ensures that the size of the Searchfield Wrapper does not change whenever a category
     * is chosen from a category searchfield.
     * NOTE: this method must be run AFTER changes to DOM elements (text/size changes) have been made.
     * @private
     */
    calculateSearchfieldWidth: function calculateSearchfieldWidth() {
      var inlineStyleProp = this.element[0].getAttribute('style');
      var baseWidth = '100%';
      var subtractWidth = 0;
      var targetWidthProp = void 0;

      if (inlineStyleProp) {
        this.element[0].removeAttribute('style');
      }

      var computedStyle = window.getComputedStyle(this.element[0]);
      if (computedStyle.width && !this.isContextSearch) {
        baseWidth = computedStyle.width;
      }

      // Subtract width of extraneous buttons/elems
      if (this.hasCategories()) {
        subtractWidth += this.categoryButton.outerWidth(true);
      }
      if (this.hasGoButton()) {
        subtractWidth += this.goButton.outerWidth(true);
      }

      // NOTE: final width can only be 100% if no value is subtracted for other elements
      if (subtractWidth > 0) {
        targetWidthProp = 'calc(' + baseWidth + ' - ' + subtractWidth + 'px)';
      }
      if (targetWidthProp) {
        this.element[0].style.width = targetWidthProp;
      }
    },


    /**
     * Category Selection event handler
     * @private
     * @param  {object} e The event.
     * @param  {object} anchor the link object
     */
    handleCategorySelected: function handleCategorySelected(e, anchor) {
      this.element.trigger('selected', [anchor]);

      // Only change the text and searchfield size if we can
      if (!this.settings.showCategoryText) {
        return;
      }

      this.setCategoryButtonText(e, anchor.text().trim());
      this.calculateSearchfieldWidth();

      if (!this.settings.categoryMultiselect) {
        this.setAsActive(true, true);
      }
    },


    /**
     * Category Button Focus event handler
     * @private
     * @returns {undefined}
     */
    handleCategoryFocus: function handleCategoryFocus() {
      this.saveFocus();
      this.setAsActive(true);
    },


    /**
     * Gets a complete list of categories in jQuery-collection form.
     * @returns {jQuery} categories
     */
    getCategories: function getCategories() {
      return this.list.children('li:not(.separator)');
    },


    /**
     * Gets the currently selected list of categories in jQuery-collection form.
     * @returns {jQuery} selectedCategories
     */
    getSelectedCategories: function getSelectedCategories() {
      return this.getCategories().filter('.is-checked');
    },


    /**
     * Gets the currently selected categories as data.
     * @param {boolean} [onlyReturnSelected=false] - If set to true, will only return
     *  checked list items.
     * @returns {Object[]} data -
     * @returns {string} name - Category name
     * @returns {string|number} id - Category element's ID (if applicable)
     * @returns {string|number} value - Category element's value (if applicable)
     * @returns {boolean} [checked=true] - Category's selection status
     */
    getCategoryData: function getCategoryData(onlyReturnSelected) {
      var categories = this.getCategories();
      var data = [];

      categories.each(function () {
        var classList = this.classList;
        var checked = classList.contains('is-checked');

        if (onlyReturnSelected === true && checked === false) {
          return;
        }

        var category = {
          name: this.innerText,
          checked: checked
        };

        if (this.id) {
          category.id = this.id;
        }

        var value = this.getAttribute('data-value');
        if (value !== undefined) {
          category.value = value;
        }

        data.push(category);
      });

      return data;
    },


    /**
     * Updates just the categories setting and rerenders the category list.
     * @param {Object[]} categories - Array of category object definitions.
     * @param {string} categories[].name - Category name.
     * @param {string|number} [id] - Category element's ID (if applicable).
     * @param {string|number} [value] - Category element's value (if applicable).
     * @param {boolean} [checked=true] - Category's selection status
     * @returns {undefined}
     */
    updateCategories: function updateCategories(categories) {
      this.settings.categories = categories;
      this.setCategories(this.settings.categories);
    },


    /**
     * Creates a new set of categories on the Searchfield and rerenders it.
     * @param {Object[]} categories - Array of category object definitions.
     * @param {string} categories[].name - Category name.
     * @param {string|number} [id] - Category element's ID (if applicable).
     * @param {string|number} [value] - Category element's value (if applicable).
     * @param {boolean} [checked=true] - Category's selection status
     * @returns {undefined}
     */
    setCategories: function setCategories(categories) {
      this.list.empty();

      var self = this;
      var valueTypes = ['string', 'number'];
      var previouslySelected = false;

      categories.forEach(function (val) {
        // if passed a string, typecast to an object.
        if (typeof val === 'string') {
          val = {
            name: val
          };
        }

        // Object types get a bit more customization.
        // Don't continue if there's no name present.
        if (!val.name) {
          return;
        }

        var id = '';
        if (typeof val.id === 'string' && val.id.length) {
          id = ' id="' + val.id + '"';
        }

        var value = '';
        if (valueTypes.indexOf(_typeof(val.value)) > -1) {
          value = ' data-value="' + val.value + '"';
        }

        var selected = '';
        if (val.checked === true && previouslySelected !== true) {
          selected = ' class="is-checked"';

          if (!self.settings.categoryMultiselect) {
            previouslySelected = true;
          }
        }

        self.list.append('<li' + selected + id + value + '><a href="#">' + val.name + '</a></li>');
      });

      var api = this.categoryButton.data('popupmenu');
      if (api && typeof api.updated === 'function') {
        api.updated();
      }
    },


    /**
     * Expands the Searchfield
     * @param {boolean} [noFocus] If defined, causes the searchfield component not to become focused
     *  at the end of the expand method. Its default functionality is that it will become focused.
     * @returns {Promise} resolved when the expansion completes
     */
    expand: function expand(noFocus) {
      var _this3 = this;

      var self = this;
      var expandPromise = new Promise(function (resolve) {
        if (self.isExpanded || self.isExpanding || self.isCollapsing) {
          resolve();
          return;
        }

        var notFullWidth = !self.shouldBeFullWidth();

        self.isExpanding = true;

        // Places the input wrapper into the toolbar on smaller breakpoints
        if (!notFullWidth) {
          self.appendToParent();
        }

        // Re-adjust the size of the buttonset element if the expanded searchfield would be
        // too large to fit.
        var buttonsetWidth = 0;
        if (self.buttonsetElem) {
          buttonsetWidth = parseInt(window.getComputedStyle(self.buttonsetElem).width, 10);
        }

        var buttonsetElemWidth = buttonsetWidth + TOOLBARSEARCHFIELD_EXPAND_SIZE;
        var containerSizeSetters = {
          buttonset: buttonsetElemWidth
        };

        if (!_this3.isContainedByFlexToolbar || breakpoints.isAbove('phone-to-tablet')) {
          _this3.wrapper[0].classList.add('is-open');
        }
        _this3.calculateOpenWidth();
        _this3.setOpenWidth();

        // Some situations require adjusting the focused element
        if (!noFocus || Environment.os.name === 'ios' || self.isFocused && document.activeElement !== self.input) {
          if (self.focusElem) {
            self.focusElem = self.input;
          }
          self.input.focus();
        }

        // Recalculate the Toolbar Buttonset/Title sizes.
        var eventArgs = [];
        if (containerSizeSetters) {
          eventArgs.push(containerSizeSetters);
        }

        self.element.trigger('beforeexpand');
        $(self.toolbarParent).triggerHandler('recalculate-buttons', eventArgs);

        var expandTimer = new RenderLoopItem({
          duration: 10,
          updateCallback: function updateCallback() {},
          // TODO: make this work without an empty function
          timeoutCallback: function timeoutCallback() {
            $(self.toolbarParent).triggerHandler('recalculate-buttons', eventArgs);
            self.element.trigger('expanded');
            delete self.isExpanding;
            self.isExpanded = true;

            if (self.isCurrentlyCollapsible && !self.isFocused && !self.focusElem) {
              self.handleSafeBlur();
            }
          }
        });
        renderLoop.register(expandTimer);
      });

      return expandPromise;
    },


    /**
     * Collapses the Searchfield
     * @returns {Promise} resolved once the collapse completes
     */
    collapse: function collapse() {
      var _this4 = this;

      var self = this;
      var collapsePromise = new Promise(function (resolve) {
        if (!self.isExpanded && self.isExpanding && !self.isCollapsing) {
          resolve();
          return;
        }

        self.isCollapsing = true;

        // Puts the input wrapper back where it should be if it's been moved due to small form factors.
        self.appendToButtonset();

        self.checkContents();

        self.clearResponsiveState();

        self.wrapper[0].classList.remove('active', 'is-open');
        if (Environment.browser.isIE11) {
          self.wrapper[0].classList.remove('is-open');
        }
        if (_this4.isContainedByFlexToolbar || !_this4.isFocused) {
          self.wrapper[0].classList.remove('has-focus');
        }

        self.wrapper.removeAttr('style');
        self.input.removeAttribute('style');

        if (self.categoryButton && self.categoryButton.length) {
          self.categoryButton.data('popupmenu').close(false, true);
        }

        self.element.trigger('beforecollapse');

        if (Environment.os.name === 'ios') {
          $('head').triggerHandler('enable-zoom');
        }

        delete self.isExpanded;
        delete self.isExpanding;

        var collapseTimer = new RenderLoopItem({
          duration: 10,
          updateCallback: function updateCallback() {},
          // TODO: make this work without an empty function
          timeoutCallback: function timeoutCallback() {
            delete self.isCollapsing;
            $(self.toolbarParent).triggerHandler('recalculate-buttons');
            self.element.trigger('collapsed');
            resolve();
          }
        });

        renderLoop.register(collapseTimer);
      });

      return collapsePromise;
    },


    /**
     * @private
     * @param {jQuery.Event} e incoming click event (driven either by keyboard or actual click)
     * @returns {void}
     */
    collapseResponsive: function collapseResponsive(e) {
      if (this.previouslyCollapsedByKey && e.type === 'click') {
        delete this.previouslyCollapsedByKey;
        return;
      }

      // Navigate forward unless the event has been driven by a keystroke
      var self = this;
      var dir = 1;
      if (e && !e.key) {
        dir = 0;
        if (this.toolbarFlexItem && this.toolbarFlexItem.focused) {
          dir = 1;
        }
      }

      if (e.type === 'keydown') {
        this.previouslyCollapsedByKey = true;
      }

      // Collapse followed by a special event trigger (gets picked up by Flex Toolbar)
      this.collapse().then(function () {
        self.wrapper.trigger('collapsed-responsive', [dir]);
      });
    },


    /**
     * Adds/removes a CSS class to the searchfield wrapper depending on whether or not the input field is empty.
     * Needed for expand/collapse scenarios, for proper searchfield resizing.
     * @private
     * @returns {void}
     */
    checkContents: function checkContents() {
      var textMethod = 'remove';
      var value = !this.input.value ? '' : this.input.value.trim();
      if (value !== '') {
        textMethod = 'add';
      }
      this.wrapper[0].classList[textMethod]('has-text');
    },


    /**
     * Adds a link at the bottom of a searchfield with more than (0) results that can be used to link out to a
     * larger display of search results.
     * @private
     * @returns {void}
     */
    addMoreLink: function addMoreLink() {
      var list = $('#autocomplete-list');
      var val = this.element.val();

      if ($('.more-results', list).length > 0) {
        return;
      }

      var separator = $('<li class="separator" role="presentation"></li>').appendTo(list);
      var more = $('<li role="presentation"></li>').appendTo(list);
      this.moreLink = $('<a href="#" class="more-results" tabindex="-1" role="menuitem"></a>').html('<span>' + Locale.translate('AllResults') + ' "' + xssUtils.ensureAlphaNumeric(val) + '"</span>').appendTo(more);

      if (this.autocomplete.maxWidth) {
        separator.width(this.autocomplete.maxWidth + 'px');
      }
    },


    /**
     * Adds a link at the bottom of a searchfield with no results that announces no search results.
     * @private
     * @returns {void}
     */
    addNoneLink: function addNoneLink() {
      var list = $('#autocomplete-list');
      if ($('.no-results', list).length > 0) {
        return;
      }

      var none = $('<li role="presentation" class="is-placeholder"></li>').appendTo(list);

      this.noneLink = $('<a href="#" class="no-results" disabled="disabled" tabindex="-1" role="menuitem" aria-disabled="true"></a>').html('<span>' + Locale.translate('NoResults') + '</span>').appendTo(none);
    },


    /**
     * Tears down and rebuilds the Searchfield. Can be called directly, but is also
     * triggered by calling the "updated.searchfield" event on the searchfield element.
     * @param {object} [settings] incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }
      this.teardown().init();
    },


    /**
     * Disables the Searchfield
     * @returns {void}
     */
    disable: function disable() {
      this.wrapper.addClass('is-disabled');
      this.element.prop('disabled', true);
    },


    /**
     * Enables the Searchfield
     * @returns {void}
     */
    enable: function enable() {
      this.wrapper.removeClass('is-disabled');
      this.element.prop('disabled', false);
    },


    /**
     * Unbinds events and removes unnecessary markup.
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.element.off(['updated.' + this.id, 'focus.' + this.id, 'blur.' + this.id, 'click.' + this.id, 'keydown.' + this.id, 'beforeopen.' + this.id, 'input.' + this.id, 'listopen.' + this.id, 'listclose.' + this.id, 'safe-blur.' + this.id, 'selected.' + this.id, 'populated.' + this.id, 'cleared.' + this.id].join(' '));

      this.wrapper.off(['mouseenter.' + this.id, 'mouseleave.' + this.id, 'focusin.' + this.id, 'focusout.' + this.id, 'keydown.' + this.id, 'collapse.' + this.id].join(' '));

      if (this.toolbarParent) {
        $(this.toolbarParent).off('navigate.toolbarsearchfield');
      }

      if (this.goButton && this.goButton.length) {
        this.goButton.off('click.' + this.id + ' blur.' + this.id).remove();
        delete this.goButton;
      }

      if (this.categoryButton && this.categoryButton.length) {
        this.categoryButton.off().remove();
        delete this.categoryButton;
      }

      if (this.collapseButton && this.collapseButton.length) {
        this.collapseButton.off().remove();
        delete this.collapseButton;
        delete this.previouslyCollapsedByKey;
      }

      // Used to determine if the "Tab" key was involved in switching focus to the searchfield.
      this.removeDocumentDeactivationEvents();
      $('body').off('resize.' + this.id);

      if (this.autocomplete) {
        this.autocomplete.destroy();
      }

      if (this.wrapper.hasClass('context')) {
        this.element.addClass('context');
      }

      this.element.next('.icon').remove();
      if (this.element.parent().hasClass('searchfield-wrapper')) {
        this.element.parent().find('ul').remove();
        this.element.parent().find('.icon').remove();
      }

      if (this.xButton && this.xButton.length) {
        this.xButton.off('blur.' + this.id);
        this.xButton.remove();
      }

      return this;
    },


    /**
     * Destroys the Searchfield and removes all jQuery component instancing.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$c);
    }
  };

  /**
   * jQuery Component Wrapper for SearchField
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.searchfield = function (settings) {
    return this.each(function () {
      // Normal invoke setup
      var instance = $.data(this, COMPONENT_NAME$c);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$c, new SearchField(this, settings));
      }
    });
  };

  /* eslint-disable no-underscore-dangle, prefer-arrow-callback */

  // Name of the component in this file.
  var COMPONENT_NAME$d = 'applicationmenu';

  /**
   * The Application Menu provides access to all the functions, pages, and forms in an application.
   * @class ApplicationMenu
   * @param {object} element The element that gets the plugin established on it.
   * @param {object} [settings] The settings to use on this instance.
   * @param {string} [settings.breakpoint='phone-to-tablet'] Can be 'tablet' or 'phone-to-tablet' (+767),
   * 'phablet (+610)', 'desktop' +(1024) or 'tablet-to-desktop' (+1280). Default is 'phone-to-tablet' (767)
   * @param {boolean} [settings.dismissOnClickMobile=false] If true, causes a clicked menu option to dismiss on click when the responsive view is shown.
   * @param {boolean} [settings.filterable=false] If true a search / filter option will be added.
   * @param {boolean} [settings.openOnLarge=false]  If true, will automatically open the Application Menu when a large screen-width breakpoint is met.
   * @param {array} [settings.triggers=[]]  An Array of jQuery-wrapped elements that are able to open/close this nav menu.
   */
  var APPLICATIONMENU_DEFAULTS = {
    breakpoint: 'phone-to-tablet',
    dismissOnClickMobile: false,
    filterable: false,
    openOnLarge: false,
    triggers: []
  };

  function ApplicationMenu(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, APPLICATIONMENU_DEFAULTS);

    return this.init();
  }

  // Plugin Methods
  ApplicationMenu.prototype = {

    /**
     * Initialize the plugin.
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup().handleEvents();
    },


    /**
     * @private
     * @returns {this} component instance
     */
    setup: function setup() {
      this.hasTrigger = false;
      this.isAnimating = false;

      if (!this.hasTriggers()) {
        this.triggers = $();
      }

      this.menu = this.element;

      var openOnLarge = this.element.attr('data-open-on-large');
      this.settings.openOnLarge = openOnLarge !== undefined ? openOnLarge === 'true' : this.settings.openOnLarge;

      var dataBreakpoint = this.element.attr('data-breakpoint');
      this.settings.breakpoint = breakpoints[dataBreakpoint] !== undefined ? dataBreakpoint : this.settings.breakpoint;

      // Pull in the list of Nav Menu trigger elements and store them internally.
      this.modifyTriggers(this.settings.triggers, false, true);

      this.scrollTarget = this.menu.parents('.header');
      var masthead = this.menu.prevAll('.masthead');
      var moduleTabs = this.menu.prevAll('.module-tabs');

      if (masthead.length > 0) {
        this.scrollTarget = masthead;
        this.menu.addClass('short');
      }
      if (moduleTabs.length > 0) {
        this.scrollTarget = moduleTabs;
      }

      this.accordion = this.menu.find('.accordion');
      this.accordion.addClass('panel').addClass('inverse');

      // Check to make sure that the internal Accordion Control is invoked
      var accordion = this.accordion.data('accordion');
      if (!accordion) {
        this.accordion.accordion();
        accordion = this.accordion.data('accordion');
      }
      this.accordionAPI = accordion;

      // detect the presence of a searchfield
      this.searchfield = this.element.children('.searchfield, .searchfield-wrapper');

      // Setup filtering, if applicable.
      if (this.settings.filterable && typeof $.fn.searchfield === 'function') {
        if (this.searchfield.length) {
          if (this.searchfield.is('.searchfield-wrapper')) {
            this.searchfield = this.searchfield.children('.searchfield');
          }
        } else {
          this.searchfield = $('' + ('<div class="searchfield-wrapper">' + '<label for="application-menu-searchfield">') + Locale.translate('Search') + '</label>' + '<input id="application-menu-searchfield" class="searchfield" /></div>').prependTo(this.element);
        }

        this.element.addClass('has-searchfield');
        var self = this;
        this.searchfield.searchfield({
          clearable: true,
          source: function source(term, done, args) {
            done(term, self.accordion.data('accordion').toData(true, true), args);
          },
          searchableTextCallback: function searchableTextCallback(item) {
            return item.text || '';
          },
          resultIteratorCallback: function resultIteratorCallback(item) {
            item.highlightTarget = 'text';
            return item;
          },
          clearResultsCallback: function clearResultsCallback() {
            self.accordionAPI.unfilter();
          },
          displayResultsCallback: function displayResultsCallback(results, done) {
            return self.filterResultsCallback(results, done);
          }
        });
      } else if (this.searchfield.length) {
        this.searchfield.off();
        this.searchfield.parent('.searchfield-wrapper').remove();
        delete this.searchfield;
      }

      // Sync with application menus that have an 'is-open' CSS class.
      // Otherwise, just adjust the height.
      if (this.isOpen()) {
        this.openMenu(false, false, true);
      } else {
        this.adjustHeight();
      }

      return this;
    },


    /**
     * Gets a reference to this Application Menu's adjacent container element.
     * @returns {jQuery[]} the adjacent container element
     */
    getAdjacentContainerElement: function getAdjacentContainerElement() {
      var container = this.element.next('.page-container');
      if (!container.length) {
        container = $('body');
      }
      return container;
    },


    /**
     * Setup click events on this.element if it's not the menu itself.
     * (this means that it's a trigger button).
     * @returns {void}
     */
    handleTriggerEvents: function handleTriggerEvents() {
      var self = this;

      function triggerClickHandler(e) {
        // Don't allow hamburger buttons that have changed state to activate/deactivate the app menu.
        if ($(e.currentTarget).find('.icon.app-header').hasClass('go-back')) {
          return false;
        }

        if (self.isAnimating) {
          return false;
        }

        var isOpen = self.menu.hasClass('is-open');
        if (!isOpen) {
          self.openMenu(undefined, true);
        } else {
          self.closeMenu(true);
        }
        return true;
      }

      if (this.triggers.length) {
        this.triggers.off('click.applicationmenu').on('click.applicationmenu', triggerClickHandler);
      }

      $(document).on('keydown.applicationmenu', function (e) {
        self.handleKeyDown(e);
      });
    },


    /**
     * Handles Keydown Events on the App Menu
     * @param {jQuery.Event} e `keydown` events
     * @returns {boolean} whether or not the keydown event was successful
     */
    handleKeyDown: function handleKeyDown(e) {
      var key = e.which;

      if (key === 121 && !e.shiftKey) {
        // F10 - opens the menu
        e.preventDefault();

        if (this.isOpen()) {
          this.closeMenu(true);
          if (this.triggers.length) {
            this.triggers.eq(0).focus();
          }
        } else {
          this.openMenu();
        }

        return false;
      }

      return true;
    },


    /**
     * Adds a visual badge-style notification to an Application Menu accordion header
     * @param {jQuery[]} anchor the anchor to target
     * @param {number} value the numeric value to attach
     * @returns {jQuery[]|undefined} a reference to the new tag markup, if applicable
     */
    notify: function notify(anchor, value) {
      if (!anchor || anchor === undefined) {
        return undefined;
      }
      if (anchor instanceof HTMLElement) {
        anchor = $(anchor);
      }
      if (!anchor.is('a')) {
        return undefined;
      }

      var tag = anchor.find('.tag');

      // Close the tag if an undefined or '0' value is passed
      if (!value || value === undefined || parseInt(value, 10) === 0) {
        if (tag.length) {
          tag.remove();
        }
        return undefined;
      }

      if (!tag.length) {
        tag = $('<span class="tag"></span>').appendTo(anchor);
      }

      tag.text(value.toString());
      return tag;
    },


    /**
     * Adjusts the application menu's height to fit the page.
     * @private
     * @returns {void}
     */
    adjustHeight: function adjustHeight() {
      var isSticky = this.scrollTarget.is('.is-sticky');
      var totalHeight = this.scrollTarget.outerHeight(true);
      var offset = totalHeight - (!isSticky ? $(window).scrollTop() : 0);

      if (this.scrollTarget.prev().is('.masthead')) {
        offset += this.scrollTarget.prev().outerHeight(true);
      }

      this.menu[0].style.height = offset > 0 ? 'calc(100% - ' + offset + 'px)' : '100%';
    },


    /**
     * Checks the window size against the defined breakpoint.
     * @private
     * @returns {boolean} whether or not the window size is larger than the
     *  settings-defined breakpoint
     */
    isLargerThanBreakpoint: function isLargerThanBreakpoint() {
      return breakpoints.isAbove(this.settings.breakpoint);
    },


    /**
     * Detects whether or not the application menu is open
     * @returns {boolean} whether or not the application menu is open
     */
    isOpen: function isOpen() {
      return this.menu[0].classList.contains('is-open');
    },


    /**
     * Detects a change in breakpoint size that can cause the Application Menu's state to change.
     * @returns {void}
     */
    testWidth: function testWidth() {
      if (this.isOpen()) {
        if (breakpoints.isAbove(this.settings.breakpoint)) {
          this.element[0].classList.remove('show-shadow');
          return;
        }

        this.element[0].classList.add('show-shadow');

        if (this.isAnimating) {
          return;
        }

        if (!this.userOpened) {
          this.closeMenu();
        }
        return;
      }

      if (breakpoints.isBelow(this.settings.breakpoint)) {
        return;
      }

      if (this.userClosed || !this.settings.openOnLarge || this.isAnimating) {
        return;
      }

      this.openMenu(true);
    },


    /**
     * Opens the Application Menu
     * @param {boolean} noFocus If true, sets focus on the first item in the application menu.
     * @param {boolean} [userOpened] If true, notifies the component that the menu was
     *  manually opened by the user.
     * @param {boolean} [openedByClass] If true, only adjusts bare-miniumum requirements
     *  for the application menu to appear open (should be used in cases where the application
     *  menu has the `is-open` CSS appended to it via markup).  This skips events, animation, etc.
     */
    openMenu: function openMenu(noFocus, userOpened, openedByClass) {
      if (this.isAnimating === true) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitonEndName;

      if (!openedByClass) {
        this.isAnimating = true;
      }
      this.adjustHeight();

      function isOpen() {
        if (self.timeout !== null) {
          clearTimeout(self.timeout);
          self.timeout = null;
        }

        if (userOpened) {
          self.userOpened = true;
          self.userClosed = undefined;
        }

        /**
        * Fires the menu is opened
        *
        * @event applicationmenuopen
        * @memberof ApplicationMenu
        * @param {object} event - The jquery event object
        */
        if (!openedByClass) {
          self.isAnimating = false;
          self.element.trigger('applicationmenuopen');
          $('body').triggerHandler('resize');
        }

        self.menu.removeClass('no-transition');
        $('.page-container').removeClass('no-transition');
      }

      this.triggers.each(function () {
        var trig = $(this);
        if (trig.parents('.header').length > 0 || trig.parents('.masthead').length > 0) {
          var header = trig.parents('.header, .masthead');
          if (header.parents('.page-container').length) {
            return;
          }

          trig.find('.icon.app-header').removeClass('go-back').addClass('close');
          trig.trigger('icon-change');
        }
      });

      // Animate the application menu open.
      // If opened by class, `is-open` is already applied to the app menu at this
      // point in the render cycle, and should not be re-applied.
      if (!openedByClass) {
        this.menu.off(transitionEnd + '.applicationmenu');
        this.menu[0].style.display = '';
        // next line forces a repaint
        // eslint-disable-next-line
        this.menu[0].offsetHeight;
        this.menu.addClass('is-open');
      }

      if (breakpoints.isBelow(this.settings.breakpoint)) {
        this.menu.addClass('show-shadow');
      }

      if (!noFocus || noFocus !== true) {
        this.menu.find('.is-selected > a').focus();
      }

      if (Environment.os.name === 'ios') {
        var container = this.getAdjacentContainerElement();
        container.addClass('ios-click-target');
      }

      if (!openedByClass) {
        this.menu.one(transitionEnd + '.applicationmenu', isOpen);
        this.timeout = setTimeout(isOpen, 300);
      } else {
        isOpen();
      }

      // Events that will close the nav menu
      // On a timer to prevent conflicts with the Trigger button's click events
      setTimeout(function () {
        $(document).on('click.applicationmenu', function (e) {
          if ($(e.target).parents('.application-menu').length < 1 && !self.isLargerThanBreakpoint()) {
            self.closeMenu(true);
          }
        });
      }, 0);
    },


    /**
     * Closes the Application Menu
     * @param {boolean} [userClosed] if true, sets a flag notifying the component
     *  that the user was responsible for closing.
     */
    closeMenu: function closeMenu(userClosed) {
      if (this.isAnimating === true) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitionEndName();

      this.isAnimating = true;

      function close() {
        if (self.timeout !== null) {
          clearTimeout(self.timeout);
          self.timeout = null;
        }

        self.menu.off(transitionEnd + '.applicationmenu');
        self.menu[0].style.display = 'none';
        self.isAnimating = false;

        if (userClosed) {
          self.userOpened = undefined;
          self.userClosed = true;
        }

        /**
        * Fires the menu is closed
        *
        * @event applicationmenuclose
        * @memberof ApplicationMenu
        * @param {object} event - The jquery event object
        */
        self.element.trigger('applicationmenuclose');
        $('body').triggerHandler('resize');
      }

      this.triggers.each(function () {
        var trig = $(this);
        if (trig.parents('.header').length > 0 || trig.parents('.masthead').length > 0) {
          trig.find('.icon.app-header').removeClass('close');
          trig.trigger('icon-change');
        }
      });

      if (Environment.os.name === 'ios') {
        var container = this.getAdjacentContainerElement();
        container.removeClass('ios-click-target');
      }

      this.menu.one(transitionEnd + '.applicationmenu', close);
      this.timeout = setTimeout(close, 300);

      this.menu.removeClass('is-open show-shadow').find('[tabindex]');
      $(document).off('click.applicationmenu');
    },


    /**
     * Detects whether or not the Application Menu has external trigger buttons setup to control it.
     * @returns {boolean} whether or not external triggers have been defined.
     */
    hasTriggers: function hasTriggers() {
      return this.triggers !== undefined && this.triggers instanceof $ && this.triggers.length;
    },


    /**
     * Externally Facing function that can be used to add/remove application nav menu triggers.
     * @param {Array[]} triggers an array of HTMLElements or jQuery-wrapped elements that
     *  will be used as triggers.
     * @param {boolean} [remove] if defined, triggers that are defined will be removed
     *  internally instead of added.
     * @param {boolean} [norebuild] if defined, this control's events won't automatically
     *  be rebound to include the new triggers.
     */
    modifyTriggers: function modifyTriggers(triggers, remove, norebuild) {
      if (!triggers || !triggers.length) {
        return;
      }
      var changed = $();

      $.each(triggers, function (i, obj) {
        changed = changed.add($(obj));
      });

      this.triggers = this.triggers[!remove ? 'add' : 'not'](changed);
      this.handleTriggerEvents();

      if (norebuild && norebuild === true) {
        return;
      }

      this.updated();
    },


    /**
     * @param {array} results list of items that passed the filtering process
     * @param {function} done method to be called when the display of filtered items completes.
     * @returns {void}
     */
    filterResultsCallback: function filterResultsCallback(results, done) {
      if (!results || !results.length) {
        this.accordionAPI.unfilter();
        done();
        return;
      }

      var headers = $(results.map(function (item) {
        return item.element;
      }));
      this.accordionAPI.filter(headers, true);

      this.element.triggerHandler('filtered', [results]);
      done();
    },


    /**
     * handles the Searchfield Input event
     * @param {jQuery.Event} e jQuery `input` event
     */
    handleSearchfieldInputEvent: function handleSearchfieldInputEvent() {
      if (!this.searchfield || !this.searchfield.length) {
        return;
      }

      var val = this.searchfield.val();

      if (!val || val === '') {
        var filteredParentHeaders = this.accordion.find('.has-filtered-children');
        this.accordionAPI.headers.removeClass('filtered has-filtered-children');
        this.accordionAPI.collapse(filteredParentHeaders);
        this.accordionAPI.updated();
        this.element.triggerHandler('filtered', [[]]);
      }
    },


    /**
     * @param {jQuery} anchor the anchor being checked
     * @returns {void}
     */
    handleDismissOnClick: function handleDismissOnClick(anchor) {
      if (!this.settings.dismissOnClickMobile) {
        return;
      }

      this.userOpened = false;
      $(anchor).blur();
      if (this.isLargerThanBreakpoint()) {
        return;
      }

      this.closeMenu();
    },


    /**
     * Unbinds event listeners and removes extraneous markup from the Application Menu.
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.menu.off('animateopencomplete animateclosedcomplete').removeClass('short').removeAttr('style');

      $(window).off('scroll.applicationmenu');
      $('body').off('resize.applicationmenu');
      $(document).off('click.applicationmenu open-applicationmenu close-applicationmenu keydown.applicationmenu');

      this.accordion.off('blur.applicationmenu selected.applicationmenu followlink.applicationmenu');
      if (this.accordionAPI && typeof this.accordionAPI.destroy === 'function') {
        if (this.isFiltered) {
          this.accordionAPI.collapse();
        }
        this.accordionAPI.destroy();
      }

      if (this.searchfield && this.searchfield.length) {
        this.searchfield.off('input.applicationmenu');
        var sfAPI = this.searchfield.data('searchfield');
        if (sfAPI) {
          sfAPI.destroy();
        }
      }

      if (this.hasTriggers()) {
        this.triggers.off('click.applicationmenu');
      }

      return this;
    },


    /**
     * Triggers a UI Resync.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
     * Teardown - Remove added markup and events
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$d);
    },


    /**
     * This component fires the following events.
     * @fires Applicationmenu#events
     * @listens applicationmenuopen  Fires when the menu is opened.
     * @listens applicationmenuclose  Fires as the menu is closed.
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.handleTriggerEvents();

      // Setup notification change events
      this.menu.on('notify.applicationmenu', function (e, anchor, value) {
        self.notify(anchor, value);
      }).on('updated.applicationmenu', function () {
        self.updated();
      });

      this.accordion.on('blur.applicationmenu', function () {
        self.closeMenu();
      }).on('selected.applicationmenu', function (e, header) {
        var a = $(header).children('a');
        self.handleDismissOnClick(a);
      }).on('followlink.applicationmenu', function (e, anchor) {
        self.handleDismissOnClick(anchor);
      });

      $(document).on('open-applicationmenu', function () {
        self.openMenu(undefined, true);
      }).on('close-applicationmenu', function () {
        self.closeMenu();
      });

      $(window).on('scroll.applicationmenu', function () {
        self.adjustHeight();
      });

      $('body').on('resize.applicationmenu', function () {
        self.testWidth();
      });

      if (this.settings.filterable === true && this.searchfield && this.searchfield.length) {
        this.searchfield.on('input.applicationmenu', function (e) {
          self.handleSearchfieldInputEvent(e);
        });
      }

      if (this.settings.openOnLarge && this.isLargerThanBreakpoint()) {
        this.menu.addClass('no-transition');
        $('.page-container').addClass('no-transition');
      }
      this.testWidth();

      // Remove after initial transition
      setTimeout(function () {
        self.menu.removeClass('no-transition');
        $('.page-container').removeClass('no-transition');
      }, 800);

      return this;
    }
  };

  /**
   * jQuery component wrapper for the Application Menu
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.applicationmenu = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$d);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$d, new ApplicationMenu(this, settings));
      }
      return instance;
    });
  };

  // Settings and Options
  var COMPONENT_NAME$e = 'blockgrid';

  /**
   * Component Name - Does this and that.
   * @class Blockgrid
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {array} [settings.dataset=[]] An array of data objects
   * @param {string} [settings.selectable=false] Controls the selection mode this can be:
   * @param {boolean} paging Enable paging mode
   * @param {number} pagesize Number of rows per page
   * @param {array} pagesizes Array of page sizes to show in the page size dropdown.
   * false, 'single' or 'multiple' or 'mixed'
   */
  var BLOCKGRID_DEFAULTS = {
    dataset: [],
    selectable: false, // false, 'single' or 'multiple' or mixed
    paging: false,
    pagesize: 25,
    pagesizes: [10, 25, 50, 75]
  };

  function Blockgrid(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings, BLOCKGRID_DEFAULTS);
    if (settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.init();
  }

  // Plugin Methods
  Blockgrid.prototype = {

    /**
     * @returns {Pager|undefined} a pager API, if applicable
     */
    get pagerAPI() {
      return this.element.data('pager');
    },

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    init: function init() {
      this.selectedRows = [];
      this.handlePaging();

      return this.build().handleEvents();
    },


    /**
     * Add any needed markup to the component.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    build: function build() {
      if (this.settings.paging) {
        this.element.empty();
      }

      this.render();
      return this;
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;

      this.element.on('click.' + COMPONENT_NAME$e, '.block', function (e) {
        var activeBlock = $(e.currentTarget);
        var target = $(e.target);
        var isCheckbox = target.is('.checkbox-label') || target.is('.checkbox');

        setTimeout(function () {
          self.selectBlock(activeBlock, isCheckbox);
        }, 0);

        e.stopPropagation();
        e.preventDefault();
      });

      this.element.on('focus.' + COMPONENT_NAME$e, '.checkbox', function (e) {
        var block = $(e.currentTarget).parent();
        block.addClass('has-focus');
      });

      this.element.on('blur.' + COMPONENT_NAME$e, '.checkbox', function (e) {
        var block = $(e.currentTarget).parent();
        block.removeClass('has-focus');
      });

      this.element.on('keypress.' + COMPONENT_NAME$e, '.block', function (e) {
        if (e.which !== 32) {
          return;
        }

        var activeBlock = $(e.target);
        self.selectBlock(activeBlock, false);
      });

      this.element.on('updated.' + COMPONENT_NAME$e, function () {
        self.updated();
      });

      if (this.pagerAPI) {
        this.element.on('page.' + COMPONENT_NAME$e, function () {
          _this.previousFocusedElement = true;
          _this.build();
        }).on('pagesizechange.' + COMPONENT_NAME$e, function () {
          _this.previousFocusedElement = true;
          _this.build();
        });
      }

      return this;
    },
    handlePaging: function handlePaging() {
      if (!this.settings.paging) {
        return;
      }

      this.element.addClass('paginated');
      this.element.pager({
        componentAPI: this,
        dataset: this.settings.dataset,
        pagesize: this.settings.pagesize,
        pagesizes: this.settings.pagesizes
      });
    },


    /**
     * Run selection over a block item.
     * This method is slated to be removed in a future v4.21.0 or v5.0.0.
     * @deprecated as of v4.15.0. Please use `select()` instead.
     * @param {jQuery[]} activeBlock the jQuery-wrapped DOM element that will be selected.
     * @param {boolean} isCheckbox True if a checkbox, used for mixed mode.
     * @returns {void}
     */
    selectBlock: function selectBlock(activeBlock, isCheckbox) {
      return deprecateMethod(this.select, this.selectBlock).apply(this, [activeBlock, isCheckbox]);
    },


    /**
     * Run selection over a block item
     * @param {jQuery[]} activeBlock the jQuery-wrapped DOM element that will be selected.
     * @param {boolean} isCheckbox True if a checkbox, used for mixed mode.
     */
    select: function select(activeBlock, isCheckbox) {
      var allBlocks = this.element.find('.block');
      var allChecks = this.element.find('.checkbox');
      var activeCheckbox = activeBlock.find('.checkbox');
      var isChecked = activeCheckbox.is(':checked');
      var action = '';
      var idx = Number(activeCheckbox.data('idx'));

      if (this.settings.selectable === 'single') {
        this.selectedRows = [];
        allBlocks.removeClass('is-selected').removeAttr('aria-selected');
        allChecks.prop('checked', false);
      }

      if (this.settings.selectable === 'multiple' && isChecked || this.settings.selectable === 'mixed' && isCheckbox && isChecked) {
        activeBlock.removeClass('is-selected').removeAttr('aria-selected');
        activeCheckbox.prop('checked', false);

        for (var i = 0; i < this.selectedRows.length; i++) {
          if (idx === this.selectedRows[i].idx) {
            this.selectedRows.splice(i, 1);
          }
        }

        this.element.triggerHandler('deselected', [{ selectedRows: this.selectedRows, action: 'deselect' }]);
        return;
      }

      if (this.settings.selectable !== false && !(this.settings.selectable === 'mixed' && !isCheckbox)) {
        if (!isChecked) {
          activeBlock.addClass('is-selected').attr('aria-selected', 'true');
          activeCheckbox.prop('checked', true);
        }

        this.selectedRows.push({ idx: idx, data: this.settings.dataset[idx], elem: activeBlock });
        action = isChecked ? 'deselected' : 'selected';
      }

      if (this.settings.selectable === 'mixed' && !isCheckbox) {
        var isActivated = activeBlock.hasClass('is-activated');
        allBlocks.removeClass('is-activated');

        /**
        * Fires when a block is deactivated
        *
        * @event deactivated
        * @memberof Blockgrid
        * @property {object} event - The jquery event object
        * @property {object} ui - The dialog object
        */
        /**
        * Fires when a block is activated
        *
        * @event activated
        * @memberof Blockgrid
        * @property {object} event - The jquery event object
        * @property {object} ui - The dialog object
        */
        if (isActivated) {
          activeBlock.removeClass('is-activated');
          this.element.triggerHandler('deactivated', [{ row: idx, item: this.settings.dataset[idx] }]);
        } else {
          activeBlock.addClass('is-activated');
          this.element.triggerHandler('activated', [{ row: idx, item: this.settings.dataset[idx] }]);
        }
        return;
      }

      /**
      * Fires when a block is selected
      *
      * @event selected
      * @memberof Blockgrid
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      /**
      * Fires when a block is unselected
      *
      * @event deselected
      * @memberof Blockgrid
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      this.element.triggerHandler(isChecked ? 'deselected' : 'selected', [{ selectedRows: this.selectedRows, action: action }]);
    },


    /**
     * Renders the blockgrid page.
     * @returns {void}
     */
    render: function render() {
      var _this2 = this;

      var blockelements = '';
      var displayedDataset = this.settings.dataset;
      var selectText = Locale ? Locale.translate('Select') : 'Select';

      if (this.pagerAPI) {
        // If the paging information sets limits on the dataset, customize the
        // displayed dataset to fit the conditions.
        var pagerInfo = this.pagerAPI.state;
        if (pagerInfo.pages > 1) {
          var trueActivePage = pagerInfo.activePage > 0 ? pagerInfo.activePage - 1 : 0;
          var firstRecordIdx = pagerInfo.pagesize * trueActivePage;
          var lastRecordIdx = pagerInfo.pagesize * (trueActivePage + 1);
          displayedDataset = displayedDataset.slice(firstRecordIdx, lastRecordIdx);

          // If the dataset doesn't actually have IDs, set temporary ones for
          // tracking selected/deselected
          if (displayedDataset.length !== this.settings.dataset.length) {
            for (var j = 0; j < lastRecordIdx - firstRecordIdx + 1; j++) {
              if (displayedDataset[j].id) {
                break;
              }
              displayedDataset[j].id = firstRecordIdx + j;
            }
          }
        }
      }

      var checkedIdxs = [];
      this.selectedRows.forEach(function (row) {
        checkedIdxs.push(row.idx);
      });

      for (var i = 0; i < displayedDataset.length; i++) {
        var data = displayedDataset[i];
        var tabindex = this.settings.selectable === 'mixed' ? '0' : '-1';
        var selected = '';
        var checked = '';

        if (checkedIdxs.indexOf(data.id) > -1) {
          selected = ' is-selected';
          checked = ' checked';
        }

        blockelements += '<div class="block is-selectable' + selected + '" role="listitem" tabindex="0">\n        <input type="checkbox" aria-hidden="true" role="presentation" class="checkbox" id="checkbox' + i + '" tabindex="' + tabindex + '" data-idx="' + data.id + '"' + checked + '>\n        <label for="checkbox' + i + '" class="checkbox-label">\n          <span class="audible">' + selectText + '</span>\n        </label>\n        <img alt="Placeholder Image" src="' + (data.img || data.image) + '" class="image-round">\n        <p> ' + (data.maintxt || data.title) + ' <br> ' + (data.subtxt || data.subtitle) + ' </p>\n      </div>';
      }

      this.element.attr('role', 'list').append(blockelements);

      // If a Blockgrid element had focus before rendering, restore focus to the first new block
      if (this.previousFocusedElement) {
        setTimeout(function () {
          _this2.element.find('.block').first().focus();
          delete _this2.previousFocusedElement;
        }, 0);
      }
    },


    /**
     * Render an individual block element.
     * This method is slated to be removed in a future v4.21.0 or v5.0.0.
     * @deprecated as of v4.15.0. Please use `render()` instead.
     * @returns {void}
     */
    renderBlock: function renderBlock() {
      return deprecateMethod(this.render, this.renderBlock).apply(this);
    },


    /**
     * Handle updated settings and values.
     * @param  {settings} settings The new settings to use.
     * @returns {void}
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      this.teardown();
      this.init();
      return this;
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$e);
      this.element.off('click.' + COMPONENT_NAME$e);

      this.element.empty();
      this.selectedRows = [];
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$e);
    }
  };

  /**
   * jQuery component wrapper for the Accordion
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.blockgrid = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$e);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$e, new Blockgrid(this, settings));
      }
    });
  };

  // The Name of this component.
  var COMPONENT_NAME$f = 'busyindicator';

  /**
   * A Busy Indicator notifies the user that the system is processing a request, and that they must
   * wait for that request to be processed before continuing with the current task.
   * @class BusyIndicator
   * @param {object} element The plugin starting element.
   * @param {object} [settings] The settings to use.
   * @param {string} [settings.blockUI=true] makes the element that Busy Indicator is invoked on unusable while it's displayed.
   * @param {string} [settings.text=null] Custom Text To Show or Will Show Localized Loading....
   * @param {string} [settings.displayDelay=1000] Number in miliseconds to pass before the markup is displayed. If 0, displays immediately.
   * @param {boolean} [settings.timeToComplete=0] fires the 'complete' trigger at a certain timing interval. If 0, goes indefinitely.
   * @param {string} [settings.transparentOverlay=false] If true, allows the "blockUI" setting to display
   * an overlay that prevents interaction, but appears transparent instead of gray.
   * @param {string} [settings.overlayOnly=false] If true, the busy indicator will only be the overlay.
   */
  var BUSYINDICATOR_DEFAULTS = {
    blockUI: true,
    text: null,
    displayDelay: 1000,
    timeToComplete: 0,
    transparentOverlay: false,
    overlayOnly: false
  };

  function BusyIndicator(element, settings) {
    this.settings = utils.mergeSettings(element, settings, BUSYINDICATOR_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  BusyIndicator.prototype = {
    init: function init() {
      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = this.element.parent().is('.inline');

      this.setup().handleEvents();
    },


    // Sanitize incoming option values
    setup: function setup() {
      var blockUI = this.element.attr('data-block-ui');
      var delay = this.element.attr('data-display-delay');
      var completionTime = this.element.attr('data-completion-time');

      this.blockUI = blockUI !== undefined ? blockUI : this.settings.blockUI;
      if (!this.settings.overlayOnly) {
        this.loadingText = this.settings.text ? this.settings.text : Locale.translate('Loading');

        // Support updating the label while open
        if (this.label) {
          this.label.text(this.loadingText);
        }
      }

      var isDelayDefined = delay !== undefined && !isNaN(delay) && parseInt(delay, 10) > 20;
      var displayDelay = !isNaN(this.settings.displayDelay) && this.settings.displayDelay >= 20 ? this.settings.displayDelay : 20;

      this.delay = isDelayDefined ? delay : displayDelay;
      this.completionTime = completionTime !== undefined && !isNaN(completionTime) ? parseInt(completionTime, 10) : this.settings.timeToComplete;

      return this;
    },


    /**
    * Builds and starts the indicator
    * @private
    * @returns {void}
    */
    activate: function activate() {
      var self = this;

      if (self.isActive()) {
        return; // safety, don't activate this code if already active
      }

      // If the markup already exists don't do anything but clear
      if (this.container) {
        if (self.closeTimeout) {
          clearTimeout(self.closeTimeout);
        }
        this.label.remove();
        if (!this.settings.overlayOnly) {
          this.label = $('<span>' + this.loadingText + '</span>').appendTo(this.container);

          if (this.element.is('input, .dropdown, .multiselect, .busy-xs, .busy-sm')) {
            this.label.addClass('audible');
          }
        }

        this.container.removeClass('is-hidden').trigger('afterstart');

        return;
      }

      // Build all the markup
      this.container = $('<div class="busy-indicator-container is-hidden"></div>').attr({
        'aria-live': 'polite',
        role: 'status'
      });
      this.loader = $('<div class="busy-indicator active"></div>').appendTo(this.container);

      if (!this.settings.overlayOnly) {
        $('<div class="bar one"></div>' + '<div class="bar two"></div>' + '<div class="bar three"></div>' + '<div class="bar four"></div>' + '<div class="bar five"></div>').appendTo(this.loader);

        this.label = $('<span>' + this.loadingText + '</span>').appendTo(this.container);
      }

      var transparency = '';

      if (this.blockUI) {
        if (this.settings.transparentOverlay) {
          transparency = ' transparent';
        }

        this.originalPositionProp = this.element[0].style.position;
        this.element[0].style.position = 'relative';
        this.overlay = $('<div class="overlay busy is-hidden' + transparency + '"></div>').appendTo(this.element);
        this.container.addClass('blocked-ui');
      }

      if (this.label && this.element.is('.busy-xs, .busy-sm')) {
        this.label.addClass('audible');
      }

      // Append the markup to the page
      // Use special positioning logic for compatibility with certain controls
      if (this.element.is('input, .dropdown, .multiselect')) {
        this.element.addClass('is-loading');
        if (this.blockUI) {
          this.element.addClass('is-blocked');
        }
        if (this.label) {
          this.label.addClass('audible');
        }

        var target = void 0;

        if (this.element.is('input')) {
          target = this.element;
          this.container.insertAfter(this.isInlineLabel ? this.inlineLabel : this.element);
        } else {
          var dd = this.element.data('dropdown');
          target = dd.pseudoElem;
          this.container.appendTo(target.parent());
        }

        if (this.overlay) {
          this.overlay.insertAfter(this.container);
        }

        var rect = target.position();
        var h = target.outerHeight();
        var w = target.outerWidth();
        var elements = this.container.add(this.overlay);
        var setCssStyle = function setCssStyle(el, key, value) {
          el.style[key] = value + 'px';
        };

        for (var i = 0, l = elements.length; i < l; i++) {
          setCssStyle(elements[i], 'left', rect.left);
          setCssStyle(elements[i], 'top', rect.top);
          setCssStyle(elements[i], 'bottom', rect.bottom);
          setCssStyle(elements[i], 'right', rect.right);
          setCssStyle(elements[i], 'height', h);
          setCssStyle(elements[i], 'width', w);
        }
      } else {
        // Normal Operations
        this.container.appendTo(this.element);
      }

      // Fade in shortly after adding the markup to the page
      // (prevents the indicator from abruptly showing)
      setTimeout(function () {
        if (self.container) {
          self.container.removeClass('is-hidden');
        }
        if (self.overlay) {
          self.overlay.removeClass('is-hidden');
        }

        // Add in view from scroll parent.
        if (self.blockUI) {
          self.addScrollParent();
        }
      }, self.delay);

      // Lets external code know that we've successully kicked off.
      this.element.trigger('afterstart');

      // Start the JS Animation Loop if IE9
      if (!$.fn.cssPropSupport('animation')) {
        self.isAnimating = true;
        self.animateWithJS();
      }

      // Triggers complete if the "timeToComplete" option is set.
      if (this.completionTime > 0) {
        setTimeout(function () {
          self.element.trigger('complete');
        }, self.completionTime);
      }
    },


    /**
     * Removes the appended markup and hides any trace of the indicator.
     * @param {boolean} fromEvent Designates the close is coming from an event (internal)
     * @returns {void}
     */
    close: function close(fromEvent) {
      var self = this;

      if (!self.isActive()) {
        return; // safety, don't try and close this if not already active
      }

      this.removeScrollParent();

      // If closed from an event, fire the necessary event triggers
      // and removes the 'is-loading' CSS class.
      if (fromEvent) {
        this.element.removeClass('is-loading');
        this.element.removeClass('is-blocked');
      }

      if (this.container) {
        this.container.addClass('is-hidden');
      }

      if (this.overlay) {
        this.overlay.addClass('is-hidden');
      }

      // Give the indicator time to fade out before removing all of its components from view
      self.closeTimeout = setTimeout(function () {
        clearTimeout(self.closeTimeout);
        if (self.container) {
          self.container.remove();
        }

        self.container = undefined;
        self.loader = undefined;
        self.label = undefined;

        if (self.overlay) {
          self.overlay.remove();
          self.element[0].style.position = self.originalPositionProp;
          self.originalPositionProp = undefined;
        }
        self.overlay = undefined;
        self.element.trigger('aftercomplete.busyindicator');
        self.element.off('complete.busyindicator');
      }, 600);
    },


    /**
     * Browsers that don't support CSS-based animation can still show the animating Busy Indicator.
     * @private
     */
    animateWithJS: function animateWithJS() {
      var self = this;
      var bar1 = this.container.find('.bar.one');
      var bar2 = this.container.find('.bar.two');
      var bar3 = this.container.find('.bar.three');
      var bar4 = this.container.find('.bar.four');
      var bar5 = this.container.find('.bar.five');
      var t = 0;
      var interval = null;

      // Animation Loop
      function animate() {
        if (!self.isAnimating) {
          clearInterval(interval);
          return;
        }

        t += 1;

        if (t === 1) {
          bar1.addClass('half');
        }
        if (t === 13) {
          bar1.removeClass('half').addClass('full');
          bar2.addClass('half');
        }
        if (t === 26) {
          bar1.removeClass('full').addClass('half');
          bar2.removeClass('half').addClass('full');
          bar3.addClass('half');
        }
        if (t === 39) {
          bar1.removeClass('half');
          bar2.removeClass('full').addClass('half');
          bar3.removeClass('half').addClass('full');
          bar4.addClass('half');
        }
        if (t === 51) {
          bar2.removeClass('half');
          bar3.removeClass('full').addClass('half');
          bar4.removeClass('half').addClass('full');
          bar5.addClass('half');
        }
        if (t === 64) {
          bar3.removeClass('half');
          bar4.removeClass('full').addClass('half');
          bar5.removeClass('half').addClass('full');
        }
        if (t === 77) {
          bar4.removeClass('half');
          bar5.removeClass('full').addClass('half');
        }
        if (t === 90) {
          bar5.removeClass('half');
        }

        if (t === 103) {
          t = 0;
        }
      }

      setInterval(animate, 10);
    },


    /**
     * Adjust top position, if any of the parents is scrollable
     * @private
     * @returns {void}
     */
    addScrollParent: function addScrollParent() {
      var _this = this;

      if (this.blockUI) {
        this.scrollParent = $(this.getScrollParent(this.element[0]));
        var scrollParentHeight = this.scrollParent.length ? this.scrollParent.outerHeight() : 0;
        if (scrollParentHeight && scrollParentHeight < this.element.outerHeight()) {
          var locTop = scrollParentHeight / 2 - 58;
          this.container.css({ top: locTop });

          this.scrollParent.off('scroll.parent.busyindicator').on('scroll.parent.busyindicator', function () {
            var offset = locTop + _this.scrollParent.scrollTop();
            _this.container.css({ top: offset });
          });
        }
      }
    },


    /**
     * Remove scroll parent.
     * @private
     * @returns {void}
     */
    removeScrollParent: function removeScrollParent() {
      if (this.scrollParent) {
        this.scrollParent.off('scroll.parent.busyindicator');
        delete this.scrollParent;
      }
    },


    /**
     * Get if any of the parents is scrollable.
     * @private
     * @param {object} elem to get scroll parent.
     * @returns {object} the scroll parent.
     */
    getScrollParent: function getScrollParent(elem) {
      var properties = ['overflow', 'overflow-x', 'overflow-y'];
      var style = function style(el, prop) {
        return getComputedStyle(el, null).getPropertyValue(prop);
      };
      var styleMerged = function styleMerged(el) {
        return properties.reduce(function (a, b) {
          return a + style(el, b);
        }, 0);
      };
      var regex = /(auto|scroll)/;
      var isScroll = function isScroll(el) {
        return regex.test(styleMerged(el));
      };
      var scrollParent = function scrollParent(el) {
        var found = false;
        var parent = el.parentNode;
        while (!found && parent && parent.tagName.toLowerCase() !== 'body') {
          if (isScroll(parent)) {
            found = true;
            break;
          }
          parent = parent.parentNode;
        }
        return found ? parent : null;
      };
      return scrollParent(elem);
    },


    /**
     * Update the component and apply current settings.
     * @param {object} settings the settings to update to.
     * @returns {this} component instance.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      return this.setup();
    },


    /**
     * Returns if the indicator is active or not.
     * @returns {boolean} If the busy indicator is active.
     */
    isActive: function isActive() {
      if (this.container) {
        return this.container.children('.busy-indicator').is('.active');
      }
      return false;
    },


    /**
     * Teardown and remove any added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.removeScrollParent();
      this.close(true);
      this.element.off('start.busyindicator complete.busyindicator afterstart.busyindicator aftercomplete.busyindicator updated.busyindicator');
      $.removeData(this.element[0], COMPONENT_NAME$f);
    },
    handleEvents: function handleEvents() {
      var _this2 = this;

      var self = this;

      /**
      *  Fires when the indicator starts / shows.
      *
      * @event start
      * @memberof BusyIndicator
      * @param {object} event - The jquery event object.
      */
      self.element.on('start.busyindicator', function (e) {
        e.stopPropagation();
        _this2.activate();
      }).on('afterstart.busyindicator', function () {
        /**
         * Fires when the indicator is "started"
         *
         * @event complete
         * @memberof BusyIndicator
         * @param {object} event - The jquery event object.
         * @param {object} ui - The dialog object
         */
        _this2.element.on('complete.busyindicator', function (e) {
          e.stopPropagation();
          _this2.close(true);
        });
      })
      /**
      * Sync the UI/Settings. Fx chnaging the text in the DOM.
      * @event updated
      * @memberof BusyIndicator
      * @param {object} event - The jquery event object.
      */
      .on('updated.busyindicator', function () {
        _this2.close(true);
        _this2.updated();
      });

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for the BusyIndicator
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */
  $.fn.busyindicator = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$f);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$f, new BusyIndicator(this, settings));
      }
    });
  };

  var charts = {};

  // Reference to the tooltip
  charts.tooltip = {};
  charts.isIE = Environment.browser.name === 'ie';
  charts.isIEEdge = Environment.browser.name === 'edge';

  /**
   * Get the current height and widthe of the tooltip.
   * @private
   * @param  {string} content The tooltip content.
   * @returns {object} Object with the height and width.
   */
  charts.tooltipSize = function tooltipSize(content) {
    DOM.html(this.tooltip.find('.tooltip-content'), content, '*');
    return { height: this.tooltip.outerHeight(), width: this.tooltip.outerWidth() };
  };

  /**
   * Format the value based on settings.
   * @private
   * @param  {object} data The data object.
   * @param  {object} settings The sttings to use
   * @returns {string} the formatted string.
   */
  charts.formatToSettings = function formatToSettings(data, settings) {
    var d = data.data ? data.data : data;

    if (settings.show === 'value') {
      return settings.formatter ? d3.format(settings.formatter)(d.value) : d.value;
    }

    if (settings.show === 'label') {
      return d.name;
    }

    if (settings.show === 'label (percent)') {
      return d.name + ' (' + (isNaN(d.percentRound) ? 0 : d.percentRound) + '%)';
    }

    if (settings.show === 'label (value)') {
      return d.name + ' (' + (settings.formatter ? d3.format(settings.formatter)(d.value) : d.value) + ')';
    }

    if (settings.show === 'percent') {
      return (isNaN(d.percentRound) ? 0 : d.percentRound) + '%';
    }

    if (typeof settings.show === 'function') {
      return settings.show(d);
    }

    return d.value;
  };

  /**
  * Add Toolbar to the page.
  * @private
  * @param {string} extraClass class to add (needed for pie)
  * @returns {void}
  */
  charts.appendTooltip = function appendTooltip(extraClass) {
    var _this = this;

    this.tooltip = $('#svg-tooltip');
    if (this.tooltip.length === 0) {
      this.tooltip = $('<div id="svg-tooltip" class="tooltip ' + extraClass + ' right is-hidden">\n      <div class="arrow"></div>\n        <div class="tooltip-content">\n          <p><b>32</b> Element</p>\n        </div>\n      </div>').appendTo('body');

      if (this.isTouch) {
        this.tooltip[0].style.pointerEvents = 'auto';
        this.tooltip.on('touchend.svgtooltip', function () {
          _this.hideTooltip();
        });
      }
    }
  };

  /**
   * Hide the visible tooltip.
   * @private
   * @returns {void}
   */
  charts.hideTooltip = function hideTooltip() {
    var _this2 = this;

    d3.select('#svg-tooltip').classed('is-hidden', true).style('left', '-999px');

    // Remove scroll events
    $('body, .scrollable').off('scroll.chart-tooltip', function () {
      _this2.hideTooltip();
    });
  };

  /**
   * Remove the tooltip from the DOM
   * @private
   * @returns {void}
   */
  charts.removeTooltip = function removeTooltip() {
    if (this.tooltip && this.tooltip.remove) {
      this.tooltip.remove();
    }
  };

  /**
   * The color sequences to use across charts
   * @private
   * @type {array}
   */
  charts.colorRange = ['#2578A9', '#8ED1C6', '#C7B4DB', '#5C5C5C', '#F2BC41', '#76B051', '#B94E4E', '#8DC9E6', '#DB7726', '#317C73', '#EB9D9D', '#737373', '#89BF65', '#C7B4DB', '#54A1D3', '#6e5282', '#AFDC91', '#69ADA3', '#EE9A36', '#D8D8D8'];

  charts.colorNameRange = ['azure07', 'turquoise03', 'amethyst03', 'graphite06', 'amber05', 'emerald06', 'ruby06', 'azure03', 'amber09', 'turquoise08', 'ruby02', 'graphite05', 'emerald05', 'amethyst03', 'azure05', 'amethyst08', 'emerald03', 'turquoise06', 'amber07', 'graphite02'];

  /**
   * The colors as an array for placement
   * @private
   * @type {array}
   */
  charts.colors = typeof d3 !== 'undefined' ? d3.scaleOrdinal().range(charts.colorRange) : [];
  charts.colorNames = typeof d3 !== 'undefined' ? d3.scaleOrdinal().range(charts.colorNameRange) : [];

  /**
   * Calculate and return the correct color to use. Fx
   * error, alert, alertYellow, good, neutral or hex.
   * @private
   * @param  {number} i The line/bar object index.
   * @param  {string} chartType The type of chart.
   * @param  {object} data The data for this element.
   * @returns {string} The hex code
   */
  charts.chartColor = function chartColor(i, chartType, data) {
    var specifiedColor = data && data.color ? data.color : null;

    // Handle passed in colors.
    if (specifiedColor) {
      if (specifiedColor === 'error') {
        return '#e84f4f';
      }
      if (specifiedColor === 'alert') {
        return '#ff9426';
      }
      if (specifiedColor === 'alertYellow') {
        return '#ffd726';
      }
      if (specifiedColor === 'good') {
        return '#80ce4d';
      }
      if (specifiedColor === 'neutral') {
        return '#bdbdbd';
      }
      if (specifiedColor && specifiedColor.indexOf('#') === 0) {
        return data.color;
      }
    }

    // Some configuration by specific chart types
    if (/^(pie|donut)$/.test(chartType)) {
      return this.colorRange[i];
    }
    if (/^(bar-single|column-single)$/.test(chartType)) {
      return '#1D5F8A';
    }
    if (/^(bar|bar-stacked|bar-grouped|bar-normalized|line|scatterplot|column-stacked|column-grouped|column-positive-negative)$/.test(chartType)) {
      return this.colors(i);
    }

    return '';
  };

  charts.chartColorName = function chartColor(i, chartType, data) {
    var specifiedColor = data && data.color ? data.color : null;

    // Handle passed in colors.
    if (specifiedColor) {
      if (specifiedColor === 'error') {
        return 'alert01';
      }
      if (specifiedColor === 'alert') {
        return 'alert02';
      }
      if (specifiedColor === 'alertYellow') {
        return 'alert03';
      }
      if (specifiedColor === 'good') {
        return 'alert04';
      }
      if (specifiedColor === 'neutral') {
        return 'graphite03';
      }
      if (specifiedColor && specifiedColor.indexOf('#') === 0) {
        return data.color;
      }
    }

    // Some configuration by specific chart types
    if (/^(pie|donut)$/.test(chartType)) {
      return this.colorNameRange[i];
    }
    if (/^(bar-single|column-single)$/.test(chartType)) {
      return 'azure08';
    }
    if (/^(bar|bar-stacked|bar-grouped|bar-normalized|line|scatterplot|column-stacked|column-grouped|column-positive-negative)$/.test(chartType)) {
      return this.colorNames(i);
    }

    return '';
  };

  /**
   * Show Tooltip
   * @private
   * @param  {number} x The x position.
   * @param  {number} y The y position.
   * @param  {string} content The tooltip contents.
   * @param  {string} arrow The arrow direction.
   */
  charts.showTooltip = function (x, y, content, arrow) {
    var _this3 = this;

    // Simple Collision of left side
    if (x < 0) {
      x = 2;
    }

    this.tooltip[0].style.left = x + 'px';
    this.tooltip[0].style.top = y + 'px';
    DOM.html(this.tooltip.find('.tooltip-content'), content, '*');

    this.tooltip.removeClass('bottom top left right').addClass(arrow);
    this.tooltip.removeClass('is-hidden');

    // Hide the tooltip when the page scrolls.
    $('body').off('scroll.chart-tooltip').on('scroll.chart-tooltip', function () {
      _this3.hideTooltip();
    });

    $('.scrollable').off('scroll.chart-tooltip').on('scroll.chart-tooltip', function () {
      _this3.hideTooltip();
    });
  };

  /**
   * Add the legend to the Chart Container.
   * @private
   * @param  {array} series The groups series object.
   * @param  {string} chartType The type of chart.
   * @param  {object} settings The chart setting
   * @param  {object} container The dom container.
   * @returns {void}
   */
  charts.addLegend = function (series, chartType, settings, container) {
    var i = void 0;
    if (series.length === 0) {
      return;
    }

    var isTwoColumn = series[0].display && series[0].display === 'twocolumn';
    var legend = isTwoColumn ? $('<div class="chart-legend ' + (series[0].placement ? 'is-' + series[0].placement : 'is-bottom') + '"></div>') : $('<div class="chart-legend"></div>');

    if ((chartType === 'pie' || chartType === 'donut') && settings.showMobile) {
      legend = $('<div class="chart-legend"><div class="container"></div></div>');
    }

    // Legend width
    var width = 0;
    var currentWidth = void 0;

    for (i = 0; i < series.length; i++) {
      currentWidth = series[i].name.length * 6;
      width = series[i].name && currentWidth > width ? currentWidth : width;
    }

    width += 55;
    var widthPercent = width / $(container).width() * 100;

    for (i = 0; i < series.length; i++) {
      if (!series[i].name) {
        continue; // eslint-disable-line
      }

      var extraClass = '';
      if (isTwoColumn || series[i].display && series[i].display === 'block') {
        extraClass += ' lg';
      }
      if (settings.type === 'column-positive-negative' && series[i].option) {
        extraClass += ' ' + series[i].option;
      }

      var seriesLine = '<span class="chart-legend-item' + extraClass + '" tabindex="0"></span>';
      var hexColor = charts.chartColor(i, chartType || (series.length === 1 ? 'bar-single' : 'bar'), series[i]);
      var colorName = charts.chartColorName(i, chartType || (series.length === 1 ? 'bar-single' : 'bar'), series[i]);

      var color = '';
      if (colorName.substr(0, 1) === '#') {
        color = $('<span class="chart-legend-color"></span>');
        if (!series[i].pattern) {
          color.css('background-color', hexColor);
        }
      } else {
        color = $('<span class="chart-legend-color ' + (series[i].pattern ? '' : colorName) + '"></span>');
      }

      if (chartType === 'scatterplot') {
        color = $('<span class="chart-legend-color"></span>');
      }
      var textBlock = $('<span class="chart-legend-item-text">' + xssUtils.stripTags(series[i].name) + '</span>');

      if (series[i].pattern) {
        color.append('<svg width="12" height="12"><rect height="12" width="12" mask="url(#' + series[i].pattern + ')"/></svg>');
        color.find('rect').css('fill', hexColor);
      }

      if (series[i].percent) {
        var pct = $('<span class="chart-legend-percent"></span>').text(series[i].percent);
        textBlock.append(pct);
      }

      if (series[i].display && series[i].display === 'block') {
        seriesLine = '<span class="chart-legend-item' + extraClass + '" tabindex="0"></span>';
      }

      if (isTwoColumn) {
        if (widthPercent > 45 && settings.legendPlacement !== 'right') {
          seriesLine = '<span class="chart-legend-item' + extraClass + '" tabindex="0"></span>';
        } else {
          seriesLine = '<span class="chart-legend-item' + extraClass + ' is-two-column" tabindex="0" ></span>';
        }
      }
      seriesLine = $(seriesLine);
      seriesLine.append(color, textBlock);

      if ((chartType === 'pie' || chartType === 'donut') && settings.showMobile) {
        legend.find('.container').append(seriesLine);
      } else {
        legend.append(seriesLine);
      }

      if (series[i].display && series[i].display === 'block' || isTwoColumn && widthPercent > 45 && settings.legendPlacement !== 'right') {
        seriesLine.css({
          float: 'none',
          display: 'block',
          margin: '0 auto',
          width: width + 'px'
        });
      }

      // Add shapes
      if (chartType === 'scatterplot') {
        self.svg = d3.select(color[0]).append('svg').attr('width', '24').attr('height', '24').append('path').attr('class', 'symbol').attr('transform', 'translate(10, 10)').attr('d', d3.symbol().size('80').type(function () {
          return d3.symbols[i];
        })) //eslint-disable-line
        .style('fill', hexColor);
      }

      // Change text of legend depends of the width
      if (innerWidth <= 480 && series[i].data && series[i].data.legendAbbrName) {
        textBlock.replaceWith('<span class="chart-legend-item-text">' + series[i].data.legendAbbrName + '</span>');
      }
      if (innerWidth >= 481 && innerWidth <= 768 && series[i].data && series[i].data.legendShortName) {
        textBlock.replaceWith('<span class="chart-legend-item-text">' + series[i].data.legendShortName + '</span>');
      }
    }

    if (legend instanceof $) {
      legend.on('click.chart', '.chart-legend-item', function () {
        charts.handleElementClick(this, series, settings);
      }).on('keypress.chart', '.chart-legend-item', function (e) {
        if (e.which === 13 || e.which === 32) {
          charts.handleElementClick(this, series, settings);
        }
      });

      $(container).append(legend);
    }
  };

  /**
   * Helper Function to Select from legend click
   * @private
   * @param {object} line The element that was clicked.
   * @param {array} series The data series.
   * @param {object} settings [description]
   */
  charts.handleElementClick = function (line, series, settings) {
    var idx = $(line).index();
    var elem = series[idx];
    var selector = void 0;

    if (settings.type === 'radar') {
      selector = d3.select(settings.svg.selectAll('.chart-radar-area').nodes()[idx]);
    }

    if (settings.type === 'pie' || settings.type === 'donut') {
      selector = d3.select(settings.svg.selectAll('.slice').nodes()[idx]);
    } else if (settings.type === 'column-positive-negative') {
      if (!elem.option || elem.option && elem.option === 'target') {
        selector = settings.svg.select('.target-bar');
      } else {
        selector = settings.svg.select('.bar.' + elem.option);
      }
    } else if (['column', 'bar', 'bar-stacked', 'bar-grouped', 'bar-normalized', 'column-grouped', 'column-stacked', 'column-positive-negative'].indexOf(settings.type) !== -1) {
      // Grouped or singlular
      if (settings.isGrouped || settings.isSingle) {
        selector = settings.svg.select('.series-' + idx);
      } else if (settings.isStacked && !settings.isSingle) {
        // Stacked
        var thisGroup = d3.select(settings.svg.selectAll(settings.type === 'bar' || settings.type === 'bar-stacked' || settings.type === 'bar-normalized' ? '.series-group' : '.g').nodes()[idx]); // eslint-disable-line
        selector = thisGroup.select('.bar');
      }
    }

    if (['radar', 'pie', 'donut', 'column', 'bar', 'bar-stacked', 'bar-grouped', 'bar-normalized', 'column-grouped', 'column-stacked', 'column-positive-negative'].indexOf(settings.type) !== -1) {
      charts.clickedLegend = true;
      selector.on('click').call(selector.node(), selector.datum(), idx, true);
    }

    if (elem.selectionObj) {
      charts.selectElement(d3.select(elem.selectionObj.nodes()[idx]), elem.selectionInverse, elem.data); // eslint-disable-line
    }
  };

  // The selected array for this instance.
  charts.selected = [];

  /**
   * Select the element and fire the event, make the inverse selector opace.
   * @private
   * @param  {object} element The DOM element
   * @param  {object} inverse The opposite selection.
   * @param  {array} data  The data object
   * @param  {object} container  The DOM object
   */
  charts.selectElement = function (element, inverse, data, container) {
    var isSelected = element.node() && element.classed('is-selected');
    var triggerData = [{ elem: element.nodes(), data: !isSelected ? data : {} }];

    inverse.classed('is-selected', false).classed('is-not-selected', !isSelected);

    element.classed('is-not-selected', false).classed('is-selected', !isSelected);

    charts.selected = $.isEmptyObject(triggerData[0].data) ? [] : triggerData;

    // Fire Events
    $(container).triggerHandler('selected', [triggerData]);
  };

  /**
   * Style bars as selected or unselected
   * TODO: Refactor into individual components;
   * @private
   * @param  {object} o The object to handle.
   */
  charts.setSelectedElement = function (o) {
    var dataset = o.dataset;
    var isPositiveNegative = o.type === 'column-positive-negative';
    var isBar = /^(bar|bar-stacked|bar-grouped|bar-normalized)$/.test(o.type);
    var isTypePie = o.type === 'pie' || o.type === 'donut';
    var isTypeColumn = /^(column|column-grouped|column-stacked|column-positive-negative)$/.test(o.type);

    var svg = o.svg;
    var isSingle = o.isSingle;
    var isGrouped = o.isGrouped;
    var isStacked = o.isStacked;

    var taskSelected = o.task === 'selected';
    var selector = d3.select(o.selector);
    var isPositive = selector.classed('positive');
    var ticksX = o.svg.selectAll('.axis.x .tick');
    var ticksY = o.svg.selectAll('.axis.y .tick');
    var pnPositiveText = o.svg.selectAll('.bartext.positive, .target-bartext.positive');
    var pnNegativeText = o.svg.selectAll('.bartext.negative, .target-bartext.negative');
    var pnTargetText = o.svg.selectAll('.target-bartext.positive, .target-bartext.negative');
    var thisGroup = d3.select(o.selector.parentNode);
    var thisGroupId = parseInt(thisGroup.node() ? thisGroup.attr('data-group-id') : 0, 10);
    var triggerData = [];
    var selectedBars = [];
    var thisData = void 0;

    if (isStacked || isTypePie) {
      dataset = dataset || null;
    } else {
      dataset = dataset && dataset[thisGroupId] ? dataset[thisGroupId].data || dataset[thisGroupId] : null;
    }

    ticksX.style('font-weight', 'normal');
    ticksY.style('font-weight', 'normal');
    pnPositiveText.style('font-weight', 'normal');
    pnNegativeText.style('font-weight', 'normal');
    svg.selectAll('.is-selected').classed('is-selected', false);

    if (isTypePie) {
      svg.selectAll('.is-not-selected').classed('is-not-selected', false);
    }

    // Task make selected
    if (taskSelected) {
      svg.selectAll('.bar, .target-bar').style('opacity', 0.6);

      // By legends only
      if (charts.clickedLegend && !isTypePie) {
        if (isPositiveNegative) {
          if (o.isTargetBar) {
            o.svg.selectAll('.target-bar').classed('is-selected', true).style('opacity', 1);

            pnTargetText.style('font-weight', 'bolder');
          } else {
            o.svg.selectAll(isPositive ? '.bar.positive, .target-bar.positive' : '.bar.negative, .target-bar.negative').classed('is-selected', true).style('opacity', 1);

            (isPositive ? pnPositiveText : pnNegativeText).style('font-weight', 'bolder');
          }

          svg.selectAll('.bar').each(function (d, i) {
            var bar = d3.select(this);
            if (bar.classed('is-selected')) {
              selectedBars.push({ elem: bar.node(), data: dataset ? dataset[i] : d });
            }
          });
          triggerData = selectedBars;
        } else if (isTypeColumn || isBar) {
          // Grouped and stacked only -NOT singular-

          if (isGrouped || isSingle) {
            o.svg.selectAll('.series-' + o.i).classed('is-selected', true).style('opacity', 1); //eslint-disable-line
          } else {
            thisGroup.classed('is-selected', true).selectAll('.bar').classed('is-selected', true).style('opacity', 1);
          }

          svg.selectAll('.bar.is-selected').each(function (d, i) {
            var bar = d3.select(this);

            thisData = o.dataset;
            if (!thisData) {
              thisData = d;
            }

            if (isBar) {
              if (thisData[0][o.i]) {
                thisData = thisData[0][o.i];
              }

              if (thisData[o.i] && thisData[o.i][i]) {
                thisData = thisData[o.i][i];
              }

              if (thisData[i] && thisData[i][o.i]) {
                thisData = thisData[i][o.i];
              }
            } else {
              if (thisData[0].data[o.i]) {
                thisData = thisData[0].data[o.i];
              }

              if (thisData[o.i] && thisData[o.i].data[i]) {
                thisData = thisData[o.i].data[i];
              }

              if (thisData[i] && thisData[i].data[o.i]) {
                thisData = thisData[i].data[o.i];
              }
            }

            selectedBars.push({ elem: bar.node(), data: thisData });
          });
          triggerData = selectedBars;
        }
      } else if (isSingle && isStacked && isTypeColumn) {
        // Single and stacked only -NOT grouped-
        thisData = dataset[0] && dataset[0].data ? dataset[0].data : o.d;
        selector.classed('is-selected', true).style('opacity', 1);
        triggerData.push({ elem: selector.nodes(), data: thisData[o.i] });
      } else if ((isSingle || isGrouped) && !isStacked && (isTypeColumn || isBar)) {
        // Single or groups only -NOT stacked-
        svg.selectAll((isTypeColumn ? '.axis.x' : '.axis.y') + ' .tick:nth-child(' + ((isGrouped ? thisGroupId : o.i) + 2) + ')').style('font-weight', 'bolder');

        selector.classed('is-selected', true).style('opacity', 1);

        if (isPositiveNegative) {
          var thisIndex = o.isTargetBar ? o.i : o.i - o.dataset[0].data.length;
          svg.select('.target-bar.series-' + thisIndex).classed('is-selected', true).style('opacity', 1);
          svg.select('.bar.series-' + thisIndex).classed('is-selected', true).style('opacity', 1);

          d3.select(svg.selectAll('.bartext').nodes()[thisIndex]).style('font-weight', 'bolder');
          d3.select(svg.selectAll('.target-bartext').nodes()[thisIndex]).style('font-weight', 'bolder');
        }

        if (isGrouped || isPositiveNegative || isTypeColumn) {
          if (!isPositiveNegative && !isTypeColumn || isTypeColumn && isGrouped) {
            thisGroup.classed('is-selected', true).selectAll('.bar').classed('is-selected', true).style('opacity', 1);
          }

          thisGroup.selectAll('.bar').each(function (d, i) {
            var bar = d3.select(this);
            if (bar.classed('is-selected')) {
              selectedBars.push({ elem: bar.node(), data: dataset ? dataset[i] : d });
            }
          });
          if (isGrouped) {
            triggerData.push({
              groupIndex: thisGroupId,
              groupElem: thisGroup.nodes()[0], //eslint-disable-line
              groupItems: selectedBars
            });
          } else {
            triggerData = selectedBars;
          }
        }
      } else if (isTypeColumn || isBar) {
        // Stacked Only
        svg.selectAll((isTypeColumn ? '.axis.x' : '.axis.y') + ' .tick:nth-child(' + (o.i + 2) + ')').style('font-weight', 'bolder');

        svg.selectAll('.bar:nth-child(' + (o.i + 1) + ')').classed('is-selected', true).style('opacity', 1);

        svg.selectAll('.bar.is-selected').each(function (d, i) {
          var bar = d3.select(this);
          var data = d;
          if (dataset) {
            data = isBar && isStacked ? dataset[i][o.i] : dataset[i].data[o.i];
          }
          selectedBars.push({ elem: bar.node(), data: data });
        });
        triggerData = selectedBars;
      } else if (isTypePie) {
        // Pie
        // Unselect selected ones
        svg.selectAll('.slice').classed('is-selected', false).classed('is-not-selected', true).attr('transform', '');

        var thisArcData = dataset && dataset[0] && dataset[0].data ? //eslint-disable-line
        dataset[0].data[o.i] : o.d ? o.d.data : o.d; //eslint-disable-line

        selector.classed('is-selected', true).classed('is-not-selected', false).attr('transform', 'scale(1.025, 1.025)');
        triggerData.push({ elem: selector.nodes(), data: thisArcData, index: o.i });
      }
    } else {
      // Task make unselected
      svg.selectAll('.bar, .target-bar').style('opacity', 1);
      pnPositiveText.style('font-weight', 'bolder');
      pnNegativeText.style('font-weight', 'bolder');

      if (isTypePie) {
        selector.classed('is-selected', false).style('stroke', '#fff').style('stroke-width', '1px').attr('transform', '');
      }
    }

    if (charts.clickedLegend) {
      charts.clickedLegend = false;
    }

    charts.selected = triggerData;

    if (o.isTrigger) {
      $(o.container).triggerHandler(taskSelected ? 'selected' : 'unselected', [triggerData]);
    }
  };

  /**
   * Set the select element based on provided options and fire the events.
   * @private
   * @param {object} o An object with various
   * @param {boolean} isToggle If the select is a toggle of the state
   * @param {object} internals An object passing in chart internals
  */
  charts.setSelected = function (o, isToggle, internals) {
    if (!o) {
      return;
    }

    var selected = 0;
    var equals = utils.equals;
    var legendsNode = internals.isPie ? internals.svg.node().nextSibling : internals.svg.node().parentNode.nextSibling;
    var legends = d3.select(legendsNode);
    var isLegends = legends.node() && legends.classed('chart-legend');
    var barIndex = void 0;
    var selector = void 0;
    var isStackedGroup = void 0;
    var xGroup = void 0;

    var setSelectedBar = function setSelectedBar(g) {
      var isGroup = !!g;
      g = isGroup ? d3.select(g) : internals.svg;
      g.selectAll('.bar').each(function (d, i) {
        if (!d) {
          return;
        }
        if (selected < 1) {
          if (typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.fieldValue === d[o.fieldName] || typeof o.index !== 'undefined' && o.index === i || o.data && equals(o.data, internals.chartData[d.index].data[i]) || o.elem && $(this).is(o.elem)) {
            selected++;
            selector = d3.select(this);
            barIndex = i;
            if (isGroup && !internals.isStacked) {
              isStackedGroup = true;
            }
          }
        }
      });
    };

    var setSelectedGroup = function setSelectedGroup() {
      var groups = internals.svg.selectAll('.series-group');

      if (groups.nodes().length) {
        groups.each(function () {
          setSelectedBar(this);
        });
      }
    };

    if (internals.isGrouped || internals.isStacked && !internals.isSingle) {
      internals.chartData.forEach(function (d, i) {
        //eslint-disable-line
        if (selected < 1) {
          xGroup = $(internals.svg.select('[data-group-id="' + i + '"]').node()); //eslint-disable-line
          if (typeof o.groupName !== 'undefined' && typeof o.groupValue !== 'undefined' && o.groupValue === d[o.groupName] || typeof o.groupIndex !== 'undefined' && o.groupIndex === i || o.data && equals(o.data, d) || o.elem && xGroup.is(o.elem)) {
            if (typeof o.fieldName === 'undefined' && typeof o.fieldValue === 'undefined' && typeof o.index === 'undefined') {
              selected++;
              selector = internals.svg.select('[data-group-id="' + i + '"]').select('.bar'); //eslint-disable-line
              barIndex = i;

              if (internals.isStacked && !internals.isGrouped) {
                isStackedGroup = true;
              }
            }
          }
        }
      });
      if (selected < 1) {
        setSelectedGroup();
      }
    } else {
      setSelectedBar();
    }

    if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
      if (isStackedGroup) {
        if (isLegends) {
          $(legends.selectAll('.chart-legend-item').nodes()[barIndex]).trigger('click.chart');
        }
      } else {
        selector.on('click').call(selector.node(), selector.datum(), barIndex);
      }
    }
  };

  /**
   * Check if the labels collide.
   * @private
   * @param {object} svg The svg dom element.
   * @returns {boolean} True if the labels collide.
  */
  charts.labelsColide = function (svg) {
    var ticks = svg.selectAll('.x text');
    var collides = false;

    ticks.each(function (d1, i) {
      var rect1 = this.getBoundingClientRect();
      var rect2 = void 0;

      ticks.each(function (d2, j) {
        if (i !== j) {
          rect2 = this.getBoundingClientRect();

          var overlaps = !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom);

          if (overlaps) {
            collides = true;
          }
        }
      });
    });

    return collides;
  };

  /**
   * Apply a different length label
   * @private
   * @param  {object}  svg  The svg element.
   * @param  {array}  dataArray The data.
   * @param  {object}  elem The dom element
   * @param  {object}  selector The d3 selection
   * @param  {boolean} isNoEclipse True if its an eclipse.
   */
  charts.applyAltLabels = function (svg, dataArray, elem, selector, isNoEclipse) {
    var ticks = selector ? svg.selectAll(selector) : svg.selectAll('.x text');

    ticks.each(function (d1, i) {
      var text = dataArray[i] ? dataArray[i][elem] : '';

      text = text || (isNoEclipse ? d3.select(this).text().substring(0, 1) : d3.select(this).text().substring(0, 6) + '...');

      d3.select(this).text(text);
    });
  };

  /**
   * Trigger the right click event.
   * @private
   * @param  {object} container  The svg container.
   * @param  {object} elem The element that was right clicked.
   * @param  {object} d The data object
   */
  charts.triggerContextMenu = function (container, elem, d) {
    d3.event.preventDefault();
    d3.event.stopPropagation();
    d3.event.stopImmediatePropagation();

    var e = $.Event('contextmenu');
    e.target = elem;
    e.pageX = d3.event.pageX;
    e.pageY = d3.event.pageY;
    $(container).trigger(e, [elem, d]);
  };

  /**
   * Wraps SVG text http://bl.ocks.org/mbostock/7555321
   * @private
   * @param {object} node  The svg element.
   * @param {number}  width The width at which to wrap
   * @param {object} labelFactor The dom element
   */
  charts.wrap = function (node, width, labelFactor) {
    if (!labelFactor) {
      labelFactor = 1.27;
    }

    if (!width) {
      labelFactor = 60;
    }

    node.each(function () {
      var text = d3.select(this);
      var words = text.text().split(/\s+/).reverse();
      var word = '';
      var line = [];
      var lineNumber = 0;

      if (words.length <= 1) {
        return;
      }

      var lineHeight = labelFactor; // ems
      var y = text.attr('y');
      var x = text.attr('x');
      var dy = parseFloat(text.attr('dy'));
      var tspan = text.text(null).append('tspan').attr('x', x).attr('y', y).attr('dy', dy + 'em');

      while (word = words.pop()) {
        //eslint-disable-line
        line.push(word);
        tspan.text(line.join(' '));

        if (tspan.node().getComputedTextLength() > width) {
          line.pop();
          tspan.text(line.join(' '));
          line = [word];
          tspan = text.append('tspan').attr('x', x).attr('y', y).attr('dy', ++lineNumber * lineHeight + dy + 'em').text(word);
        }
      }
    });
  };

  /* eslint-disable no-loop-func */

  // Settings and Options
  var COMPONENT_NAME$g = 'bullet';

  /**
   * A bullet graph is a variation of a bar graph developed by Stephen Few.
   * Seemingly inspired by the traditional thermometer charts and progress bars found in many
   * dashboards, the bullet graph serves as a replacement for dashboard gauges and meters.
   * @class Bullet
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {array} [settings.dataset.data] The data to use in the chart.
   * @param {array} [settings.dataset.data.tooltip] Tooltip contents for each point.
   * @param {boolean|string} [settings.animate=true] true|false - will do or not do the animation, 'initial' will do only first time the animation.
   * @param {boolean} [settings.redrawOnResize=true] If true, the component will not resize when resizing the page.
   */
  var BULLET_DEFAULTS = {
    dataset: [],
    animate: true,
    redrawOnResize: true
  };

  function Bullet(element, settings) {
    this.settings = utils.mergeSettings(element, settings, BULLET_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Bullet.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The bullet chart prototype for chaining.
     */
    init: function init() {
      this.width = 0;

      // Do initialization. Build or Events ect
      this.build().handleEvents();

      // Handle initial option
      if (this.settings.animate === 'initial') {
        this.settings.animate = false;
      }

      return this;
    },


    /**
     * Build the Bullet Chart.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    build: function build() {
      var _this = this;

      var chartData = this.settings.dataset[0];
      this.element.addClass('bullet-chart');

      var tooltipInterval = 0;
      var tooltipDataCache = [];
      var tooltipData = chartData.data[0] ? chartData.data[0].tooltip : [];

      // Append the SVG into its parent area.
      var noMarkers = false;
      var parent = this.element.parent();
      var margin = { top: 30, right: 35, bottom: 35, left: 40 };
      var width = parent.width() - margin.left - margin.right;
      var height = parent.height() - margin.top - margin.bottom - 30; // 30 for legend

      height = height < 0 ? 50 : height; // default minimum height

      var svg = d3.select(this.element[0]).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      function bulletWidth(x) {
        var x0 = x(0);
        return function (d) {
          return Math.abs(x(d) - x0);
        };
      }

      var _loop = function _loop(i) {
        var duration = _this.settings.animate ? 600 : 0;
        var barHeight = 20;
        var self = _this;
        var rowData = chartData.data[i];
        var ranges = rowData.ranges.slice().sort(d3.descending);
        var markers = rowData.markers ? rowData.markers.slice().sort(d3.descending) : [];
        var measures = rowData.measures ? rowData.measures.slice().sort(d3.descending) : [];
        var rangesAsc = rowData.ranges.slice().sort(d3.ascending);
        var markersAsc = rowData.markers ? rowData.markers.slice().sort(d3.ascending) : [];
        var measuresAsc = rowData.measures ? rowData.measures.slice().sort(d3.ascending) : [];

        if (markers.length === 0) {
          markers = measures;
          markersAsc = measuresAsc;
          noMarkers = true;
        }

        var g = svg.append('g').attr('class', 'bullet').attr('transform', 'translate(0, ' + i * (barHeight * 3.5) + ')');

        // Add Title and Subtitle
        var title = g.append('g');

        var text = title.append('text').attr('class', 'title').attr('dy', '-10px').text(function () {
          return rowData.title;
        });

        text.append('tspan').attr('class', 'subtitle').attr('dx', '15px').text(function () {
          return rowData.subtitle;
        });

        var maxAll = Math.max(ranges[0], markers[0], measures[0]);
        var minAll = Math.min(rangesAsc[0], markersAsc[0], measuresAsc[0]);

        minAll = minAll < 0 ? minAll : 0;

        // Compute the new x-scale.
        var x1 = d3.scaleLinear().domain([minAll, maxAll]).range([0, width]).nice();

        // Derive width-scales from the x-scales.
        var w1 = bulletWidth(x1);

        // Update the range rects.
        var range = g.selectAll('rect.range').data(ranges);

        range.enter().append('rect').attr('class', function (d, a) {
          return 'range s' + a;
        }).attr('data-idx', i).attr('width', 0).attr('x', function (d) {
          return x1(d < 0 ? d : 0);
        }).style('fill', function (d, b) {
          if (chartData.barColors) {
            return chartData.barColors[b];
          }
          return '';
        }).attr('height', barHeight).on('click', function () {
          var bar = d3.select(this);
          self.element.trigger('selected', [bar, chartData.data[bar.attr('data-idx')]]);
        }).on('mouseenter', function (d, mouseEnterIdx) {
          var bar = d3.select(this);
          var data = chartData.data[bar.attr('data-idx')];
          var rect = this.getBoundingClientRect();
          var content = '<p>' + d + '</p>';

          var show = function show() {
            var size = charts.tooltipSize(content);
            var x = rect.left + rect.width - size.width / 2;
            var y = rect.top - size.height + $(window).scrollTop() - 5;

            if (content !== '') {
              charts.showTooltip(x, y, content, 'top');
            }
          };

          if (data.tooltip && data.tooltip[mouseEnterIdx]) {
            content = data.tooltip[data.tooltip.length - mouseEnterIdx - 1];
          }

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[mouseEnterIdx]) {
            content = '';
            var runInterval = true;
            tooltipInterval = setInterval(function () {
              if (runInterval) {
                runInterval = false;
                tooltipData(function (da) {
                  content = da;
                  tooltipDataCache[i] = da;
                });
              }
              if (content !== '') {
                clearInterval(tooltipInterval);
                show();
              }
            }, 10);
          } else {
            tooltipData = (typeof tooltipData === 'undefined' ? 'undefined' : _typeof(tooltipData)) === 'object' ? '' : tooltipData;
            content = tooltipDataCache[i] || tooltipData || content || '';
            show();
          }
        }).on('mouseleave', function () {
          clearInterval(tooltipInterval);
          charts.hideTooltip();
        }).merge(range).transition().duration(duration).attr('width', w1);

        // Update the measure rects.
        var measure = g.selectAll('rect.measure').data(measures);

        measure.enter().append('rect').attr('class', function (d, k) {
          return 'measure s' + k;
        }).attr('width', 0).attr('height', 3).attr('x', function (d) {
          return x1(d < 0 ? d : 0);
        }).style('fill', function (d, j) {
          if (chartData.lineColors) {
            return chartData.lineColors[j];
          }
          return '';
        }).attr('y', 8.5).merge(measure).transition().duration(duration).attr('width', w1);

        // Update the marker lines.
        var marker = g.selectAll('line.marker').data(markers);

        marker.enter().append('line').attr('class', noMarkers ? 'hidden' : 'marker').attr('x1', 0).attr('x2', 0).style('stroke', function (d, l) {
          if (chartData.markerColors) {
            return chartData.markerColors[l];
          }
          return '';
        }).attr('y1', barHeight / 6).attr('y2', barHeight * 5 / 6).merge(marker).transition().duration(duration).attr('x1', x1).attr('x2', x1).attr('y1', barHeight / 6).attr('y2', barHeight * 5 / 6);

        // Difference
        var diff = (markers[0] > measures[0] ? '-' : '+') + Math.abs(markers[0] - measures[0]);

        if (Math.abs(markers[0] - measures[0]) !== 0) {
          marker.enter().append('text').attr('class', 'inverse').attr('text-anchor', 'middle').attr('y', barHeight / 2 + 4).attr('dx', '20px').attr('x', 0).text(diff).merge(marker).transition().duration(duration).attr('x', function () {
            var total = 0;

            g.selectAll('.measure').each(function (d) {
              var w = w1(d);
              var x = x1(d);

              if (w > total) {
                total = w;
              }

              if (x > total) {
                total = x;
              }
            });

            return total;
          }).style('opacity', 1);
        }

        // Update the tick groups.
        var tick = g.selectAll('g.tick').data(x1.ticks(8));

        // Initialize the ticks with the old scale, x0.
        var tickEnter = tick.enter().append('g').attr('class', 'tick').attr('transform', 'translate(0,0)').style('opacity', 0);

        tickEnter.append('line').attr('y1', barHeight).attr('y2', Math.round(barHeight * 7 / 4.7));

        tickEnter.append('text').attr('text-anchor', 'middle').attr('dy', '1.1em').attr('y', Math.round(barHeight * 7 / 4.7)).attr('class', function (d) {
          return d < 0 ? 'negative-value' : 'positive-value';
        }).text(function (d) {
          return d;
        });

        // Transition the entering ticks to the new scale, x1
        tickEnter.transition().duration(duration).attr('transform', function (d) {
          return 'translate(' + x1(d) + ',0)';
        }).style('opacity', 1);
      };

      for (var i = 0; i < chartData.data.length; i++) {
        _loop(i);
      }

      charts.appendTooltip();
      this.element.trigger('rendered');

      return this;
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element.on('updated.' + COMPONENT_NAME$g, function () {
        _this2.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$g, function () {
          _this2.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$g, function () {
          _this2.handleResize();
        });
      }

      return this;
    },


    /*
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }
      this.element.empty();

      return this.build();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$g + ' resize.' + COMPONENT_NAME$g);
      $('body').off('resize.' + COMPONENT_NAME$g);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('bullet-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$g);
      $.removeData(this.element[0], 'chart');
    }
  };

  // Other Shared Imports

  // Settings and Options
  var COMPONENT_NAME$h = 'completion-chart';

  /**
  * A completion chart shows completion over a target value. Usually used to show progress as a percentage.
  * @class CompletionChart
  * @param {string} element The plugin element for the constuctor
  * @param {string} [settings] The settings element.
  *
  * @param {array} [settings.dataset.data] The data to use in the chart (See examples)
  * @param {string} [settings.dataset.data.name] - Required object with the title text `{text: 'Available Credit'}`
  * @param {number} [settings.dataset.data.completed] - Required data for the complete section `{text: 'Spent', value: 50000, format: '$,.0f'}`
  * @param {array} [settings.dataset.data.remaining] - Required data for the remaining section `{text: 'Pending', value: 10000, format: '$,.0f'}`
  * @param {array} [settings.dataset.data.total] - Optional data for the total section `{value: 95000, format: '$,.0f'}`
  */

  var COMPLETION_CHART_DEFAULTS = {
    dataset: []
  };

  function CompletionChart(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COMPLETION_CHART_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  CompletionChart.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The completion chart prototype for chaining.
     */
    init: function init() {
      // Do initialization. Build or Events ect
      this.build().handleEvents();

      return this;
    },


    /**
     * Build the Completion Chart.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    build: function build() {
      var _this = this;

      var chartData = this.settings.dataset[0];

      // Handle Empty Data Set
      if (this.settings.dataset.length === 0) {
        chartData = {};
        chartData.data = [{
          name: { text: Locale ? Locale.translate('NoData') : 'No Data Available' },
          completed: { value: 0 }
        }];
      }

      var dataset = chartData.data[0];
      var isTarget = this.settings.type === 'completion-target';
      var isAchievment = this.settings.type === 'targeted-achievement';

      $(this.element).addClass('completion-chart' + (this.settings.type === 'targeted-achievement' ? ' chart-targeted-achievement' : ''));

      // Set total defaults
      dataset.total = $.extend({}, { value: 100 }, dataset.total);

      // Basic functions
      var isUndefined = function isUndefined(value) {
        return typeof value === 'undefined';
      };

      var fixUndefined = function fixUndefined(value, isNumber) {
        var defaultValue = isNumber ? 0 : '';
        return !isUndefined(value) ? value : defaultValue;
      };

      var toValue = function toValue(percent, ds) {
        ds = ds || dataset;
        return percent / 100 * fixUndefined(ds.total.value, true);
      };

      var toPercent = function toPercent(value, ds) {
        ds = ds || dataset;
        return Math.round(100 * (value / fixUndefined(ds.total.value, true)));
      };

      var localePercent = function localePercent(value) {
        return Locale.formatNumber(value / 100, { style: 'percent', maximumFractionDigits: 0 });
      };

      var format = function format(value, formatterString, ds) {
        if (formatterString === '.0%') {
          return localePercent(toPercent(value, ds));
        }
        return d3.format(formatterString || '')(value);
      };

      var fixPercent = function fixPercent(value, ds) {
        var s = value.toString();
        if (s.indexOf('%') !== -1) {
          return toValue(s.replace(/%/g, ''), ds);
        }
        return value;
      };

      var updateWidth = function updateWidth(elem, value, ds) {
        var percent = toPercent(value, ds);
        percent = percent < 0 ? 0 : percent;
        var w = percent > 100 ? 100 : percent;
        elem[0].style.width = w + '%';

        if (w === 0) {
          elem[0].className += 'is-empty';
        }
      };

      var updateTargetline = function updateTargetline(elem, value) {
        var min = value < 0 ? 0 : value;
        var w = value > 100 ? 100 : min;
        elem[0].style.left = w + '%';
      };

      var setFormat = function setFormat(obj, ds, isPrivate) {
        var value = isPrivate ? obj._value : obj.value; //eslint-disable-line
        return obj && !isUndefined(value) && obj.format ? //eslint-disable-line
        format(fixPercent(value, ds), obj.format, ds) : //eslint-disable-line
        obj ? fixPercent(value, ds) : 0;
      };

      var self = this;

      var setOverlap = function setOverlap() {
        if (isTarget && !isAchievment) {
          setTimeout(function () {
            var remaining = $('.remaining', self.element);
            var total = $('.total', self.element);
            var rect1 = $('.completed .value', self.element)[0].getBoundingClientRect();
            var rect2 = remaining.find('.value')[0].getBoundingClientRect();

            remaining.add(total)[rect1.right > rect2.left - 20 ? 'addClass' : 'removeClass']('overlap');
          }, 500);
        }
      };

      var getSpecColor = function getSpecColor(ds) {
        var specColor = {};
        ds = ds || dataset;

        if (ds.info && !isUndefined(ds.info.color)) {
          if (dataset.info.color.indexOf('#') === 0) {
            specColor.info = true;
          }
        }
        if (ds.completed && !isUndefined(ds.completed.color)) {
          if (ds.completed.color.indexOf('#') === 0) {
            specColor.completed = true;
          }
        }
        if (ds.remaining && !isUndefined(ds.remaining.color)) {
          if (ds.remaining.color.indexOf('#') === 0) {
            specColor.remaining = true;
          }
        }
        if (ds.targetline && !isUndefined(ds.targetline.color)) {
          if (ds.targetline.color.indexOf('#') === 0) {
            specColor.targetline = true;
          }
        }
        return specColor;
      };

      var getTotalText = function getTotalText(ds) {
        var totalText = '';
        var difference = {};

        ds = ds || dataset;

        if (ds.total.difference) {
          difference.value = ds.total.value - ds.completed.value;
          difference.format = dataset.total.format;
        }

        totalText = (!ds.total.textOnly ? setFormat(ds.total.difference ? difference : ds.total) : '') + (ds.total.text || '');

        totalText = isAchievment && ds.remaining ? (!ds.remaining.textOnly ? setFormat(ds.remaining) : '') + (ds.remaining.text || '') : totalText;

        return totalText;
      };

      var percentTextDefault = { show: false, color1: '', color2: 'inverse' };
      var percentText = $.extend({}, percentTextDefault, dataset.percentText);
      var setPercentText = function setPercentText(ds) {
        ds = ds || dataset;
        percentText._value = ds.completed ? ds.completed.value : 0; //eslint-disable-line
        percentText.percent = toPercent(fixUndefined(percentText._value, true), ds); //eslint-disable-line
        percentText.format = '.0%';
        percentText._text = typeof percentText.text !== 'undefined' ? //eslint-disable-line
        percentText.text : typeof percentText.value !== 'undefined' ? //eslint-disable-line
        localePercent(percentText.value) : setFormat(percentText, ds, true);
        percentText.color = percentText[percentText.percent > 55 ? 'color2' : 'color1'];
      };

      var c = void 0; // Cache will after created

      var cacheElements = function cacheElements() {
        c = {
          name: $('.name', _this.element),
          info: {
            value: $('.info .value', _this.element),
            text: $('.info .text', _this.element)
          },
          completed: {
            bar: $('.completed.bar', _this.element),
            value: $('.completed .value', _this.element),
            text: $('.completed .text, .completed-label .text', _this.element)
          },
          remaining: {
            bar: $('.remaining.bar', _this.element),
            value: $('.remaining .value', _this.element),
            text: $('.remaining .text', _this.element)
          },
          targetline: {
            bar: $('.targetline', _this.element),
            value: $('.targetline .value', _this.element),
            text: $('.targetline .text', _this.element)
          },
          total: {
            bar: $('.total.bar', _this.element),
            value: $('.total.value', _this.element)
          },
          percentText: $('.chart-percent-text', _this.element)
        };
      };

      var setJsonData = function setJsonData(ds) {
        ds = ds || dataset;
        c.name.data('jsonData', { name: ds.name });
        c.info.value.add(c.info.text).data('jsonData', { info: ds.info });
        c.completed.bar.add(c.completed.value).add(c.completed.text).data('jsonData', { completed: ds.completed });
        c.remaining.bar.add(c.remaining.value).add(c.remaining.text).data('jsonData', { remaining: ds.remaining });
        c.targetline.bar.add(c.targetline.value).add(c.targetline.text).data('jsonData', { targetline: ds.targetline });
        c.total.bar.add(c.total.value).data('jsonData', { total: ds.total });
        c.percentText.data('jsonData', { percentText: ds.percentText });
      };

      var updateBars = function updateBars(ds) {
        var w = void 0;
        ds = ds || dataset;
        // Update completed bar width
        if (ds.completed) {
          w = fixPercent(ds.completed.value, ds);
          updateWidth(c.completed.bar, w, ds);
        }

        // Update remaining bar width
        if (ds.remaining) {
          w = fixPercent(ds.completed.value, ds) + fixPercent(ds.remaining.value, ds);
          updateWidth(c.remaining.bar, w, ds);
          setOverlap();
        }

        // Update target line bar position
        if (ds.targetline) {
          w = fixPercent(ds.targetline.value, ds);
          updateTargetline(c.targetline.bar, w, ds);
        }
      };

      if (!isUndefined(percentText.color) && percentText.color1 === '') {
        percentText.color1 = percentText.color;
      }

      // Render
      var html = { body: $('<div class="total bar" />') };
      var specColor = getSpecColor();

      if (isTarget || isAchievment) {
        var totalText = getTotalText();

        html.body.addClass('chart-completion-target' + (isAchievment ? ' chart-targeted-achievement' : ''));

        html.label = '<span class="label">\n        <span class="name">\n          ' + (dataset.completed.color && dataset.completed.color === 'error' ? $.createIcon({ icon: 'error', classes: 'icon-error' }) : '') + '\n          ' + fixUndefined(dataset.name.text) + '</span>\n        <span class="l-pull-right total value">' + totalText + '</span>\n      </span>';
      } else {
        html.body.addClass('chart-completion');
        var name = fixUndefined(dataset.name.text);
        var completedColor = fixUndefined(dataset.completed.color);
        var infoColor = fixUndefined(dataset.info.color);
        var bColor = dataset.info.color && !specColor.info ? infoColor : '';
        var infoText = fixUndefined(dataset.info.text);

        if (!specColor.completed) {
          bColor = completedColor;
        }

        var styleColor = '';
        if (dataset.info.color && specColor.info) {
          styleColor = infoColor;
        }

        if (specColor.completed) {
          styleColor = completedColor;
        }

        var styleValue = dataset.info && !isUndefined(dataset.info.value) ? fixUndefined(dataset.info.value) : setFormat(dataset.completed);

        html.label = '<b class="label name">' + name + '</b>\n      <b class="label info ' + bColor + ' colored">\n      <span class="value ' + bColor + '" ' + (styleColor ? 'style="color:' + styleColor : '') + '">' + styleValue + '</span>\n      <span class="text ' + bColor + '" ' + (styleColor ? 'style="color:' + styleColor : '') + '">' + infoText + '</span>\n      </b>';
      }

      if (dataset.remaining) {
        html.remaining = '' + ('' + '<div class="target remaining bar') + (!specColor.remaining ? ' ' + fixUndefined(dataset.remaining.color) : '') + '"' + (specColor.remaining ? ' style="color:' + dataset.remaining.color + ';background-color:' + dataset.remaining.color + ';"' : '') + '">' + (isAchievment ? '' : '<span aria-hidden="true"' + (!isTarget && !isAchievment ? ' class="audible"' : '') + '>' + ('<span class="value' + (!specColor.remaining ? ' ' + fixUndefined(dataset.remaining.color) : '') + '"' + (specColor.remaining ? ' style="color:' + dataset.remaining.color + ';"' : '') + '">' + setFormat(dataset.remaining) + '</span><br />') + ('<span class="text' + (!specColor.remaining ? ' ' + fixUndefined(dataset.remaining.color) : '') + '"' + (specColor.remaining ? ' style="color:' + dataset.remaining.color + ';"' : '') + '">' + fixUndefined(dataset.remaining.text) + '</span>') + '</span>') + '</div>';
      } else {
        html.remaining = '<div class="target remaining bar" style="opacity: 0"></div>';
      }

      if (dataset.completed && isAchievment) {
        setPercentText();
        specColor.percentText = percentText.color.indexOf('#') === 0;

        html.completed = '' + ('' + '<div class="completed bar') + (!specColor.completed ? ' ' + fixUndefined(dataset.completed.color) : '') + '"' + (specColor.completed ? ' style="color:' + dataset.completed.color + ';background-color:' + dataset.completed.color + ';"' : '') + '"></div>' + (percentText.show ? '<div class="chart-percent-text' + (!specColor.percentText && percentText.color !== '' ? ' ' + percentText.color : '') + '"' + (specColor.percentText ? ' style="color:' + percentText.color + ';"' : '') + '>' + percentText._text + '</div>' : '' //eslint-disable-line
        ) + '<span class="completed-label" aria-hidden="true"' + (!isTarget && !isAchievment ? ' class="audible"' : '') + '>' + ('<span class="text">' + fixUndefined(dataset.completed.text) + '</span>') + '</span>';
      }

      if (dataset.completed && !isAchievment) {
        html.completed = '' + ('' + '<div class="completed bar') + (!specColor.completed ? ' ' + fixUndefined(dataset.completed.color) : '') + '"' + (specColor.completed ? ' style="color:' + dataset.completed.color + ';background-color:' + dataset.completed.color + ';"' : '') + '>' + ('<span aria-hidden="true"' + (!isTarget && !isAchievment ? ' class="audible"' : '') + '>') + ('<span class="value' + (!specColor.completed ? ' ' + fixUndefined(dataset.completed.color) : '') + '"' + (specColor.completed ? ' style="color:' + dataset.completed.color + ';"' : '') + '">' + setFormat(dataset.completed) + '</span><br />') + ('<span class="text' + (!specColor.completed ? ' ' + fixUndefined(dataset.completed.color) : '') + '"' + (specColor.completed ? ' style="color:' + dataset.completed.color + ';"' : '') + '">' + fixUndefined(dataset.completed.text) + '</span>') + '</span></div>';
      }

      if (dataset.targetline) {
        html.targetline = '' + ('' + '<div class="target-line targetline bar') + (!specColor.targetline ? ' ' + fixUndefined(dataset.targetline.color) : '') + '"' + (specColor.targetline ? ' style="color:' + dataset.targetline.color + ';background-color:' + dataset.targetline.color + ';"' : '') + '">' + ('<span aria-hidden="true"' + (!isTarget && !isAchievment ? ' class="audible"' : '') + '>') + ('<span class="value' + (!specColor.targetline ? ' ' + fixUndefined(dataset.targetline.color) : '') + '"' + (specColor.targetline ? ' style="color:' + dataset.targetline.color + ';"' : '') + '">' + setFormat(dataset.targetline) + '</span><br />') + ('<span class="text' + (!specColor.targetline ? ' ' + fixUndefined(dataset.targetline.color) : '') + '"' + (specColor.targetline ? ' style="color:' + dataset.targetline.color + ';"' : '') + '">' + fixUndefined(dataset.targetline.text) + '</span>') + '</span>' + '</div>';
      }

      DOM.append(html.body, (html.remaining || '') + (html.completed || '') + (html.targetline || ''), '<div><span><br>');
      DOM.append(this.element, html.label + html.body.prop('outerHTML'), '<div><span><br>');

      cacheElements();
      setJsonData();
      updateBars();

      return this;
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element.on('updated.' + COMPONENT_NAME$h, function () {
        _this2.updated();
      });

      return this;
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings object
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      var type = settings.type || this.settings.type;
      this.settings = settings;
      this.settings.type = type;
      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }
      this.element.empty();

      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$h);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('completion-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$h);
      $.removeData(this.element[0], 'chart');
    }
  };

  /* eslint-disable no-nested-ternary, prefer-arrow-callback */

  // Settings and Options
  var COMPONENT_NAME$i = 'sparkline';

  // The Component Defaults
  var SPARKLINE_DEFAULTS = {
    dataset: [],
    colors: ['#1D5F8A', '#999999', '#bdbdbd', '#d8d8d8'],
    isDots: false,
    isPeakDot: false,
    isMinMax: false,
    isMedianRange: false
  };

  /**
   * Sparklines are a compact way to show trends.
   * @class Sparkline
   * @param {string} element The plugin element for the constuctor
   * @param {string} settings The settings element.
   * @param {array} [settings.dataset] The data to use in the sparklines.
   * @param {array} [settings.colors = ['#1D5F8A', '#999999', '#bdbdbd', '#d8d8d8']] An array of color sequences in hex format fx #1D5F8A,
   * defaulting to the correct standard colors.
   * @param {boolean} [settings.isDots = false] Shows dots on the data points.
   * @param {boolean} [settings.isPeakDot = false] Highlights the top value as peak with a special dot.
   * @param {boolean} [settings.isMinMax  = false] Shows a continuous shading to highlight the min and max values.
   * @param {boolean} [settings.isMedianRange  = false] Adds a median range display.
   */
  function Sparkline(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SPARKLINE_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Sparkline.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The sparkline prototype for chaining.
     */
    init: function init() {
      this.sparklineColors = d3.scaleOrdinal().range(this.settings.colors);

      return this.build().handleEvents();
    },


    /**
     * Build the Sparkline Chart.
     * @private
     * @returns {object} The sparkline prototype for chaining.
     */
    build: function build() {
      // chartData, options
      // Sparkline Chart
      var self = this;
      var tooltipIntervalMedianRange = void 0;
      var tooltipIntervalDots = void 0;
      var tooltipDataCacheMedianRange = [];
      var tooltipDataCacheDots = [];
      var tooltipData = self.settings.tooltip;

      // calculate max and min values in the NLWest data
      var max = 0;
      var min = 0;
      var len = 0;
      var i = void 0;
      var dimensions = this.calculateAspectRatioFit({
        srcWidth: 385,
        srcHeight: 65,
        maxWidth: this.element.width(),
        maxHeight: 600 // container min-height
      });
      var dotsize = dimensions.width > 300 ? 4 : 3;

      var chartData = self.settings.dataset;
      for (i = 0; i < chartData.length; i++) {
        min = d3.min([d3.min(chartData[i].data), min]);
        max = d3.max([d3.max(chartData[i].data), max]);
        len = d3.max([chartData[i].data.length, len]);
      }

      // Make the lines based on the range of values and width
      var p = 10;
      var w = dimensions.width;
      var h = dimensions.height;
      var x = d3.scaleLinear().domain([0, len]).range([p, w - p]);
      var y = d3.scaleLinear().domain([min, max]).range([h - p, p]);
      var line = d3.line().x(function (d, j) {
        return x(j);
      }).y(function (d) {
        return y(d);
      });

      // Add the tooltip dom element
      charts.appendTooltip();

      // Append to the main dom element
      var svg = d3.select(this.element[0]).append('svg').attr('height', h).attr('width', w);

      // Add Median Range
      // https://www.purplemath.com/modules/meanmode.htm
      if (self.settings.isMedianRange) {
        max = d3.max(chartData[0].data);
        min = d3.min(chartData[0].data);

        var minWidth = 10;
        var maxWidth = w - 45;
        var median = d3.median(chartData[0].data);
        var range = max - min;
        var scaleMedianRange = d3.scaleLinear().domain([min, max]).range([0, h]);
        var top = h - scaleMedianRange(median > range ? median : range);
        var bot = h - scaleMedianRange(median < range ? median : range);

        svg.append('g').attr('class', 'medianrange').attr('transform', function () {
          return 'translate(' + minWidth + ',' + top + ')';
        }).append('rect').attr('width', maxWidth).attr('height', bot).style('fill', '#d8d8d8').on('mouseenter', function () {
          var rect = this.getBoundingClientRect();
          var content = '<p class="sparkline-tooltip">' + // eslint-disable-line
          Locale.translate('Median') + '<b>' + median + '</b><br>' + Locale.translate('Range') + '<b>' + range + '</b>' + (self.settings.isPeakDot ? '<br>' + Locale.translate('Peak') + '<b>' + max + '</b>' : '') + '</p>'; // eslint-disable-line

          var show = function show() {
            var size = charts.tooltipSize(content);
            var posX = rect.left + (rect.width - size.width) / 2;
            var posY = rect.top - size.height - 5; // 5 is extra padding

            if (content !== '') {
              charts.showTooltip(posX, posY, content, 'top');
            }
          };

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCacheMedianRange[i]) {
            content = '';
            var runInterval = true;
            tooltipIntervalMedianRange = setInterval(function () {
              if (runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = data;
                  tooltipDataCacheMedianRange[i] = data;
                });
              }
              if (content !== '') {
                clearInterval(tooltipIntervalMedianRange);
                show();
              }
            }, 10);
          } else {
            tooltipData = (typeof tooltipData === 'undefined' ? 'undefined' : _typeof(tooltipData)) === 'object' ? '' : tooltipData;
            content = tooltipDataCacheMedianRange[i] || tooltipData || chartData[0].tooltip || content || '';
            show();
          }
        }).on('mouseleave', function () {
          clearInterval(tooltipIntervalMedianRange);
          charts.hideTooltip();
        });
      }

      for (i = 0; i < chartData.length; i++) {
        var set = chartData[i];
        var g = svg.append('g');

        g.append('path').attr('d', line(set.data)).attr('stroke', self.settings.isMinMax ? '#999999' : this.sparklineColors(i)).attr('class', 'team connected-line');
      }

      // Add Dots (Dots/Peak/MinMAx)
      min = d3.min(chartData[0].data);
      svg.selectAll('.point').data(chartData[0].data).enter().append('circle').attr('r', function (d) {
        return self.settings.isMinMax && max === d || self.settings.isMinMax && min === d ? dotsize + 1 : self.settings.isDots || self.settings.isPeakDot && max === d ? dotsize : 0;
      }).attr('class', function (d) {
        return self.settings.isPeakDot && max === d && !self.settings.isMinMax ? 'point peak' : self.settings.isMinMax && max === d ? 'point max' : self.settings.isMinMax && min === d ? 'point min' : 'point';
      }).style('fill', function (d) {
        return self.settings.isPeakDot && max === d && !self.settings.isMinMax ? '#ffffff' : self.settings.isMinMax && max === d ? '#56932E' : self.settings.isMinMax && min === d ? '#941E1E' : self.sparklineColors(0);
      }).style('stroke', function (d) {
        return self.settings.isPeakDot && max === d && !self.settings.isMinMax ? self.sparklineColors(0) : self.settings.isMinMax && max === d ? 'none' : self.settings.isMinMax && min === d ? 'none' : '#ffffff';
      }).style('cursor', 'pointer').attr('cx', function (d, m) {
        return x(m);
      }).attr('cy', function (d) {
        return y(d);
      }).on('mouseenter', function (d) {
        var rect = this.getBoundingClientRect();
        var content = '<p>' + (chartData[0].name ? chartData[0].name + '<br> ' + (self.settings.isMinMax && max === d ? Locale.translate('Highest') + ': ' : self.settings.isMinMax && min === d ? Locale.translate('Lowest') + ': ' : self.settings.isPeakDot && max === d ? Locale.translate('Peak') + ': ' : '') : '') + '<b>' + d + '</b></p>';

        var show = function show() {
          var size = charts.tooltipSize(content);
          var posX = rect.left - size.width / 2 + 6;
          var posY = rect.top - size.height - 8;

          if (content !== '') {
            charts.showTooltip(posX, posY, content, 'top');
          }
        };

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCacheDots[i]) {
          content = '';
          var runInterval = true;
          tooltipIntervalDots = setInterval(function () {
            if (runInterval) {
              runInterval = false;
              tooltipData(function (data) {
                content = data;
                tooltipDataCacheDots[i] = data;
              });
            }
            if (content !== '') {
              clearInterval(tooltipIntervalDots);
              show();
            }
          }, 10);
        } else {
          tooltipData = (typeof tooltipData === 'undefined' ? 'undefined' : _typeof(tooltipData)) === 'object' ? '' : tooltipData;
          content = tooltipDataCacheDots[i] || tooltipData || chartData[0].tooltip || content || '';
          show();
        }

        d3.select(this).attr('r', self.settings.isMinMax && max === d || self.settings.isMinMax && min === d ? dotsize + 2 : dotsize + 1);
      }).on('mouseleave', function (d) {
        clearInterval(tooltipIntervalDots);
        charts.hideTooltip();
        d3.select(this).attr('r', self.settings.isMinMax && max === d || self.settings.isMinMax && min === d ? dotsize + 1 : dotsize);
      });

      /**
      * Fires when the sparkline is fully renders.
      *
      * @event close
      * @memberof About
      * @property {object} event - The jquery event object
      * @property {object} ui - The svg element.
      */
      this.element.trigger('rendered', svg);
      return this;
    },


    /**
     * Conserve aspect ratio of the orignal region. Useful when shrinking/enlarging
     * @private
     * @param  {object} d the data element with the properties
     * @returns {object} Object with the calulated width and height
     */
    calculateAspectRatioFit: function calculateAspectRatioFit(d) {
      var ratio = Math.min(d.maxWidth / d.srcWidth, d.maxHeight / d.srcHeight);
      return { width: d.srcWidth * ratio, height: d.srcHeight * ratio };
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('updated.' + COMPONENT_NAME$i, function () {
        _this.updated();
      });

      return this;
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings object
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      var type = settings.type || this.settings.type;
      this.settings = settings;
      this.settings.type = type;
      this.element.empty();

      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$i);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$i);
      $.removeData(this.element[0], 'chart');
    }
  };

  /* eslint-disable consistent-return */

  // The name of this component
  var COMPONENT_NAME$j = 'emptymessage';

  /**
  * The Empty Message is a message with an icon that can be used when no data is present.
  * @class EmptyMessage
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.title = null] The Main text to show.
  * @param {string} [settings.info = null] Longer paragraph text to show
  * @param {string} [settings.icon = null] The name of the icon to use. See {@link https://design.infor.com/code/ids-enterprise/latest/demo/icons/example-empty-widgets?font=source-sans} for options.
  * @param {boolean} [settings.button = null] The botton text and click event to add.
  * @param {string} [settings.color = 'graphite']  Defaults to 'graphite' but can also be azure. Later may be expanded to all personalization colors.
  */
  var EMPTYMESSAGE_DEFAULTS = {
    title: null,
    info: null,
    icon: null,
    button: null,
    color: 'graphite' // or azure for now until personalization works
  };

  function EmptyMessage(element, settings) {
    this.settings = utils.mergeSettings(element, settings, EMPTYMESSAGE_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Component Methods
  EmptyMessage.prototype = {
    init: function init() {
      this.setup().build();
    },
    setup: function setup() {
      this.element.addClass('empty-message');
      return this;
    },
    build: function build() {
      var opts = this.settings;

      if (opts.icon) {
        $('<div class="empty-icon">\n          <svg class="icon-empty-state is-' + this.settings.color + '" focusable="false" aria-hidden="true" role="presentation">\n            <use xlink:href="#' + opts.icon + '"></use>\n          </svg></div>').appendTo(this.element);
      }

      if (opts.title) {
        // Re-evaluate the text
        if (opts.title === '[NoData]') {
          opts.title = Locale ? Locale.translate('NoData') : 'No Data Available';
        }

        $('<div class="empty-title">' + opts.title + '</div>').appendTo(this.element);
      }

      if (opts.info) {
        $('<div class="empty-info">' + opts.info + '</div>').appendTo(this.element);
      }

      if (opts.button) {
        $('' + ('<div class="empty-actions">' + '<button type="button" class="btn-secondary hide-focus ') + opts.button.cssClass + '" id="' + opts.button.id + '">' + ('<span>' + opts.button.text + '</span>') + '</button>' + '</div>').appendTo(this.element);

        if (opts.button.click) {
          this.element.on('click', opts.button.click);
        }
      }

      return this;
    },


    /**
     * Update the component and optionally apply new settings.
     *
     * @param  {object} settings the settings to update to.
     * @returns {void}
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      this.element.empty();
      this.build();
    },


    /**
     * Teardown - Remove added markup and events
     * @returns {void}
     */
    destroy: function destroy() {
      $.removeData(this.element[0], COMPONENT_NAME$j);
      this.element.empty();
    }
  };

  // Empty Message jQuery wrapper
  $.fn.emptymessage = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$j);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$j, new EmptyMessage(this, settings));
      }
    });
  };

  /* eslint-disable no-nested-ternary, prefer-arrow-callback */

  // Settings and Options
  var COMPONENT_NAME$k = 'line';

  /**
   * A line chart or line graph is a type of chart which displays information as a series of data
   * points called 'markers' connected by straight line segments.
   * @class Line
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   *
   * @param {array} [settings.dataset=[]] The data to use in the line/area/bubble.
   * @param {function|string} [settings.tooltip] A custom tooltip or tooltip renderer function
   * for the whole chart.
   * @param {string} [settings.isArea] Render as an area chart.
   * @param {string} [settings.isBubble=false] Render as a bubble chart.
   * @param {string} [settings.isScatterPlot=false] Render as a Scatter Plot Chart.
  * @param {string} [settings.showLegend=true] If false the label will not be shown.
   * @param {object} [settings.xAxis] A series of options for the xAxis
   * @param {number} [settings.xAxis.rotate] Rotate the elements on the x axis.
   * Recommend -65 deg but this can be tweaked depending on look.
   * @param {object} [settings.yAxis] A series of options for the yAxis
   * @param {object} [settings.xAxis.ticks] Data to control the number of ticks and y axis format.
   * For example `{number: 5, format: ',.1s'}` would show only 5 yaxis points and format the
   * data to show 1K, 1M, 1G ect.. This uses the d3 formatter.
   * @param {function} [settings.xAxis.formatText] A function that passes the text element and a counter.
   * You can return a formatted svg markup element to replace the current element.
   * For example you could use tspans to wrap the strings or color them.
   * @param {object} [settings.yAxis] A series of options for the yAxis
   * @param {function} [settings.yAxis.formatter] A d3 formatter for the yAxis points.
   * @param {boolean} [settings.hideDots=false] If true no dots are shown
   * @param {array} [settings.axisLabels]  Option to a label to one of the four sides. For Example
   * `{left: 'Left axis label', top: 'Top axis label',
   * right: 'Right axis label', bottom: 'Bottom axis label'}`
   * @param {boolean|string} [settings.animate] true|false - will do or not do the animation.
   * 'initial' will do only first time the animation.
   * @param {boolean} [settings.redrawOnResize=true] If true, the component will not resize when resizing the page.
   * @param {object} [settings.dots] Option to customize the dot behavior. You can set the dot size (radius),
   * the size on hover and stroke or even add a custom class.
   * Example `dots: { radius: 3, radiusOnHover: 4, strokeWidth: 0, class: 'custom-dots'}`
   * @param {string} [settings.formatterString] Use d3 format some examples can be found on http://bit.ly/1IKVhHh
   * @param {object} [settings.emptyMessage] An empty message will be displayed when there is no chart data.
   * This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results', icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}
   *  }`
   *  Set this to null for no message or will default to 'No Data Found with an icon.'
   */
  var LINE_DEFAULTS = {
    dataset: [],
    isArea: false,
    isBubble: false,
    isScatterPlot: false,
    showLegend: true,
    hideDots: false,
    animate: true,
    redrawOnResize: true,
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  function Line(element, settings) {
    this.settings = utils.mergeSettings(element, settings, LINE_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Line.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.build().handleEvents();

      // Handle initial option
      if (this.settings.animate === 'initial') {
        this.settings.animate = false;
      }

      /**
      * Fires when the chart is complete done rendering, for customization.
      * @event rendered
      * @memberof Line
      * @param {object} event - The jquery event object
      * @param {array} svg - The svg object.
      */
      this.element.trigger('rendered', [this.svg]);

      return this;
    },


    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      var self = this;
      var isFormatter = !!this.settings.formatterString;
      var format = function format(value) {
        return isFormatter ? d3.format(self.settings.formatterString)(value) : value;
      };

      this.element.addClass('line-chart' + (self.settings.isBubble ? ' bubble' : ''));
      this.element.addClass('line-chart' + (self.settings.isScatterPlot ? ' scatterplot' : ''));

      // Handle Empty Data Set
      if (self.settings.dataset.length === 0) {
        self.element.emptymessage(self.settings.emptyMessage);
        return this;
      }

      var dots = {
        radius: 5,
        radiusOnHover: 7,
        strokeWidth: 2,
        class: 'dot'
      };

      // Set to zero for animation
      if (self.settings.isBubble) {
        dots.radius = 0;
        dots.radiusOnHover = 0;
        dots.strokeWidth = 0;
      }

      if (self.settings.isScatterPlot) {
        dots.radius = 0;
        dots.strokeWidth = 50;
      }
      $.extend(true, dots, this.settings.dots);

      var isRTL = Locale.isRTL();

      var tooltipInterval = void 0;
      var tooltipDataCache = [];
      var tooltipData = self.settings.tooltip;

      // Config axis labels
      var i = void 0;
      var l = void 0;
      var axisLabels = {};
      var isAxisLabels = { atLeastOne: false };
      var axisArray = ['left', 'top', 'right', 'bottom'];

      if (self.settings.axisLabels) {
        $.extend(true, axisLabels, self.settings.axisLabels);
      }

      if (!$.isEmptyObject(axisLabels)) {
        for (i = 0, l = axisArray.length; i < l; i++) {
          var thisAxis = axisLabels[axisArray[i]];
          if (thisAxis && typeof thisAxis === 'string' && $.trim(thisAxis) !== '') {
            isAxisLabels[axisArray[i]] = true;
            isAxisLabels.atLeastOne = true;
          }
        }
      }

      // Append the SVG in the parent area.
      var longestLabel = '';
      var longestLabelLength = 0;
      var dataset = this.settings.dataset;

      var isAxisXRotate = self.settings.xAxis && self.settings.xAxis.rotate !== undefined; // TODO
      var getMaxes = function getMaxes(d, option) {
        return d3.max(d.data, function (maxData) {
          return option ? maxData.value[option] : maxData.value;
        });
      };

      if (isAxisXRotate) {
        // get the longeset label
        dataset[0].data.map(function (d) {
          //eslint-disable-line
          if (d.name.length > longestLabel.length) {
            longestLabel = d.name;
          }
        });
        longestLabelLength = longestLabel.length;
      }

      var hideDots = this.settings.hideDots;
      var parent = this.element.parent();
      var isCardAction = !!$('.widget-chart-action', parent).length;
      var isViewSmall = parent.width() < 450;
      var margin = {
        top: isAxisLabels.top ? isCardAction ? 15 : 40 : isCardAction ? 5 : 30,
        right: isAxisLabels.right ? isViewSmall ? 45 : 65 : isViewSmall ? 45 : 55,
        bottom: isAxisLabels.bottom ? isAxisXRotate ? 60 : 50 : isAxisXRotate ? longestLabelLength * 5 + 35 : 35,
        left: isAxisLabels.right ? isViewSmall ? 55 : 75 : isViewSmall ? 45 : 65
      };
      var width = parent.width() - margin.left - margin.right;
      var height = parent.height() - margin.top - margin.bottom - 30; // legend

      if (isCardAction) {
        height -= 40;
      }

      self.svg = d3.select(this.element[0]).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      var names = dataset[0].data.map(function (d) {
        return d.name;
      });

      var valueFormatterString = {};

      if (dataset[0] && dataset[0].valueFormatterString) {
        $.extend(true, valueFormatterString, dataset[0].valueFormatterString);
      }

      var formatValue = function formatValue(s, value) {
        return !$.isEmptyObject(valueFormatterString) && !!s ? d3.format(s)(s === '0.0%' ? value / 100 : value) : value;
      };

      var labels = {
        name: 'Name',
        value: {
          x: 'Value.x',
          y: 'Value.y',
          z: 'Value.z'
        }
      };

      if (dataset[0] && dataset[0].labels) {
        $.extend(true, labels, dataset[0].labels);
      }

      // Calculate the Domain X and Y Ranges
      var maxes = void 0;
      var x = (!!self.settings.xAxis && !!self.settings.xAxis.scale ? self.settings.xAxis.scale : d3.scaleLinear()).range([0, width]);

      var y = d3.scaleLinear().range([height, 0]);
      var z = d3.scaleLinear().range([1, 25]);

      if (self.settings.isBubble) {
        maxes = {
          x: dataset.map(function (d) {
            return getMaxes(d, 'x');
          }),
          y: dataset.map(function (d) {
            return getMaxes(d, 'y');
          }),
          z: dataset.map(function (d) {
            return getMaxes(d, 'z');
          })
        };
      } else if (self.settings.isScatterPlot) {
        maxes = {
          x: dataset.map(function (d) {
            return getMaxes(d, 'x');
          }),
          y: dataset.map(function (d) {
            return getMaxes(d, 'y');
          })
        };
      } else {
        maxes = dataset.map(function (d) {
          return getMaxes(d);
        });
      }

      var entries = d3.max(dataset.map(function (d) {
        return d.data.length;
      })) - 1;
      var xScale = x.domain(!!self.settings.xAxis && !!self.settings.xAxis.domain ? self.settings.xAxis.domain : [0, self.settings.isBubble || self.settings.isScatterPlot ? d3.max(maxes.x) : entries]);

      var yScale = y.domain([0, d3.max(self.settings.isBubble || self.settings.isScatterPlot ? maxes.y : maxes)]).nice();
      var zScale = z.domain([0, d3.max(self.settings.isBubble ? maxes.z : maxes)]).nice();
      var numTicks = entries;
      if (self.settings.xAxis && self.settings.xAxis.ticks) {
        numTicks = self.settings.xAxis.ticks === 'auto' ? Math.max(width / 85, 2) : self.settings.xAxis.ticks;
        if (self.settings.isBubble || self.settings.isScatterPlot && isViewSmall) {
          numTicks = Math.round(entries / 2);
        }
      }

      var xAxis = d3.axisBottom(xScale).ticks(numTicks).tickPadding(10).tickSize(self.settings.isBubble || self.settings.isScatterPlot ? -(height + 10) : 0).tickFormat(function (d, j) {
        if (self.settings.xAxis) {
          if (self.settings.xAxis.formatter) {
            return self.settings.xAxis.formatter(d, j);
          }
          if (self.settings.xAxis.ticks === 'auto') {
            return names[d];
          }
        }
        return self.settings.isBubble || self.settings.isScatterPlot ? d : names[j];
      });

      var yAxis = d3.axisLeft(yScale).ticks(8).tickSize(-(width + 20)).tickPadding(isRTL ? -18 : 20);

      if (self.settings.yAxis && self.settings.yAxis.formatter) {
        yAxis.tickFormat(function (d, k) {
          if (typeof self.settings.yAxis.formatter === 'function') {
            return self.settings.yAxis.formatter(d, k);
          }
          return d;
        });
      }

      if (self.settings.yAxis && self.settings.yAxis.ticks) {
        yAxis.ticks(self.settings.yAxis.ticks.number, self.settings.yAxis.ticks.format);
      }

      // Append The Axis Labels
      if (isAxisLabels.atLeastOne) {
        var axisLabelsGroup = self.svg.append('g').attr('class', 'axis-labels');
        var place = {
          top: 'translate(' + width / 2 + ',' + -10 + ')',
          right: 'translate(' + (width + 28) + ',' + height / 2 + ')rotate(90)',
          bottom: 'translate(' + width / 2 + ',' + (height + 40) + ')',
          left: 'translate(' + -40 + ',' + height / 2 + ')rotate(-90)'
        };

        var placeStyle = {
          top: 'rotate(0deg) scaleX(-1) translate(-' + width / 2 + 'px, ' + -10 + 'px)',
          right: 'rotate(90deg) scaleX(-1) translate(-' + (height / 2 + 5) + 'px, -' + (width + 28) + 'px)',
          bottom: 'rotate(0deg) scaleX(-1) translate(-' + width / 2 + 'px, ' + (height + 40) + 'px)',
          left: 'rotate(90deg) scaleX(-1) translate(-' + (height / 2 - 5) + 'px, ' + 55 + 'px)'
        };

        var addAxis = function addAxis(pos) {
          if (isAxisLabels[pos]) {
            axisLabelsGroup.append('text').attr('class', 'axis-label-' + pos).attr('text-anchor', 'middle').attr('transform', isRTL ? '' : place[pos]).style('font-size', '1.25em').style('transform', isRTL ? placeStyle[pos] : '').text(axisLabels[pos]);
          }
        };

        for (i = 0, l = axisArray.length; i < l; i++) {
          addAxis(axisArray[i]);
        }
      }

      // Append The Axis to the svg
      self.svg.append('g').attr('class', 'x axis').attr('transform', 'translate(0,' + height + ')').call(xAxis);

      self.svg.append('g').attr('class', 'y axis').call(yAxis);

      // Offset the tick inside, uses the fact that the yAxis has 20 added.
      self.svg.selectAll('.tick line').attr('x1', '-10');

      if (self.settings.isBubble || self.settings.isScatterPlot) {
        self.svg.selectAll('.x.axis .tick line, .y.axis .tick line').style('opacity', 0);
        self.svg.select('.x.axis .tick line').attr('x2', '-10').style('opacity', 1);
        self.svg.select('.y.axis .tick line').style('opacity', 1);
      }

      if (isRTL) {
        self.svg.selectAll('text').attr('transform', 'scale(-1, 1)');
        self.svg.selectAll('.y.axis text').style('text-anchor', 'end');
      }

      if (isAxisXRotate) {
        self.svg.selectAll('.x.axis .tick text') // select all the text for the xaxis
        .attr('y', 0).attr('x', function () {
          return -(this.getBBox().width + 10);
        }).attr('dy', '1em').attr('transform', 'rotate(' + self.settings.xAxis.rotate + ')').style('text-anchor', 'start');
      }

      if (self.settings.xAxis && self.settings.xAxis.formatText) {
        self.svg.selectAll('.x.axis .tick text').each(function (m) {
          var elem = d3.select(this);
          var text = d3.select(this).text();
          var markup = self.settings.xAxis.formatText(text, m);
          DOM.html(elem.node(), markup, '<tspan><text><glyph>');
        });
      }

      // Create the line generator
      var line = d3.line().x(function (d, n) {
        if (!!self.settings.xAxis && !!self.settings.xAxis.parser) {
          return xScale(self.settings.xAxis.parser(d, n));
        }
        return xScale(self.settings.isBubble || self.settings.isScatterPlot ? d.value.x : n);
      }).y(function (d) {
        return yScale(self.settings.isBubble || self.settings.isScatterPlot ? d.value.y : d.value);
      });

      // Append the lines
      dataset.forEach(function (d, lineIdx) {
        var lineGroups = self.svg.append('g').attr('data-group-id', lineIdx).attr('class', 'line-group');

        if (self.settings.isArea) {
          var area = d3.area().x(function (dc, p) {
            return xScale(p);
          }).y0(height).y1(function (db) {
            return yScale(self.settings.isBubble || self.settings.isScatterPlot ? db.value.y : db.value);
          });

          lineGroups.append('path').datum(d.data).attr('fill', function () {
            return charts.chartColor(lineIdx, 'line', d);
          }).style('opacity', '.2').attr('class', 'area').attr('d', area);
        }

        var path = lineGroups.append('path').datum(d.data).attr('d', line(d.data)).attr('stroke', function () {
          return self.settings.isBubble || self.settings.isScatterPlot ? '' : charts.chartColor(lineIdx, 'line', d);
        }).attr('stroke-width', 2).attr('fill', 'none').attr('class', 'line').on('click.chart', function () {
          charts.selectElement(d3.select(this.parentNode), self.svg.selectAll('.line-group'), d, self.element);
        });

        // Add animation
        var totalLength = path.node().getTotalLength();
        path.attr('stroke-dasharray', totalLength + ' ' + totalLength).attr('stroke-dashoffset', totalLength).transition().duration(self.settings.animate ? 600 : 0).ease(d3.easeCubic).attr('stroke-dashoffset', 0);

        var handleMouseEnter = function handleMouseEnter(elem, mouseEnterData) {
          var rect = elem.getBoundingClientRect();
          var content = '<p><b>' + mouseEnterData.name + ' </b> ' + format(mouseEnterData.value) + '</p>';

          var show = function show() {
            var size = charts.tooltipSize(content);
            var posX = rect.left - size.width / 2 + 6;
            var posY = rect.top - size.height - 18;

            posX = self.settings.isBubble || self.settings.isScatterPlot ? rect.left + rect.width / 2 - size.width / 2 : posX;

            if (content !== '') {
              charts.showTooltip(posX, posY, content, 'top');
            }
          };

          if (self.settings.isBubble || self.settings.isScatterPlot) {
            content = '<div class="chart-swatch line"><div class="swatch-caption"><span class="indicator-box"></span>\n            <b>' + mouseEnterData.name + '</b></div>';

            for (var key in mouseEnterData) {
              //eslint-disable-line
              if (mouseEnterData.hasOwnProperty(key)) {
                //eslint-disable-line
                if (_typeof(mouseEnterData[key]) !== 'object') {
                  content += '' + ('' + '<div class="swatch-row">' + '<span>') + labels[key] + '</span>' + ('<b>' + d.name + '</b>') + '</div>';
                } else {
                  var obj2 = mouseEnterData[key];
                  for (var key2 in obj2) {
                    //eslint-disable-line
                    if (obj2.hasOwnProperty(key2)) {
                      //eslint-disable-line
                      content += '' + ('' + '<div class="swatch-row">' + '<span class="text-capitalize">') + labels[key][key2] + '</span>' + ('<b>' + formatValue(valueFormatterString[key2], obj2[key2]) + '</b>') + '</div>';
                    }
                  }
                }
              }
            }
            content += '</div>';
          }

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
            content = '';
            var runInterval = true;
            tooltipInterval = setInterval(function () {
              if (runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = data;
                  tooltipDataCache[i] = data;
                });
              }
              if (content !== '') {
                clearInterval(tooltipInterval);
                show();
              }
            }, 10);
          } else {
            tooltipData = (typeof tooltipData === 'undefined' ? 'undefined' : _typeof(tooltipData)) === 'object' ? '' : tooltipData;
            content = tooltipDataCache[i] || tooltipData || mouseEnterData.tooltip || d.tooltip || content || '';
            show();

            // Set the colors
            var spans = document.querySelectorAll('#svg-tooltip .swatch-caption span');
            for (var k = 0; k < spans.length; k++) {
              spans[k].style.backgroundColor = charts.chartColor(k, 'line', mouseEnterData);
            }
          }

          // Circle associated with hovered point
          d3.select(this).attr('r', function (df) {
            return self.settings.isBubble ? 2 + zScale(df.value.z) : dots.radiusOnHover;
          });
        };

        if (!hideDots) {
          if (!self.settings.isScatterPlot) {
            lineGroups.selectAll('circle').data(d.data).enter().append('circle').attr('class', dots.class).attr('cx', function (dd, p) {
              if (!!self.settings.xAxis && !!self.settings.xAxis.parser) {
                return xScale(self.settings.xAxis.parser(dd, p));
              }
              return xScale(self.settings.isBubble || self.settings.isScatterPlot ? dd.value.x : p);
            }).attr('cy', function (de) {
              return yScale(self.settings.isBubble || self.settings.isScatterPlot ? 0 : de.value);
            }).attr('r', dots.radius).style('stroke-width', dots.strokeWidth).style('fill', function () {
              return charts.chartColor(lineIdx, 'line', d);
            }).style('opacity', self.settings.isBubble || self.settings.isScatterPlot ? '.7' : '1').on('mouseenter.chart', function (mouseEnterData) {
              handleMouseEnter(this, mouseEnterData);
            }).on('mouseleave.chart', function () {
              clearInterval(tooltipInterval);
              charts.hideTooltip();
              d3.select(this).attr('r', function (dg) {
                return self.settings.isBubble ? zScale(dg.value.z) : dots.radius;
              });
            }).on('click.chart', function (dh) {
              charts.selectElement(d3.select(this.parentNode), self.svg.selectAll('.line-group'), dh, self.element);
            });
          }

          if (self.settings.isScatterPlot) {
            lineGroups.selectAll('.symbol').data(d.data).enter().append('path').attr('class', 'symbol').attr('transform', function (ds) {
              return 'translate(' + xScale(ds.value.x) + ',' + yScale(ds.value.y) + ')';
            }).attr('d', d3.symbol().size(dots.strokeWidth).type(function () {
              return d3.symbols[lineIdx];
            })).style('opacity', 0).style('fill', function () {
              return charts.chartColor(lineIdx, 'line', d);
            }).on('mouseenter.chart', function (mouseEnterData) {
              handleMouseEnter(this, mouseEnterData);
            }).on('mouseleave.chart', function () {
              clearInterval(tooltipInterval);
              charts.hideTooltip();
              d3.select(this).attr('r', function () {
                return dots.radius;
              });
            }).on('click.chart', function (dh) {
              charts.selectElement(d3.select(this.parentNode), self.svg.selectAll('.line-group'), dh, self.element);
            });
          }
          if (self.settings.isBubble) {
            // Add animation
            lineGroups.selectAll('circle').attr('cy', function (di) {
              return yScale(di.value.y);
            }).transition().duration(self.settings.animate ? 750 : 0).ease(d3.easeCubic).attr('r', function (dj) {
              return zScale(dj.value.z);
            });
          }

          if (self.settings.isScatterPlot) {
            // Add animation
            lineGroups.selectAll('.symbol').transition().duration(self.settings.animate ? 750 : 0).ease(d3.easeCubic).style('opacity', 1);
          }
        }
      });

      // Set y-axix tick css class
      self.svg.selectAll('.y.axis .tick').attr('class', function (di) {
        return 'tick' + (di === 0 ? ' tick0' : '');
      });

      var series = dataset.map(function (d) {
        return { color: d.color, name: d.name, selectionObj: self.svg.selectAll('.line-group'), selectionInverse: self.svg.selectAll('.line-group'), data: d };
      });

      if (this.settings.showLegend) {
        charts.addLegend(series, self.settings.isScatterPlot ? 'scatterplot' : 'line', this.settings, this.element);
      }
      charts.appendTooltip();

      charts.setSelected = function (o, isToggle) {
        var selected = 0;
        var equals = utils.equals;
        var selector = void 0;
        var selectorData = void 0;
        var elem = void 0;

        var setSelected = function setSelected(d, i1, d2, i2) {
          if (d2) {
            elem = self.svg.select('[data-group-id="' + i1 + '"]').select('.dot:nth-child(' + (i2 + 2) + ')');
            if (typeof o.groupIndex === 'number' && typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.groupIndex === i1 && o.fieldValue === d2[o.fieldName] || typeof o.index !== 'undefined' && typeof o.groupIndex === 'number' && o.groupIndex === i1 && o.index === i2 || o.elem && $(elem.node()).is(o.elem) || o.data && equals(o.data, d2)) {
              selected++;
              selectorData = d2;
              selector = self.svg.select('[data-group-id="' + i1 + '"]');
            }
          } else {
            elem = self.svg.select('[data-group-id="' + i1 + '"]');
            if (typeof o.groupName !== 'undefined' && typeof o.groupValue !== 'undefined' && o.groupValue === d[o.groupName] || typeof o.groupIndex !== 'undefined' && o.groupIndex === i1 || o.elem && $(elem.node()).is(o.elem) || o.data && equals(o.data, d)) {
              selected++;
              selectorData = d;
              selector = elem;
            }
          }
        };

        dataset.forEach(function (d, i3) {
          if (selected < 1 && d && d.data) {
            d.data.forEach(function (d2, i2) {
              if (selected < 1 && d2) {
                setSelected(d, i3, d2, i2);
              }
            });
            if (selected < 1) {
              setSelected(d, i3);
            }
          }
        });

        if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
          charts.selectElement(selector, self.svg.selectAll('.line-group'), selectorData, self.element);
        }
      };

      this.setInitialSelected();
      this.element.trigger('rendered');
      return this;
    },


    /**
     * Set the initially selected elements
     * @private
     */
    setInitialSelected: function setInitialSelected() {
      var self = this;
      var selected = 0;
      var selector = void 0;
      var selectorData = void 0;

      var setInitialSelected = function setInitialSelected(node, d, selectedIdx) {
        if (node.selected && selected < 1) {
          selected++;
          selector = d3.select(self.svg.selectAll('.line-group').nodes()[selectedIdx]);
          selectorData = d;
        }
      };

      this.settings.dataset.forEach(function (d, setIdx) {
        if (d) {
          setInitialSelected(d, d, setIdx);
        }
      });

      this.settings.dataset.forEach(function (d, setIdx) {
        if (d || d.data) {
          d.data.forEach(function (d2) {
            setInitialSelected(d2, d, setIdx);
          });
        }
      });

      if (selected > 0) {
        charts.selectElement(selector, self.svg.selectAll('.line-group'), selectorData, self.element);
      }
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('updated.' + COMPONENT_NAME$k, function () {
        _this.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$k, function () {
          _this.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$k, function () {
          _this.handleResize();
        });
      }

      return this;
    },


    width: 0,

    /*
     * Get info on the currently selected lines.
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },


    /*
     * Get info on the currently selected lines.
     */
    setSelected: function setSelected(options, isToggle) {
      var internals = {
        svg: this.svg,
        chartData: this.settings.dataset,
        isStacked: false,
        isGrouped: false,
        isSingle: false
      };
      charts.setSelected(options, isToggle, internals);
    },


    /*
     * Get info on the currently selected lines.
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },


    /*
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      this.element.empty();

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }
      return this.build();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$k);
      $('body').off('resize.' + COMPONENT_NAME$k);
      return this;
    },


    /**
     * Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('line-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$k);
      $.removeData(this.element[0], 'chart');
    }
  };

  /* eslint-disable no-nested-ternary, prefer-arrow-callback */

  // Settings and Options
  var COMPONENT_NAME$l = 'column';

  /**
  * A column chart displays a series as a set of vertical bars that are grouped by category.
  * Column charts are useful for showing data changes over a period of time or for illustrating
  * comparisons among items.
  * @class Column
  * @param {string} element The plugin element for the constuctor
  * @param {string} [settings] The settings element.
  *
  * @param {array} [settings.dataset = []] The data to use in the line/area/bubble.
  * @param {boolean} [settings.isStacked = false] Set to true if its a stacked column chart
  * @param {boolean} [settings.showLegend = true] If false the legend will not be shown.
  * @param {boolean|string} [settings.animate = true] true|false - will do or not do the animation. 'initial' will do only first time the animation.
  * @param {boolean} [settings.redrawOnResize = true] If true, the component will not resize when resizing the page.
  * @param {string} [settings.format = null] The d3 axis format
  * @param {string} [settings.formatterString] Use d3 format some examples can be found on http://bit.ly/1IKVhHh
  * @param {number} [settings.ticks = 9] The number of ticks to show.
  * @param {function} [settings.xAxis.formatText] A function that passes the text element and a counter.
  * You can return a formatted svg markup element to replace the current element.
  * For example you could use tspans to wrap the strings or color them.
  * @param {object} [settings.emptyMessage = { title: 'No Data', info: , icon: 'icon-empty-no-data' }]
  * An empty message will be displayed when there is no chart data. This accepts an object of the form
  * `emptyMessage: {
  *   title: 'No Data Available',
  *   info: 'Make a selection on the list above to see results',
  *   icon: 'icon-empty-no-data',
  *   button: {text: 'xxx', click: <function>
  *   }`
  * Set this to null for no message or will default to 'No Data Found with an icon.'
  */

  var COLUMN_DEFAULTS = {
    dataset: [],
    isStacked: false,
    showLegend: true,
    animate: true,
    format: null,
    redrawOnResize: true,
    ticks: 9,
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  function Column(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COLUMN_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Column.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.width = 0;

      this.build().handleEvents();

      // Handle initial option
      if (this.settings.animate === 'initial') {
        this.settings.animate = false;
      }

      return this;
    },


    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      var self = this;
      var isFormatter = !!this.settings.formatterString;
      var format = function format(value) {
        return isFormatter ? d3.format(self.settings.formatterString)(value) : value;
      };

      var datasetStacked = void 0;
      var dataset = this.settings.dataset;
      this.dataset = dataset;

      // Handle Empty Data Set
      if (dataset.length === 0) {
        self.element.emptymessage(self.settings.emptyMessage);
        return this;
      }

      var parent = this.element.parent();
      var isRTL = Locale.isRTL();
      var isPositiveNegative = this.settings.type === 'column-positive-negative' || this.settings.type === 'positive-negative';
      var isSingle = dataset.length === 1;
      this.isSingle = isSingle;
      var isGrouped = !(isSingle || !isSingle && self.settings.isStacked);
      this.isGrouped = isGrouped;

      var margin = {
        top: 40,
        right: 40,
        bottom: isSingle && dataset[0].name === undefined ? self.settings.isStacked ? 20 : 50 : 35,
        left: 45
      };
      var legendHeight = 40;
      var width = parent.width() - margin.left - margin.right - 10;
      var height = parent.height() - margin.top - margin.bottom - (isSingle && dataset[0].name === undefined ? self.settings.isStacked || isPositiveNegative ? legendHeight - 10 : 0 : legendHeight);
      var yMinTarget = void 0;
      var yMaxTarget = void 0;
      var series = void 0;
      var seriesStacked = void 0;
      var pnColors = void 0;
      var pnPatterns = void 0;
      var pnLegends = void 0;
      var pnSeries = void 0;

      var yMin = d3.min(dataset, function (group) {
        return d3.min(group.data, function (d) {
          return d.value;
        });
      });

      var yMax = d3.max(dataset, function (group) {
        //eslint-disable-line
        return d3.max(group.data, function (d) {
          return d.value;
        });
      });

      if (isPositiveNegative) {
        yMinTarget = d3.min(dataset, function (group) {
          return d3.min(group.data, function (d) {
            return d.target;
          });
        });

        yMaxTarget = d3.max(dataset, function (group) {
          return d3.max(group.data, function (d) {
            return d.target;
          });
        });

        yMin = d3.min([yMin, yMinTarget]);
        yMax = d3.max([yMax, yMaxTarget]);

        pnLegends = { target: 'Target', positive: 'Positive', negative: 'Negative' };
        pnColors = { target: 'neutral', positive: 'good', negative: 'error' };
        pnPatterns = {};

        if (dataset[0]) {
          if (dataset[0].colors) {
            $.extend(true, pnColors, dataset[0].colors);
          }
          if (dataset[0].legends) {
            $.extend(true, pnLegends, dataset[0].legends);
          }
          if (dataset[0].patterns) {
            $.extend(true, pnPatterns, dataset[0].patterns);
          }
        }
        // Converting object into array
        pnSeries = [];
        $.each(pnLegends, function (key, val) {
          pnSeries.push({
            name: val,
            color: pnColors[key],
            pattern: pnPatterns[key],
            option: key
          });
        });
      }

      this.element.addClass('column-chart');

      var tooltipInterval = void 0;
      var tooltipDataCache = [];
      var tooltipData = self.settings.tooltip;

      var x0 = d3.scaleBand().range([0, width]).round(true).padding(0.1);

      var x1 = d3.scaleBand();

      var y = d3.scaleLinear().range([height, 0]);

      var xScale = null;
      var yScale = null;

      if (self.settings.isStacked) {
        // Map the Data Sets and Stack them.
        var yStack = { y1: [], y2: [] };
        if (isSingle) {
          datasetStacked = dataset[0].data.map(function (d, i) {
            var y0 = 0;
            if (i === 0) {
              yStack.y1.push(d.value);
              yStack.y2.push(0);
            } else {
              y0 = yStack.y1[0] + yStack.y2[0];
              yStack.y1[0] = d.value;
              yStack.y2[0] = y0;
            }
            return [$.extend({}, d, {
              y0: y0,
              y: d.value,
              x: d.name,
              color: d.color,
              pattern: d.pattern,
              parentName: d.name,
              tooltip: d.tooltip
            })];
          });
        } else {
          datasetStacked = dataset.map(function (d, i) {
            return d.data.map(function (o, i2) {
              var y0 = 0;
              if (i === 0) {
                yStack.y1.push(o.value);
                yStack.y2.push(0);
              } else {
                y0 = yStack.y1[i2] + yStack.y2[i2];
                yStack.y1[i2] = o.value;
                yStack.y2[i2] = y0;
              }
              return $.extend({}, o, {
                y0: y0,
                y: o.value,
                x: o.name,
                color: o.color,
                pattern: o.pattern,
                parentName: d.name,
                tooltip: d.tooltip
              });
            });
          });
        }

        var stack = d3.stack();
        stack(datasetStacked);

        xScale = d3.scaleBand().domain(d3.range(datasetStacked[0].length)).rangeRound([0, width], 0.05);

        if (isSingle && self.settings.isStacked) {
          xScale.paddingInner(0.095);
        }

        yScale = d3.scaleLinear().domain([0, d3.max(datasetStacked, function (d) {
          return d3.max(d, function (d1) {
            return d1.y0 + d1.y;
          });
        })]).range([0, height]);
      }

      // List the values along the x axis
      var xAxisValues = dataset[0].data.map(function (d) {
        return d.name;
      });

      var xAxis = d3.axisBottom(x0).tickSize(0).tickPadding(12);

      var yAxis = d3.axisLeft(y).tickSize(-width).tickPadding(isRTL ? -12 : 12).ticks(self.settings.ticks || 9, d3.format(self.settings.format || 's'));

      if (self.settings.yAxis) {
        if (self.settings.yAxis.formatter) {
          yAxis.tickFormat(function (d, k) {
            if (typeof self.settings.yAxis.formatter === 'function') {
              return self.settings.yAxis.formatter(d, k);
            }
            return d;
          });
        }

        if (self.settings.yAxis.ticks && self.settings.yAxis.ticks.number > 1 && self.settings.yAxis.ticks.format) {
          yAxis.ticks(self.settings.yAxis.ticks.number, self.settings.yAxis.ticks.format);
        }
      }

      var svg = d3.select(this.element[0]).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      this.svg = svg;

      // Get the Different Names
      var names = dataset.map(function (d) {
        return d.name;
      });

      // Get the Maxes of each series
      var maxesStacked = void 0;
      var maxes = dataset.map(function (d) {
        return d3.max(d.data, function (maxD) {
          return isPositiveNegative ? maxD.target : maxD.value;
        });
      });

      if (self.settings.isStacked) {
        maxesStacked = datasetStacked.map(function (maxesD) {
          return d3.max(maxesD, function (d) {
            return d.y + d.y0;
          });
        });
      }

      if (isSingle) {
        names = dataset[0].data.map(function (d) {
          return d.name;
        });
      }

      // Extra ticks
      if (isPositiveNegative) {
        yMin += yMin / y.ticks().length;
        maxes[0] += maxes[0] / (y.ticks().length / 2);
      }

      // Set series
      (function () {
        if (self.settings.isStacked && isSingle) {
          series = dataset[0].data;
        } else {
          var lm = void 0;
          // Loop backwards to catch and override with found first custom info from top
          for (var i = dataset.length - 1, l = -1; i > l; i--) {
            lm = dataset[i].data.map(function (d) {
              return d;
            });
            $.extend(true, series, lm);
            // Convert back to array from object
            series = $.map(series, function (d) {
              return d;
            });
          }
        }
      })();

      if (self.settings.isStacked && !isSingle) {
        seriesStacked = names.map(function (d, i) {
          return dataset[i];
        });
      }

      x0.domain(self.settings.isStacked ? xAxisValues : names);
      x1.domain(xAxisValues).rangeRound([0, isSingle || self.settings.isStacked ? width : x0.bandwidth()]);
      y.domain([yMin < 0 ? yMin : self.settings.minValue || 0, d3.max(self.settings.isStacked ? maxesStacked : maxes)]).nice();

      if (!isSingle || isSingle && !self.settings.isStacked) {
        svg.append('g').attr('class', 'x axis').attr('transform', 'translate(0,' + (height + (isPositiveNegative ? 10 : 0)) + ')').call(xAxis);
      }

      svg.append('g').attr('class', 'y axis').call(yAxis);

      // Adjust extra(x) space for negative values for RTL
      if (isRTL && yMin < 0) {
        var yMaxLength = 0;
        var tempLength = void 0;

        svg.selectAll('.axis.y text').attr('class', function (d) {
          tempLength = d3.select(this).text().length;
          yMaxLength = tempLength > yMaxLength ? tempLength : yMaxLength;
          return d < 0 ? 'negative-value' : 'positive-value';
        }).attr('x', function (d) {
          return yMaxLength * (d < 0 ? 9 : 5);
        });
      }

      // Make an Array of objects with name + array of all values
      var dataArray = [];
      dataset.forEach(function (d) {
        dataArray.push($.extend({}, d, { values: d.data }));
      });

      if (isSingle) {
        dataArray = [];
        names = dataset[0].data.forEach(function (d) {
          dataArray.push(d);
        });
      }

      var targetBars = void 0;
      var pnBars = void 0;
      var barMaxWidth = 35;
      var barsInGroup = dataArray[0] && dataArray[0].values ? dataArray[0].values.length : 0;
      var isGroupSmaller = width / dataArray.length > barMaxWidth * (barsInGroup + 1);
      var color = function color(colorStr) {
        return charts.chartColor(0, '', { color: colorStr });
      };
      var onEndAllTransition = function onEndAllTransition(transition, callback) {
        var n = void 0;
        if (transition.empty()) {
          callback();
        } else {
          n = transition.size();
          transition.on('end', function () {
            n--;
            if (n === 0) {
              callback();
            }
          });
        }
      };

      var drawBars = function drawBars(isTargetBars) {
        var bars = void 0; //eslint-disable-line
        isTargetBars = isPositiveNegative && isTargetBars;

        // Add the bars - done different depending on if grouped or singlular
        if (isSingle || isPositiveNegative) {
          bars = self.svg.selectAll('rect' + (isTargetBars ? '.target-bar' : '.bar')).data(self.settings.isStacked ? datasetStacked : dataArray).enter().append('rect').attr('class', function (d, i) {
            var classStr = 'bar series-' + i;

            if (isPositiveNegative) {
              classStr = (isTargetBars ? 'target-bar series-' + i : classStr) + (d.value > 0 ? ' positive' : ' negative');
            }
            return classStr;
          }).attr('width', Math.min.apply(null, [x1.bandwidth() - 2, barMaxWidth])).attr('x', function (d) {
            return self.settings.isStacked ? xScale(0) : x1(d.name) + (x1.bandwidth() - barMaxWidth) / 2;
          }).attr('y', function () {
            return y(0) > height ? height : y(0);
          }).attr('height', function () {
            return 0;
          }).attr('mask', function (d) {
            return !isPositiveNegative ? null : isTargetBars ? pnPatterns.target ? 'url(#' + pnPatterns.target + ')' : null : d.value < 0 ? pnPatterns.negative ? 'url(#' + pnPatterns.negative + ')' : null : pnPatterns.positive ? 'url(#' + pnPatterns.positive + ')' : null;
          }).style('fill', function (d) {
            return !isPositiveNegative ? null : color(isTargetBars ? pnColors.target : d.value < 0 ? pnColors.negative : pnColors.positive);
          });

          if (isPositiveNegative) {
            var yTextPadding = 12;
            svg.selectAll(isTargetBars ? '.target-bartext' : '.bartext').data(dataArray).enter().append('text').attr('class', function (d) {
              return (isTargetBars ? 'target-bartext' : 'bartext') + (d.value > 0 ? ' positive' : ' negative');
            }).attr('text-anchor', 'middle').attr('x', function (d) {
              return (x1(d.name) + x1.bandwidth() / 2) * (isRTL ? -1 : 1);
            }).attr('y', function (d) {
              return isTargetBars ? y(d.target) - yTextPadding / 2 : y(d.value > 0 ? 0 : d.value) + yTextPadding;
            }).style('opacity', 0).style('fill', function (d) {
              return isTargetBars ? '' /* color(pnColors.target) */ : d.value < 0 ? color(pnColors.negative) : color(pnColors.positive);
            }).style('font-weight', 'bold').text(function (d) {
              return format(isTargetBars ? d.target : d.value);
            });
          }

          bars.transition().duration(self.settings.animate ? 1000 : 0).call(onEndAllTransition, function () {
            svg.selectAll('.target-bartext, .bartext').transition().duration(self.settings.animate ? 300 : 0).style('opacity', 1);
          }).attr('y', function (d) {
            var r = self.settings.isStacked ? height - yScale(d[0].y) - yScale(d[0].y0) : d.value < 0 ? y(0) : y(d.value);
            return isTargetBars ? y(d.target) : d.value < 0 ? r : r > height - 3 ? height - 2 : r;
          }).attr('height', function (d) {
            var r = void 0;
            if (self.settings.isStacked) {
              r = yScale(d[0].y);
            } else if (d.value < 0) {
              r = height - y(0) - (height - y(d.value));
            } else {
              r = height - y(d.value) - (height - y(0));
            }
            r = d.value < 0 ? r : r < 3 ? 2 : r > height ? height - y(d.value) : r;
            return isTargetBars ? height - y(d.target) - (height - y(0)) : r;
          });
        } else {
          var xValues = svg.selectAll('.x-value').data(self.settings.isStacked ? datasetStacked : dataArray).enter().append('g').attr('class', 'series-group g').attr('data-group-id', function (d, i) {
            return i;
          }).attr('transform', function (d) {
            var x = x0(self.settings.isStacked ? xAxisValues[0] : d.name);
            var bandwidth = x0.bandwidth();
            if (!self.settings.isStacked && isGroupSmaller && bandwidth > barMaxWidth * dataArray.length * 2) {
              x += x0.bandwidth() / 2 / dataArray.length / 2;
            }
            return 'translate(' + x + ',0)';
          });

          bars = xValues.selectAll('rect').data(function (d) {
            return self.settings.isStacked ? d : d.values;
          }).enter().append('rect').attr('class', function (d, i) {
            return 'series-' + i + ' bar';
          }).attr('width', Math.min.apply(null, [x1.bandwidth() - 2, barMaxWidth])).attr('x', function (d, i) {
            var width = Math.min.apply(null, [x1.bandwidth() - 2, barMaxWidth]); //eslint-disable-line
            return self.settings.isStacked ? xScale(i) : x1.bandwidth() / 2 + (width + 2) * i - (dataArray[0].values.length === 1 || dataArray[0].values.length === 5 || dataArray[0].values.length === 4 ? width / 2 : 0);
          }).attr('y', function () {
            return y(0) > height ? height : y(0);
          }).attr('height', function () {
            return 0;
          });

          bars.transition().duration(self.settings.animate ? 600 : 0).attr('y', function (d) {
            var r = self.settings.isStacked ? height - yScale(d.y) - yScale(d.y0) : d.value < 0 ? y(0) : y(d.value);
            return d.value < 0 ? r : r > height - 3 ? height - 2 : r;
          }).attr('height', function (d) {
            var r = void 0;
            if (self.settings.isStacked) {
              r = yScale(d.y);
            } else if (d.value < 0) {
              r = height - y(0) - (height - y(d.value));
            } else {
              r = height - y(d.value) - (height - y(0));
            }
            return d.value < 0 ? r : r < 3 ? 2 : r > height ? height - y(d.value) : r;
          });
        }
        return bars;
      };

      if (isPositiveNegative) {
        targetBars = drawBars(true); // Draw target bars
      }
      var bars = drawBars();

      if (isPositiveNegative) {
        pnBars = d3.selectAll([].concat(toConsumableArray(targetBars.nodes()), toConsumableArray(bars.nodes())));
      }

      if (!isPositiveNegative) {
        // Style the bars and add interactivity
        if (!self.settings.isStacked) {
          bars.style('fill', function (d, i) {
            return isSingle ? charts.chartColor(i, 'column-single', dataset[0].data[i]) : charts.chartColor(i, 'bar', series[i]);
          }).attr('mask', function (d, i) {
            return isSingle ? dataset[0].data[i].pattern ? 'url(#' + dataset[0].data[i].pattern + ')' : null : series[i].pattern ? 'url(#' + series[i].pattern + ')' : null;
          });
        } else if (self.settings.isStacked && !isSingle) {
          bars.style('fill', function () {
            var thisGroup = d3.select(this.parentNode).attr('data-group-id');
            return charts.chartColor(thisGroup, 'bar', dataset[thisGroup]);
          }).attr('mask', function () {
            var thisGroup = d3.select(this.parentNode).attr('data-group-id');
            return dataset[thisGroup].pattern ? 'url(#' + dataset[thisGroup].pattern + ')' : null;
          });
        } else if (self.settings.isStacked && isSingle) {
          bars.style('fill', function (d, i) {
            return charts.chartColor(i, 'bar', d[0]);
          }).attr('mask', function (d) {
            return d[0].pattern ? 'url(#' + d[0].pattern + ')' : null;
          });
        }
      }

      $.extend(charts.settings, {
        svg: svg,
        chartType: 'Column',
        isSingle: isSingle,
        isGrouped: isGrouped,
        isStacked: self.settings.isStacked
      });

      (isPositiveNegative ? pnBars : bars).on('mouseenter', function (d, i) {
        var x = void 0;
        var y = void 0; //eslint-disable-line
        var j = void 0;
        var l = void 0;
        var hexColor = void 0;
        var size = void 0;
        var isTooltipBottom = void 0;
        var maxBarsForTopTooltip = 6;
        var thisShape = this;
        var shape = $(this);
        var content = '';
        var ePageY = d3.event.pageY;

        var setPattern = function setPattern(pattern, hexColor) {
          //eslint-disable-line
          return !pattern || !hexColor ? '' : '' + ('<svg width="12" height="12">' + '<rect style="fill: ') + hexColor + '" mask="url(#' + pattern + ')" height="12" width="12" />' + '</svg>';
        };

        var show = function show(isTooltipBottom) {
          //eslint-disable-line
          size = charts.tooltipSize(content);
          x = shape[0].getBoundingClientRect().left - size.width / 2 + shape.attr('width') / 2;

          if (self.settings.isStacked) {
            y = shape[0].getBoundingClientRect().top - size.height - 10;
          } else {
            y = ePageY - charts.tooltip.outerHeight() - 25;
            if (dataset.length > 1) {
              x = thisShape.parentNode.getBoundingClientRect().left - size.width / 2 + thisShape.parentNode.getBoundingClientRect().width / 2;
              if (isTooltipBottom) {
                y += charts.tooltip.outerHeight() + 50;
                if (y > thisShape.parentNode.getBoundingClientRect().bottom + 10) {
                  y = thisShape.parentNode.getBoundingClientRect().bottom + 10;
                }
              } else {
                y = thisShape.parentNode.getBoundingClientRect().top - charts.tooltip.outerHeight() + 25;
              }
            }
          }

          if (content !== '') {
            charts.showTooltip(x, y, content, isTooltipBottom ? 'bottom' : 'top');
          }
        };

        // Stacked
        if (self.settings.isStacked) {
          if (isSingle) {
            content = '<p><b>' + format(d[0].value) + '</b> ' + d[0].name + '</p>';
          } else {
            content = '' + ('' + '<div class="chart-swatch">' + '<div class="swatch-caption"><b>') + datasetStacked[0][i].name + '</b></div>';
            for (j = datasetStacked.length - 1, l = 0; j >= l; j--) {
              hexColor = charts.chartColor(j, 'bar', dataset[j]);
              content += '' + ('' + '<div class="swatch-row">' + '<div style="background-color:') + (dataset[j].pattern ? 'transparent' : hexColor) + ';">' + setPattern(dataset[j].pattern, hexColor) + '</div>' + ('<span>' + datasetStacked[j][i].parentName + '</span><b>' + format(datasetStacked[j][i].value) + '</b>') + '</div>';
            }
            content += '</div>';
          }
          size = charts.tooltipSize(content);
          x = shape[0].getBoundingClientRect().left - size.width / 2 + shape.attr('width') / 2;
          y = shape[0].getBoundingClientRect().top - size.height - 10;
        } else {
          // Not Stacked
          if (isPositiveNegative) {
            content = '' + ('' + '<div class="chart-swatch">' + '<div class="swatch-caption"><b>') + d.name + '</b></div>' + '<div class="swatch-row">' + ('<div style="background-color:' + (pnPatterns.target ? 'transparent' : color(pnColors.target)) + ';">' + setPattern(pnPatterns.target, color(pnColors.target)) + '</div>') + ('<span>' + pnLegends.target + '</span><b>' + format(d.target) + '</b>') + '</div>' + '<div class="swatch-row">' + ('<div style="background-color:' + (d.value < 0 ? pnPatterns.negative ? 'transparent' : color(pnColors.negative) : pnPatterns.positive ? 'transparent' : color(pnColors.positive)) + ';">' + (d.value < 0 ? setPattern(pnPatterns.negative, color(pnColors.negative)) : setPattern(pnPatterns.positive, color(pnColors.positive))) + '</div>') + ('<span>' + pnLegends[d.value < 0 ? 'negative' : 'positive'] + '</span><b>' + format(d.value) + '</b>') + '</div>' + '</div>';
          } else if (dataset.length === 1) {
            content = '<p><b>' + format(d.value) + '</b> ' + d.name + '</p>';
          } else {
            var data = d3.select(this.parentNode).datum().values;

            content = '<div class="chart-swatch">';
            for (j = 0, l = data.length; j < l; j++) {
              hexColor = charts.chartColor(j, 'bar', series[j]);
              content += '' + ('' + '<div class="swatch-row">' + '<div style="background-color:') + (series[j].pattern ? 'transparent' : hexColor) + ';">' + setPattern(series[j].pattern, hexColor) + '</div>' + ('<span>' + data[j].name + '</span><b>' + format(data[j].value) + '</b>') + '</div>';
            }
            content += '</div>';
            isTooltipBottom = data.length > maxBarsForTopTooltip;
          }

          size = charts.tooltipSize(content);
          x = shape[0].getBoundingClientRect().left - size.width / 2 + shape.attr('width') / 2;
          y = ePageY - charts.tooltip.outerHeight() - 25;
          if (dataset.length > 1) {
            x = this.parentNode.getBoundingClientRect().left - size.width / 2 + this.parentNode.getBoundingClientRect().width / 2;
            y = this.parentNode.getBoundingClientRect().top - charts.tooltip.outerHeight() + 25;
          }
        }

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          content = '';
          var runInterval = true;
          tooltipInterval = setInterval(function () {
            if (runInterval) {
              runInterval = false;
              tooltipData(function (data) {
                content = data;
                tooltipDataCache[i] = data;
              });
            }

            if (content !== '') {
              clearInterval(tooltipInterval);
              show();
            }
          }, 10);
        } else {
          content = tooltipDataCache[i] || tooltipData || content || '';
          if (d.tooltip) {
            var val = d.tooltip.replace('{{value}}', format(d.value));
            content = '<p>' + val + '</p>';
          }
          show(isTooltipBottom);
        }
      })

      // Mouseleave
      .on('mouseleave', function () {
        clearInterval(tooltipInterval);
        charts.hideTooltip();
      })

      // Click
      .on('click', function (d, i, clickedLegend) {
        var isTargetBar = this && d3.select(this).classed('target-bar');
        var isSelected = this && d3.select(this).classed('is-selected');
        var thisGroupId = parseInt(d3.select(this.parentNode).attr('data-group-id'), 10);

        // Set isSelected to false if even 1 bar is selected
        if (isTargetBar) {
          var allBars = d3.selectAll('.bar').nodes();
          var len = allBars.length;

          for (var j = 0; j < len; j++) {
            var bar = allBars[j];

            if (d3.select(bar).classed('is-selected')) {
              isSelected = false;
              break;
            }
          }
        }

        charts.setSelectedElement({
          task: isSelected ? 'unselected' : 'selected',
          container: self.element,
          selector: this,
          isTrigger: !isSelected,
          isTargetBar: isTargetBar,
          triggerGroup: isGrouped,
          d: d,
          i: i,
          type: self.settings.type,
          dataset: self.dataset,
          isSingle: self.isSingle,
          isGrouped: self.isGrouped,
          isStacked: self.settings.isStacked,
          svg: self.svg,
          clickedLegend: clickedLegend === true
        });

        if (isSelected) {
          self.element.triggerHandler('selected', [d3.select(this).nodes(), {}, isGrouped ? thisGroupId : i]);
        }
      })

      // Contextmenu
      .on('contextmenu', function (d) {
        charts.triggerContextMenu(self.element, d3.select(this).nodes()[0], d);
      });

      // Add Legend
      self.settings.isGrouped = isGrouped;
      self.settings.isSingle = isSingle;
      self.settings.isStacked = self.settings.isStacked;
      self.settings.svg = this.svg;

      if (self.settings.showLegend) {
        if (isSingle && dataset[0].name) {
          charts.addLegend(dataset, 'column-single', self.settings, self.element);
        } else if (isPositiveNegative) {
          charts.addLegend(pnSeries, self.settings.type, self.settings, self.element);
        } else if (self.settings.isStacked && isSingle) {
          charts.addLegend(series, self.settings.type, self.settings, self.element);
        } else if (!isSingle) {
          charts.addLegend(self.settings.isStacked ? seriesStacked : series, self.settings.type, self.settings, self.element);
        }
      }

      if (self.settings.xAxis && self.settings.xAxis.formatText) {
        self.svg.selectAll('.x.axis .tick text').each(function (m) {
          var elem = d3.select(this);
          var text = d3.select(this).text();
          var markup = self.settings.xAxis.formatText(text, m);

          DOM.html(elem.node(), markup, '<tspan>');
        });
      }

      // Set y-axix tick css class
      svg.selectAll('.y.axis .tick').attr('class', function (d) {
        return 'tick' + (d === 0 ? ' tick0' : '');
      });

      // Add Tooltips and legend
      charts.appendTooltip();

      // See if any labels overlap and use shorter */
      // [applyAltLabels] - function(svg, dataArray, elem, selector, isNoEclipse)
      if (charts.labelsColide(svg)) {
        charts.applyAltLabels(svg, dataArray, 'shortName');
      }

      if (charts.labelsColide(svg)) {
        charts.applyAltLabels(svg, dataArray, 'abbrName');
      }

      if (charts.labelsColide(svg)) {
        charts.applyAltLabels(svg, dataArray, null, null, true);

        // Adjust extra(x) space with short name for RTL
        if (isPositiveNegative) {
          svg.selectAll('.target-bartext, .bartext').attr('x', function () {
            return +d3.select(this).attr('x') - (isRTL ? -6 : 6);
          });
        }
      }

      charts.setSelected = function (o, isToggle) {
        var selected = 0;
        var equals = utils.equals;
        var legendsNode = svg.node().parentNode.nextSibling;
        var legends = d3.select(legendsNode);
        var isLegends = legends.node() && legends.classed('chart-legend');
        var barIndex = void 0;
        var selector = void 0;
        var isStackedGroup = void 0;
        var xGroup = void 0;

        var setSelectedBar = function setSelectedBar(g, gIdx) {
          var isGroup = !!g;
          g = isGroup ? d3.select(g) : svg;
          gIdx = typeof gIdx !== 'undefined' ? gIdx : 0;
          g.selectAll('.bar').each(function (d, i) {
            if (!d) {
              return;
            }
            if (selected < 1) {
              if (typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.fieldValue === (isSingle && self.settings.isStacked ? d[0][o.fieldName] : d[o.fieldName]) || //eslint-disable-line
              typeof o.index !== 'undefined' && o.index === i || o.data && equals(o.data, dataset[gIdx].data[i]) || o.elem && $(this).is(o.elem)) {
                selected++;
                selector = d3.select(this);
                barIndex = i;
                if (isGroup && !self.settings.isStacked) {
                  isStackedGroup = true;
                }
              }
            }
          });
        };

        var setSelectedGroup = function setSelectedGroup() {
          var groups = svg.selectAll('.series-group');
          if (groups.nodes().length) {
            groups.each(function (d, i) {
              setSelectedBar(this, i);
            });
          }
        };

        if (isGrouped || self.settings.isStacked && !isSingle && !isGrouped) {
          dataset.forEach(function (d, i) {
            if (selected < 1) {
              xGroup = $(svg.select('[data-group-id="' + i + '"]').node());
              if (typeof o.groupName !== 'undefined' && typeof o.groupValue !== 'undefined' && o.groupValue === d[o.groupName] || typeof o.groupIndex !== 'undefined' && o.groupIndex === i || o.data && equals(o.data, d) || o.elem && xGroup.is(o.elem)) {
                if (typeof o.fieldName === 'undefined' && typeof o.fieldValue === 'undefined' && typeof o.index === 'undefined') {
                  selected++;
                  selector = svg.select('[data-group-id="' + i + '"]').select('.bar');
                  barIndex = i;
                  if (self.settings.isStacked && !isGrouped) {
                    isStackedGroup = true;
                  }
                }
              }
            }
          });
          if (selected < 1) {
            setSelectedGroup();
          }
        } else {
          setSelectedBar();
        }

        if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
          if (isStackedGroup) {
            if (isLegends) {
              $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
            }
          } else {
            selector.on('click').call(selector.node(), selector.datum(), barIndex);
          }
        }
      };

      this.setInitialSelected();
      this.element.trigger('rendered');
      return this;
    },


    /**
     * Set the initially selected elements
     * @private
     */
    setInitialSelected: function setInitialSelected() {
      var selected = 0;
      var self = this;
      var legendsNode = self.svg.node().parentNode.nextSibling;
      var legends = d3.select(legendsNode);
      var isLegends = legends.node() && legends.classed('chart-legend');
      var barIndex = void 0;
      var selector = void 0;
      var isStackedGroup = void 0;

      var setSelectedBar = function setSelectedBar(g) {
        g = g ? d3.select(g) : self.svg;
        g.selectAll('.bar').each(function (d, i) {
          if (!d) {
            return;
          }
          if ((self.isSingle && self.settings.isStacked ? d[0].selected : d.selected) && selected < 1) {
            selected++;
            selector = d3.select(this);
            barIndex = i;
          }
        });
      };

      var setSelectedGroup = function setSelectedGroup() {
        var groups = self.svg.selectAll('.series-group');
        if (groups.nodes().length) {
          groups.each(function () {
            setSelectedBar(this);
          });
        }
      };

      if (self.isGrouped || self.settings.isStacked && !self.isSingle && !self.isGrouped) {
        self.dataset.forEach(function (d, i) {
          if (d.selected && selected < 1) {
            selected++;
            selector = self.svg.select('[data-group-id="' + i + '"]').select('.bar');
            barIndex = i;
            if (self.settings.isStacked && !self.isSingle && !self.isGrouped) {
              isStackedGroup = true;
            }
          }
        });
        if (selected < 1) {
          setSelectedGroup();
        }
      } else {
        setSelectedBar();
      }

      if (selected > 0) {
        if (isStackedGroup) {
          if (isLegends) {
            $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
          }
        } else {
          selector.on('click').call(selector.node(), selector.datum(), barIndex);
        }
      }
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('updated.' + COMPONENT_NAME$l, function () {
        _this.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$l, function () {
          _this.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$l, function () {
          _this.handleResize();
        });
      }

      return this;
    },


    /*
     * Get info on the currently selected lines.
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },


    /*
     * Get info on the currently selected lines.
     */
    setSelected: function setSelected(options, isToggle) {
      var internals = {
        svg: this.svg,
        chartData: this.settings.dataset,
        isStacked: false,
        isGrouped: false,
        isSingle: false
      };
      charts.setSelected(options, isToggle, internals);
    },


    /*
     * Get info on the currently selected lines.
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },


    /*
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }
      this.element.empty();

      return this.build();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$l);
      $('body').off('resize.' + COMPONENT_NAME$l);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('column-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$l);
      $.removeData(this.element[0], 'chart');
    }
  };

  // Other Shared Imports

  // Settings and Options
  var COMPONENT_NAME$m = 'bar';

  /**
   * A bar chart or bar graph is a chart or graph that presents categorical data with rectangular bars
   * with heights or lengths proportional to the values that they represent. This is adapated from
   * http://jsfiddle.net/datashaman/rBfy5/2/
   * @class Bar
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {array} [settings.dataset=[]] The data to use in the line/area/bubble.
   * @param {boolean} [settings.isStacked=true] Default is a single or stacked chart.
   * @param {boolean} [settings.isNormalized=false] If true its a 100% bar chart
   * @param {boolean} [settings.isGrouped=false] If true its a grouped bar chart
   * @param {boolean} [settings.showLegend=true] If false the legend will not be shown.
   * @param {boolean|string} [settings.animate=true] true|false - will do or not do the animation, 'initial' will do only first time the animation.
   * @param {boolean} [settings.redrawOnResize=true] If true, the component will not resize when resizing the page.
   * @param {string} [settings.formatterString] Use d3 format some examples can be found on http://bit.ly/1IKVhHh
   * @param {string} [settings.format=true] The d3 axis format
   * @param {string} [settings.tooltip=null] A tooltip for the whole chart
   * @param {boolean} [settings.useLogScale=false] If true log scale is enabled.
   * @param {object} [settings.ticks=null] Settings for the chart ticks. Can set ticks: {format: d3Format, number: n}
   * @param {boolean} [settings.showLines=true] Show the in the axis lines or not.
   * @param {number} [settings.labelFactor=1.27] How far out than the outer circle should the labels be placed, this
   * may be useful to adjust for some labels.
   * @param {number} [settings.wrapWidth=60] The number of pixels after which a label needs to be given a new line.
   * You may want to change this based on label data.
   * @param {object} [settings.emptyMessage={
   *  title: (Locale ? Locale.translate('NoData') : 'No Data Available'),
   *   info: '',
   *  icon: 'icon-empty-no-data' }]
   * An empty message will be displayed when there is no chart data. This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results'
   *  icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}  }`
   * Set this to null for no message or will default to 'No Data Found with an icon.'
   */
  var BAR_DEFAULTS = {
    dataset: [],
    isStacked: true,
    isNormalized: false,
    isGrouped: false,
    showLegend: true,
    animate: true,
    longText: false,
    format: null,
    redrawOnResize: true,
    tooltip: null,
    useLogScale: false,
    ticks: null,
    showLines: true,
    labelFactor: 1.27,
    wrapWidth: 60,
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  function Bar(element, settings) {
    this.settings = utils.mergeSettings(element, settings, BAR_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Bar.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.width = 0;
      this.build().handleEvents();

      // Handle initial option
      if (this.settings.animate === 'initial') {
        this.settings.animate = false;
      }

      /**
      * Fires when the chart is complete done rendering, for customization.
      * @event rendered
      * @memberof Bar
      * @param {object} event - The jquery event object
      * @param {array} svg - The svg object.
      */
      this.element.trigger('rendered', [this.svg]);
      return this;
    },


    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      var self = this;
      var isRTL = Locale.isRTL();
      var isFormatter = !!this.settings.formatterString;
      var format = function format(value) {
        return isFormatter ? d3.format(self.settings.formatterString)(value) : value;
      };

      var maxTextWidth = void 0;
      var yMap = void 0;
      var legendMap = void 0;
      var gindex = void 0;
      var totalBarsInGroup = void 0;
      var totalGroupArea = void 0;
      var totalHeight = void 0;
      var gap = void 0;
      var barHeight = void 0;

      var tooltipInterval = void 0;
      var tooltipDataCache = [];
      var tooltipData = self.settings.tooltip;

      var maxBarHeight = 30;
      var legendHeight = 30;
      var gapBetweenGroups = 0.6; // Makes it one bar in height (barHeight * 0.5)
      var isViewSmall = this.element.parent().width() < 450;
      var smallViewport = innerWidth <= 480;
      var mediumViewport = innerWidth >= 481 && innerWidth <= 992;
      var largeViewport = innerWidth > 992;
      var dataset = this.settings.dataset;

      var margins = {
        top: 20,
        left: 30,
        right: 30,
        bottom: dataset.length === 1 ? 5 : 30
      };

      this.element.addClass('bar-chart');
      if (this.settings.isGrouped) {
        this.element.addClass('bar-chart-grouped');
      }

      if (this.settings.isStacked) {
        this.element.addClass('bar-chart-stacked');
      }

      // Handle Empty Data Set
      if (dataset.length === 0) {
        self.element.emptymessage(self.settings.emptyMessage);
        return this;
      }

      // const width = parseInt(this.element.parent().width(), 10) - margins.left - margins.right;
      var height = parseInt(this.element.parent().height(), 10) - margins.top - margins.bottom - legendHeight; // influences the bar width

      // Get the Legend Series'
      var series = dataset.map(function (d) {
        //eslint-disable-line
        return { name: d.name, color: d.color, pattern: d.pattern };
      });

      // Map the Data Sets and Stack them.
      var yStack = { y1: [], y2: [] };
      dataset = dataset.map(function (d, i) {
        //eslint-disable-line
        return d.data.map(function (o, i2) {
          //eslint-disable-line
          var y0 = 0;
          if (i === 0) {
            yStack.y1.push(o.value);
            yStack.y2.push(0);
          } else {
            y0 = yStack.y1[i2] + yStack.y2[i2];
            yStack.y1[i2] = o.value;
            yStack.y2[i2] = y0;
          }
          return $.extend({}, o, { //eslint-disable-line
            y0: y0,
            y: o.value,
            x: o.name,
            color: o.color,
            pattern: o.pattern
          });
        });
      });

      // Calculate max text width
      maxTextWidth = 0;
      dataset = dataset.map(function (group, i) {
        // eslint-disable-line
        if (!self.settings.isStacked) {
          if (series[i]) {
            maxTextWidth = series[i].name.length > maxTextWidth ? series[i].name.length : maxTextWidth;
          }
        }
        return group.map(function (d) {
          // eslint-disable-line
          if (self.settings.isStacked) {
            maxTextWidth = d.x.length > maxTextWidth ? d.x.length : maxTextWidth;
          }

          // Invert the x and y values, and y0 becomes x0
          return $.extend({}, d, {
            x: d.y,
            y: d.x,
            x0: d.y0,
            color: d.color,
            pattern: d.pattern
          });
        });
      });

      var isLongText = this.settings.longText;
      var h = parseInt(this.element.parent().height(), 10) - margins.bottom - (self.settings.isStacked ? 0 : legendHeight / 2);
      var w = parseInt(this.element.parent().width(), 10) - margins.left;
      var textWidth = void 0;

      if (smallViewport) {
        textWidth = margins.left + maxTextWidth * 1;
      } else if (mediumViewport) {
        textWidth = margins.left + maxTextWidth * 4;
      } else if (largeViewport) {
        textWidth = margins.left + maxTextWidth * 6;
      }

      if (!isLongText) {
        textWidth = margins.left + maxTextWidth * 6;
      }

      self.svg = d3.select(this.element[0]).append('svg').attr('width', w).attr('height', h).append('g').attr('class', 'group').attr('transform', 'translate(' + textWidth + ',' + margins.top + ')');

      var xMin = d3.min(dataset, function (group) {
        //eslint-disable-line
        return d3.min(group, function (d) {
          //eslint-disable-line
          return self.settings.isStacked ? d.x + d.x0 : d.x;
        });
      });

      var xMax = d3.max(dataset, function (group) {
        //eslint-disable-line
        return d3.max(group, function (d) {
          //eslint-disable-line
          return self.settings.isStacked ? d.x + d.x0 : d.x;
        });
      });

      if (self.settings.isStacked && self.settings.isNormalized) {
        var gMax = [];
        // get the max for each array group
        dataset.forEach(function (d) {
          //eslint-disable-line
          d.forEach(function (d, i) {
            //eslint-disable-line
            gMax[i] = (gMax[i] === undefined ? 0 : gMax[i]) + d.x;
          });
        });

        // Normalize Each Group
        dataset.forEach(function (d) {
          //eslint-disable-line
          d.forEach(function (d, i) {
            //eslint-disable-line
            var xDif = gMax[i] / 100;
            d.x /= xDif;
            d.x0 /= xDif;
          });
        });
        xMax = 100;
      }

      // Width of the bar minus the margin
      var barWith = w - textWidth - margins.left;
      var xScale = void 0;

      if (self.settings.useLogScale) {
        xScale = d3.scaleLog().domain([xMin > 0 ? xMin : 1, xMax]).range([1, barWith]).nice();
      } else {
        xScale = d3.scaleLinear().domain([xMin < 0 ? xMin : 0, xMax]).range([0, barWith]).nice();
      }

      if (self.settings.isStacked) {
        yMap = dataset[0].map(function (d) {
          return d.y;
        });

        barHeight = 0.32;
      } else {
        yMap = series.map(function (d) {
          return d.name;
        });

        (function () {
          var i = void 0;
          var l = void 0;
          var lm = void 0;
          // Loop backwards to catch and override with found first custom info from top
          for (i = dataset.length - 1, l = -1; i > l; i--) {
            lm = dataset[i].map(function (d) {
              return d;
            });
            $.extend(true, legendMap, lm);
            // Convert back to array from object
            legendMap = $.map(legendMap, function (d) {
              return d;
            });
          }
        })();

        gindex = 0;
        totalBarsInGroup = legendMap.length;
        totalGroupArea = height / yMap.length;
        barHeight = totalGroupArea / totalBarsInGroup;
        totalHeight = totalBarsInGroup > 1 ? totalGroupArea - barHeight * gapBetweenGroups : maxBarHeight;
        gap = totalGroupArea - totalHeight;
        maxBarHeight = totalHeight / totalBarsInGroup;
        barHeight = 0;
      }

      var yScale = d3.scaleBand().domain(yMap).rangeRound([0, height]).padding(barHeight, barHeight); // TODO

      var xAxis = d3.axisBottom().scale(xScale).tickSize(-height); //  .orient('middle') ??

      if (isViewSmall) {
        xAxis.ticks(textWidth < 100 ? 5 : 3);
      }

      if (self.settings.isStacked && self.settings.isNormalized) {
        xAxis.tickFormat(function (d) {
          return d + '%';
        });
      }

      if (self.settings.useLogScale) {
        xAxis.ticks(10, ',.1s');

        if (self.settings.showLines === false) {
          xAxis.tickSize(0);
        }
      }

      if (self.settings.ticks && !self.settings.useLogScale) {
        if (smallViewport) {
          xAxis.ticks(self.settings.ticks.smallNumber, self.settings.ticks.format);
        } else if (mediumViewport) {
          xAxis.ticks(self.settings.ticks.mediumNumber, self.settings.ticks.format);
        } else if (largeViewport) {
          xAxis.ticks(self.settings.ticks.largeNumber, self.settings.ticks.format);
        }
      }

      var yAxis = d3.axisLeft().scale(yScale).tickPadding(15).tickSize(0);

      self.svg.append('g').attr('class', 'axis x').attr('transform', 'translate(0,' + height + ')').call(xAxis);

      self.svg.append('g').attr('class', 'axis y').call(yAxis);

      var groups = self.svg.selectAll('g.group').data(dataset).enter().append('g').attr('class', 'series-group').attr('data-group-id', function (d, i) {
        return i;
      });

      self.settings.isGrouped = self.svg.selectAll('.series-group').nodes().length > 1 && !self.settings.isStacked;
      self.settings.isSingle = self.svg.selectAll('.series-group').nodes().length === 1 && self.settings.isStacked;

      groups.selectAll('rect').data(function (d, i) {
        d.forEach(function (d3) {
          d3.index = i;

          if (!self.settings.isStacked) {
            d3.gindex = gindex++;
          }
        });
        return d;
      }).enter().append('rect').attr('class', function (d, i) {
        return 'bar series-' + i;
      }).style('fill', function (d, i) {
        return self.settings.isStacked ? // eslint-disable-line
        series.length === 1 ? charts.chartColor(i, 'bar-single', d) : // eslint-disable-line
        charts.chartColor(d.index, 'bar', series[d.index]) : // eslint-disable-line
        charts.chartColor(i, 'bar', legendMap[i]);
      }) // eslint-disable-line
      .attr('mask', function (d, i) {
        if (dataset.length === 1 && dataset[0][i].pattern) {
          return 'url(#' + dataset[0][i].pattern + ')';
        } else if (self.settings.isStacked && series[d.index].pattern) {
          return 'url(#' + series[d.index].pattern + ')';
        } else if (!self.settings.isStacked && legendMap[i].pattern) {
          return 'url(#' + legendMap[i].pattern + ')';
        }
        return '';
      }).attr('x', function (d) {
        if (self.settings.useLogScale) {
          return 0;
        }
        return self.settings.isStacked && !self.settings.isSingle ? xScale(d.x0) : xScale(0);
      }).attr('y', function (d) {
        return self.settings.isStacked ? yScale(d.y) : (totalGroupArea - totalHeight) / 2 + d.gindex * maxBarHeight + d.index * gap;
      }).attr('height', function () {
        return self.settings.isStacked ? yScale.bandwidth() : maxBarHeight;
      }).attr('width', 0) // Animated in later
      .on('mouseenter', function (d, i) {
        var j = void 0;
        var l = void 0;
        var hexColor = void 0;
        var total = 0;
        var totals = [];
        var content = '';
        var data = d3.select(this.parentNode).datum();
        var mid = Math.round(data.length / 2);
        var shape = d3.select(this);
        var setPattern = function setPattern(pattern, hexColor2) {
          return !pattern || !hexColor2 ? '' : '<svg width="12" height="12"><rect mask="url(#' + pattern + ')" height="12" width="12" /></svg>';
        };

        var show = function show(xPosS, yPosS, isTooltipBottom) {
          var size = charts.tooltipSize(content);
          var x = xPosS + parseFloat(shape.attr('width')) / 2 - size.width / 2;
          var y = isTooltipBottom ? yPosS : yPosS - size.height - 13;

          if (content !== '') {
            charts.showTooltip(x, y, content, isTooltipBottom ? 'bottom' : 'top');
          }
        };

        if (dataset.length === 1) {
          content = '<p><b>' + d.y + ' </b>' + d.x + '</p>';
        } else {
          content = '<div class="chart-swatch">';

          if (self.settings.isStacked) {
            for (j = 0, l = dataset.length; j < l; j++) {
              total = 0;
              hexColor = charts.chartColor(j, 'bar', series[j]);
              for (var k = 0, kl = dataset.length; k < kl; k++) {
                total += dataset[k][i].x;
                totals[k] = dataset[k][i].x;
              }
              content += '<div class="swatch-row">\n                  <div class="swatch-color">' + setPattern(series[j].pattern, hexColor) + '</div>\n                  <span>' + series[j].name + '</span>\n                  <b> ' + (isFormatter ? format(totals[j]) : Math.round(totals[j] / total * 100) + '%') + ' </b>\n                </div>';
            }
          } else {
            if (mid > 1) {
              shape = d3.select(this.parentNode).select('.series-' + mid);
            }
            for (j = 0, l = data.length; j < l; j++) {
              hexColor = charts.chartColor(j, 'bar', legendMap[j]);
              content += '<div class="swatch-row">\n                    <div class="swatch-color">' + setPattern(legendMap[j].pattern, hexColor) + '</div>\n                  <span>' + data[j].name + '</span><b>' + format(data[j].value) + '</b>\n                </div>';
            }
          }
          content += '</div>';
        }

        if (total > 0) {
          content = '<span class="chart-tooltip-total"><b>' + total + '</b> ' + Locale.translate('Total') + '</span>' + content;
        }

        var yPosS = shape.nodes()[0].getBoundingClientRect().top + $(window).scrollTop();
        var xPosS = shape.nodes()[0].getBoundingClientRect().left + $(window).scrollLeft();

        var maxBarsForTopTooltip = 6;
        var isTooltipBottom = !self.settings.isStacked && data.length > maxBarsForTopTooltip;

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          content = '';
          var runInterval = true;
          tooltipInterval = setInterval(function () {
            if (runInterval) {
              runInterval = false;
              tooltipData(function (data2) {
                content = data2;
                tooltipDataCache[i] = data2;
              });
            }
            if (content !== '') {
              clearInterval(tooltipInterval);
              show(xPosS, yPosS, isTooltipBottom);
            }
          }, 10);
        } else {
          content = tooltipDataCache[i] || tooltipData || d.tooltip || content || '';
          show(xPosS, yPosS, isTooltipBottom);

          // set inline colors
          if (self.settings.isStacked) {
            for (j = 0, l = dataset.length; j < l; j++) {
              hexColor = charts.chartColor(j, 'bar', series[j]);

              var row = $('#svg-tooltip').find('.swatch-row').eq(j);
              if (!series[j].pattern) {
                row.find('div').css('background-color', hexColor);
              }
              row.find('rect').css('fill', hexColor);
            }
          } else {
            for (j = 0, l = data.length; j < l; j++) {
              hexColor = charts.chartColor(j, 'bar', legendMap[j]);

              var _row = $('#svg-tooltip').find('.swatch-row').eq(j);
              if (!legendMap[j].pattern) {
                _row.find('div').css('background-color', hexColor);
              }
              _row.find('rect').css('fill', hexColor);
            }
          }
        }
      }).on('mouseleave', function () {
        clearInterval(tooltipInterval);
        charts.hideTooltip();
      }).on('click', function (d, i) {
        var isSelected = this && d3.select(this).classed('is-selected');
        var thisGroupId = parseInt(d3.select(this.parentNode).attr('data-group-id'), 10);

        charts.setSelectedElement({
          task: isSelected ? 'unselected' : 'selected',
          container: self.element,
          selector: this,
          isTrigger: !isSelected,
          triggerGroup: self.settings.isGrouped,
          d: d,
          i: i,
          type: self.settings.type,
          dataset: dataset,
          isSingle: self.isSingular,
          isGrouped: self.settings.isGrouped,
          isStacked: self.settings.isStacked,
          svg: self.svg,
          clickedLegend: self.settings.clickedLegend
        });

        if (isSelected) {
          self.element.triggerHandler('selected', [d3.select(this).nodes(), {}, i]);
        }
      });

      // Adjust the labels
      self.svg.selectAll('.axis.y text').attr('x', function () {
        return isRTL ? 15 : -15;
      });
      self.svg.selectAll('.axis.x text').attr('class', function (d) {
        return d < 0 ? 'negative-value' : 'positive-value';
      });

      if (isRTL && (charts.isIE || charts.isIEEdge)) {
        self.svg.selectAll('text').attr('transform', 'scale(-1, 1)');
        self.svg.selectAll('.y.axis text').style('text-anchor', 'start');
      }

      if (isViewSmall && self.settings.useLogScale) {
        var ticks = d3.selectAll('.x .tick text');
        var foundMid = false;

        // At small breakpoint hide the last ones
        ticks.attr('class', function (d, i) {
          var middleTick = Math.round(ticks.size() / 2);

          if (i >= middleTick && !foundMid && d.toString().startsWith('1')) {
            foundMid = true;
            middleTick = d;
          }

          if (i !== 0 && i !== ticks.size() - 1 && (self.settings.useLogScale ? d !== middleTick : i !== middleTick)) {
            d3.select(this).remove();
          }
        });
      }

      // Set x-axix tick css class
      self.svg.selectAll('.x.axis .tick').attr('class', function (d) {
        return 'tick' + (d === 0 ? ' tick0' : '');
      });

      // Animate the Bars In
      self.svg.selectAll('.bar').transition().duration(self.settings.animate ? 600 : 0).attr('width', function (d) {
        var scale = xScale(d.x);
        var scale0 = xScale(0);

        if (isNaN(scale) || !math.isFinite(scale)) {
          scale = 0;
        }

        if (isNaN(scale0) || !math.isFinite(scale0)) {
          scale0 = 0;
        }

        return Math.abs(scale - scale0);
      }).attr('x', function (d) {
        if (self.settings.useLogScale) {
          return 0;
        }
        return self.settings.isStacked && !self.settings.isSingle ? xScale(d.x0) : //eslint-disable-line
        d.x < 0 ? xScale(d.x) : xScale(0);
      });

      self.settings.svg = self.svg;

      // Add Legends
      if (self.settings.showLegend) {
        charts.addLegend(self.settings.isStacked ? series : legendMap, self.settings.type, self.settings, this.element);
        // charts.addLegend(self.settings.isStacked ? series : legendMap);
      }
      charts.appendTooltip();

      this.setInitialSelected();
      this.setTextValues();
      this.element.trigger('rendered');
      return this;
    },


    /**
     * Set the text value in three viewport of bar chart
     * @private
     */
    setTextValues: function setTextValues() {
      if (this.settings.isGrouped) {
        // These are TODO, as you need a different structure since its using the group name
        return;
      }

      var elems = document.querySelectorAll('.bar-chart .axis.y .tick text');
      var dataset = this.settings.dataset;

      var _loop = function _loop(i) {
        var values = Object.keys(dataset[i]).map(function (e) {
          return dataset[i][e];
        });
        values.forEach(function (key) {
          if (key && key.constructor === Array) {
            for (var j = 0; j < key.length; j++) {
              if (innerWidth <= 480) {
                elems[j].textContent = key[j].shortName || key[j].name;
              } else if (innerWidth >= 481 && innerWidth <= 992) {
                elems[j].textContent = key[j].abbrName || key[j].name;
              } else if (innerWidth > 992) {
                elems[j].textContent = key[j].name;
              }
            }
          }
        });
      };

      for (var i = 0; i < dataset.length; i++) {
        _loop(i);
      }
    },


    /**
     * Set the initially selected elements
     * @private
     */
    setInitialSelected: function setInitialSelected() {
      var selected = 0;
      var self = this;
      var legendsNode = self.svg.node().parentNode.nextSibling;
      var legends = d3.select(legendsNode);
      var isLegends = legends.node() && legends.classed('chart-legend');
      var barIndex = void 0;
      var selector = void 0;
      var isStackedGroup = void 0;

      var setSelectedBar = function setSelectedBar(g) {
        g = g ? d3.select(g) : self.svg;
        g.selectAll('.bar').each(function (d, i) {
          if (!d) {
            return;
          }
          if (d.selected && selected < 1) {
            selected++;
            selector = d3.select(this);
            barIndex = i;
          }
        });
      };

      var setSelectedGroup = function setSelectedGroup() {
        var groups = self.svg.selectAll('.series-group');
        if (groups.nodes().length) {
          // eslint-disable-line
          groups.each(function () {
            setSelectedBar(this);
          });
        }
      };

      if (self.settings.isGrouped || self.settings.isStacked && !self.settings.isSingle) {
        self.settings.dataset.forEach(function (d, i) {
          if (d.selected && selected < 1) {
            selected++;
            selector = self.svg.select('[data-group-id="' + i + '"]').select('.bar');
            barIndex = i;
            if (self.settings.isStacked && !self.settings.isGrouped) {
              isStackedGroup = true;
            }
          }
        });
        if (selected < 1) {
          setSelectedGroup();
        }
      } else {
        setSelectedBar();
      }

      if (selected > 0) {
        if (isStackedGroup) {
          if (isLegends) {
            $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
          }
        } else {
          selector.on('click').call(selector.node(), selector.datum(), barIndex);
        }
      }
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('updated.' + COMPONENT_NAME$m, function () {
        _this.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$m, function () {
          _this.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$m, function () {
          _this.handleResize();
        });
      }

      return this;
    },


    /*
     * Get info on the currently selected lines.
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },


    /*
     * Get info on the currently selected lines.
     */
    setSelected: function setSelected(options, isToggle) {
      var internals = {
        svg: this.svg,
        chartData: this.settings.dataset,
        isStacked: this.settingsisStacked,
        isGrouped: this.settings.isGrouped,
        isSingle: this.settings.isSingle
      };
      charts.setSelected(options, isToggle, internals);
    },


    /*
     * Get info on the currently selected lines.
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },


    /*
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }
      this.element.empty();

      return this.build().element.trigger('rendered', [this.svg]);
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$m);
      $('body').off('resize.' + COMPONENT_NAME$m);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('bar-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$m);
      $.removeData(this.element[0], 'chart');
    }
  };

  /* eslint-disable no-nested-ternary, prefer-arrow-callback */

  // Settings and Options
  var COMPONENT_NAME$n = 'pie';

  /**
   * A pie chart (or a circle chart) is a circular statistical graphic which is divided
    into slices to illustrate numerical proportion. In a pie chart, the arc length of each slice is proportional to the quantity it represents.
   * @class Pie
   * @constructor
   *
   * @param {jquery[]|htmlelement} element The plugin element for the constuctor
   * @param {object} [settings] The component settings.
   * @param {array} [settings.dataset] The data to use in the line/area/bubble.
   * @param {boolean} [settings.isDonut=false] If true it renders as a donut chart.
   * @param {boolean} [settings.redrawOnResize=true] If true, the component will not resize when resizing the page. There is tooltip values provided.
    It will not be shown. If you still want lines at the lower breakpoint you can set this to true
   * @param {boolean} [settings.hideCenterLabel=false] If false the center label will not be shown.
   * @param {boolean} [settings.showLines=true] If false connector lines wont be shown
   * @param {boolean} [settings.showLinesMobile=false] This defaults to false, when false and under 450px the lines
   * @param {object} [settings.lines] A setting that controls the line values and format.
   * @param {string} [settings.line.show='value'] Controls the line value, this can be value, label or percent or custom function.
   * @param {string} [settings.line.formatter='.0f'] The d3.formatter string.
   * @param {boolean} [settings.showLegend=true] If false the legend will not be shown.
   * @param {boolean} [settings.showMobile=false] If true the chart is better formed to fit in a single widget.
   * @param {string} [settings.legendPlacement='right'] Where to locate the legend. This can be bottom or right at the moment.
   * @param {object} [settings.legend] A setting that controls the legend values and format.
   * @param {string} [settings.legend.show='label (percent)'] Controls what is visible
    in the legend, this can be value, value (percent), label or percent or your own custom function.
   * @param {string} [settings.legend.formatter='.0f'] The d3.formatter string.
   * @param {boolean} [settings.showTooltips=true] If false now tooltips will be shown
   * @param {object} [settings.tooltip] A setting that controls the tooltip values and format.
   * @param {string} [settings.tooltip.show='label (value)'] Controls what is visible in
    the tooltip, this can be value, label or percent or custom function.
   * @param {string} [settings.tooltip.formatter='.0f'] The d3.formatter string.
   * @param {object} [settings.emptyMessage] An empty message will be displayed when there is no chart data.
   * This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results', icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}
   *  }`
   *  Set this to null for no message or will default to 'No Data Found with an icon.'
   */

  var PIE_DEFAULTS = {
    dataset: [],
    isDonut: false,
    redrawOnResize: true,
    hideCenterLabel: false,
    showLines: true,
    showLinesMobile: false,
    lines: {
      show: 'value', // value, label or percent or custom function
      formatter: '.0f'
    },
    showLegend: true,
    legendPlacement: 'right', // Can be bottom or right
    legend: {
      show: 'label (percent)', // value, label, label (percent) or percent or custom function
      formatter: '.0f'
    },
    showTooltips: true,
    tooltip: {
      show: 'label (value)', // value, label, label (value) or percent or custom function
      formatter: '.0f'
    },
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  function Pie(element, settings) {
    this.settings = utils.mergeSettings(element, settings, PIE_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Pie.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.width = 0;
      this.isFirefox = Environment.browser.name === 'firefox';

      // Handle Empty Data Set
      if (this.settings.dataset.length === 0) {
        this.element.emptymessage(this.settings.emptyMessage);
        return this;
      }

      this.build().handleEvents();

      /**
       * Fires when the chart is complete done rendering, for customization.
       * @event rendered
       * @memberof Pie
       * @property {object} event - The jquery event object
       * @property {object} svg - The svg object.
       */
      this.element.trigger('rendered', [this.svg]);

      return this;
    },


    /**
     * Build the Component.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    build: function build() {
      var self = this;

      self.svg = d3.select(this.element[0]).append('svg');

      self.mainGroup = self.svg.append('g');

      self.mainGroup.append('g').attr('class', 'slices');
      self.mainGroup.append('g').attr('class', 'labels');
      self.mainGroup.append('g').attr('class', 'lines');
      this.element.addClass('chart-pie');

      if (this.settings.showMobile) {
        this.settings.legendPlacement = 'bottom';
      }

      if (self.settings.legendPlacement) {
        this.element.addClass('has-' + self.settings.legendPlacement + '-legend');
      }

      var w = parseInt(this.element.width(), 10);
      var h = parseInt(this.element.height(), 10);

      var dims = {
        height: h,
        width: w
      };

      if (self.settings.legendPlacement === 'right') {
        dims.width = w * 0.75;
      }

      if (this.settings.showMobile) {
        dims.height = h * 0.80; // make some more room for the legend
        this.element.addClass('is-mobile');
      }

      dims.radius = Math.min(dims.width, dims.height) / 2;
      self.dims = dims;

      self.pie = d3.pie().sort(null).value(function (d) {
        return d.value;
      });

      self.arc = d3.arc().outerRadius(dims.radius * 0.75).innerRadius(self.settings.isDonut ? dims.radius * 0.5 : 0);

      // Influences the label position
      self.outerArc = d3.arc().innerRadius(dims.radius * 0.75).outerRadius(dims.radius * 0.75 + 20);

      self.svg.attr('width', self.settings.legendPlacement === 'right' ? '75%' : '100%').attr('height', self.settings.showMobile ? '80%' : '100%');

      self.mainGroup.attr('transform', 'translate(' + dims.width / 2 + ',' + dims.height / 2 + ')');

      // move the origin of the group's coordinate space to the center of the SVG element
      dims.center = { x: dims.width / 2, y: dims.height / 2 };

      self.key = function (d) {
        return d.data.name;
      };
      var isEmpty = !self.settings.dataset || self.settings.dataset.length === 0;
      this.chartData = !isEmpty ? self.settings.dataset[0].data : [];
      this.sum = d3.sum(this.chartData, function (d) {
        return d.value;
      });

      // Calculate the percentages
      var values = this.chartData.map(function (d) {
        return d.value / self.sum * 100;
      });
      var rounded = this.roundLargestRemainer(values);

      this.chartData = this.chartData.map(function (d, i) {
        d.percent = d.value / self.sum;
        d.percentRound = rounded[i];
        return d;
      });

      var sum = 0;
      this.chartData.map(function (d) {
        // eslint-disable-line
        sum += d.percentRound;
      });

      // Handle zero sum or empty pies
      if (isEmpty || sum === 0 || isNaN(sum)) {
        this.chartData.push({ data: {}, color: '#BDBDBD', name: 'Empty-Pie', value: 100, percent: 1, percentRound: 100 });
      }

      self.updateData(self.chartData);
      if (self.settings.showTooltips) {
        charts.appendTooltip('is-pie');
      }

      if (this.settings.showLegend) {
        var series = self.chartData.map(function (d) {
          var name = charts.formatToSettings(d, self.settings.legend);

          if (self.settings.legendFormatter) {
            name = d.name + ' (' + d3.format(self.settings.legendFormatter)(d.value) + ')';
          }

          if (d.name === 'Empty-Pie') {
            name = '';
          }
          return { name: name, display: 'twocolumn', placement: self.settings.legendPlacement, color: d.color };
        });

        this.settings.svg = self.svg;
        charts.addLegend(series, 'pie', this.settings, this.element);
      }

      this.setInitialSelected();
      this.addCenterLabel();
      this.element.trigger('rendered');
      return this;
    },


    /**
     * Randomize the data for testing.
     * @private
     * @param  {boolean} toZero Set them all to zero value.
     * @returns {void}
     */
    randomize: function randomize(toZero) {
      var self = this;
      this.chartData = this.chartData.map(function (d) {
        d.value = toZero ? 0 : Math.random();
        return d;
      });

      this.sum = d3.sum(this.chartData, function (d) {
        return d.value;
      });
      var values = this.chartData.map(function (d) {
        return d.value / self.sum * 100;
      });
      var rounded = this.roundLargestRemainer(values);

      this.chartData = this.chartData.map(function (d, i) {
        d.percent = d.value / self.sum;
        d.percentRound = rounded[i];
        return d;
      });

      return this.chartData;
    },


    /**
     * Add the center label for donut chart.
     * @private
     * @returns {void}
     */
    addCenterLabel: function addCenterLabel() {
      var self = this;

      if (self.settings.isDonut && !self.settings.hideCenterLabel) {
        var centerLabel = self.settings.dataset[0].centerLabel;
        var arcs = self.svg.selectAll('.slices');

        arcs.append('text').attr('dy', '.35em').style('text-anchor', 'middle').attr('class', 'chart-donut-text').html(centerLabel);

        // FIX: IE does not render .html
        // http://stackoverflow.com/questions/13962294/dynamic-styling-of-svg-text
        if (charts.isIE && !charts.isIEEdge) {
          if (utils.isHTML(centerLabel)) {
            var text = arcs.select('.chart-donut-text');
            var tmp = document.createElement('text');

            tmp.innerHTML = centerLabel;

            var nodes = Array.prototype.slice.call(tmp.childNodes);
            nodes.forEach(function (node) {
              text.append('tspan').attr('style', node.getAttribute && node.getAttribute('style')).attr('x', node.getAttribute && node.getAttribute('x')).attr('dy', node.getAttribute && node.getAttribute('dy')).text(node.textContent);
            });
          } else {
            arcs.select('.chart-donut-text').text(centerLabel);
          }
        }
      }
    },


    /**
     * Update the chart with a new dataset
     * @param  {object} data The data to use.
     * @returns {void}
     */
    updateData: function updateData(data) {
      // Pie Slices
      var self = this;
      var tooltipInterval = void 0;
      var isEmpty = !self.settings.dataset || self.settings.dataset.length === 0;
      var slice = self.svg.select('.slices').selectAll('path.slice').data(self.pie(data), self.key);

      var getOffset = function getOffset(node) {
        var body = document.body;
        var rect = void 0;

        // Fix: With firefox `getBoundingClientRect` not working if node is hidden
        if (self.isFirefox && self.settings.dotSize === 0) {
          var dot = d3.select(node);
          dot.attr('r', 2);
          rect = node.getBoundingClientRect();
          dot.attr('r', self.settings.dotSize);
        } else {
          rect = node.getBoundingClientRect();
        }
        return {
          top: rect.top + body.scrollTop,
          left: rect.left + body.scrollLeft
        };
      };

      self.isRTL = Locale.isRTL();

      slice.enter().insert('path').style('fill', function (d, i) {
        return charts.chartColor(i, 'pie', d.data);
      }).attr('class', 'slice').on('contextmenu', function (d) {
        // Handle Right Click Menu
        charts.triggerContextMenu(self.element, d3.select(this).select('path').nodes()[0], d);
      }).on('click', function (d, i) {
        clearTimeout(tooltipInterval);
        // Handle Click to select
        var isSelected = this && d3.select(this).classed('is-selected');

        // Make unselected
        charts.setSelectedElement({
          task: isSelected ? 'unselected' : 'selected',
          container: self.element,
          selector: isSelected ? '.chart-container .is-selected' : this,
          isTrigger: !isSelected,
          d: d.data,
          i: i,
          type: self.settings.type,
          dataset: self.settings.dataset,
          svg: self.svg
        });

        if (isSelected) {
          /**
           * Fires when arc/slice is selected.
           * @event selected
           * @memberof Pie
           * @property {object} event - The jquery event object
           * @property {object} selected arc/slice.
           * @property {object} data of selected arc/slice.
           * @property {number} index of selected arc/slice.
           */
          self.element.triggerHandler('selected', [d3.select(this).nodes(), {}, i]);
        }
      }).on('mouseenter', function (d, i) {
        if (!self.settings.showTooltips) {
          return;
        }
        // See where to position
        var dot = self.svg.selectAll('circle').nodes()[i];
        var offset = getOffset(dot);

        // See where we want the arrow
        var rads = self.midAngle(d);

        // https://www.wyzant.com/resources/lessons/math/trigonometry/unit-circle
        var isTop = rads <= Math.PI / 4 && rads >= 0 || rads > 7 * Math.PI / 4;
        var isRight = rads <= 3 * Math.PI / 4 && rads >= Math.PI / 4;
        var isBottom = rads <= 5 * Math.PI / 4 && rads >= 3 * Math.PI / 4;
        var isLeft = rads <= 7 * Math.PI / 4 && rads >= 5 * Math.PI / 4;

        // Build the content
        var content = '';
        var show = function show() {
          if (content === '') {
            return;
          }

          var size = charts.tooltipSize(content);
          var x = offset.left;
          var y = offset.top;
          var padding = 5;

          if (isTop) {
            x -= size.width / 2;
            y -= size.height - padding;
            charts.showTooltip(x, y, content, 'top');
          }
          if (isRight) {
            y -= size.height / 2;
            charts.showTooltip(x, y, content, 'right');
          }
          if (isBottom) {
            x -= size.width / 2;
            // y -= padding;
            charts.showTooltip(x, y, content, 'bottom');
          }
          if (isLeft) {
            x -= size.width - padding;
            y -= size.height / 2;
            charts.showTooltip(x, y, content, 'left');
          }
        };

        var value = charts.formatToSettings(d, self.settings.tooltip);
        content = d.data.tooltip || value;
        content = content.replace('{{percent}}', d.data.percentRound + '%');
        content = content.replace('{{value}}', d.value);
        content = content.replace('%percent%', d.data.percentRound + '%');
        content = content.replace('%value%', d.value);

        if (content.indexOf('<b>') === -1) {
          content = content.replace('(', '<b>');
          content = content.replace(')', '</b>');
        }

        // Debounce it a bit
        if (tooltipInterval != null) {
          clearTimeout(tooltipInterval);
        }

        tooltipInterval = setTimeout(function () {
          show();
        }, 300);
      }).on('mouseleave', function () {
        clearTimeout(tooltipInterval);
        charts.hideTooltip();
      }).merge(slice).transition().duration(self.settings.animationSpeed).attrTween('d', function (d) {
        this.current = this.current || d;
        var interpolate = d3.interpolate(this.current, d);
        this.current = interpolate(0);
        return function (t) {
          return self.arc(interpolate(t));
        };
      });

      slice.exit().remove();

      if (isEmpty) {
        return;
      }

      var isMobile = self.element.parent().width() < 520;
      var shouldShow = self.settings.showLines;

      if (!self.settings.showLinesMobile && shouldShow) {
        shouldShow = !isMobile;
      }

      self.settings.dotSize = shouldShow ? 2 : 0;

      // Text Labels
      if (shouldShow) {
        var padding = 20;
        var text = self.svg.select('.labels').selectAll('text').data(self.pie(data), self.key);

        text.enter().append('text').attr('dy', '.35em').text(function (d) {
          return charts.formatToSettings(d, self.settings.lines);
        }).merge(text).transition().duration(self.settings.animationSpeed).attrTween('transform', function (d) {
          this.current = this.current || d;
          var interpolate = d3.interpolate(this.current, d);
          this.current = interpolate(0);
          return function (t) {
            var d2 = interpolate(t);
            var pos = self.outerArc.centroid(d2);
            pos[0] = self.dims.radius * (self.midAngle(d2) < Math.PI ? 1 : -1);
            pos[0] -= self.midAngle(d2) < Math.PI ? padding : -padding;
            return 'translate(' + pos + ')';
          };
        }).styleTween('text-anchor', function (d) {
          this.current = this.current || d;
          var interpolate = d3.interpolate(this.current, d);
          this.current = interpolate(0);
          return function (t) {
            var d2 = interpolate(t);

            if (self.isRTL) {
              return self.midAngle(d2) > Math.PI ? 'start' : 'end';
            }

            return self.midAngle(d2) < Math.PI ? 'start' : 'end';
          };
        });

        text.exit().remove();

        // Slice to text poly lines
        var polyline = self.svg.select('.lines').selectAll('polyline').data(self.pie(data), self.key);

        polyline.enter().append('polyline').merge(polyline).transition().duration(self.settings.animationSpeed).attrTween('points', function (d) {
          this.current = this.current || d;
          var interpolate = d3.interpolate(this.current, d);
          this.current = interpolate(0);
          return function (t) {
            var d2 = interpolate(t);
            var pos = self.outerArc.centroid(d2);
            pos[0] = self.dims.radius * 0.85 * (self.midAngle(d2) < Math.PI ? 1 : -1);
            return [self.outerArc.centroid(d2), self.outerArc.centroid(d2), pos];
          };
        });

        polyline.exit().remove();
      }

      var dots = self.svg.select('.lines').selectAll('circle').data(self.pie(data), self.key);

      dots.enter().append('circle').attr('class', 'circles').attr('r', self.settings.dotSize).merge(dots).transition().duration(self.settings.animationSpeed).attrTween('transform', function (d) {
        this.current = this.current || d;
        var interpolate = d3.interpolate(this.current, d);
        this.current = interpolate(0);
        return function (t) {
          var d2 = interpolate(t);
          return 'translate(' + self.outerArc.centroid(d2) + ' )';
        };
      });

      dots.exit().remove();
    },


    /**
     * Set the initially selected elements
     * @private
     * @returns {void}
     */
    setInitialSelected: function setInitialSelected() {
      var selected = 0;
      var selector = void 0;

      this.svg.selectAll('.slice').each(function (d, i) {
        if (!d || !d.data) {
          return;
        }

        if (d.data.selected && selected < 1) {
          selected++;
          selector = d3.select(this);
          selector.on('click').call(selector.node(), selector.datum(), i);
        }
      });
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('updated.' + COMPONENT_NAME$n, function () {
        _this.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$n, function () {
          _this.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$n, function () {
          _this.handleResize();
        });
      }

      return this;
    },


    /**
     * Get info on the currently selected lines.
     * @private
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },


    /**
     * Get info on the currently selected lines.
     * @private
     * @param {object} o The selection data object
     * @param {boolean} isToggle If true toggle the current state.
     */
    setSelected: function setSelected(o, isToggle) {
      var self = this;
      var selector = void 0;
      var arcIndex = void 0;
      var selected = 0;
      var equals = utils.equals;

      this.svg.selectAll('.slice').each(function (d, i) {
        if (!d || !d.data) {
          return;
        }

        if (selected < 1) {
          if (typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.fieldValue === d.data[o.fieldName] || typeof o.index !== 'undefined' && o.index === i || o.data && equals(o.data, self.chartData[i].data) || o.elem && $(this).is(o.elem)) {
            selected++;
            selector = d3.select(this);
            arcIndex = i;
          }
        }
      });

      if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
        selector.on('click').call(selector.node(), selector.datum(), arcIndex);
      }
    },


    /**
     * Get info on the currently selected lines.
     * @param {object} options The selected info object.
     * @returns {void}
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },


    /**
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      this.element.empty();

      return this.build().element.trigger('rendered', [this.svg]);
    },


    /**
     * Handle updated settings and values.
     * @private
     * @param  {array} values A list of values
     * @returns {array} The values rounded to 100
     */
    roundLargestRemainer: function roundLargestRemainer(values) {
      var sum = 0;
      var count = 0;
      var dVala = 0;
      var dValb = 0;
      var order = [];

      // Round everything down
      for (var i = 0; i < values.length; i++) {
        sum += parseInt(values[i], 10);
        order[i] = i;
      }

      // Getting the difference in sum and 100
      var diff = 100 - sum;

      // Distributing the difference by adding 1 to items in decreasing order of their decimal parts
      order.sort(function (a, b) {
        dVala = values[a] - parseInt(values[a], 10);
        dValb = values[b] - parseInt(values[b], 10);
        return dValb - dVala;
      });

      values.sort(function (a, b) {
        dVala = a - parseInt(a, 10);
        dValb = b - parseInt(b, 10);
        return dValb - dVala;
      });

      for (var j = 0; j < values.length; j++) {
        count = j;
        if (count < diff) {
          values[j] = parseInt(values[j], 10) + 1;
        } else {
          values[j] = parseInt(values[j], 10);
        }
      }

      // Set back the order
      var unsorted = [];
      for (var _i = 0; _i < values.length; _i++) {
        unsorted[order[_i]] = values[_i];
      }
      return unsorted;
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$n);
      $('body').off('resize.' + COMPONENT_NAME$n);
      return this;
    },


    /**
     * Calculate the middle angle.
     * @private
     * @param  {object} d The d3 data.
     * @returns {boolean} The mid angule
     */
    midAngle: function midAngle(d) {
      return d.startAngle + (d.endAngle - d.startAngle) / 2;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('pie-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$n);
      $.removeData(this.element[0], 'chart');
    }
  };

  // Shared Imports

  // Settings and Options
  var COMPONENT_NAME$o = 'radar';

  // Default Radar Options
  var RADAR_DEFAULTS = {
    dataset: [],
    redrawOnResize: true,
    margin: { top: 50, right: 0, bottom: 50, left: 0 },
    levels: 4,
    maxValue: 0,
    labelFactor: 1.27,
    wrapWidth: 60,
    opacityArea: 0.2,
    dotRadius: 3,
    opacityCircles: 0,
    strokeWidth: 1,
    roundStrokes: true,
    showCrosslines: true,
    showAxisLabels: true,
    colors: charts.colorRange,
    showTooltips: true,
    tooltip: {
      show: 'value', // value, label, label (value) or percent or custom function
      formatter: '.0%' // or .0% ?
    },
    axisFormatter: '.0%',
    showLegend: true,
    legendPlacement: 'right',
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  /**
   * A radar chart is a graphical method of displaying multivariate data in the form of a
   * two-dimensional chart of three or more quantitative variables represented on axes starting
   * from the same poin
   * @class Radar
   * @param {string} element The plugin element for the constuctor
   * @param {string} settings The settings element.
   * @param {array} settings.dataset The data to use in the radar
   * @param {boolean} [settings.redrawOnResize = true] If false, the component will not resize when resizing the page.
   * @param {object} [settings.margin] The margins of the SVG, you may want to adjust
   * depending on text location.
   * @param {number} [settings.levels = 4] How many levels or inner circles should there be drawn.
   * @param {number} [settings.maxValue = 0] What is the value that the biggest circle will represent
   * @param {number} [settings.labelFactor = 1.27] How far out than the outer circle should the labels be placed,
   * this may be useful to adjust for some charts.
   * @param {number} [settings.wrapWidth = 60] The number of pixels after which a label needs to be
   * given a new line. You may want to change this based on label data.
   * @param {boolean} [settings.showCrosslines = true] Set to false to hide the cross line axes.
   * @param {boolean} [settings.showAxisLabels = true] Set to false to hide percent labels.
   * @param {number} [settings.opacityArea = 0.2] The opacity value of the blobs. This is set to the correct Infor Style.
   * @param {number} [settings.dotRadius = 3] The size of the colored circles of each blog. Set to zero to remove dots.
   * @param {number} [settings.opacityCircles  = 0]The opacity of the circles of each blob 0 or .1 are good values.
   * This is set to the correct Infor Style.
   * @param {number} [settings.strokeWidth = 1] The width of the stroke around each blob.
   * This is set to the correct Infor Style.
   * @param {boolean} [settings.roundStrokes = true] If true the area and stroke will follow a
   * round path (cardinal-closed).
   * @param {boolean} [settings.showCrosslines = true]  If false the axis lines will not be shown in the diagonals.
   * @param {boolean} [settings.showAxisLabels = true]  If false the axis labels will not be shown.
   * @param {string} [settings.axisFormatter = '.0%'] D3 formatter to use on the axis labels
   * @param {array} [settings.colors] An array of colors to use.
   * @param {boolean} [settings.showTooltips = true] If false no tooltips will be shown.
   * @param {object} [settings.tooltip] A setting that controls the tooltip values and format.
   * @param {string} [settings.tooltip.show = 'value'] Controls what is visible in the tooltip, this can be value, label
   * or percent or custom function.
   * @param {object} [settings.tooltip.formatter = '.0%'] The d3.formatter string.
   * @param {boolean} [settings.showLegend = true] If false the legend will not be shown.
   * @param {string} [settings.legendPlacement = 'right'] Where to locate the legend. This can be bottom or right at
   * the moment.
   * @param {object} [settings.emptyMessage] An empty message will be displayed when there is no chart data.
   * This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results', icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}
   *  }`
   *  Set this to null for no message or will default to 'No Data Found with an icon.'
   */
  function Radar(element, settings) {
    this.settings = utils.mergeSettings(element, settings, RADAR_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Radar.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.width = 0;

      this.build().handleEvents();

      /**
      * Fires when the chart is complete done rendering, for customization.
      * @event rendered
      * @memberof Radar
      * @property {object} event - The jquery event object
      * @property {array} svg - The svg object.
      */
      this.element.trigger('rendered', [this.svg]);

      return this;
    },


    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      this.updateData(this.settings.dataset);
      this.setInitialSelected();
      return this;
    },


    /**
     * Update the chart with a new dataset
     * @param  {object} data The data to use.
     */
    updateData: function updateData(data) {
      var self = this;
      var settings = self.settings;
      var dims = {
        // Width of the circle
        w: parseInt(this.element.parent().width(), 10),
        // Height of the circle && 60px on top and bottom for labels
        h: parseInt(this.element.parent().height() - 115, 10)
      };

      if (settings.legendPlacement === 'right') {
        dims.w *= 0.75;
      }
      this.element.addClass('chart-radar');

      // Handle Empty Data Set
      if (data.length === 0) {
        self.element.emptymessage(self.settings.emptyMessage);
        return;
      }

      // Get the name text from given data
      var getNameText = function getNameText(d) {
        var size = { min: 328, max: 469 };
        var text = '';
        if (dims.w <= size.min) {
          text = d.shortName || d.abbrName || d.name || '';
        } else if (dims.w >= size.min + 1 && dims.w <= size.max) {
          text = d.abbrName || d.name || '';
        } else if (dims.w > size.max) {
          text = d.name || '';
        }
        return text;
      };

      var tooltipInterval = void 0;
      var colors = d3.scaleOrdinal(self.settings.colors);

      // If the supplied maxValue is smaller than the actual one, replace by the max in the data
      var maxValue = Math.max(settings.maxValue, d3.max(data, function (i) {
        return d3.max(i.data.map(function (o) {
          return o.value;
        }));
      })); //eslint-disable-line

      var allAxes = data[0].data.map(function (d) {
        return getNameText(d);
      }); // Map the names to the axes
      var total = allAxes.length; // The number of different axes
      var radius = Math.min(dims.w / 2, dims.h / 2); // Radius of the outermost circle
      var angleSlice = Math.PI * 2 / total; // The width in radians of each 'slice'

      if (dims.w <= 328) {
        var extra = dims.w < 225 ? 75 : 50; // Reduce the size of the radar
        radius = Math.min((dims.w - extra) / 2, (dims.h - extra) / 2);
      }

      // Create the Scale for the radius
      var rScale = d3.scaleLinear().range([0, radius]).domain([0, maxValue]);

      // Create the container SVG and parent g
      // Remove whatever chart with the same id/class was present before
      var elem = this.element[0];
      d3.select(elem).select('svg').remove();

      // Initiate the radar chart SVG
      var svg = d3.select(elem).append('svg').attr('width', dims.w + settings.margin.left + settings.margin.right).attr('height', dims.h + settings.margin.top + settings.margin.bottom).attr('class', 'chart-radar');

      this.svg = svg; // Pointer for selection states

      // Append a g element
      var g = svg.append('g').attr('transform', 'translate(' + (dims.w / 2 + settings.margin.left) + ',' + (dims.h / 2 + settings.margin.top) + ')');

      // Filter for the outside glow effect
      if (settings.opacityCircles > 0) {
        var filter = g.append('defs').append('filter').attr('id', 'glow');
        filter.append('feGaussianBlur').attr('stdDeviation', '2.5').attr('result', 'coloredBlur');
        var feMerge = filter.append('feMerge');
        feMerge.append('feMergeNode').attr('in', 'coloredBlur');
        feMerge.append('feMergeNode').attr('in', 'SourceGraphic');
      }

      // Draw the Circular grid

      // Wrapper for the grid & axes
      var axisGrid = g.append('g').attr('class', 'chart-radar-axis-wrapper');

      // Draw the background circles
      axisGrid.selectAll('.levels').data(d3.range(1, settings.levels + 1).reverse()).enter().append('circle').attr('class', 'chart-radar-grid-circle').attr('r', function (d) {
        return radius / settings.levels * d;
      }).style('fill-opacity', settings.opacityCircles).style('filter', settings.opacityCircles > 0 ? 'url(#glow)' : '');

      // Text indicating at what % each level is
      if (this.settings.showAxisLabels) {
        axisGrid.selectAll('.axis-label').data(d3.range(1, settings.levels + 1).reverse()).enter().append('text').attr('class', 'axis-label').attr('x', 4).attr('y', function (d) {
          return -d * radius / settings.levels;
        }).attr('dy', '0.4em').style('font-size', '10px').attr('fill', '#737373').text(function (d) {
          var text = '';
          var roundedVal = Math.round(maxValue * 10) / 10;

          if (settings.axisFormatter.indexOf('%') > -1) {
            text = d3.format(settings.axisFormatter)(roundedVal * d / settings.levels);
          } else {
            text = d3.format(settings.axisFormatter)(d / settings.levels);
          }

          return text;
        });
      }

      // Draw the axes

      // Create the straight lines radiating outward from the center
      var axis = axisGrid.selectAll('.axis').data(allAxes).enter().append('g').attr('class', 'axis');

      // Append the cross lines
      if (this.settings.showCrosslines) {
        axis.append('line').attr('x1', 0).attr('y1', 0).attr('x2', function (d, i) {
          return rScale(maxValue * 1.05) * Math.cos(angleSlice * i - Math.PI / 2);
        }).attr('y2', function (d, i) {
          return rScale(maxValue * 1.05) * Math.sin(angleSlice * i - Math.PI / 2);
        }).attr('class', 'chart-radar-crossline').style('stroke-width', '1px');
      }

      // Append the labels at each axis
      axis.append('text').attr('class', 'legend').style('font-size', '12px').attr('text-anchor', 'middle').attr('dy', '0.35em').attr('x', function (d, i) {
        return rScale(maxValue * settings.labelFactor) * Math.cos(angleSlice * i - Math.PI / 2);
      }).attr('y', function (d, i) {
        return rScale(maxValue * settings.labelFactor) * Math.sin(angleSlice * i - Math.PI / 2);
      }).text(function (d) {
        return d;
      });

      this.element[dims.w < 420 ? 'addClass' : 'removeClass']('is-small');

      if (dims.w > 456) {
        svg.selectAll('.chart-radar-axis-wrapper .axis .legend').each(function () {
          charts.wrap(d3.select(this), settings.wrapWidth, settings.labelFactor);
        });
      }

      // Draw the radar chart blobs

      // The radial line function
      var radarLine = d3.lineRadial().curve(d3.curveBasisClosed).radius(function (d) {
        return rScale(d.value);
      }).angle(function (d, i) {
        return i * angleSlice;
      });

      if (settings.roundStrokes) {
        radarLine.curve(d3.curveCardinalClosed);
      }

      // Create a wrapper for the blobs
      var blobWrapper = g.selectAll('.radarWrapper').data(data.map(function (i) {
        return i.data;
      })).enter().append('g').attr('class', 'chart-radar-wrapper');

      // Append the backgrounds
      blobWrapper.append('path').attr('class', 'chart-radar-area').attr('d', function (d) {
        return radarLine(d);
      }).style('fill', function (d, i) {
        return colors(i);
      }).style('fill-opacity', settings.opacityArea).on('click', function (d, i) {
        // Handle Click to select
        clearTimeout(tooltipInterval);

        var selectElem = d3.select(this);
        var isSelected = selectElem.classed('is-selected');
        svg.selectAll('.is-selected').classed('is-selected', false);
        svg.selectAll('.is-not-selected').classed('is-not-selected', false);

        if (!isSelected) {
          svg.selectAll('.chart-radar-area').classed('is-not-selected', true);
          selectElem.classed('is-selected', true).classed('is-not-selected', false);
          selectElem.style('fill-opacity', self.settings.opacityArea);
        }

        var triggerData = {
          elem: selectElem.nodes(),
          data: d,
          index: i
        };

        /**
        * Fires when the chart is complete done rendering, for customization.
        * @event selected
        * @memberof Radar
        * @property {object} data - The data element attached
        * @property {HTMLElement} elem - The dom element
        * @property {number} index - The index for this blob.
        */

        /**
        * Fires when the chart is complete done rendering, for customization.
        * @event deselected
        * @memberof Radar
        * @property {object} data - The data element attached
        * @property {HTMLElement} elem - The dom element
        * @property {number} index - The index for this blob.
        */
        self.element.triggerHandler(isSelected ? 'deselected' : 'selected', triggerData);

        charts.selected = !isSelected ? triggerData : [];
      });

      // Create the outlines
      blobWrapper.append('path').attr('class', 'chart-radar-stroke').attr('d', function (d) {
        return radarLine(d);
      }).style('stroke-width', settings.strokeWidth + 'px').style('stroke', function (d, i) {
        return colors(i);
      }).style('fill', 'none').style('filter', settings.opacityCircles > 0 ? 'url(#glow)' : '');

      // Append the circles
      blobWrapper.selectAll('.chart-radar-circle').data(function (d) {
        return d;
      }).enter().append('circle').attr('class', 'chart-radar-circle').attr('r', settings.dotRadius).attr('cx', function (d, i) {
        return rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2);
      }).attr('cy', function (d, i) {
        return rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2);
      }).style('fill', function () {
        return colors($(this.parentNode).index() - 1);
      }).style('fill-opacity', 0.6);

      // Wrapper for the invisible circles on top
      var blobCircleWrapper = g.selectAll('.radar-circle-wrapper').data(data.map(function (i) {
        return i.data;
      })).enter().append('g').attr('class', 'radar-circle-wrapper');

      // Append a set of invisible circles on top for the mouseover pop-up
      blobCircleWrapper.selectAll('.radar-invisible-circle').data(function (d) {
        return d;
      }).enter().append('circle').attr('class', 'radar-invisible-circle').attr('r', settings.dotRadius * 1.5).attr('cx', function (d, i) {
        return rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2);
      }).attr('cy', function (d, i) {
        return rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2);
      }).style('fill', 'none').style('pointer-events', 'all').on('mouseenter', function (d) {
        if (!settings.showTooltips) {
          return;
        }

        var offset = $(this).offset();
        var content = charts.formatToSettings(d, self.settings.tooltip);

        if (content.indexOf('<b>') === -1) {
          content = content.replace('(', '<b>');
          content = content.replace(')', '</b>');
        }

        var size = charts.tooltipSize(content);
        var x = offset.left;
        var y = offset.top;
        var padding = 6;
        x -= size.width / 2 - padding;
        y -= size.height + padding;

        // Debounce it a bit
        if (tooltipInterval != null) {
          clearTimeout(tooltipInterval);
        }

        tooltipInterval = setTimeout(function () {
          charts.showTooltip(x, y, content, 'top');
        }, 300);
      }).on('mouseleave', function () {
        clearTimeout(tooltipInterval);
        charts.hideTooltip();
      });

      // Add tooltip object
      if (settings.showTooltips) {
        charts.appendTooltip('is-pie');
      }

      if (settings.showLegend) {
        if (settings.legendPlacement) {
          this.element.addClass('has-' + settings.legendPlacement + '-legend');
        }

        var series = self.settings.dataset.map(function (d, i) {
          return {
            name: d.name,
            display: 'twocolumn',
            placement: self.settings.legendPlacement,
            color: colors(i)
          };
        });

        this.settings.svg = self.svg;
        charts.addLegend(series, 'pie', this.settings, this.element);
      }
    },


    /**
     * Set the initially selected elements
     * @private
     */
    setInitialSelected: function setInitialSelected() {},


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('updated.' + COMPONENT_NAME$o, function () {
        _this.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$o, function () {
          _this.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$o, function () {
          _this.handleResize();
        });
      }

      return this;
    },


    /**
     * Get info on the currently selected lines.
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },


    /**
     * Get info on the currently selected lines.
     * @param {object} o The selection data object
     * @param {boolean} isToggle If true toggle the current state.
     */
    setSelected: function setSelected(o, isToggle) {
      var selector = void 0;
      var arcIndex = void 0;
      var selected = 0;
      var self = this;

      this.svg.selectAll('.chart-radar-area').each(function (d, i) {
        var set = self.settings.dataset[i];
        if (!set || !set.data) {
          return;
        }

        if (selected < 1) {
          if (typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.fieldValue === set[o.fieldName] || typeof o.index !== 'undefined' && o.index === i || o.elem && $(this).is(o.elem)) {
            selected++;
            selector = d3.select(this);
            arcIndex = i;
          }
        }
      });

      if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
        selector.on('click').call(selector.node(), selector.datum(), arcIndex);
      }
    },


    /**
     * Get info on the currently selected lines.
     * @param {object} options The selected info object.
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },


    /**
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.element.find('.chart-legend').remove();
        this.settings.dataset = settings.dataset;
        this.updateData(this.settings.dataset);
        return this;
      }

      this.element.empty();
      return this.build();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$o);
      $('body').off('resize.' + COMPONENT_NAME$o);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('radar-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$o);
      $.removeData(this.element[0], 'radar');
    }
  };

  /*
  * jQuery Component Wrapper for Charts. It maps the singlular components
  * to the previous versions single jquery wrapper.
  * @param  {object} settings The settings to apply.
  * @returns {object} The jquery object for chaining.
  */
  $.fn.chart = function (settings) {
    var instance = null;
    this.empty(); // allow changing chart type

    switch (settings.type) {
      case 'targeted-achievement':
      case 'completion':
      case 'completion-target':
        {
          instance = this.data(settings.type);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var chartComponent = new CompletionChart(this, settings);
          this.data(COMPONENT_NAME$h, chartComponent);
          this.data('chart', chartComponent); // Compatibility
          this.data(settings.type, chartComponent); // Compatibility
          break;
        }
      case 'bullet':
        {
          instance = this.data(COMPONENT_NAME$g);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent = new Bullet(this, settings);
          this.data(COMPONENT_NAME$g, _chartComponent);
          this.data('chart', _chartComponent); // Compatibility
          break;
        }
      case 'radar':
        {
          instance = this.data(COMPONENT_NAME$o);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent2 = new Radar(this, settings);
          this.data(COMPONENT_NAME$o, _chartComponent2);
          this.data('chart', _chartComponent2); // Compatibility
          break;
        }
      case 'sparkline':
        {
          instance = this.data(COMPONENT_NAME$i);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent3 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$i, _chartComponent3);
          this.data('chart', _chartComponent3); // Compatibility
          break;
        }
      case 'sparkline-dots':
        {
          settings.isDots = true;
          instance = this.data(COMPONENT_NAME$i);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent4 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$i, _chartComponent4);
          this.data('chart', _chartComponent4); // Compatibility
          break;
        }
      case 'sparkline-peak':
        {
          settings.isPeakDot = true;
          instance = this.data(COMPONENT_NAME$i);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent5 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$i, _chartComponent5);
          this.data('chart', _chartComponent5); // Compatibility
          break;
        }
      case 'sparkline-dots-n-peak':
        {
          settings.isPeakDot = true;
          settings.isDots = true;
          instance = this.data(COMPONENT_NAME$i);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent6 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$i, _chartComponent6);
          this.data('chart', _chartComponent6); // Compatibility
          break;
        }
      case 'sparkline-minmax':
        {
          settings.isMinMax = true;
          instance = this.data(COMPONENT_NAME$i);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent7 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$i, _chartComponent7);
          this.data('chart', _chartComponent7); // Compatibility
          break;
        }
      case 'sparkline-medianrange':
        {
          settings.isMedianRange = true;
          instance = this.data(COMPONENT_NAME$i);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent8 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$i, _chartComponent8);
          this.data('chart', _chartComponent8); // Compatibility
          break;
        }
      case 'sparkline-medianrange-n-peak':
        {
          settings.isMedianRange = true;
          settings.isPeakDot = true;
          instance = this.data(COMPONENT_NAME$i);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent9 = new Sparkline(this, settings);
          this.data(COMPONENT_NAME$i, _chartComponent9);
          this.data('chart', _chartComponent9); // Compatibility
          break;
        }
      case 'line':
        {
          instance = this.data(COMPONENT_NAME$k);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent10 = new Line(this, settings);
          this.data(COMPONENT_NAME$k, _chartComponent10);
          this.data('chart', _chartComponent10); // Compatibility
          break;
        }
      case 'area':
        {
          settings.isArea = true;
          instance = this.data(COMPONENT_NAME$k);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent11 = new Line(this, settings);
          this.data(COMPONENT_NAME$k, _chartComponent11);
          this.data('chart', _chartComponent11); // Compatibility
          break;
        }
      case 'bubble':
        {
          settings.isBubble = true;
          instance = this.data(COMPONENT_NAME$k);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent12 = new Line(this, settings);
          this.data(COMPONENT_NAME$k, _chartComponent12);
          this.data('chart', _chartComponent12); // Compatibility
          break;
        }
      case 'scatterplot':
        {
          settings.isScatterPlot = true;
          instance = this.data(COMPONENT_NAME$k);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent13 = new Line(this, settings);
          this.data(COMPONENT_NAME$k, _chartComponent13);
          this.data('chart', _chartComponent13); // Compatibility
          break;
        }
      case 'column':
      case 'column-grouped':
      case 'positive-negative':
      case 'column-positive-negative':
        {
          instance = this.data(COMPONENT_NAME$l);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent14 = new Column(this, settings);
          this.data(COMPONENT_NAME$l, _chartComponent14);
          this.data('chart', _chartComponent14); // Compatibility
          break;
        }
      case 'column-stacked':
        {
          settings.isStacked = true;
          instance = this.data(COMPONENT_NAME$l);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent15 = new Column(this, settings);
          this.data(COMPONENT_NAME$l, _chartComponent15);
          this.data('chart', _chartComponent15); // Compatibility
          break;
        }
      case 'bar':
        {
          settings.isStacked = true;
          instance = this.data(COMPONENT_NAME$m);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent16 = new Bar(this, settings);
          this.data(COMPONENT_NAME$m, _chartComponent16);
          this.data('chart', _chartComponent16); // Compatibility
          break;
        }
      case 'bar-stacked':
        {
          settings.isStacked = true;
          instance = this.data(COMPONENT_NAME$m);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent17 = new Bar(this, settings);
          this.data(COMPONENT_NAME$m, _chartComponent17);
          this.data('chart', _chartComponent17); // Compatibility
          break;
        }
      case 'bar-normalized':
        {
          settings.isNormalized = true;
          instance = this.data(COMPONENT_NAME$m);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent18 = new Bar(this, settings);
          this.data(COMPONENT_NAME$m, _chartComponent18);
          this.data('chart', _chartComponent18); // Compatibility
          break;
        }
      case 'bar-grouped':
        {
          settings.isStacked = false;
          settings.isGrouped = true;
          instance = this.data(COMPONENT_NAME$m);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent19 = new Bar(this, settings);
          this.data(COMPONENT_NAME$m, _chartComponent19);
          this.data('chart', _chartComponent19); // Compatibility
          break;
        }
      case 'pie':
        {
          instance = this.data(COMPONENT_NAME$n);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent20 = new Pie(this, settings);
          this.data(COMPONENT_NAME$n, _chartComponent20);
          this.data('chart', _chartComponent20); // Compatibility
          break;
        }
      case 'donut':
        {
          settings.isDonut = true;
          instance = this.data(COMPONENT_NAME$n);
          if (instance) {
            instance.updated(settings);
            return this;
          }
          var _chartComponent21 = new Pie(this, settings);
          this.data(COMPONENT_NAME$n, _chartComponent21);
          this.data('chart', _chartComponent21); // Compatibility
          break;
        }
      default:
        instance = null;
    }

    return this;
  };

  // Settings and Options
  var COMPONENT_NAME$p = 'monthview';

  var COMPONENT_NAME_DEFAULTS = {
    locale: null,
    month: new Date().getMonth(),
    year: new Date().getFullYear(),
    activeDate: null,
    activeDateIslamic: null,
    isPopup: false,
    headerStyle: 'full',
    firstDayOfWeek: null,
    disable: {
      dates: [],
      minDate: '',
      maxDate: '',
      dayOfWeek: [],
      isEnable: false,
      restrictMonths: false
    },
    legend: [{ name: 'Public Holiday', color: '#76B051', dates: [] }, { name: 'Weekends', color: '#EFA836', dayOfWeek: [] }],
    hideDays: false,
    showMonthYearPicker: false,
    advanceMonths: 5,
    range: {
      useRange: false, // true - if datepicker using range dates
      start: '', // Start date '03/05/2018'
      end: '', // End date '03/21/2018'
      separator: ' - ', // separator string between two dates
      minDays: 0, // Minimum days
      maxDays: 0, // Maximum days
      selectForward: false, // Only in forward direction
      selectBackward: false, // Only in backward direction
      includeDisabled: false // if true range will include disable dates in it
    },
    selectable: true,
    onSelected: null
  };

  /**
   * MonthView - Renders a Month calendar
   * @class MonthView
   * @param {string} element The plugin element for the constuctor
   * @param {object} [settings] The settings element.
   * @param {string} [settings.locale] The name of the locale to use for this instance. If not set the current locale will be used.
   * @param {number} [settings.month] The month to show.
   * @param {number} [settings.year] The year to show.
   * @param {number} [settings.activeDate] The date to highlight as selected/today.
   * @param {number} [settings.activeDateIslamic] The date to highlight as selected/today (as an array for islamic)
   * @param {number} [settings.isPopup] Is it in a popup (datepicker using it)
   * @param {number} [settings.headerStyle] Configure the header, this can be 'simple' or 'full'. Full adds a picker and today link.
   * @param {number} [settings.firstDayOfWeek=null] Set first day of the week. '1' would be Monday.
   * @param {object} [settings.disable] Disable dates in various ways.
   * For example `{minDate: 'M/d/yyyy', maxDate: 'M/d/yyyy'}`. Dates should be in format M/d/yyyy
   * or be a Date() object or string that can be converted to a date with new Date().
   * @param {array} [settings.disable.dates] Disable specific dates.
   * Example `{dates: ['12/31/2018', '01/01/2019'}`.
   * @param {string|date} [settings.disable.minDate] Disable up to a minimum date.
   * Example `{minDate: '12/31/2016'}`.
   * @param {string|date} [settings.disable.maxDate] Disable up to a maximum date.
   * Example `{minDate: '12/31/2019'}`.
   * @param {array} [settings.disable.dayOfWeek] Disable a specific of days of the week 0-6.
   * Example `{dayOfWeek: [0,6]}`.
   * @param {boolean} [settings.disable.isEnable=false] Inverse the disable settings.
   * If true all the disable settings will be enabled and the rest will be disabled.
   * So you can inverse the settings.
   * @param {boolean} [settings.disable.retrictMonths=false] Restrict month selections on datepicker.
   * It requires minDate and maxDate for the feature to activate.
   * For example if you have more non specific dates to disable then enable ect.
   * @param {object} [settings.range] Range between two dates with various options.
   * @param {boolean} [settings.range.useRange=false] Use range of two dates options.
   * @param {string|date} [settings.range.start] Start date in range.
   * @param {string|date} [settings.range.end] End date in range.
   * @param {string} [settings.range.separator=' - '] Visual separator between two dates.
   * @param {number} [settings.range.minDays=0] Minimum days to be in range.
   * @param {number} [settings.range.maxDays=0] Maximum days to be in range.
   * @param {boolean} [settings.range.selectForward=false] Range only in forward direction.
   * @param {boolean} [settings.range.selectBackward=false] Range only in backward direction.
   * @param {boolean} [settings.range.includeDisabled=false] Include disable dates in range of dates.
   * @param {boolean} [settings.hideDays=false] If true the days portion of the calendar will be hidden. Usefull for Month/Year only formats.
   * @param {boolean} [settings.showMonthYearPicker=false] If true the month and year will render as dropdowns.
   * @param {number} [settings.advanceMonths=5] The number of months in each direction to show in
   *  the dropdown for months (when initially opening)
   * @param {array} [settings.legend]  Legend Build up
   * for example `[{name: 'Public Holiday', color: '#76B051', dates: []},
   * {name: 'Weekends', color: '#EFA836', dayOfWeek: []}]`
   * @param {boolean} [settings.selectable=false] If true the month days can be clicked to select
   * @param {boolean} [settings.onSelected=false] Call back that fires when a month day is clicked.
   */
  function MonthView(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COMPONENT_NAME_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  MonthView.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    init: function init() {
      // Do initialization. Build or Events ect
      return this.build();
    },


    /**
     * Set current locale to be used
     * @private
     * @returns {void}
     */
    setLocale: function setLocale() {
      var _this = this;

      if (this.settings.locale && (!this.locale || this.locale.name !== this.settings.locale)) {
        Locale.getLocale(this.settings.locale).done(function (locale) {
          _this.locale = Locale.cultures[locale];
          _this.setCurrentCalendar();
          _this.build().handleEvents();
        });
      } else if (!this.settings.locale) {
        this.locale = Locale.currentLocale;
      }
    },


    /**
     * Add any needed markup to the component.
     * @private
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    build: function build() {
      var _this2 = this;

      this.setLocale();
      if (this.rendered || this.settings.locale && (!this.locale || this.locale.name !== this.settings.locale)) {
        // Defer loading
        this.rendered = false;
        return this;
      }

      this.rendered = true;
      this.setCurrentCalendar();

      // Calendar Html in Popups
      this.prevButton = '' + ('<button type="button" class="btn-icon prev">\n        ' + $.createIcon('caret-left') + '\n        <span>' + Locale.translate('PreviousMonth', { locale: this.locale.name }) + '</span>\n      </button>');
      this.nextButton = '' + ('<button type="button" class="btn-icon next">\n        ' + $.createIcon('caret-right') + '\n        <span>' + Locale.translate('NextMonth', { locale: this.locale.name }) + '</span>\n      </button>');

      this.header = $('' + ('<div class="monthview-header">\n        <span class="month">november</span>\n        <span class="year">2015</span>\n        ' + (this.isRTL ? this.nextButton + this.prevButton : this.prevButton + this.nextButton) + '\n      </div>'));
      this.table = $('<table class="monthview-table" aria-label="' + Locale.translate('Calendar', { locale: this.locale.name }) + '" role="application"></table>');
      this.dayNames = $('' + '<thead>\n        <tr>\n          <th>SU</th>\n          <th>MO</th>\n          <th>TU</th>\n          <th>WE</th>\n          <th>TH</th>\n          <th>FR</th>\n          <th>SA</th>\n        </tr>\n      </thead>').appendTo(this.table);
      this.days = $('' + '<tbody>\n        <tr>\n          <td class="alternate">26</td>\n          <td class="alternate">27</td>\n          <td class="alternate">28</td>\n          <td class="alternate">29</td>\n          <td class="alternate" >30</td>\n          <td class="alternate">31</td>\n          <td>1</td>\n        </tr><tr>\n          <td>2</td>\n          <td>3</td>\n          <td>4</td>\n          <td>5</td>\n          <td>6</td>\n          <td>7</td>\n          <td>8</td>\n        </tr><tr>\n          <td>9</td>\n          <td>10</td>\n          <td>11</td>\n          <td>12</td>\n          <td>13</td>\n          <td>14</td>\n          <td>15</td>\n        </tr><tr>\n          <td>16</td>\n          <td>17</td>\n          <td>18</td>\n          <td>19</td>\n          <td class="is-today">20</td>\n          <td>21</td>\n          <td>22</td>\n        </tr><tr>\n          <td>23</td>\n          <td>24</td>\n          <td>25</td>\n          <td>26</td>\n          <td>27</td>\n          <td>28</td>\n          <td class="alternate">1</td>\n        </tr><tr>\n          <td class="alternate">2</td>\n          <td class="alternate">3</td>\n          <td class="alternate">4</td>\n          <td class="alternate">5</td>\n          <td class="alternate">6</td>\n          <td class="alternate">7</td>\n          <td class="alternate">8</td>\n        </tr>\n      </tbody>').appendTo(this.table);

      if (this.settings.hideDays) {
        this.table = '';
      }

      // Reconfigure the header
      if (this.settings.headerStyle === 'full') {
        this.header = $('' + ('<div class="monthview-header full">\n          ' + (this.isRTL ? this.nextButton + this.prevButton : this.prevButton + this.nextButton) + '\n          <span class="monthview-datepicker">\n            <input aria-label="' + Locale.translate('Today', { locale: this.locale.name }) + '" id="monthview-datepicker-field" readonly data-init="false" class="datepicker" name="monthview-datepicker-field" type="text"/>\n          </span>\n          <a class="hyperlink today" href="#">' + Locale.translate('Today', { locale: this.locale.name }) + '</a>\n        </div>'));
        this.monthPicker = this.header.find('#monthview-datepicker-field');
        this.todayLink = this.header.find('.hyperlink.today');
      }

      this.showMonth(this.settings.month, this.settings.year);
      this.calendar = this.element.addClass('monthview').append(this.header, this.table);

      if (!this.settings.isPopup) {
        this.element.addClass('is-fullsize');
      }

      // Add Legend
      this.addLegend();

      if (this.settings.headerStyle === 'full') {
        this.monthPicker.datepicker({
          autoSize: true,
          dateFormat: Locale.calendar(this.locale.name).dateFormat.year,
          locale: this.settings.locale,
          showMonthYearPicker: true,
          hideButtons: true,
          onOpenCalendar: function onOpenCalendar() {
            return _this2.currentDate;
          }
        });
        this.header.find('button, a').hideFocus();
      }

      this.handleEvents();
      return this;
    },


    /**
     * Set current calendar
     * @private
     * @returns {void}
     */
    setCurrentCalendar: function setCurrentCalendar() {
      this.currentCalendar = Locale.calendar(this.locale.name, this.settings.calendarName);
      this.isIslamic = this.currentCalendar.name === 'islamic-umalqura';
      this.isRTL = this.locale.direction === 'right-to-left';
      this.conversions = this.currentCalendar.conversions;
    },


    /**
     * Update the calendar to show the given month and year
     * @param {number} month The zero based month to display
     * @param {number} year The year to display
     * @returns {void}
     */
    showMonth: function showMonth(month, year) {
      var self = this;
      var now = new Date();

      now.setHours(0);
      now.setMinutes(0);
      now.setSeconds(0);

      var elementDate = this.settings.activeDate && this.settings.activeDate.getDate() ? this.settings.activeDate : now;

      this.setCurrentCalendar();

      if (this.isIslamic) {
        if (!this.settings.activeDateIslamic) {
          var gregorianDate = new Date();
          this.todayDateIslamic = this.conversions.fromGregorian(gregorianDate);
          this.settings.activeDateIslamic = [];
          this.settings.activeDateIslamic[0] = this.todayDateIslamic[0];
          this.settings.activeDateIslamic[1] = this.todayDateIslamic[1];
          this.settings.activeDateIslamic[2] = this.todayDateIslamic[2];
          year = this.settings.activeDateIslamic[0];
          month = this.settings.activeDateIslamic[1];
          elementDate = this.conversions.fromGregorian(now);
        } else {
          elementDate = this.settings.activeDateIslamic;
        }
      }

      if (year.toString().length < 4) {
        year = new Date().getFullYear();
      }

      if (month === 12) {
        year++;
        month = 0;
        this.currentMonth = month;
        this.currentYear = year;
      }

      if (month < 0) {
        year--;
        month = 11;
        this.currentMonth = month;
        this.currentYear = year;
      }

      this.currentDay = now.getDate();

      var days = this.currentCalendar.days.narrow;
      days = days || this.currentCalendar.days.abbreviated;

      if (!this.settings.isPopup) {
        days = this.currentCalendar.days.abbreviated;
      }
      var monthName = this.currentCalendar.months.wide[month];

      this.currentMonth = month;
      this.currentYear = year;

      // Set the Days of the week
      var firstDayofWeek = this.currentCalendar.firstDayofWeek || 0;

      if (this.settings.firstDayOfWeek) {
        firstDayofWeek = this.settings.firstDayOfWeek;
      }

      this.dayNames.find('th').each(function (i) {
        $(this).text(days[(i + firstDayofWeek) % 7]);
      });

      // Localize Month Name
      this.yearFirst = this.currentCalendar.dateFormat.year && this.currentCalendar.dateFormat.year.substr(1, 1) === 'y';
      this.header.find('.month').attr('data-month', month).text(xssUtils.stripTags(monthName) + ' ');
      this.header.find('.year').text(' ' + year);

      if (this.yearFirst && !this.isIslamic && !this.isRTL) {
        elementDate.setFullYear(year);
        var translation = Locale.formatDate(elementDate, { date: 'year', locale: this.locale.name });
        var justYear = translation.split(' ')[0];

        this.header.find('.year').text(justYear + ' ');
        this.header.find('.year').insertBefore(this.header.find('.month'));
      }

      if (this.settings.headerStyle === 'full' && this.monthPicker) {
        this.monthPicker.val(Locale.formatDate(new Date(year, month, 1), { date: 'year', locale: this.locale.name }));
        if (this.monthPicker.data('datepicker')) {
          this.monthPicker.data('datepicker').setSize();
        }
      }

      this.appendMonthYearPicker(month, year);

      // Adjust days of the week
      // lead days
      var firstDayOfMonth = this.firstDayOfMonth(year, month);
      var leadDays = (firstDayOfMonth - firstDayofWeek + 7) % 7;
      var lastMonthDays = this.daysInMonth(year, month + (this.isIslamic ? 1 : 0));
      var thisMonthDays = this.daysInMonth(year, month + (this.isIslamic ? 0 : 1));
      var nextMonthDayCnt = 1;
      var dayCnt = 1;
      var exYear = void 0;
      var exMonth = void 0;
      var exDay = void 0;

      var s = this.settings;
      this.dayMap = [];
      this.days.find('td').each(function (i) {
        var th = $(this).removeClass('alternate prev-month next-month is-selected range is-today');
        th.removeAttr('aria-selected');

        if (i < leadDays) {
          exDay = lastMonthDays - leadDays + 1 + i;
          exMonth = month === 0 ? 11 : month - 1;
          exYear = month === 0 ? year - 1 : year;

          self.setDisabled(th, exYear, exMonth, exDay);
          self.setLegendColor(th, exYear, exMonth, exDay);
          self.dayMap.push({ key: stringUtils.padDate(exYear, exMonth, exDay), elem: th });
          th.addClass('alternate prev-month').html('<span class="day-container"><span aria-hidden="true" class="day-text">' + xssUtils.stripTags(exDay) + '</span></span>');
          th.attr('data-key', stringUtils.padDate(exYear, exMonth, exDay));
        }

        if (i >= leadDays && dayCnt <= thisMonthDays) {
          self.dayMap.push({ key: stringUtils.padDate(year, month, dayCnt), elem: th });
          th.html('<span class="day-container"><span aria-hidden="true" class="day-text">' + xssUtils.stripTags(dayCnt) + '</span></span>');
          th.attr('data-key', stringUtils.padDate(year, month, dayCnt));

          // Add Selected Class to Selected Date
          if (self.isIslamic) {
            if (year === elementDate[0] && month === elementDate[1] && dayCnt === elementDate[2]) {
              th.addClass('is-selected' + (s.range.useRange ? ' range' : '')).attr('aria-selected', 'true').attr('tabindex', '0');
            }
          } else {
            var tHours = elementDate.getHours();
            var tMinutes = elementDate.getMinutes();
            var tSeconds = self.isSeconds ? elementDate.getSeconds() : 0;

            var newDate = new Date(year, month, dayCnt).setHours(tHours, tMinutes, tSeconds, 0);

            if (newDate === elementDate.setHours(tHours, tMinutes, tSeconds, 0)) {
              th.addClass('is-selected' + (s.range.useRange ? ' range' : '')).attr('aria-selected', 'true').attr('tabindex', '0');
            }
          }

          if (dayCnt === self.todayDay && self.currentMonth === self.todayMonth && self.currentYear === self.todayYear) {
            th.addClass('is-today');
          }

          th.attr('aria-label', Locale.formatDate(new Date(self.currentYear, self.currentMonth, dayCnt), {
            date: 'full',
            locale: self.locale.name
          }));
          var startKey = stringUtils.padDate(self.currentYear, self.currentMonth, dayCnt);
          th.attr('data-key', startKey);

          self.setDisabled(th, year, month, dayCnt);
          self.setLegendColor(th, year, month, dayCnt);

          th.attr('role', 'link');
          dayCnt++;
          return;
        }

        if (dayCnt >= thisMonthDays + 1) {
          exDay = nextMonthDayCnt;
          exMonth = month === 11 ? 0 : month + 1;
          exYear = month === 11 ? year + 1 : year;

          self.dayMap.push({ key: stringUtils.padDate(exYear, exMonth, exDay), elem: th });
          self.setDisabled(th, exYear, exMonth, exDay);
          self.setLegendColor(th, exYear, exMonth, exDay);

          th.addClass('alternate next-month').html('<span class="day-container"><span aria-hidden="true" class="day-text">' + nextMonthDayCnt + '</span></span>');
          th.attr('data-key', stringUtils.padDate(exYear, exMonth, exDay));
          nextMonthDayCnt++;
        }
      });

      // Hide 6th Row if all disabled
      var row = this.days.find('tr').eq(5);
      if (row.find('td.alternate').length === 7) {
        row.hide();
      } else {
        row.show();
      }

      if (!this.currentDate) {
        if (this.isIslamic) {
          this.currentIslamicDate = [self.currentYear, self.currentMonth, self.currentDay];
          this.currentDate = this.conversions.toGregorian(self.currentYear, self.currentMonth, self.currentDay);
        } else {
          this.currentDate = new Date(self.currentYear, self.currentMonth, self.currentDay);
        }
      }

      this.setRangeSelection();
      this.validatePrevNext();

      /**
      * Fires as the calendar popup is opened.
      * @event monthrendered
      * @memberof MonthView
      * @property {object} event - The jquery event object
      * @property {object} args - The event arguments
      * @property {number} args.year - The rendered year
      * @property {object} args.elem - The DOM object
      * @property {object} args.api - The MonthView api
      */
      this.element.trigger('monthrendered', { year: year, month: month, elem: this.element, api: this });
    },


    /**
     * Set range selection
     * @private
     * @returns {void}
     */
    setRangeSelection: function setRangeSelection() {
      if (this.settings.range.useRange) {
        var range = {};
        range.date = new Date(this.currentYear, this.currentMonth, 1);
        range.date.setDate(range.date.getDate() - (this.days.find('.prev-month:visible').length + 1));
        range.formatedDate = Locale.formatDate(range.date, { date: 'full', locale: this.locale.name });
        range.cell = this.days.find('[aria-label="' + range.formatedDate + '"]');
        this.setRangeOnCell(this.settings.range.second ? false : range.cell);
      }
    },


    /**
     * Append month year picker
     * @private
     * @param {number} month The month to show in the picker
     * @param {number} year The year to show in the picker
     * @returns {void}
     */
    appendMonthYearPicker: function appendMonthYearPicker(month, year) {
      var self = this;

      if (!this.settings.showMonthYearPicker) {
        return;
      }

      this.header.addClass('is-monthyear');

      var monthDropdown = '' + ('<label for="month-dropdown" class="audible">\n        ' + Locale.translate('Month', { locale: this.locale.name }) + '\n      </label>\n      <select id="month-dropdown" class="dropdown">');

      var wideMonths = this.currentCalendar.months.wide;
      // eslint-disable-next-line
      wideMonths.map(function (monthMap, i) {
        monthDropdown += '<option ' + (i === month ? ' selected ' : '') + ' value="' + i + '">' + monthMap + '</option>';
      });
      monthDropdown += '</select>';

      var monthSpan = this.header.find('.month').empty().append(monthDropdown);
      monthSpan.find('select.dropdown').dropdown().off('change.monthview').on('change.monthview', function () {
        var elem = $(this);
        self.currentMonth = parseInt(elem.val(), 10);
        self.showMonth(self.currentMonth, self.currentYear);
      });

      var yearDropdown = '' + ('<label for="year-dropdown" class="audible">\n        ' + Locale.translate('Year', { locale: this.locale.name }) + '\n      </label>\n      <select id="year-dropdown" class="dropdown year">');

      var years = [];

      for (var i = this.settings.advanceMonths; i >= 1; i--) {
        years.push(parseInt(year, 10) - i);
      }
      years.push(year);
      for (var j = 1; j <= this.settings.advanceMonths; j++) {
        years.push(parseInt(year, 10) + j);
      }

      // eslint-disable-next-line
      years.map(function (yearMap) {
        yearDropdown += '<option ' + (year === yearMap ? ' selected ' : '') + ' value="' + yearMap + '">' + yearMap + '</option>';
      });
      yearDropdown += '</select>';

      var yearSpan = this.header.find('.year').empty().append(yearDropdown);
      yearSpan.find('select.dropdown').dropdown().off('change.datepicker').on('change.datepicker', function () {
        var elem = $(this);
        self.currentYear = parseInt(elem.val(), 10);
        self.showMonth(self.currentMonth, self.currentYear, true);
      });

      if (this.yearFirst) {
        yearSpan.find('.dropdown-wrapper').css('left', '0');
        monthSpan.find('.dropdown-wrapper').css('left', '10px');
      }
    },


    /**
     * Find first day of the week for a given month
     * @private
     * @param {number} year The year to use with the month
     * @param {number} month The month to find the first day for
     * @returns {number} day
     */
    firstDayOfMonth: function firstDayOfMonth(year, month) {
      if (this.isIslamic) {
        var firstDay = this.conversions.toGregorian(year, month, 1);
        return firstDay === null ? 1 : firstDay.getDay();
      }
      return new Date(year, month, 1).getDay();
    },


    /**
     * Find the date of the Month (29, 30, 31 ect)
     * @private
     * @param {number} year The year to use with the month
     * @param {number} month The month to find the days in month for
     * @returns {number} date
     */
    daysInMonth: function daysInMonth(year, month) {
      if (this.isIslamic) {
        var monthLengthBitmap = this.conversions.yearInfo[this.islamicYearIndex(year)][0];
        var monthDayCount = 0;
        for (var M = 0; M <= month; M++) {
          // eslint-disable-next-line
          monthDayCount = 29 + (monthLengthBitmap & 1);
          if (M === month) {
            return monthDayCount;
          }
          // eslint-disable-next-line
          monthLengthBitmap = monthLengthBitmap >> 1;
        }
        return 0;
      }
      return new Date(year, month, 0).getDate();
    },


    /**
     * Get the islamic year index
     * @private
     * @param {number} islamicYear Year to test.
     * @returns {number} index
     */
    islamicYearIndex: function islamicYearIndex(islamicYear) {
      var yearIdx = islamicYear - 1318;
      if (yearIdx < 0 || yearIdx >= this.conversions.yearInfo.length) {
        return 0; // for an out-of-range year, simply returns 0
      }
      return yearIdx;
    },


    /**
     * Set disable Date
     * @private
     * @param {object} elem Node element to set.
     * @param {string} year to check.
     * @param {string} month to check.
     * @param {string} date to check.
     * @returns {void}
     */
    setDisabled: function setDisabled(elem, year, month, date) {
      var s = this.settings;
      var dateIsDisabled = this.isDateDisabled(year, month, date);
      elem.removeClass('is-disabled').removeAttr('aria-disabled');

      if (dateIsDisabled && !s.disable.isEnable || !dateIsDisabled && s.disable.isEnable) {
        elem.addClass('is-disabled').attr('aria-disabled', 'true').removeClass('is-selected range').removeAttr('aria-selected');
      }
    },


    /**
     * Check through the options to see if the date is disabled
     * @private
     * @param {string} year to check.
     * @param {string} month to check.
     * @param {string} date to check.
     * @returns {boolean} true if the date is disabled
     */
    isDateDisabled: function isDateDisabled(year, month, date) {
      var s = this.settings;
      var min = new Date(s.disable.minDate).setHours(0, 0, 0, 0);
      var max = new Date(s.disable.maxDate).setHours(0, 0, 0, 0);
      var d2 = new Date(year, month, date);

      // dayOfWeek
      if (s.disable.dayOfWeek.indexOf(d2.getDay()) !== -1) {
        return true;
      }

      d2 = d2.setHours(0, 0, 0, 0);

      // min and max
      if (d2 <= min || d2 >= max) {
        return true;
      }

      // dates
      if (s.disable.dates.length && typeof s.disable.dates === 'string') {
        s.disable.dates = [s.disable.dates];
      }

      for (var i = 0, l = s.disable.dates.length; i < l; i++) {
        var d = new Date(s.disable.dates[i]);
        if (d2 === d.setHours(0, 0, 0, 0)) {
          return true;
        }
      }

      return false;
    },


    /**
     * Get array of dates between two dates
     * @private
     * @param {object} startDate .
     * @param {object} endDate .
     * @param {boolean} includeDisabled .
     * @returns {array} dates between two dates
     */
    getDateRange: function getDateRange(startDate, endDate, includeDisabled) {
      var dates = [];
      var current = new Date(startDate);

      includeDisabled = typeof includeDisabled !== 'undefined' ? includeDisabled : this.settings.range.includeDisabled;

      while (endDate.getTime() >= current.getTime()) {
        if (includeDisabled || !includeDisabled && !this.isDateDisabled(current.getFullYear(), current.getMonth(), current.getDate())) {
          dates.push(new Date(current));
        }
        current.setDate(current.getDate() + 1);
      }
      return dates;
    },


    /**
     * Set Color for the Legend settings
     * @private
     * @param {object} elem to set.
     * @param {string} year to check.
     * @param {string} month to check.
     * @param {string} date to check.
     * @returns {void}
     */
    setLegendColor: function setLegendColor(elem, year, month, date) {
      if (!this.settings.showLegend || !elem[0]) {
        return;
      }

      var hex = this.getLegendColor(year, month, date);
      var self = this;

      elem[0].style.backgroundColor = '';
      elem.off('mouseenter.legend mouseleave.legend');

      if (hex) {
        // set color on elem at .3 of provided color as per design
        elem.addClass('is-colored');
        elem[0].style.backgroundColor = this.hexToRgba(hex, 0.3);

        var normalColor = self.hexToRgba(hex, 0.3);
        var hoverColor = self.hexToRgba(hex, 0.7);

        // handle hover states
        elem.on('mouseenter.legend', function () {
          var thisElem = $(this);
          thisElem[0].style.backgroundColor = hoverColor;
          thisElem.find('span')[0].style.backgroundColor = 'transparent';
        }).on('mouseleave.legend', function () {
          var thisElem = $(this);
          thisElem[0].style.backgroundColor = normalColor;
          thisElem.find('span')[0].style.backgroundColor = '';
        });
      }
    },


    /**
     * Process Color Options to get the date color
     * @private
     * @param {string} year .
     * @param {string} month .
     * @param {string} date .
     * @returns {string} date color
     */
    /* eslint-disable consistent-return */
    getLegendColor: function getLegendColor(year, month, date) {
      var s = this.settings;
      if (!s.showLegend) {
        return;
      }

      var checkDate = new Date(year, month, date);
      var checkHours = checkDate.setHours(0, 0, 0, 0);

      for (var i = 0; i < s.legend.length; i++) {
        var series = s.legend[i];

        // Check Day of week
        if (series.dayOfWeek && series.dayOfWeek.indexOf(checkDate.getDay()) !== -1) {
          return series.color;
        }

        // Check for dates that match
        if (series.dates) {
          for (var j = 0; j < series.dates.length; j++) {
            var d = new Date(series.dates[j]);
            if (checkHours === d.setHours(0, 0, 0, 0)) {
              return series.color;
            }
          }
        }
      }

      return '';
    },

    /* eslint-enable consistent-return */

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.off('updated.' + COMPONENT_NAME$p).on('updated.' + COMPONENT_NAME$p, function () {
        self.updated();
      });

      // Change Month Events
      this.header.off('click.monthview').on('click.monthview', 'button', function () {
        var isNext = $(this).is('.next');
        var range = {};

        if (self.settings.range.useRange) {
          if (isNext) {
            range.date = new Date(self.currentYear, self.currentMonth + 1, self.element.find('.next-month:visible').length + 1);
          } else {
            range.date = new Date(self.currentYear, self.currentMonth, 1);
            range.date.setDate(range.date.getDate() - (self.days.find('.prev-month:visible').length + 1));
          }
        }

        self.showMonth(self.currentMonth + (isNext ? 1 : -1), self.currentYear);

        if (self.settings.range.useRange) {
          range.formatedDate = Locale.formatDate(range.date, { date: 'full', locale: this.locale.name });
          range.cell = self.days.find('[aria-label="' + range.formatedDate + '"]');
          self.setRangeOnCell(self.settings.range.second ? false : range.cell);
        }
      });

      if (self.settings.range.useRange) {
        this.header.off('mouseover.datepicker').on('mouseover.datepicker', 'button', function () {
          if (self.settings.range.extra) {
            self.setRangeOnCell($(this).is('.next') ? self.settings.range.extra.maxCell : self.settings.range.extra.minCell);
          }
        }).off('focus.datepicker').on('focus.datepicker', 'button:not(.hide-focus)', function () {
          if (self.settings.range.extra) {
            self.setRangeOnCell($(this).is('.next') ? self.settings.range.extra.maxCell : self.settings.range.extra.minCell);
          }
        });

        this.days.off('mouseover.datepicker').on('mouseover.datepicker', 'td', function () {
          self.setRangeOnCell(this);
        });
      }

      if (self.settings.headerStyle === 'full' && this.monthPicker) {
        this.monthPicker.off('change.monthview').on('change.monthview', function () {
          var picker = $(this).data('datepicker');
          self.selectDay(picker.currentDate);
        });

        this.todayLink.off('click.monthview').on('click.monthview', function () {
          self.selectToday();
        });
      }

      // Allow dates to be selected
      if (self.settings.selectable) {
        self.element.addClass('is-selectable').off('click.monthview-day').on('click.monthview-day', 'td', function (e) {
          var key = e.currentTarget.getAttribute('data-key');
          self.lastClickedKey = key;

          if (e.currentTarget.classList.contains('is-disabled')) {
            return;
          }
          self.selectDay(key);
        });
      }

      this.handleKeys();
      return this;
    },


    /**
     * Select a specific date visually.
     * @param {date | string} date specific date or a date key (hash string of the date)
     * @param {boolean} closePopup Send a flag to close the popup
    */
    selectDay: function selectDay(date, closePopup) {
      if (this.isIslamic && typeof date !== 'string') {
        this.currentIslamicDate = this.currentCalendar.conversions.fromGregorian(date);
        date = stringUtils.padDate(this.currentIslamicDate[0], this.currentIslamicDate[1], this.currentIslamicDate[2]);
      }

      if (!this.isIslamic && typeof date !== 'string') {
        date = stringUtils.padDate(date.getFullYear(), date.getMonth(), date.getDate());
      }

      var dayObj = this.dayMap.filter(function (dayFilter) {
        return dayFilter.key === date;
      });
      var year = parseInt(date.substr(0, 4), 10);
      var month = parseInt(date.substr(4, 2), 10) - 1;
      var day = parseInt(date.substr(6, 2), 10);

      if (this.isIslamic) {
        this.currentIslamicDate = date;
        this.currentDate = this.conversions.toGregorian(year, month, day);
      } else {
        this.currentDate = new Date(year, month, day);
      }

      if (dayObj.length === 0 || dayObj[0].elem.hasClass('alternate')) {
        // Show month
        this.showMonth(month, year);
        dayObj = this.dayMap.filter(function (dayFilter) {
          return dayFilter.key === date;
        });
      }

      // Error - date not found
      if (!dayObj.lenth === 0) {
        return;
      }

      var node = dayObj[0].elem[0];

      var args = {
        node: node,
        key: date,
        day: day,
        month: month,
        year: year,
        close: closePopup
      };

      delete this.isKeyClick;
      this.element.find('td.is-selected').removeClass('is-selected').removeAttr('tabindex');
      $(node).addClass('is-selected').attr('tabindex', '0').focus();

      if (this.settings.onSelected) {
        this.settings.onSelected(node, args);
      }
      this.element.trigger('selected', args);
    },


    /**
     * Select todays date visually.
     */
    selectToday: function selectToday() {
      this.selectDay(new Date());
    },


    /**
     * Attach keyboard events for the calendar.
     * @private
     */
    handleKeys: function handleKeys() {
      var _this3 = this;

      var s = this.settings;

      this.element.off('keydown.monthview').on('keydown.monthview', '.monthview-table', function (e) {
        var key = e.keyCode || e.charCode || 0;
        var cell = $(e.target);
        var allCell = _this3.days.find('td:visible');
        var allCellLength = allCell.length;
        var idx = null;
        var selector = null;
        var handled = false;
        var minDate = new Date(s.disable.minDate);
        var maxDate = new Date(s.disable.maxDate);

        // Arrow Down: select same day of the week in the next week
        if (key === 40) {
          handled = true;
          if (_this3.settings.range.useRange) {
            idx = allCell.index(e.target) + 7;
            selector = allCell.eq(idx);
            if (idx < allCellLength) {
              _this3.setRangeOnCell(selector.is('.is-selected') ? null : selector);
              _this3.activeTabindex(selector, true);
            }
          } else if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (_this3.currentDate.getMonth() < maxDate.getMonth()) {
              _this3.currentDate.setDate(_this3.currentDate.getDate() + 7);
            } else if (maxDate.getDate() - 1 >= _this3.currentDate.getDate() + 7) {
              _this3.currentDate.setDate(_this3.currentDate.getDate() + 7);
            }
            _this3.selectDay(_this3.currentDate);
          } else {
            _this3.currentDate.setDate(_this3.currentDate.getDate() + 7);
            _this3.selectDay(_this3.currentDate);
          }
        }

        // Arrow Up: select same day of the week in the previous week
        if (key === 38) {
          handled = true;
          if (s.range.useRange) {
            idx = allCell.index(e.target) - 7;
            selector = allCell.eq(idx);
            if (idx > -1) {
              _this3.setRangeOnCell(selector.is('.is-selected') ? null : selector);
              _this3.activeTabindex(selector, true);
            }
          } else if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (_this3.currentDate.getMonth() > minDate.getMonth()) {
              _this3.currentDate.setDate(_this3.currentDate.getDate() - 7);
            } else if (minDate.getDate() + 1 <= _this3.currentDate.getDate() - 7) {
              _this3.currentDate.setDate(_this3.currentDate.getDate() - 7);
            }
            _this3.selectDay(_this3.currentDate);
          } else {
            _this3.currentDate.setDate(_this3.currentDate.getDate() - 7);
            _this3.selectDay(_this3.currentDate);
          }
        }

        // Arrow Left
        if (key === 37) {
          handled = true;
          if (s.range.useRange) {
            idx = allCell.index(e.target) - 1;
            selector = allCell.eq(idx);
            if (idx > -1) {
              _this3.setRangeOnCell(selector.is('.is-selected') ? null : selector);
              _this3.activeTabindex(selector, true);
            }
          } else if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (_this3.currentDate.getMonth() > minDate.getMonth()) {
              _this3.currentDate.setDate(_this3.currentDate.getDate() - 1);
            } else if (minDate.getDate() + 1 !== _this3.currentDate.getDate()) {
              _this3.currentDate.setDate(_this3.currentDate.getDate() - 1);
            }
            _this3.selectDay(_this3.currentDate);
          } else {
            _this3.currentDate.setDate(_this3.currentDate.getDate() - 1);
            _this3.selectDay(_this3.currentDate);
          }
        }

        // Arrow Right
        if (key === 39) {
          handled = true;
          if (s.range.useRange) {
            idx = allCell.index(e.target) + 1;
            selector = allCell.eq(idx);
            if (idx < allCellLength) {
              _this3.setRangeOnCell(selector.is('.is-selected') ? null : selector);
              _this3.activeTabindex(selector, true);
            }
          } else if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (_this3.currentDate.getMonth() < maxDate.getMonth()) {
              _this3.currentDate.setDate(_this3.currentDate.getDate() + 1);
            } else if (maxDate.getDate() - 1 !== _this3.currentDate.getDate()) {
              _this3.currentDate.setDate(_this3.currentDate.getDate() + 1);
            }
            _this3.selectDay(_this3.currentDate);
          } else {
            _this3.currentDate.setDate(_this3.currentDate.getDate() + 1);
            _this3.selectDay(_this3.currentDate);
          }
        }

        // Page Up Selects Same Day Prev Month
        if (key === 33 && !e.altKey) {
          handled = true;
          if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (minDate.getMonth() !== _this3.currentDate.getMonth()) {
              _this3.currentDate.setMonth(_this3.currentDate.getMonth() - 1);
              _this3.selectDay(_this3.currentDate);
            }
          } else {
            _this3.currentDate.setMonth(_this3.currentDate.getMonth() - 1);
            _this3.selectDay(_this3.currentDate);
          }
        }

        // Page Down Selects Same Day Next Month
        if (key === 34 && !e.altKey) {
          handled = true;
          if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (_this3.currentDate.getMonth() !== maxDate.getMonth()) {
              _this3.currentDate.setMonth(_this3.currentDate.getMonth() + 1);
              _this3.selectDay(_this3.currentDate);
            }
          } else {
            _this3.currentDate.setMonth(_this3.currentDate.getMonth() + 1);
            _this3.selectDay(_this3.currentDate);
          }
        }

        // ctrl + Page Up Selects Same Day previous Year
        if (key === 33 && e.ctrlKey) {
          handled = true;
          _this3.currentDate.setFullYear(_this3.currentDate.getFullYear() - 1);
          _this3.selectDay(_this3.currentDate);
        }

        // ctrl + Page Down Selects Same Day next Year
        if (key === 34 && e.ctrlKey) {
          handled = true;
          _this3.currentDate.setFullYear(_this3.currentDate.getFullYear() + 1);
          _this3.selectDay(_this3.currentDate);
        }

        // Home Moves to Start of the month
        if (key === 36) {
          handled = true;
          var d = _this3.currentDate;
          var firstDay = void 0;

          if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (minDate.getMonth() !== _this3.currentDate.getMonth()) {
              firstDay = new Date(d.getFullYear(), d.getMonth(), 1);
            } else {
              firstDay = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
              firstDay.setDate(firstDay.getDate() + 1);
            }
          } else {
            firstDay = new Date(d.getFullYear(), d.getMonth(), 1);
          }

          _this3.currentDate = firstDay;
          if (_this3.isIslamic) {
            _this3.currentIslamicDate = _this3.conversions.fromGregorian(_this3.currentDate);
          }
          _this3.selectDay(_this3.currentDate);
        }

        // End Moves to End of the month
        if (key === 35) {
          handled = true;
          var _d = _this3.currentDate;
          var lastDay = void 0;
          if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (_this3.currentDate.getMonth() !== maxDate.getMonth()) {
              lastDay = new Date(_d.getFullYear(), _d.getMonth() + 1, 0);
            } else {
              lastDay = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate());
              lastDay.setDate(lastDay.getDate() - 1);
            }
          } else {
            lastDay = new Date(_d.getFullYear(), _d.getMonth() + 1, 0);
          }

          _this3.currentDate = lastDay;
          if (_this3.isIslamic) {
            _this3.currentIslamicDate = _this3.conversions.fromGregorian(_this3.currentDate);
          }
          _this3.selectDay(_this3.currentDate);
        }

        // 't' selects today
        if (key === 84) {
          _this3.selectToday();
          handled = true;
        }

        // Space or Enter closes Date Picker, selecting the Date
        if (key === 32 || key === 13) {
          handled = true;
          if (s.range.useRange) {
            if (!s.range.first || s.range.first && !s.range.first.date) {
              allCell.removeClass('is-selected');
            }
            cell.focus().trigger('click');
            return false;
          }
          var _d2 = _this3.getCellDate(cell);

          if (_this3.isIslamic) {
            _this3.currentIslamicDate = [_d2.year, _d2.month, _d2.day];
            _this3.currentDate = _this3.conversions.toGregorian(_this3.currentIslamicDate[0], _this3.currentIslamicDate[1], _this3.currentIslamicDate[2]);
          } else {
            _this3.currentDate = new Date(_d2.year, _d2.month, _d2.day);
          }

          _this3.selectDay(_this3.currentDate, true);
        }

        if (handled) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }
        return true;
      });
    },


    /**
     * Validate the Previous and Next Button availability.
     * @private
     */
    validatePrevNext: function validatePrevNext() {
      if (!this.settings.disable.restrictMonths || !this.settings.disable.minDate || !this.settings.disable.maxDate) {
        return;
      }
      var minDate = new Date(this.settings.disable.minDate);
      var maxDate = new Date(this.settings.disable.maxDate);

      this.element.find('.prev').prop('disabled', false);
      this.element.find('.next').prop('disabled', false);

      // Wierd edge case, the user probably should use validation.
      if (minDate.getFullYear() > this.currentYear || this.currentYear > maxDate.getFullYear()) {
        this.element.find('.prev').prop('disabled', true);
        this.element.find('.next').prop('disabled', true);
        return;
      }

      if (this.currentMonth - 1 < minDate.getMonth()) {
        this.element.find('.prev').prop('disabled', true);
      }

      if (this.currentMonth + 1 > maxDate.getMonth()) {
        this.element.find('.next').prop('disabled', true);
      }
    },


    /**
     * Add a Legend below the table
     * @private
     * @returns {void}
     */
    addLegend: function addLegend() {
      var s = this.settings;
      if (!s.showLegend) {
        return;
      }

      // Remove Legend
      if (this.legend && this.legend.length) {
        this.legend.remove();
      }

      this.legend = $('<div class="monthview-legend"></div>');

      for (var i = 0; i < s.legend.length; i++) {
        var series = s.legend[i];
        var item = '' + ('<div class="monthview-legend-item">\n          <span class="monthview-legend-swatch" style="background-color: ' + this.hexToRgba(series.color, 0.3) + '"></span>\n          <span class="monthview-legend-text">' + series.name + '</span>\n        </div>');

        this.legend.append(item);
      }
      this.table.after(this.legend);
    },


    /**
     * Convert the provided hex to an RGBA for states
     * This may be later moved into a colors file along with getLuminousColorShade
     * @private
     * @param {string} hex to set.
     * @param {string} opacity to check.
     * @returns {string} converted rgba
     */
    hexToRgba: function hexToRgba(hex, opacity) {
      var c = void 0;
      if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
        c = hex.substring(1).split('');

        if (c.length === 3) {
          c = [c[0], c[0], c[1], c[1], c[2], c[2]];
        }

        c = '0x' + c.join('');
        // eslint-disable-next-line
        return 'rgba(' + [c >> 16 & 255, c >> 8 & 255, c & 255].join(',') + ',' + opacity.toString() + ')';
      }
      return '';
    },


    /**
     * Set range on given cell -or- current month/year.
     * @private
     * @param {object} cell to set range.
     * @returns {void}
     */
    setRangeOnCell: function setRangeOnCell(cell) {
      var self = this;
      var s = this.settings;

      if (s.range.useRange && s.range.first && !s.range.second) {
        var first = s.range.first;
        var extra = s.range.extra;
        var len = extra.cellLength - 1;
        var firstCell = first.rowIdx + first.cellIdx + len * first.rowIdx;
        cell = $(cell); // First date selected cell element

        if (cell.length && !cell.is('.is-disabled, .is-selected')) {
          var row = cell.closest('tr');
          var cellIdx = cell.index();
          var rowIdx = row.index();
          var thisCell = rowIdx + cellIdx + len * rowIdx;
          var d = self.getCellDate(cell);
          var cellDate = new Date(d.year, d.month, d.day);
          var max = this.getDifferenceToDate(s.range.first.date, s.range.maxDays);

          self.days.find('td:visible').each(function (i) {
            var thisTd = $(this);
            if (cellDate > s.range.first.date && !s.range.selectBackward && (!s.range.maxDays || s.range.maxDays > 0 && cellDate.getTime() <= max.aftertime) && (i > firstCell && i <= thisCell || cellDate > extra.max && i <= thisCell)) {
              thisTd.addClass('range-next');
            } else if (cellDate < s.range.first.date && !s.range.selectForward && (!s.range.maxDays || s.range.maxDays > 0 && cellDate.getTime() >= max.beforetime) && (i < firstCell && i >= thisCell || cellDate < extra.min && i >= thisCell)) {
              thisTd.addClass('range-prev');
            } else {
              thisTd.removeClass('range-next range-prev');
            }
          });
        } else if (!cell.length) {
          self.days.find('td').removeClass('range-next range-prev');
        }
      }
      if (!cell && s.range.second) {
        self.setRangeSelected();
      }
    },


    /**
     * Get difference to given date
     * @private
     * @param {object} date .
     * @param {number} days .
     * @param {boolean} includeDisabled .
     * @returns {object} before/after difference to given date
     */
    getDifferenceToDate: function getDifferenceToDate(date, days, includeDisabled) {
      var _this4 = this;

      var difference = {};
      var move = function move(d, daystomove, isNext) {
        d = new Date(d);
        while (daystomove > 0) {
          d.setDate(d.getDate() + (isNext ? 1 : -1));
          if (includeDisabled || !includeDisabled && !_this4.isDateDisabled(d.getFullYear(), d.getMonth(), d.getDate())) {
            daystomove--;
            difference[isNext ? 'after' : 'before'] = new Date(d);
          }
        }
        if (isNext && difference.after) {
          difference.aftertime = difference.after.getTime();
        } else if (difference.before) {
          difference.beforetime = difference.before.getTime();
        }
      };
      includeDisabled = typeof includeDisabled !== 'undefined' ? includeDisabled : this.settings.range.includeDisabled;
      move(date, days); // previous
      move(date, days, true); // next
      return difference;
    },


    /**
     * Set range selected value
     * @private
     * @returns {void}
     */
    setRangeSelected: function setRangeSelected() {
      var self = this;
      var s = this.settings;
      var dateObj = function dateObj(d) {
        return new Date(d.year, d.month, d.day);
      };

      if (s.range.useRange && s.range.second && s.range.second.date && this.days && this.days.length) {
        this.days.find('td').removeClass('range range-next range-prev range-selection end-date is-selected');
        this.days.find('td:visible').each(function () {
          var cell = $(this);
          var isDisabled = cell.is('.is-disabled') && !s.range.includeDisabled;
          var includeDisabled = cell.is('.is-disabled') && s.range.includeDisabled;
          var includeDisableClass = includeDisabled ? ' include-disabled' : '';
          var getTime = function getTime(d) {
            d = new Date(d);
            d.setHours(0, 0, 0);
            return d.getTime();
          };
          var date = getTime(dateObj(self.getCellDate(cell)));
          var d1 = getTime(s.range.first.date);
          var d2 = getTime(s.range.second.date);

          if ((date === d1 || date === d2) && !isDisabled) {
            cell.addClass('is-selected' + includeDisableClass + (d1 !== d2 ? ' range-selection' + (date === d2 ? ' end-date' : '') : ''));
          } else if (date > d1 && date < d2 && !isDisabled) {
            cell.addClass('range-selection' + includeDisableClass);
          }
        });
      }
    },


    /**
     * Get date from given cell.
     * @private
     * @param {object} cell to get date.
     * @returns {object} as: year, month, day
     */
    getCellDate: function getCellDate(cell) {
      var s = this.settings;
      var day = parseInt(cell.text(), 10);
      var month = parseInt(this.header.find('.month').attr('data-month'), 10);
      var year = parseInt(this.header.find('.year').text(), 10);

      if (s.showMonthYearPicker) {
        year = parseInt(this.header.find('.year select').val(), 10);
        month = parseInt(this.header.find('.month select').val(), 10);
      }

      if (cell.hasClass('prev-month')) {
        if (month === 0) {
          month = 11;
          year--;
        } else {
          month--;
        }
      } else if (cell.hasClass('next-month')) {
        if (month === 11) {
          month = 0;
          year++;
        } else {
          month++;
        }
      }

      return { year: year, month: month, day: day };
    },


    /**
     * Check if file type allowed
     * @private
     * @param {object} elem to set fouus
     * @param {boolean} isFocus true if need to set foucs
     * @returns {object} element passed in
     */
    activeTabindex: function activeTabindex(elem, isFocus) {
      $('td', this.element).removeAttr('tabindex');
      elem.attr('tabindex', 0);

      if (isFocus) {
        elem.focus();
      }
      return elem;
    },


    /**
     * Handle updated settings and values.
     * @returns {object} [description]
     */
    updated: function updated() {
      return this.destroy().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.header.off();
      this.days.off();
      this.element.off('updated.' + COMPONENT_NAME$p);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @private
     * @returns {object} The prototype.
     */
    destroy: function destroy() {
      this.teardown();
      this.element.empty();
      this.element.off('keydown.monthview');
      $.removeData(this.element[0], COMPONENT_NAME$p);
      return this;
    }
  };

  /* eslint-disable no-nested-ternary */

  // Settings and Options
  var COMPONENT_NAME$q = 'calendar';

  var COMPONENT_NAME_DEFAULTS$1 = {
    eventTypes: [{ id: 'example', label: 'Example', color: 'emerald07', checked: true, click: function click() {} }],
    events: [],
    locale: null,
    month: new Date().getMonth(),
    year: new Date().getFullYear(),
    showViewChanger: true,
    onRenderMonth: null,
    template: null,
    upcomingEventDays: 14,
    modalTemplate: null,
    menuId: null,
    menuSelected: null,
    newEventDefaults: {
      title: 'NewEvent',
      subject: '',
      isAllDay: true,
      comments: ''
    }
  };

  /**
   * Calendar - Full eventing calendar.
   * @class Calendar
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {array} [settings.eventTypes] An array of objects with data for the event types.
   * @param {array} [settings.events] An array of objects with data for the events.
   * @param {string} [settings.locale] The name of the locale to use for this instance. If not set the current locale will be used.
   * @param {array} [settings.month] Initial month to show.
   * @param {array} [settings.year] Initial year to show.
   * @param {array} [settings.upcomingEventDays=14] How many days in advance should we show in the upcoming events pane.
   * @param {boolean} [settings.showViewChanger] If false the dropdown to change views will not be shown.
   * @param {function} [settings.onRenderMonth] Fires when a month is rendered, allowing you to pass back events or event types to show.
   * @param {function} [settings.onSelected] Fires when a month day is clicked. Allowing you to do something.
   * @param {string} [settings.template] The ID of the template used for the events.
   * @param {string} [settings.modalTemplate] The ID of the template used for the modal dialog on events.
   * @param {string} [settings.menuId=null] ID of the menu to use for an event right click context menu
   * @param {string} [settings.menuSelected=null] Callback for the  right click context menu
   * @param {string} [settings.newEventDefaults] Initial event properties for the new events dialog.
   */
  function Calendar(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COMPONENT_NAME_DEFAULTS$1);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Calendar.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @returns {object} The Component prototype, useful for chaining.
     */
    init: function init() {
      return this.build();
    },


    /**
     * Add any needed markup to the component.
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    build: function build() {
      this.setLocale();
      if (this.rendered || this.settings.locale && (!this.locale || this.locale.name !== this.settings.locale)) {
        this.rendered = false;
        return this;
      }

      this.rendered = true;
      this.setCurrentCalendar().renderEventTypes().renderMonth().renderViewChanger().handleEvents();

      return this;
    },


    /**
     * Set current locale to be used.
     * @private
     * @returns {void}
     */
    setLocale: function setLocale() {
      var _this = this;

      if (this.settings.locale && (!this.locale || this.locale.name !== this.settings.locale)) {
        Locale.getLocale(this.settings.locale).done(function (locale) {
          _this.locale = Locale.cultures[locale];
          _this.setCurrentCalendar();
          _this.build();
        });
      } else if (!this.settings.locale) {
        this.locale = Locale.currentLocale;
      }
      return this;
    },


    /**
     * Set current calendar data to to be used.
     * @private
     * @returns {void}
     */
    setCurrentCalendar: function setCurrentCalendar() {
      this.isRTL = this.locale.direction === 'right-to-left';
      return this;
    },


    /**
     * Render the eventType Section
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    renderEventTypes: function renderEventTypes() {
      this.eventTypeContainer = document.querySelector('.calendar-event-types');
      if (!this.eventTypeContainer) {
        return false;
      }

      var eventTypeMarkup = '';
      for (var i = 0; i < this.settings.eventTypes.length; i++) {
        var eventType = this.settings.eventTypes[i];
        eventTypeMarkup += '<input type="checkbox" class="checkbox ' + eventType.color + '07" name="' + eventType.id + '" id="' + eventType.id + '" checked="' + (eventType.checked ? 'true' : 'false') + '" ' + (eventType.disabled ? 'disabled="true"' : '') + ' />\n        <label for="' + eventType.id + '" class="checkbox-label">' + (eventType.translationKey ? Locale.translate(eventType.translationKey, { locale: this.locale.name }) : eventType.label) + '</label><br/>';
      }
      this.eventTypeContainer.innerHTML = eventTypeMarkup;
      this.element.initialize();
      return this;
    },


    /**
     * Render the monthview calendar
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    renderMonth: function renderMonth() {
      this.monthViewContainer = document.querySelector('.calendar .calendar-monthview');

      this.monthView = new MonthView(this.monthViewContainer, {
        onRenderMonth: this.settings.onRenderMonth,
        onSelected: this.settings.onSelected,
        selectable: true,
        locale: this.settings.locale,
        month: this.settings.month,
        year: this.settings.year
      });
      this.monthViewHeader = document.querySelector('.calendar .monthview-header');
      this.renderAllEvents();
      return this;
    },


    /**
     * Render the upcoming events view
     * @param {object} event The Calendar event to show.
     * @private
     */
    appendUpcomingEvent: function appendUpcomingEvent(event) {
      this.upcomingEventsContainer = document.querySelector('.calendar-upcoming-events');
      if (!this.upcomingEventsContainer || event.daysUntil > 0) {
        return;
      }

      var daysUntil = Math.abs(event.daysUntil);
      if (daysUntil < 0 || daysUntil > this.settings.upcomingEventDays) {
        return;
      }

      var upcomingEvent = document.createElement('a');
      upcomingEvent.setAttribute('href', '#');
      upcomingEvent.setAttribute('data-key', event.startKey);
      DOM.addClass(upcomingEvent, 'calendar-upcoming-event');

      var upcomingEventsMarkup = '';
      var startDay = Locale.formatDate(event.starts, { pattern: 'd', locale: this.locale.name });
      var endDay = Locale.formatDate(event.ends, { pattern: 'd', locale: this.locale.name });
      var dateRange = Locale.formatDate(event.starts, { pattern: 'MMMM', locale: this.locale.name }) + ' ' + (startDay === endDay ? startDay : startDay + '-' + endDay) + ', ' + Locale.formatDate(event.starts, { pattern: 'yyyy', locale: this.locale.name });

      if (parseInt(endDay, 10) < parseInt(startDay, 10)) {
        var nextMonth = new Date(event.starts);
        nextMonth.setDate(1);
        nextMonth.setMonth(nextMonth.getMonth() + 1);
        var endYear = nextMonth.getFullYear();
        dateRange = Locale.formatDate(event.starts, { pattern: 'MMMM', locale: this.locale.name }) + ' ' + startDay + ' - ' + Locale.formatDate(nextMonth, { pattern: 'MMMM', locale: this.locale.name }) + ' ' + endDay + ', ' + endYear;
      }

      upcomingEventsMarkup += '\n      <span class="calendar-upcoming-date">' + dateRange + '</span>\n      <span class="calendar-upcoming-event-color ' + (event.color || '') + '">' + (event.color || '') + '</span>\n      <span class="calendar-upcoming-description">' + (event.subject || '') + '</span>\n      <span class="calendar-upcoming-status-text">' + (event.status || '') + '</span>\n      <span class="calendar-upcoming-duration">' + (event.isDays ? event.duration : event.durationHours) + ' ' + (event.durationUnits || '') + '</span>';
      upcomingEvent.innerHTML = upcomingEventsMarkup;
      this.upcomingEventsContainer.appendChild(upcomingEvent);
    },


    /**
     * Render the dropdown to change views.
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    renderViewChanger: function renderViewChanger() {
      if (!this.settings.showViewChanger) {
        return this;
      }
      var viewChangerHtml = '<label for="calendar-view-changer" class="label audible">' + Locale.translate('ChangeView', { locale: this.locale.name }) + '</label>\n      <select id="calendar-view-changer" name="calendar-view-changer" class="dropdown">\n        <option value="month" selected>' + Locale.translate('Month', { locale: this.locale.name }) + '</option>\n        <option value="week" disabled>' + Locale.translate('Week', { locale: this.locale.name }) + '</option>\n        <option value="day" disabled>' + Locale.translate('Day', { locale: this.locale.name }) + '</option>\n        <option value="schedule" disabled>' + Locale.translate('Schedule', { locale: this.locale.name }) + '</option>\n      </select>\n    </div>';
      $(this.monthViewHeader).append(viewChangerHtml);
      this.viewChangerHtml = $('#calendar-view-changer');
      this.viewChangerHtml.dropdown();
      return this;
    },


    /**
     * Render or re-render the events details section, using on the readonly or default eventTemplate
     * @param {string} eventId The event id
     * @param {number} count The event count
     * @private
     */
    renderEventDetails: function renderEventDetails(eventId, count) {
      if (!this.settings.events) {
        return;
      }

      // Find the event data
      var eventData = this.settings.events.filter(function (event) {
        return event.id === eventId;
      });
      if (!eventData || eventData.length === 0) {
        return;
      }

      this.eventDetailsContainer = document.querySelector('.calendar-event-details');
      this.renderTmpl(eventData[0], this.settings.template, this.eventDetailsContainer, count > 1);

      var api = $(this.eventDetailsContainer).data('accordion');
      if (api) {
        api.destroy();
      }
      $(this.eventDetailsContainer).accordion();

      if (DOM.hasClass(this.eventDetailsContainer, 'has-only-one')) {
        $(this.eventDetailsContainer).find('.accordion-header, .accordion-header a').off('click');
      }
    },


    /**
     * Render each of the events for the currently selected node
     * @private
     */
    renderSelectedEventDetails: function renderSelectedEventDetails() {
      var dayObj = this.getDayEvents();
      this.clearEventDetails();
      if (!dayObj.events || dayObj.events.length === 0) {
        return;
      }

      for (var i = 0; i < dayObj.events.length; i++) {
        this.renderEventDetails(dayObj.events[i].id, dayObj.events.length);
      }
    },


    /**
     * Clear all contents from the event details area.
     * @private
     */
    clearEventDetails: function clearEventDetails() {
      this.eventDetailsContainer = document.querySelector('.calendar-event-details');
      if (this.eventDetailsContainer) {
        this.eventDetailsContainer.innerHTML = '';
      }
    },


    /**
     * Clear all contents from the upcoming events area.
     * @private
     */
    clearUpcomingEvents: function clearUpcomingEvents() {
      if (this.upcomingEventsContainer) {
        this.upcomingEventsContainer.innerHTML = '';
      }
    },


    /**
     * Get the currently unchecked filter types
     * @returns {array} The active types.
     * @private
     */
    filterEventTypes: function filterEventTypes() {
      var checkboxes = this.eventTypeContainer.querySelectorAll('.checkbox');
      var types = [];

      for (var i = 0; i < checkboxes.length; i++) {
        var input = checkboxes[i];
        if (!input.checked) {
          types.push(input.getAttribute('id'));
        }
      }
      return types;
    },


    /**
     * Get the difference between two dates.
     * @private
     * @param {date} first The first date.
     * @param {date} second The second date.
     * @param {boolean} useHours The different in hours if true, otherways days.
     * @param {boolean} isFullDay Add an hour to include the full day to match the calendar.
     * @returns {number} The difference between the two dates.
     */
    dateDiff: function dateDiff(first, second, useHours, isFullDay) {
      // Take the difference between the dates and divide by milliseconds per day.
      // Round to nearest whole number to deal with DST.
      var diff = Math.round((second - first) / (1000 * 60 * 60 * (useHours ? 1 : 24)));
      if (isFullDay) {
        diff += 1;
      }
      return diff;
    },


    /**
     * Render/ReRender the events attached to the settings.
     * @param {boolean} isCallback Will be set to true when a callback occurs
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    renderAllEvents: function renderAllEvents(isCallback) {
      if (this.settings.onRenderMonth && !isCallback) {
        this.callOnRenderMonth();
        return this;
      }

      var self = this;
      var filters = this.filterEventTypes();

      // Cleanup from previous renders
      this.removeAllEvents();
      this.clearUpcomingEvents();
      this.clearEventDetails();

      // Clone and sort the array.
      var eventsSorted = this.settings.events.slice(0);
      eventsSorted.sort(function (a, b) {
        return a.starts < b.starts ? -1 : a.starts > b.starts ? 1 : 0;
      });

      for (var i = 0; i < eventsSorted.length; i++) {
        var event = eventsSorted[i];
        if (filters.indexOf(event.type) > -1) {
          continue;
        }
        self.renderEvent(event);
      }

      this.renderSelectedEventDetails();
      return this;
    },


    /**
     * Render a single event on the ui, use in the loop and other functions.
     * @param  {object} event The event object.
     */
    renderEvent: function renderEvent(event) {
      var self = this;

      // Check for events starting on this day , or only on this day.
      var startDate = new Date(event.starts);
      var startKey = stringUtils.padDate(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());

      // Check for events extending onto this day
      var endDate = new Date(event.ends);
      var endKey = stringUtils.padDate(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());

      var days = self.monthView.dayMap.filter(function (day) {
        return day.key >= startKey && day.key <= endKey;
      });
      event.endKey = endKey;
      event.startKey = startKey;
      event = this.addCalculatedFields(event);
      // const idx = self.monthView.dayMap.findIndex(day => day.key >= startKey && day.key <= endKey);
      var idx = -1;
      for (var i = 0; i < self.monthView.dayMap.length; ++i) {
        if (self.monthView.dayMap[i].key >= startKey && self.monthView.dayMap[i].key <= endKey) {
          idx = i;
          break;
        }
      }

      // Event is only on this day
      if (days.length === 1) {
        self.appendEvent(days[0].elem[0], event, 'event-day-start-end', idx);
      }

      // Event extends multiple days
      if (days.length > 1) {
        for (var l = 0; l < days.length; l++) {
          var cssClass = l === 0 ? 'event-day-start' : 'event-day-span';

          if (days.length - 1 === l) {
            cssClass = 'event-day-end';
          }
          self.appendEvent(days[l].elem[0], event, cssClass, idx + l);
        }
      }

      // Event extends multiple days
      this.appendUpcomingEvent(event, days, idx);
    },


    /**
     * Remove all events from the month.
     */
    removeAllEvents: function removeAllEvents() {
      var moreEvents = this.monthViewContainer.querySelectorAll('.calendar-event-more');
      for (var i = 0; i < moreEvents.length; i++) {
        moreEvents[i].parentNode.removeChild(moreEvents[i]);
      }

      var calendarEvents = this.monthViewContainer.querySelectorAll('.calendar-event');
      for (var _i = 0; _i < calendarEvents.length; _i++) {
        calendarEvents[_i].parentNode.removeChild(calendarEvents[_i]);
      }

      for (var _i2 = 0; _i2 < this.monthView.dayMap.length; _i2++) {
        this.monthView.dayMap[_i2].events = [];
      }
    },


    /**
     * Add calculated fields to the event object.
     * @private
     * @param {object} event The starting event object
     * @returns {object} The event object with stuff added.
     */
    addCalculatedFields: function addCalculatedFields(event) {
      event.color = this.getEventTypeColor(event.type);
      event.duration = Math.abs(this.dateDiff(new Date(event.ends), new Date(event.starts), false, event.isFullDay));
      event.durationUnits = event.duration > 1 ? Locale.translate('Days', { locale: this.locale.name }) : Locale.translate('Day', { locale: this.locale.name });
      event.daysUntil = event.starts ? this.dateDiff(new Date(event.starts), new Date()) : 0;
      event.durationHours = this.dateDiff(new Date(event.starts), new Date(event.ends), true);
      event.isDays = true;
      if (event.isAllDay === undefined) {
        event.isAllDay = true;
      }

      if (event.durationHours < 24) {
        event.isDays = false;
        event.isAllDay = false;
        delete event.duration;
        event.durationUnits = event.durationHours > 1 ? Locale.translate('Hours', { locale: this.locale.name }) : Locale.translate('Hour', { locale: this.locale.name });
      }
      if (event.isAllDay.toString() === 'true') {
        event.isDays = true;
        delete event.durationHours;
        event.durationUnits = event.duration > 1 ? Locale.translate('Days', { locale: this.locale.name }) : Locale.translate('Day', { locale: this.locale.name });
        event.duration = this.dateDiff(new Date(event.starts), new Date(event.ends));
      }
      if (event.duration === 0 && event.isAllDay.toString() === 'true') {
        event.isDays = true;
        event.duration = 1;
        event.durationUnits = Locale.translate('Day', { locale: this.locale.name });
      }
      if (event.starts) {
        var startsLocale = Locale.parseDate(event.starts, { pattern: 'yyyy-MM-ddTHH:mm:ss.SSS', locale: this.locale.name });
        event.startsLocale = Locale.formatDate(startsLocale, { locale: this.locale.name });
      }
      if (event.ends) {
        var endsLocale = Locale.parseDate(event.ends, { pattern: 'yyyy-MM-ddTHH:mm:ss.SSS', locale: this.locale.name });
        event.endsLocale = Locale.formatDate(endsLocale, { locale: this.locale.name });
      }
      event.eventTypes = this.settings.eventTypes;
      event.isAllDay = event.isAllDay.toString();
      if (event.isAllDay.toString() === 'false') {
        delete event.isAllDay;
      }
      return event;
    },


    /**
     * Add the ui event to the container.
     * @private
     * @param {object} container The container to append to
     * @param {object} event The event data object.
     * @param {string} type Type of event, can be event-day-start, event-day-start-end, event-day-span, event-day-end
     * @param {number} idx The dayMap index
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    appendEvent: function appendEvent(container, event, type, idx) {
      var _this2 = this;

      var node = void 0;
      var eventCnt = container.querySelectorAll('.calendar-event').length;

      if (idx > -1) {
        if (!this.monthView.dayMap[idx].events) {
          this.monthView.dayMap[idx].events = [];
        }
        this.monthView.dayMap[idx].events.push(event);
      }

      if (eventCnt >= 2) {
        var moreSpan = container.querySelector('.calendar-event-more');
        var moreText = Locale.translate('More', { locale: this.locale.name }).replace('...', '');
        if (!moreSpan) {
          node = document.createElement('span');
          DOM.addClass(node, 'calendar-event-more');
          node.innerHTML = '+ 1 ' + moreText;
          node.setAttribute('data-count', 1);
          container.querySelector('.day-container').appendChild(node);
        } else {
          var cnt = moreSpan.getAttribute('data-count');
          cnt++;
          moreSpan.setAttribute('data-count', cnt);
          moreSpan.innerHTML = '+ ' + cnt + ' ' + moreText;
        }

        return this;
      }

      node = document.createElement('a');
      DOM.addClass(node, 'calendar-event', event.color, type);
      node.setAttribute('data-id', event.id);
      node.setAttribute('data-key', event.startKey);

      node.innerHTML = '<div class="calendar-event-content">\n      ' + (event.icon ? '<span class="calendar-event-icon"><svg class="icon ' + event.icon + '" focusable="false" aria-hidden="true" role="presentation" data-status="' + event.status + '"><use xlink:href="#' + event.icon + '"></use></svg></span>' : '') + '\n      <span class="calendar-event-title">' + (event.shortSubject || event.subject) + '</span>\n    </div>';
      container.querySelector('.day-container').appendChild(node);

      // Show the full text if cut off
      if (!event.shortSubject) {
        node.setAttribute('title', event.subject);
        $(node).tooltip({
          beforeShow: function beforeShow(response, ui) {
            var title = ui[0].querySelector('.calendar-event-title');
            var icon = ui[0].querySelector('.calendar-event-icon');
            var iconStatus = icon ? icon.querySelector('.icon').getAttribute('data-status') : '';

            if (title.offsetWidth > ui[0].scrollWidth - (icon ? icon.offsetWidth : 0)) {
              response('' + title.innerText + (iconStatus ? ' (' + Locale.translate(iconStatus, { locale: _this2.locale.name }, false) + ')' : ''));
              return;
            }
            response(false);
          }
        });
      }

      return this;
    },


    /**
     * Find the matching type and get the color.
     * @param {object} id The eventType id to find.
     * @param {object} event The event data object.
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    getEventTypeColor: function getEventTypeColor(id) {
      var color = 'azure';
      if (!id) {
        return color;
      }

      var eventInfo = this.settings.eventTypes.filter(function (eventType) {
        return eventType.id === id;
      });
      if (eventInfo.length === 1) {
        color = eventInfo[0].color || 'azure';
      }
      return color;
    },


    /**
     * Find the matching type and get the color.
     * @param {object} id The eventType id to find.
     * @param {object} event The event data object.
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    getEventTypeLabel: function getEventTypeLabel(id) {
      var type = '';
      if (!id) {
        return type;
      }

      var eventInfo = this.settings.eventTypes.filter(function (eventType) {
        return eventType.id === id;
      });
      if (eventInfo.length === 1) {
        type = eventInfo[0].label;
      }
      return type;
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this3 = this;

      var self = this;

      this.element.off('updated.' + COMPONENT_NAME$q).on('updated.' + COMPONENT_NAME$q, function () {
        _this3.updated();
      });

      this.isSwitchingMonth = false;
      this.element.off('monthrendered.' + COMPONENT_NAME$q).on('monthrendered.' + COMPONENT_NAME$q, function () {
        _this3.isSwitchingMonth = true;
        if (_this3.modalVisible()) {
          _this3.removeModal();
        }
        _this3.renderAllEvents();

        setTimeout(function () {
          _this3.isSwitchingMonth = false;
        }, 500);
      });

      this.element.off('change.' + COMPONENT_NAME$q).on('change.' + COMPONENT_NAME$q, '.checkbox', function () {
        _this3.renderAllEvents(true);
      });

      $(this.monthViewContainer).off('selected.' + COMPONENT_NAME$q).on('selected.' + COMPONENT_NAME$q, function () {
        _this3.renderSelectedEventDetails();
      });

      this.element.off('click.' + COMPONENT_NAME$q).on('click.' + COMPONENT_NAME$q, '.calendar-upcoming-event', function (e) {
        var key = e.currentTarget.getAttribute('data-key');
        _this3.monthView.selectDay(key);
      });

      if (this.settings.menuId) {
        this.element.off('contextmenu.' + COMPONENT_NAME$q).on('contextmenu.' + COMPONENT_NAME$q, '.calendar-event', function (e) {
          e.preventDefault();
          var event = $(e.currentTarget);
          event.popupmenu({ attachToBody: true, menuId: _this3.settings.menuId, trigger: 'immediate', offset: { y: 5 } });

          event.off('selected.calendar').on('selected.calendar', function (evt, elem) {
            var eventId = this.getAttribute('data-id');
            if (self.settings.menuSelected) {
              self.settings.menuSelected(evt, elem, eventId);
            }

            if (elem.attr('data-action') === 'delete-event') {
              self.deleteEvent({ id: eventId });
            }
            if (elem.attr('data-action') === 'show-event') {
              var key = this.getAttribute('data-key');
              self.monthView.selectDay(key);
            }
          });
        });
      }

      var showModalWithCallback = function showModalWithCallback(eventData, isAdd) {
        _this3.showEventModal(eventData, function (elem, event) {
          // Collect the data and popuplate the event object
          var inputs = elem.querySelectorAll('input, textarea, select');
          for (var i = 0; i < inputs.length; i++) {
            event[inputs[i].id] = inputs[i].getAttribute('type') === 'checkbox' ? inputs[i].checked : inputs[i].value;
          }

          if (isAdd) {
            _this3.addEvent(event);
          } else {
            _this3.updateEvent(event);
          }
        });
      };

      this.element.off('click.' + COMPONENT_NAME$q).on('click.' + COMPONENT_NAME$q, '.calendar-event', function (e) {
        var eventId = e.currentTarget.getAttribute('data-id');
        var eventData = _this3.settings.events.filter(function (event) {
          return event.id === eventId;
        });
        if (!eventData || eventData.length === 0) {
          return;
        }
        showModalWithCallback(eventData[0], false);
      });

      this.element.off('dblclick.' + COMPONENT_NAME$q).on('dblclick.' + COMPONENT_NAME$q, 'td', function (e) {
        // throw this case out or you can click the wrong day
        if (_this3.isSwitchingMonth || _this3.modalVisible()) {
          return;
        }
        var key = e.currentTarget.getAttribute('data-key');
        var day = new Date(key.substr(0, 4), key.substr(4, 2) - 1, key.substr(6, 2));

        var eventData = utils.extend({}, _this3.settings.newEventDefaults);
        eventData.startKey = key;
        eventData.endKey = key;
        eventData.starts = day;
        eventData.ends = day;

        _this3.cleanEventData(eventData, false);
        showModalWithCallback(eventData, true);
      });
      return this;
    },


    /**
     * Handle updated settings and values.
     * @private
     */
    callOnRenderMonth: function callOnRenderMonth() {
      var self = this;

      function response(events, eventTypes) {
        if (eventTypes && eventTypes.length > 0) {
          self.settings.eventTypes = eventTypes;
          self.renderEventTypes();
        }
        if (events && events.length > 0) {
          self.settings.events = events;
          self.renderAllEvents(true);
        }
      }
      this.settings.onRenderMonth(this.element, response);
    },


    /**
     * Get the current selected date on the calendar.
     * @returns {date} the currently selected date on the control.
     */
    currentDate: function currentDate() {
      return this.isRTL ? this.monthView.currentIslamicDate : this.monthView.currentDate;
    },


    /**
     * Get the events and date for the currently selected calendar day.
     * @param {date} date The date to find the events for.
     * @returns {object} dayEvents An object with all the events and the event date.
     */
    getDayEvents: function getDayEvents(date) {
      if (!date) {
        date = this.currentDate();
      }

      if (typeof date !== 'string' && !this.isRTL) {
        date = stringUtils.padDate(date.getFullYear(), date.getMonth(), date.getDate());
      }

      if (this.isRTL) {
        date = stringUtils.padDate(date[0], date[1], date[2]);
      }

      var dayObj = this.monthView.dayMap.filter(function (dayFilter) {
        return dayFilter.key === date;
      });

      var dayEvents = {
        date: this.monthView.currentDate,
        events: []
      };

      if (dayObj.length === 0) {
        return [];
      }

      dayEvents.events = dayObj[0].events;
      dayEvents.elem = dayObj[0].elem;
      return dayEvents;
    },


    /**
     * Render the template into the container.
     * @param {object} event The event object with common event properties.
     * @param {object} template The template id.
     * @param {object} container The container to put it in.
     * @param {boolean} append If true we append the template into the container.
    */
    renderTmpl: function renderTmpl(event, template, container, append) {
      if ((typeof Tmpl === 'undefined' ? 'undefined' : _typeof(Tmpl)) !== 'object' || !template) {
        return;
      }

      // create a copy of the template
      if (template instanceof $) {
        template = '' + template.html();
      } else if (typeof template === 'string') {
        // If a string doesn't contain HTML elments,
        // assume it's an element ID string and attempt to select with jQuery
        if (!stringUtils.containsHTML(template)) {
          template = $('#' + template).html();
        }
      }

      event.color = this.getEventTypeColor(event.type);
      event.startsLong = Locale.formatDate(event.starts, { date: 'long', locale: this.locale.name });
      event.endsLong = Locale.formatDate(event.ends, { date: 'long', locale: this.locale.name });
      event.typeLabel = this.getEventTypeLabel(event.type);

      var renderedTmpl = Tmpl.compile(template, { event: event });
      container.classList.remove('has-only-one');

      if (append) {
        DOM.append(container, renderedTmpl, '*');
        return;
      }
      container.innerHTML = renderedTmpl;
      container.classList.add('has-only-one');
    },


    /**
     * Add a new event via the event object and show it if it should be visible in the calendar.
     * @param {object} event The event object with common event properties.
     */
    addEvent: function addEvent(event) {
      this.cleanEventData(event, true);
      this.settings.events.push(event);
      this.renderEvent(event);
      this.renderSelectedEventDetails();
    },


    /**
     * Update an event via the event object and show it if it should be visible in the calendar.
     * It uses the event id to do this.
     * @param {object} event The event object with common event properties.
     */
    updateEvent: function updateEvent(event) {
      var eventId = event.id;
      for (var i = this.settings.events.length - 1; i >= 0; i--) {
        if (this.settings.events[i].id === eventId) {
          this.settings.events[i] = utils.extend(true, this.settings.events[i], event);
          this.cleanEventData(this.settings.events[i], true);
        }
      }

      this.renderAllEvents();
    },


    /**
     * Remove an event from the dataset and page. It uses the id property.
     * @param {object} event The event object with common event properties.
     */
    deleteEvent: function deleteEvent(event) {
      var eventId = event.id;

      for (var i = this.settings.events.length - 1; i >= 0; i--) {
        if (this.settings.events[i].id === eventId) {
          this.settings.events.splice(i, 1);
        }
      }
      this.renderAllEvents();
    },


    /**
     * Fix missing / incomlete event data
     * @param {object} event The event object with common event properties.
     * @param {boolean} addPlaceholder If true placeholder text will be added for some empty fields.
     * @private
     */
    cleanEventData: function cleanEventData(event, addPlaceholder) {
      var isAllDay = event.isAllDay === 'on' || event.isAllDay === 'true' || event.isAllDay;
      var startDate = new Date(event.starts);
      var endDate = new Date(event.ends);

      if (!Locale.isValidDate(startDate)) {
        startDate = this.currentDate();
      }
      if (!Locale.isValidDate(endDate)) {
        endDate = this.currentDate();
      }

      if (isAllDay) {
        startDate.setHours(0, 0, 0, 0);
        event.starts = Locale.formatDate(new Date(startDate), { pattern: 'yyyy-MM-ddTHH:mm:ss.SSS', locale: this.locale.name });
        endDate.setHours(23, 59, 59, 999);
        event.ends = Locale.formatDate(new Date(endDate), { pattern: 'yyyy-MM-ddTHH:mm:ss.SSS', locale: this.locale.name });
        event.duration = event.starts === event.ends ? 1 : null;
        event.isAllDay = true;
      } else {
        if (startDate === endDate) {
          endDate.setHours(endDate.getHours() + parseInt(event.durationHours, 10));
          event.ends = Locale.formatDate(endDate.toISOString(), { pattern: 'yyyy-MM-ddTHH:mm:ss.SSS', locale: this.locale.name });
          event.duration = null;
        } else {
          event.ends = Locale.formatDate(new Date(endDate), { pattern: 'yyyy-MM-ddTHH:mm:ss.SSS', locale: this.locale.name });
        }
        event.starts = Locale.formatDate(new Date(startDate), { pattern: 'yyyy-MM-ddTHH:mm:ss.SSS', locale: this.locale.name });
        event.isAllDay = false;
      }

      if (event.comments === undefined && addPlaceholder) {
        event.comments = Locale.translate('NoCommentsEntered', { locale: this.locale.name });
        event.noComments = true;
      }

      if (!event.subject && addPlaceholder) {
        event.subject = Locale.translate('NoTitle', { locale: this.locale.name });
      }

      if (!event.type) {
        // Default to the first one
        event.type = this.settings.eventTypes[0].id;
      }

      if (event.id === undefined && addPlaceholder) {
        var lastId = this.settings.events.length === 0 ? 0 : parseInt(this.settings.events[this.settings.events.length - 1].id, 10);
        event.id = (lastId + 1).toString();
      }

      if (event.title === 'NewEvent') {
        event.title = Locale.translate('NewEvent', { locale: this.locale.name });
      }
    },


    /**
     * Show a modal used to add/edit events. This uses the modalTemplate setting for the modal contents.
     * @param {object} event The event object with common event properties for defaulting fields in the template.
     * @param {function} done The callback for when the modal closes.
     */
    showEventModal: function showEventModal(event, done) {
      var _this4 = this;

      if (!this.settings.modalTemplate) {
        return;
      }

      if (this.modalVisible()) {
        this.removeModal();
      }

      this.modalContents = document.createElement('div');
      DOM.addClass(this.modalContents, 'calendar-event-modal', 'hidden');
      document.getElementsByTagName('body')[0].appendChild(this.modalContents);

      event = this.addCalculatedFields(event);
      this.renderTmpl(event || {}, this.settings.modalTemplate, this.modalContents);
      var dayObj = this.getDayEvents();
      var modalOptions = this.settings.modalOptions || {
        content: $(this.modalContents),
        closebutton: true,
        // Placement logic wasnt working, flip left most cell
        placement: dayObj.elem.index() === 6 ? 'left' : 'right',
        popover: true,
        offset: {
          y: 10
        },
        title: event.title || event.subject,
        trigger: 'immediate',
        keepOpen: true,
        extraClass: 'calendar-popup',
        tooltipElement: '#calendar-popup',
        headerClass: event.color
      };

      var isCancel = true;
      dayObj.elem.off('hide.calendar').on('hide.calendar', function () {
        if (isCancel) {
          _this4.removeModal();
          return;
        }

        done(_this4.modalContents, event);
        _this4.element.trigger('hidemodal', { elem: _this4.modalContents, event: event });
        _this4.removeModal();
        isCancel = true;
      }).popover(modalOptions).off('show.calendar').on('show.calendar', function (evt, elem) {
        _this4.element.trigger('showmodal', { elem: _this4.modalContents, event: event });

        // Wire the click on isAllDay to disable spinbox.
        elem.find('#isAllDay').off().on('click.calendar', function (e) {
          var isDisabled = $(e.currentTarget).prop('checked');
          if (isDisabled) {
            elem.find('#durationHours').data('spinbox').disable();
          } else {
            elem.find('#durationHours').data('spinbox').enable();
          }
        });

        // Wire the correct type selector
        elem.find('#type').val(event.type).trigger('updated');

        // Wire the correct comments
        elem.find('#comments').val(event.comments);
        elem.find('#subject').focus();

        // Wire the buttons
        elem.find('button').on('click', function (e) {
          var popupApi = dayObj.elem.data('tooltip');
          var action = e.currentTarget.getAttribute('data-action');
          isCancel = action !== 'submit';
          if (popupApi) {
            popupApi.hide(true);
          }
        });
      });

      this.activeElem = dayObj.elem;
    },


    /**
     * @returns {boolean} whether or not this Modal is currently being displayed
     */
    modalVisible: function modalVisible() {
      return document.querySelector('.calendar-event-modal') !== null;
    },


    /**
     * Remove and destroy the modal.
     * @private
     */
    removeModal: function removeModal() {
      this.modalContents = null;
      if (this.activeElem) {
        this.activeElem.off();
        this.activeElem.data('tooltip').destroy();
      }
      DOM.remove(document.getElementById('calendar-popup'));
      DOM.remove(document.querySelector('.calendar-event-modal'));
    },


    /**
     * Remove all events from the calendar
     */
    clearEvents: function clearEvents() {
      this.settings.events = [];
      this.renderAllEvents();
    },


    /**
     * Handle updated settings and values.
     * @returns {object} [description]
     */
    updated: function updated() {
      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$q);
      this.element.off('monthrendered.' + COMPONENT_NAME$q);
      this.element.off('change.' + COMPONENT_NAME$q);
      this.element.on('click.' + COMPONENT_NAME$q);
      $(this.monthViewContainer).off();

      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @private
     */
    destroy: function destroy() {
      if (this.eventTypeContainer) {
        this.eventTypeContainer.innerHTML = '';
      }
      if (this.monthViewContainer) {
        this.monthViewContainer.innerHTML = '';
      }
      if (this.upcomingEventsContainer) {
        this.upcomingEventsContainer.innerHTML = '';
      }
      if (this.eventDetailsContainer) {
        this.eventDetailsContainer.innerHTML = '';
      }
      this.removeModal();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$q);
    }
  };

  /**
   * jQuery Component Wrapper for Calendar
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.calendar = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$q);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$q, new Calendar(this, settings));
      }
    });
  };

  // Default Settings
  var COMPONENT_NAME$r = 'circlepager';

  /**
   * The Circle Pager Displays content in a sliding carousel and has paging buttons.
   * @class CirclePager
   * @constructor
   *
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {Integer} [settings.slidesToShow=1] The number of slides to show in one view / pane
   * @param {Integer} [settings.startingSlide] First showing slide/group, an 0-based integer
   * @param {boolean} [settings.loop=false] Setting loop: true will loop back after next/previous reached to end
   */
  var CIRCLEPAGER_DEFAULTS = {
    slidesToShow: 1,
    startingSlide: null,
    loop: false
  };

  function CirclePager(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, CIRCLEPAGER_DEFAULTS);
    this.init();
  }

  // CirclePager Methods
  CirclePager.prototype = {
    init: function init() {
      this.setElements();

      if (this.slides.length) {
        this.createControls();
        this.handleEvents();
        this.initActiveSlide();
        this.showCollapsedView();
      }
    },


    /**
     * Set elements
     * @private
     * @returns {void}
     */
    setElements: function setElements() {
      var s = this.settings;

      this.container = $('.slides', this.element);
      this.slidesJQ = $('.slide', this.element);
      this.slidesToShow = s.slidesToShow;
      this.slides = [];
      this.isVisible = true;

      for (var i = 0, l = this.slidesJQ.length; i < l; i++) {
        this.slides.push({ node: $(this.slidesJQ[i]) });
      }

      this.activeIndex = s.startingSlide !== null && s.startingSlide > -1 && s.startingSlide < this.slides.length ? s.startingSlide : 0;
    },


    /**
     * Create controls
     * @private
     * @returns {void}
     */
    createControls: function createControls() {
      var len = this.slides.length;
      var html = '<div class="controls">';
      var htmlContent = '';
      var numOfButtons = 0;
      var slide = void 0;
      var temp = void 0;
      var href = void 0;
      var text = void 0;
      var buttonText = void 0;
      var last = void 0;
      var lastIndex = void 0;
      var isSingle = void 0;
      var isDisabled = void 0;

      for (var i = 0, l = len; i < l; i += this.slidesToShow) {
        temp = '';
        numOfButtons++;
        isSingle = this.slidesToShow === 1 || len - i === 1;
        text = Locale.translate(isSingle ? 'SlideOf' : 'SlidesOf');
        // Keep href in english language only
        href = isSingle ? '#slide {0} of {1}' : '#slides {0} and {1} of {2}';

        // Collect as much bullets need to present
        for (var g = 0; g < this.slidesToShow && i + g < len; g++) {
          temp += i + g + 1 + ', ';
        }
        text = text.replace(isSingle ? '{1}' : '{2}', len);
        href = href.replace(isSingle ? '{1}' : '{2}', len);
        temp = temp.slice(0, -2);
        lastIndex = temp.lastIndexOf(',');
        last = temp.substr(lastIndex + 2);

        // Controls for single slide in view
        if (isSingle) {
          isDisabled = '';
          slide = this.slides[i].node;

          // Set disabled
          if (slide.is('.is-disabled, [disabled]') && !slide.is('[disabled="false"]')) {
            isDisabled = ' disabled tabindex="-1"';
            this.slides[i].isDisabled = true;
          }

          // Set default starting slide
          if (slide.is('.active') && this.settings.startingSlide === null && isDisabled === '') {
            this.activeIndex = i;
          }

          // Use custom text if supplied
          buttonText = slide.attr('data-button-text');
          text = buttonText && buttonText.length ? buttonText : text.replace('{0}', temp);

          href = href.replace('{0}', temp);
        } else {
          // Controls for multiple slides in view
          temp = temp.substr(0, lastIndex);
          text = text.replace('{1}', last).replace('{0}', temp);
          href = href.replace('{1}', last).replace('{0}', temp);
        }

        href = href.toLowerCase().replace(/[\s,--]+/g, '-');

        htmlContent += '<a href="' + href + '" class="control-button hyperlink hide-focus"' + isDisabled + '><span class="audible">' + text + '</span></a>';
      }

      html += htmlContent + '</div>';

      // Previous/Next buttons
      this.isBulletsNav = this.element.width() > numOfButtons * 29;
      var previousButton = $('.btn-previous', this.element);
      var nextButton = $('.btn-next', this.element);
      if (!this.isBulletsNav) {
        if (!previousButton.length) {
          html += '' + ('<button class="btn-previous" type="button">\n            ' + $.createIcon('left-arrow') + '\n            <span class="audible"> ' + Locale.translate('Previous') + '</span>\n          </button>');
        }
        if (!nextButton.length) {
          html += '' + ('<button class="btn-next" type="button">\n            ' + $.createIcon('right-arrow') + '\n            <span class="audible">' + Locale.translate('Next') + '</span>\n          </button>');
        }
      } else {
        previousButton.add(nextButton).remove();
      }

      if (this.activeIndex > 0 && this.activeIndex > numOfButtons - 1) {
        this.activeIndex = numOfButtons - 1;
      }

      if (numOfButtons > 1) {
        this.element.append(html);
      }
    },


    /**
     * Check if given element is visible in container
     * @private
     * @param {object} element to check.
     * @returns {boolean} -1 if not in container
     */
    isVisibleInContainer: function isVisibleInContainer(element) {
      if (element && element[0]) {
        var eRect = element[0].getBoundingClientRect();
        var cRect = this.element[0].getBoundingClientRect();

        return eRect.left > cRect.left && eRect.left < cRect.left + cRect.width && eRect.top > cRect.top && eRect.top < cRect.top + cRect.height;
      }
      return -1;
    },


    /**
     * Update number of slides to show in view
     * @private
     * @param {object} numOfSlides to show.
     * @returns {object} this api
     */
    updateSlidesToShow: function updateSlidesToShow(numOfSlides) {
      if (!this.isActive) {
        return;
      }
      this.settings.slidesToShow = numOfSlides || 1;
      this.updated();
      return this; // eslint-disable-line
    },


    /**
     * Make sure max number of slides to show in view
     * @private
     * @param {object} numOfSlides to show.
     * @returns {void}
     */
    responsiveSlidesToShow: function responsiveSlidesToShow(numOfSlides) {
      var _this = this;

      if (!this.isActive) {
        return;
      }

      this.slidesToShow = numOfSlides || this.settings.slidesToShow;
      this.unbind().slidesJQ.css('width', '');
      if (this.slides.length) {
        setTimeout(function () {
          _this.createControls();
          _this.handleEvents();
          _this.initActiveSlide();
          _this.showCollapsedView();
        }, 0);
      }
    },


    /**
     * Show a slide to First Slide
     * @private
     * @param {string} index  The index of the slide to show (0 based)
     * @returns {void}
     */
    show: function show(index) {
      if (!this.isActive) {
        return;
      }
      index = typeof index !== 'undefined' ? index : this.activeIndex;
      this.activeIndex = index;

      var left = index > 0 ? (Locale.isRTL() ? '' : '-') + index * 100 + '%' : 0;
      this.controlButtons.removeClass('is-active').eq(index).addClass('is-active');
      this.container[0].style.left = left;

      // Make sure bullets navigation do not overflow
      if (!this.isBulletsNav) {
        this.element.addClass('is-bullets-nav-hidden');
        this.controlButtons.find('span').addClass('audible').end().eq(index).find('span').removeClass('audible');
      } else {
        this.element.removeClass('is-bullets-nav-hidden');
        this.controlButtons.find('span').addClass('audible');
      }

      // Set focus
      if (this.isFocus && this.isBulletsNav) {
        this.isFocus = false;
        this.controlButtons.eq(index).focus();
      }
    },


    /**
     * Move to First Slide
     * @private
     * @returns {void}
     */
    first: function first() {
      this.show(0);
    },


    /**
     * Move to Last Slide
     * @private
     * @returns {void}
     */
    last: function last() {
      this.show(Math.round(this.slides.length / this.slidesToShow) - 1);
    },


    /**
     * Move to Previous Slide
     * @private
     * @returns {void}
     */
    prev: function prev() {
      var _this2 = this;

      // eslint-disable-line
      var prev = void 0;

      if (this.activeIndex > 0) {
        prev = this.activeIndex - 1;
      } else {
        prev = this.settings.loop ? Math.round(this.slides.length / this.slidesToShow) - 1 : 0;
      }

      if (this.slides[prev].isDisabled) {
        setTimeout(function () {
          _this2.prev();
        }, 0);
        this.activeIndex = prev;
        return false;
      }
      this.show(prev);
    },


    /**
    * Move to Next Slide
    * @private
    * @returns {void}
    */
    next: function next() {
      var _this3 = this;

      // eslint-disable-line
      var next = void 0;
      if (this.activeIndex >= Math.round(this.slides.length / this.slidesToShow) - 1) {
        next = this.settings.loop ? 0 : this.activeIndex;
      } else {
        next = this.activeIndex + 1;
      }

      if (this.slides[next].isDisabled) {
        setTimeout(function () {
          _this3.next();
        }, 0);
        this.activeIndex = next;
        return false;
      }
      this.show(next);
    },


    /**
    * Make active
    * @private
    * @returns {void}
    */
    showCollapsedView: function showCollapsedView() {
      this.isActive = true;
      this.element.addClass('is-active');
      this.container[0].style.width = 100 * this.slides.length + '%';
      if (this.settings.slidesToShow > 1 && this.slidesJQ.eq(0).width() * this.slidesToShow > this.element.width()) {
        this.responsiveSlidesToShow(this.slidesToShow - 1);
        return;
      }
      for (var i = 0, l = this.slidesJQ.length; i < l; i++) {
        this.slidesJQ[i].style.width = 100 / this.slidesToShow / this.slides.length + '%';
      }
      this.show();
    },


    /**
    * Make un-active
    * @private
    * @returns {void}
    */
    showExpandedView: function showExpandedView() {
      this.isActive = false;
      this.element.removeClass('is-active');
      if (this.element && this.element[0]) {
        this.element[0].style.width = '';
      }
      if (this.container && this.container[0]) {
        this.container[0].style.width = '';
        this.container[0].style.left = '';
      }
    },


    /**
    * Initialize active slide
    * @private
    * @returns {void}
    */
    initActiveSlide: function initActiveSlide() {
      // eslint-disable-line
      if (this.slides[this.activeIndex].isDisabled) {
        this.next();
        return false;
      }
      this.show();
      this.slidesJQ.addClass('is-visible');
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      $('body').off('resize.circlepager');
      this.element.off('focus.circlepager keydown.circlepager', '*');
      if (this.controlButtons) {
        this.controlButtons.off('click.circlepager keydown.circlepager');
      }
      $('.btn-previous, .btn-next', this.element).off('click.circlepager');
      $('.controls', this.element).remove();
      this.showExpandedView();

      var possibleTab = this.element.closest('.tab-panel-container').prev('.tab-container');
      possibleTab.off('activated.circlepager');
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, CIRCLEPAGER_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$r);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this4 = this;

      var self = this;

      // Previous button
      $('.btn-previous', this.element).on('click.circlepager', function (e) {
        _this4.prev();
        e.stopImmediatePropagation();
      });

      // Next button
      $('.btn-next', this.element).on('click.circlepager', function (e) {
        _this4.next();
        e.stopImmediatePropagation();
      });

      this.controlButtons = $('.control-button', this.element);

      var _loop = function _loop(i, l) {
        var btn = $(_this4.controlButtons[i]);
        btn.hideFocus();

        // Handle clicks for bottom bullet links
        btn.on('click.circlepager', function (e) {
          e.preventDefault();
          if (_this4.slides[i].isDisabled) {
            return;
          }
          _this4.show(i);
        });
      };

      for (var i = 0, l = this.controlButtons.length; i < l; i++) {
        _loop(i, l);
      }

      // Handle keyboard events

      // Prevent hidden slide's content to be get focused
      // on focusable elements in slides content
      this.element.on('focus.circlepager', '*', function (e) {
        // eslint-disable-line
        var handled = false;
        if (!self.isVisibleInContainer($(this))) {
          var canfocus = self.element.find(':focusable');
          for (var i = 0, l = canfocus.length; i < l; i++) {
            if (self.isVisibleInContainer(canfocus.eq(i))) {
              canfocus.eq(i).focus();
              handled = true;
              break;
            }
          }
        }
        e.stopPropagation();
        if (handled) {
          return false;
        }
      });
      // Keydown on focusable elements in slides content to
      // prevent hidden slide's content to be get focused
      this.element.on('keydown.circlepager', '*', function (e) {
        // eslint-disable-line
        var handled = false;
        var key = e.which || e.keyCode || e.charCode || 0;
        var canfocus = $(':focusable');
        var index = canfocus.index(this);

        if (key === 9) {
          // tab
          // Using shift key with tab (going backwards)
          if (e.shiftKey) {
            for (var i = index - 1; i >= 0; i--) {
              if (self.element.has(canfocus.eq(i)).length < 1 || self.isVisibleInContainer(canfocus.eq(i))) {
                canfocus.eq(i).focus();
                handled = true;
                break;
              }
            }
          } else if (!self.isVisibleInContainer(canfocus.eq(index + 1))) {
            // Using only tab key (going forward)
            self.controlButtons.first().focus();
            handled = true;
          }
        }
        e.stopPropagation();
        if (handled) {
          return false;
        }
      });

      // Control buttons
      this.controlButtons.on('keydown.circlepager', function (e) {
        // eslint-disable-line
        var handled = false;
        var key = e.which || e.keyCode || e.charCode || 0;
        var isRTL = Locale.isRTL();

        // Left and Right arrow keys
        if ([37, 39].indexOf(key) !== -1) {
          self.isFocus = true; // Move focus
          if (e.altKey) {
            // [Alt + Left/Right arrow] to move to the first or last
            if (key === 37 && !isRTL || key === 39 && isRTL) {
              self.first();
            } else {
              self.last();
            }
          } else {
            // Left and Right arrow keys to navigate
            if (!isRTL && key === 37 || isRTL && key === 39) {
              self.prev();
            } else {
              self.next();
            }
            handled = true;
          }
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      });

      // Set max number of slides can view on resize
      $('body').on('resize.circlepager', function () {
        self.responsiveSlidesToShow();
      });

      var possibleTab = self.element.closest('.tab-panel-container').prev('.tab-container');
      possibleTab.off('activated.circlepager').on('activated.circlepager', function () {
        self.responsiveSlidesToShow();
      });
    }
  };

  /**
   * jQuery Component Wrapper for CirclePager
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.circlepager = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$r);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$r, new CirclePager(this, settings));
      }
    });
  };

  // Default Settings
  var COMPONENT_NAME$s = 'colorpicker';

  /**
   * The ColorPicker Component is a trigger field with a listing colors that can be selected.
   * @class ColorPicker
   * @param {jQuery[]|HTMLElement} element The plugin element for the constuctor
   * @param {object} [settings] The settings element.
   * @param {object} [settings.themes={}] Themes available for ColorPicker
   * @param {array} [settings.colors=[]] An array of objects of the form. {label: 'Azure', number: '01', value: 'CBEBF4'}
   * that can be used to populate the color grid.
   * @param {boolean} [settings.showLabel=false]  Show the label if true vs the hex value if false.
   * @param {boolean} [settings.editable=true]  If false, the field is readonly and transparent. I.E. The value
   * cannot be typed only editable by selecting.
   * @param {boolean} [settings.uppercase=true] If false, lower case hex is allowed. If true upper case hex is allowed.
   * If showLabel is true this setting is ignored.
   * @param {boolean} [settings.colorOnly=false] If true the field will be shrunk to only show the color portion.
   * @param {boolean} [settings.clearable=true] If true will add clearable option.
   * @param {string} [settings.clearableText] The text to show in tooltip.
   */
  var COLORPICKER_DEFAULTS = {
    // Theme key: MUST match with theme file name (ie: [filename: 'light-theme.css' -> 'light-theme'])

    // BORDERS
    // Use (,) commas to separate themes or single entry for border as:
    // colors[{label: 'Slate', number: '01', value: 'F0F0F0',
    // border: 'light-theme, high-contrast-theme'}]
    // and assign which swatch theborder should apply ['all' or 'matched-only']
    // themes: { 'high-contrast-theme': {'border': 'all'} }

    // CHECKMARKS
    // checkmark: {'one': [1, 2], 'two': [3, 10]}
    // will add class as "checkmark-{key}", where current colors number is in range
    // [{value[0]} to {value[1]}]
    // will add class "checkmark-one", where current colors number is in range [1 to 3]
    // and will add class "checkmark-two", where current colors number is in range [3 to 10]
    themes: {
      light: { border: 'matched-only', checkmark: { one: [1, 2], two: [3, 10] } },
      dark: { border: 'matched-only', checkmark: { one: [1, 2], two: [3, 10] } },
      'high-contrast': { border: 'all', checkmark: { one: [1, 3], two: [4, 10] } }
    },
    customColors: false,
    colors: [{ label: 'Slate', number: '10', value: '1a1a1a' }, { label: 'Slate', number: '09', value: '292929' }, { label: 'Slate', number: '08', value: '383838', border: 'dark' }, { label: 'Slate', number: '07', value: '454545', border: 'dark' }, { label: 'Slate', number: '06', value: '5C5C5C' }, { label: 'Slate', number: '05', value: '737373' }, { label: 'Slate', number: '04', value: '999999' }, { label: 'Slate', number: '03', value: 'BDBDBD' }, { label: 'Slate', number: '02', value: 'D8D8D8' }, { label: 'Slate', number: '01', value: 'F0F0F0', border: 'light, high-contrast' }, { label: 'Amber', number: '10', value: 'D66221' }, { label: 'Amber', number: '09', value: 'DE7223' }, { label: 'Amber', number: '08', value: 'E68425' }, { label: 'Amber', number: '07', value: 'EB9728' }, { label: 'Amber', number: '06', value: 'EFAA30' }, { label: 'Amber', number: '05', value: 'F2BC41' }, { label: 'Amber', number: '04', value: 'F4C951' }, { label: 'Amber', number: '03', value: 'F7D475' }, { label: 'Amber', number: '02', value: 'F8E09C' }, { label: 'Amber', number: '01', value: 'FBE9BF' }, { label: 'Ruby', number: '10', value: '880E0E' }, { label: 'Ruby', number: '09', value: '941E1E' }, { label: 'Ruby', number: '08', value: 'A13030' }, { label: 'Ruby', number: '07', value: 'AD4242' }, { label: 'Ruby', number: '06', value: 'B94E4E' }, { label: 'Ruby', number: '05', value: 'C65F5F' }, { label: 'Ruby', number: '04', value: 'D26D6D' }, { label: 'Ruby', number: '03', value: 'DE8181' }, { label: 'Ruby', number: '02', value: 'EB9D9D' }, { label: 'Ruby', number: '01', value: 'F4BCBC' }, { label: 'Turquoise', number: '10', value: '0E5B52' }, { label: 'Turquoise', number: '09', value: '206B62' }, { label: 'Turquoise', number: '08', value: '317C73' }, { label: 'Turquoise', number: '07', value: '448D83' }, { label: 'Turquoise', number: '06', value: '579E95' }, { label: 'Turquoise', number: '05', value: '69ADA3' }, { label: 'Turquoise', number: '04', value: '7BBFB5' }, { label: 'Turquoise', number: '03', value: '8ED1C6' }, { label: 'Turquoise', number: '02', value: 'A9E1D6' }, { label: 'Turquoise', number: '01', value: 'C0EDE3' }, { label: 'Emerald', number: '10', value: '397514' }, { label: 'Emerald', number: '09', value: '44831F' }, { label: 'Emerald', number: '08', value: '56932E' }, { label: 'Emerald', number: '07', value: '66A140' }, { label: 'Emerald', number: '06', value: '76B051' }, { label: 'Emerald', number: '05', value: '89BF65' }, { label: 'Emerald', number: '04', value: '9CCE7C' }, { label: 'Emerald', number: '03', value: 'AFDC91' }, { label: 'Emerald', number: '02', value: 'C3E8AC' }, { label: 'Emerald', number: '01', value: 'D5F6C0' }, { label: 'Amethyst', number: '10', value: '4B2A5E' }, { label: 'Amethyst', number: '09', value: '5A3A6F' }, { label: 'Amethyst', number: '08', value: '6C4B81' }, { label: 'Amethyst', number: '07', value: '7D5F92' }, { label: 'Amethyst', number: '06', value: '8E72A4' }, { label: 'Amethyst', number: '05', value: 'A189B8' }, { label: 'Amethyst', number: '04', value: 'B59ECA' }, { label: 'Amethyst', number: '03', value: 'C7B4DB' }, { label: 'Amethyst', number: '02', value: 'DACCEC' }, { label: 'Amethyst', number: '01', value: 'EDE3FC' }, { label: 'Azure', number: '10', value: '133C59' }, { label: 'Azure', number: '09', value: '134D71' }, { label: 'Azure', number: '08', value: '1D5F8A' }, { label: 'Azure', number: '07', value: '2876A8' }, { label: 'Azure', number: '06', value: '368AC0' }, { label: 'Azure', number: '05', value: '4EA0D1' }, { label: 'Azure', number: '04', value: '69B5DD' }, { label: 'Azure', number: '03', value: '8DC9E6' }, { label: 'Azure', number: '02', value: 'ADD8EB' }, { label: 'Azure', number: '01', value: 'C8E9F4' }],
    placeIn: null, // null|'editor'
    showLabel: false,
    editable: true,
    disabled: false,
    uppercase: true,
    colorOnly: false,
    clearable: true,
    clearableText: null
  };

  function ColorPicker(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COLORPICKER_DEFAULTS);

    // Merge Settings does deep copy we want to replace here
    if (settings && settings.colors) {
      this.settings.colors = settings.colors;
    }

    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  ColorPicker.prototype = {
    init: function init() {
      this.isIe = Environment.browser.name === 'ie';
      this.isIeEdge = Environment.browser.name === 'edge';
      this.isIe11 = this.isIe && Environment.browser.version === '11';
      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = this.element.parent().is('.inline');

      // Set default clearable text
      if (!this.settings.clearableText) {
        this.settings.clearableText = Locale ? Locale.translate('None') : 'None';
      }

      this.build();
      this.handleEvents();
      this.setCustomWidth();
    },


    // Add the extra markup
    build: function build() {
      this.isEditor = this.settings.placeIn === 'editor';
      var colorpicker = this.element;
      var initialValue = this.isEditor ? this.element.attr('data-value') : this.element.val();
      var classList = 'swatch' + (!initialValue || $.trim(initialValue) === '' ? ' is-empty' : '');

      if (!this.isEditor) {
        // Add Button
        if (this.isInlineLabel) {
          this.inlineLabel.addClass('colorpicker-container');
        } else {
          this.container = $('<span class="colorpicker-container"></span>');
          colorpicker.wrap(this.container);
        }

        this.container = colorpicker.parent();
        this.swatch = $('<span class="' + classList + '"></span>').prependTo(this.container);

        // Add Masking to show the #.
        // Remove the mask if using the "showLabel" setting
        if (!this.settings.showLabel) {
          var pattern = ['#', /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/];

          colorpicker.mask({ pattern: pattern });
        } else {
          var maskAPI = colorpicker.data('mask');
          if (maskAPI && typeof maskAPI.destroy === 'function') {
            maskAPI.destroy();
          }
        }
      }

      this.icon = $.createIconElement('dropdown').appendTo(this.isEditor ? this.element : this.container);
      this.icon.wrap('<span class="trigger"></span>');

      // Handle initial values
      if (initialValue) {
        this.setColor(initialValue);
      }

      if (this.element.is(':disabled') || this.settings.disabled) {
        this.disable();
      }

      if (this.element.prop('readonly')) {
        this.readonly();
      }

      if (!this.settings.editable && !this.settings.disabled) {
        this.readonly();
      }

      if (this.settings.colorOnly) {
        this.element.parent().addClass('color-only');
      }

      this.addAria();
    },


    /**
    * Get the hex value based on a label. Does not handle duplicates.
    * @param {string} label  The label to search for in the color labels.
    * @returns {void}
    */
    getHexFromLabel: function getHexFromLabel(label) {
      for (var i = 0; i < this.settings.colors.length; i++) {
        var data = this.settings.colors[i];
        var translated = Locale.translate(data.label, true);

        if (label === data.label + data.number || label === translated + data.number) {
          var hex = data.value;
          if (hex.substr(0, 1) !== '#') {
            hex = '#' + hex;
          }

          return hex;
        }
      }
      return '';
    },


    /**
    * Get the label value based on a hex. Does not handle duplicates.
    * Can pass with or without the #
    *
    * @param {string} hex The hex to search for in the color set.
    * @returns {void}
    */
    getLabelFromHex: function getLabelFromHex(hex) {
      if (!hex) {
        return '';
      }

      for (var i = 0; i < this.settings.colors.length; i++) {
        var data = this.settings.colors[i];

        if (hex.replace('#', '') === data.value.replace('#', '')) {
          return this.translateColorLabel(data.label) + data.number;
        }
      }

      return '';
    },


    /**
    * Set custom width.
    * @private
    * @returns {void}
    */
    setCustomWidth: function setCustomWidth() {
      if (this.element[0].style && this.element[0].style.width) {
        var w = parseInt(this.element[0].style.width, 10);
        this.container.css({ width: w });
        this.element.css({ width: w - 2 - this.swatch.width() });
      }
    },

    /**
    * Get the currently set hex value.
    * @returns {string} A string containing the hex
    */
    getHexValue: function getHexValue() {
      return this.element.attr('value');
    },


    /**
    * Get the currently set label value.
    * @returns {string} A string containing the hex
    */
    getLabelValue: function getLabelValue() {
      return this.settings.showLabel ? this.element.val() : this.getLabelFromHex(this.element.val());
    },


    /**
    * Add the necessary aria for accessibility.
    * @private
    * @returns {void}
    */
    addAria: function addAria() {
      this.element.attr({
        role: 'combobox',
        'aria-autocomplete': 'list'
      });

      $('label[for="' + this.element.attr('id') + '"]').append('<span class="audible">' + Locale.translate('UseArrow') + '</span>');
    },


    /**
    * Toggle / Open the List of Colors
    * @returns {void}
    */
    toggleList: function toggleList() {
      var _this = this;

      var menu = $('#colorpicker-menu');

      if (this.element.is(':disabled') || this.element.prop('readonly') && this.settings.editable) {
        return;
      }

      if (menu.length && this.isPickerOpen) {
        return;
      }

      // Append Color Menu
      menu = this.updateColorMenu();

      var popupmenuOpts = {
        ariaListbox: true,
        menuId: 'colorpicker-menu',
        trigger: 'immediate',
        attachToBody: true,
        placementOpts: {
          containerOffsetX: 10,
          containerOffsetY: 10,
          parentXAlignment: Locale.isRTL() ? 'right' : 'left',
          strategies: ['flip', 'nudge', 'shrink']
        },
        offset: {
          x: 0,
          y: 10
        }
      };

      // Show Menu
      this.element.popupmenu(popupmenuOpts).on('open.colorpicker', function () {
        _this.element.parent().addClass('is-open');
        _this.isPickerOpen = true;
      }).on('close.colorpicker', function () {
        var links = [].slice.call(_this.menu[0].querySelectorAll('a'));
        links.forEach(function (link) {
          var tooltipApi = $(link).data('tooltip');
          if (tooltipApi) {
            tooltipApi.hide();
          }
        });
        menu.on('destroy.colorpicker', function () {
          _this.element.off('open.colorpicker selected.colorpicker close.colorpicker');
          _this.menu.off('destroy.colorpicker').remove();
        });

        _this.element.parent().removeClass('is-open');
        _this.isPickerOpen = false;

        _this.element.trigger('listclosed', 'select');
      }).on('selected.colorpicker', function (e, item) {
        if (!_this.isEditor) {
          _this.setColor(item.data('value'), item.data('label'));
        }
        _this.element.focus();
        _this.element.trigger('change');
      });

      // Append Buttons
      this.menu = $('#colorpicker-menu');

      setTimeout(function () {
        _this.menu.find('.is-selected').focus();
      }, 1);
    },


    /**
    * Set the visible color in the field
    * @param {string} hex The hex value to use (can have the # or not).
    * @param {string} label The text to display
    * @returns {void}
    */
    setColor: function setColor(hex, label) {
      hex = hex || '';
      var s = this.settings;
      var colorHex = hex;
      var colorLabel = label;

      // Make sure there is always a hash
      if (hex.substr(0, 1) !== '#' && hex !== '') {
        colorHex = '#' + colorHex;
      }

      var isValidHex = /(^#[0-9a-fA-F]{6}$)|(^#[0-9a-fA-F]{3}$)/i.test(colorHex);

      // Simply return out if hex isn't valid
      if (s.showLabel && label === s.clearableText) {
        this.setValueOnField({ hex: colorHex, label: s.clearableText, isEmpty: true });
        return;
      } else if (!isValidHex) {
        if (!s.showLabel) {
          colorHex = colorHex !== '#' ? colorHex : '';
          this.setValueOnField({ hex: colorHex, invalid: true });
          return;
        }
        colorLabel = hex.replace('#', '');
        colorHex = this.getHexFromLabel(colorLabel);
      }

      if (!colorLabel) {
        colorLabel = this.getLabelFromHex(colorHex);
      }

      this.setValueOnField({ hex: colorHex, label: colorLabel });
    },


    /**
     * Set the value on the field
     * @private
     * @param {object} [o] Options
     * @param {string} [o.hex] The hex value to use
     * @param {string} [o.label] The text to display
     * @param {boolean} [o.isEmpty] if true will set empty value for all
     * @param {boolean} [o.invalid] if true will set empty value for swatch only
     * @returns {void}
     */
    setValueOnField: function setValueOnField(o) {
      var s = this.settings;
      var targetAttr = this.isEditor ? 'data-value' : 'value';
      var hex = '';

      if (!o.isEmpty && typeof o.hex === 'string') {
        hex = s.uppercase ? o.hex.toUpperCase() : o.hex.toLowerCase();
      }

      if (this.swatch) {
        if (o.isEmpty || o.invalid) {
          this.swatch.addClass(o.isEmpty ? 'is-empty' : 'is-invalid');
          this.swatch[0].style.backgroundColor = '';
        } else {
          this.swatch.removeClass('is-empty is-invalid');
          this.swatch[0].style.backgroundColor = hex;
        }
      }

      this.element[0].value = s.showLabel ? o.label : hex;
      this.element[0].setAttribute(targetAttr, hex);
      this.element[0].setAttribute('aria-describedby', o.label || '');
    },


    /**
     * @private
     * @param {string} colorText the original text color
     * @returns {string} the translated text color
     */
    translateColorLabel: function translateColorLabel(colorText) {
      if (!colorText) {
        return '';
      }
      var translatedText = Locale.translate(colorText, true);
      return typeof translatedText === 'string' ? Locale.translate(colorText, true) : colorText;
    },


    /**
     * Refresh and Append the Color Menu
     * @private
     * @returns {jQuery} the menu to be appended
     */
    updateColorMenu: function updateColorMenu() {
      var _this2 = this;

      var s = this.settings;
      var isMenu = !!$('#colorpicker-menu').length;
      var menu = $('<ul id="colorpicker-menu" class="popupmenu colorpicker"></ul>');
      var activeTheme = personalization.currentTheme;
      var isBorderAll = s.themes[activeTheme].border === 'all';
      var checkThemes = s.themes[activeTheme].checkmark;
      var checkmarkClass = '';

      var _loop = function _loop(i, l) {
        var li = $('<li></li>');
        var a = $('<a href="#"><span class="swatch"></span></a>').appendTo(li);
        var colorText = (_this2.translateColorLabel(s.colors[i].label) || s.colors[i].label) + (s.colors[i].number || '');
        var colorNum = parseInt(s.colors[i].number, 10);
        var regexp = new RegExp('\\b' + activeTheme + '\\b');
        var colorValue = s.colors[i].value;
        var isBorder = false;
        var elemValue = _this2.isEditor ? _this2.element.attr('data-value') : _this2.element.val();

        if (s.showLabel && !_this2.isEditor) {
          elemValue = _this2.getHexFromLabel(elemValue);
        }

        // Set border to this swatch
        if (isBorderAll || regexp.test(s.colors[i].border)) {
          isBorder = true;
        }

        if (elemValue && ('' + elemValue).toLowerCase().replace('#', '') === ('' + colorValue).toLowerCase()) {
          // Set checkmark color class
          if (checkThemes) {
            /* eslint-disable no-loop-func */
            $.each(checkThemes, function (k, v) {
              // checkmark: {'one': [1, 2], 'two': [3, 10]}
              // will add class "checkmark-one", where current colors number is in range [1 to 3]
              // and will add class "checkmark-two", where current colors number is in range [3 to 10]
              if (colorNum >= v[0] && colorNum <= v[1]) {
                checkmarkClass = ' checkmark-' + k;
              }
            });
            /* eslint-disable no-loop-func */
          }
          a.addClass('is-selected' + checkmarkClass);
        }

        colorValue = s.uppercase ? colorValue.toUpperCase() : colorValue.toLowerCase();
        var swatch = a.find('.swatch');
        if (swatch[0]) {
          swatch[0].style.backgroundColor = '#' + colorValue;
        }
        swatch.addClass(isBorder ? 'is-border' : '');
        a.data('label', colorText).data('value', colorValue).attr('title', colorText + ' #' + colorValue).tooltip();

        if (!isMenu) {
          menu.append(li);
        }
      };

      for (var i = 0, l = s.colors.length; i < l; i++) {
        _loop(i, l);
      }

      if (!isMenu) {
        // Add clearable swatch to popupmenu
        if (s.clearable) {
          var _li = $('<li></li>');
          var _a = $('<a href="#" title="' + s.clearableText + '"><span class="swatch is-empty' + (isBorderAll ? ' is-border' : '') + '"></span></a>').appendTo(_li);
          _a.data('label', s.clearableText).data('value', '').tooltip();
          menu.append(_li);
        }

        $('body').append(menu);
      }

      return menu;
    },


    /**
    * Change the color picker from enabled to disabled.
    * @returns {void}
    */
    enable: function enable() {
      this.element.prop('disabled', false);
      this.element.prop('readonly', false);
      this.element.parent().removeClass('is-disabled is-readonly');
    },


    /**
    * Make the color picker disabled
    * @returns {void}
    */
    disable: function disable() {
      this.element.prop('disabled', true);
      this.element.parent().addClass('is-disabled');
    },


    /**
    * Make the color picker readonly
    * @returns {void}
    */
    readonly: function readonly() {
      this.enable();
      this.element.prop('readonly', true);
      this.element.parent().addClass('is-readonly');

      if (!this.settings.editable) {
        this.element.parent().addClass('is-not-editable');
      }
    },


    /**
    * Returns true if the color picker is disabled.
    * @returns {void}
    */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
    * Gets the decimal as a rgb value so it can be shown in the editor
    * @private
    * @param {string} n Decimal value to convert to rgb.
    * @returns {void}
    */
    decimal2rgb: function decimal2rgb(n) {
      if (typeof n !== 'number') {
        return n;
      }

      /* eslint-disable no-bitwise */
      return 'rgb(' + (n & 0xFF) + ', ' + ((n & 0xFF00) >> 8) + ', ' + ((n & 0xFF0000) >> 16) + ')';
    },
    rgb2hex: function rgb2hex(rgb) {
      if (!rgb || rgb.search('rgb') === -1) {
        return rgb;
      } else if (rgb === 'rgba(0, 0, 0, 0)') {
        return 'transparent';
      }

      var hex = function hex(x) {
        return ('0' + parseInt(x, 10).toString(16)).slice(-2);
      };

      var newRgb = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+))?\)$/);
      return '#' + hex(newRgb[1]) + hex(newRgb[2]) + hex(newRgb[3]);
    },


    /**
    * Update the component and optionally apply new settings.
    *
    * @param  {object} settings the settings to update to.
    * @returns {object} The plugin api for chaining.
    */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      return this.destroy().init();
    },
    teardown: function teardown() {
      this.element.off('keypress.colorpicker keyup.colorpicker blur.colorpicker openlist.colorpicker change.colorpicker paste.colorpicker');
      this.swatch.off('click.colorpicker');
      this.swatch.remove();
      this.container.find('.trigger').remove();
      var input = this.container.find('.colorpicker');

      if (input.data('mask')) {
        input.data('mask').destroy();
      }

      input.unwrap();
      input.removeAttr('data-mask role aria-autocomplete');
    },


    /**
    * Detach events and restore DOM to default.
    * @returns {object} The plugin api (this).
    */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$s);
      return this;
    },


    /**
    * Detach events and restore DOM to default.
    * @private
    * @returns {void}
    */
    handleEvents: function handleEvents() {
      var _this3 = this;

      var elem = this.element;
      var elemParent = elem.parent();
      var originalVal = void 0;

      this.icon.parent().on('click.colorpicker', function () {
        _this3.toggleList();
      });

      elem.on('focus.colorpicker', function () {
        originalVal = elem.val();
        elemParent.addClass('is-focused');
      }).on('blur.colorpicker', function () {
        elemParent.removeClass('is-focused');

        // Fix: Force to change event
        // IE-Edge not firing `change event` after updated input-s values
        if (_this3.isIeEdge && !elem.is('.is-open') && originalVal !== elem.val()) {
          elem.triggerHandler('change');
        }
      }).on('openlist.colorpicker', function () {
        _this3.toggleList();
      });

      var eventStr = 'blur.colorpicker paste.colorpicker change.colorpicker';
      eventStr += this.isIe11 ? 'keypress.colorpicker' : 'keyup.colorpicker';
      elem.on(eventStr, function () {
        var val = _this3.isEditor ? elem.attr('data-value') : elem.val();
        if (_this3.settings.showLabel) {
          _this3.setColor(elem.attr('value'), val);
          return;
        }
        _this3.setColor(val);
      });

      // Handle Key Down to open
      elem.on('keydown.colorpicker', function (e) {
        if (e.keyCode === 38 || e.keyCode === 40) {
          _this3.toggleList();
        }
        if (e.keyCode === 13) {
          _this3.setColor(elem.val());
        }
      });
    }
  };

  /**
   * jQuery Component Wrapper for Colorpicker
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.colorpicker = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$s);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$s, new ColorPicker(this, settings));
      }
    });
  };

  var COMPONENT_NAME$t = 'expandablearea';

  /**
  * An expandable pane / area.
  * @class ExpandableArea
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  * @param {string} [settings.trigger = null]  Id of some other button to use as a trigger
  * @param {string} [settings.bottomBorder = false]  Change the border to bottom vs top (for some cases)
  */
  var EXPANDABLEAREA_DEFAULTS = {
    trigger: null,
    bottomBorder: false
  };

  function ExpandableArea(element, settings) {
    this.settings = utils.mergeSettings(element, settings, EXPANDABLEAREA_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Expandable Area API
  ExpandableArea.prototype = {

    /**
    * Initialize the Expandable area
    * @private
    */
    init: function init() {
      this.setup().build().handleEvents();
    },


    /**
    * Setup internal variables.
    * @private
    * @returns {object} The Api for chaining.
    */
    setup: function setup() {
      this.id = this.element.attr('id');
      if (!this.id || this.id === undefined) {
        this.id = 'expandable-area-' + $('body').find('.expandable-area').index(this.element);
      }

      this.header = this.settings.trigger ? this.element : this.element.children('.expandable-header');
      this.footer = this.element.children('.expandable-footer');
      this.content = this.element.children('.expandable-pane');

      this.isCard = this.element.is('.card, .widget');
      return this;
    },


    /**
    * Add markup to build up the component.
    * @private
    * @returns {object} The Api for chaining.
    */
    build: function build() {
      var _this = this;

      var expanded = this.element.hasClass('is-expanded');

      this.header.attr({
        'aria-expanded': '' + expanded,
        'aria-controls': this.id + '-content',
        id: this.id + '-header'
      });
      this.content.attr({
        id: this.id + '-content'
      });

      // Add the link and footer if not there already.
      // If we're using an expandable card,
      if (!this.isCard && !this.footer.length && !this.settings.trigger) {
        this.footer = $('<div class="expandable-footer"></div>').appendTo(this.element);
      }

      function getExpander(instance, useHeaderExpander) {
        var expander = void 0;

        if (useHeaderExpander === true) {
          // Use icon-based expander in the header
          expander = instance.header.find('expandable-expander');
          if (!expander.length) {
            expander = $('' + ('<a href="#" target="_self" class="btn-expander">' + '<svg class="chevron icon" focusable="false" aria-hidden="true" role="presenation">' + '<use xlink:href="#icon-caret-down"></use>' + '</svg>' + '<span class="audible">') + Locale.translate('ShowMore') + '</span>' + '</a>').appendTo(instance.header);
          }

          return expander;
        }

        // Use the text-based expander button in the footer
        expander = instance.footer.find('.expandable-expander');
        if (!expander.length) {
          expander = $('' + ('<a href="#" target="_self" class="expandable-expander hyperlink">' + '<span data-translated="true">') + Locale.translate('ShowMore') + '</span>' + '</a>').prependTo(instance.footer);
        }
        return expander;
      }

      this.expander = getExpander(this, this.isCard);
      this.expander.attr('href', '#').hideFocus();

      if (this.expander.length === 0) {
        this.expander = $('#' + this.settings.trigger);
      }

      // Change the borer to the bottom vs top
      if (this.settings.bottomBorder) {
        this.element.addClass('has-bottom-border');
      }

      // Initialized in expanded mode.
      if (expanded) {
        this.content.addClass('no-transition');
        this.element.one('afterexpand.expandable-area', function () {
          _this.content.removeClass('no-transition');
        });
        this.open();
      }

      if (!expanded) {
        this.content.addClass('no-transition');
        this.element.one('aftercollapse.expandable-area', function () {
          _this.content.removeClass('no-transition');
        });
        this.close();
      }

      this.resize();

      return this;
    },


    /**
    * Return if the expandable area is current disable or not.
    * @returns {boolean} True or False depending on the disabled status.
    */
    isDisabled: function isDisabled() {
      return this.element.hasClass('is-disabled');
    },


    /**
    * Add Keyboard Support.
    * @private
    * @param  {object} e The event we are handling.
    * @returns {void}
    */
    handleKeys: function handleKeys(e) {
      if (this.isDisabled()) {
        return null;
      }

      var key = e.which;

      if (key === 13 || key === 32) {
        // Enter/Spacebar
        e.preventDefault();
        this.toggleExpanded();
        return false;
      }

      return null;
    },


    /**
    * Toggle focus classes on focus.
    * @private
    * @returns {void}
    */
    handleFocus: function handleFocus() {
      if (this.isDisabled()) {
        return;
      }

      this.header.addClass('is-focused');
    },


    /**
    * Toggle blur classes on blur.
    * @private
    * @returns {void}
    */
    handleBlur: function handleBlur() {
      if (this.isDisabled()) {
        return;
      }

      this.header.removeClass('is-focused');
    },


    /**
    * Returns expanded status about the current expandable area
    * @returns {boolean} True of alse depending on current expanded status.
    */
    isExpanded: function isExpanded() {
      return this.element.is('.is-expanded');
    },


    /**
    * Toggle current expansion state.
    */
    toggleExpanded: function toggleExpanded() {
      // if (this.header.attr('aria-expanded') === 'true') {
      if (this.isExpanded()) {
        this.close();
      } else {
        this.open();
      }
    },


    /**
    * Open the pane if closed.
    */
    open: function open() {
      var _this2 = this;

      /**
       * Fires after a row is added via the api.
      * @event beforeexpand
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      var canExpand = this.element.triggerHandler('beforeexpand', [this.element]);

      if (canExpand === false) {
        return;
      }

      this.element.addClass('is-expanded');
      this.header.attr('aria-expanded', 'true');
      this.expander.addClass('active');

      /**
       * Fires after a row is added via the api.
      * @event expand
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      this.element.triggerHandler('expand', [this.element]);

      this.expander.find('span[data-translated="true"]').text(Locale.translate('ShowLess') ? Locale.translate('ShowLess') : 'Show Less');

      if (this.isCard) {
        this.expander.find('.icon').addClass('active');
      }

      if (this.content[0]) {
        this.content[0].style.display = 'block';
      }

      /**
       * Fires after a row is added via the api.
      * @event afterexpand
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      this.content.one('animateopencomplete', function () {
        _this2.element.triggerHandler('afterexpand', [_this2.element]);
      }).animateOpen();

      this.applyIE11Fix();
    },


    /**
    * Close the pane if open.
    */
    close: function close() {
      var _this3 = this;

      /**
      * Fires after a row is added via the api.
      * @event beforecollapse
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      var canCollapse = this.element.triggerHandler('beforecollapse', [this.element]);

      if (canCollapse === false) {
        return;
      }

      this.expander.removeClass('active');
      /**
      * Fires after a row is added via the api.
      * @event collapse
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      this.element.triggerHandler('collapse', [this.element]);
      this.expander.find('span[data-translated="true"]').text(Locale.translate('ShowMore') ? Locale.translate('ShowMore') : 'Show More');

      if (this.isCard) {
        this.expander.find('.icon').removeClass('active');
      }

      /**
      * Fires after a row is added via the api.
      * @event aftercollapse
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      this.content.one('animateclosedcomplete', function () {
        _this3.element.removeClass('is-expanded');
        _this3.header.attr('aria-expanded', 'false');
        _this3.element.triggerHandler('aftercollapse', [_this3.element]);
        _this3.content[0].style.display = 'none';
      }).animateClosed();

      this.applyIE11Fix();
    },


    /**
    * Determines if the browser is IE11 and applies a min-height fix for the overflow.
    * @private
    * @returns {void}
    */
    applyIE11Fix: function applyIE11Fix() {
      var self = this;
      var isIE11 = $('html').hasClass('ie11');
      setTimeout(function () {
        if (isIE11 && self.element.hasClass('is-expanded')) {
          self.element.css('min-height', self.element.children('.expandable-pane').outerHeight(true) + self.element.children('.expandable-footer').outerHeight(true));
        } else if (isIE11 && !self.element.hasClass('is-expanded')) {
          self.element.css('min-height', 'auto');
        }
      }, 300); // equal to transition time
    },


    /**
    * Determines if the the body has resized and fires the applyIE11Fix.
    * @private
    * @returns {void}
    */
    resize: function resize() {
      var self = this;
      $('body').on('resize.expandablearea', function () {
        self.applyIE11Fix();
      });
    },


    /**
    * Disable the expandable area from being closable.
    * @returns {void}
    */
    disable: function disable() {
      this.element.addClass('is-disabled');
    },


    /**
    * Enable the expandable area to allow close.
    * @returns {void}
    */
    enable: function enable() {
      this.element.removeClass('is-disabled');
    },


    /**
    * Destroy by removing markup and canceling events.
    * @returns {void}
    */
    destroy: function destroy() {
      this.header.children('a').off();
      this.header.off();
      this.header.removeAttr('aria-controls').removeAttr('aria-expanded').removeAttr('id');
      this.content.removeAttr('id').removeClass('no-transition');
      $.removeData(this.element[0], COMPONENT_NAME$t);
    },


    /**
     * Update the component and optionally apply new settings.
     * @param  {object} settings the settings to update to.
     * @returns {object} The plugin api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      return this;
    },


    /**
    * Attach event handlers.
    * @private
    * @returns {object} The Api for chaining.
    */
    handleEvents: function handleEvents() {
      var self = this;
      this.expander.on('click.expandablearea', function (e) {
        if (!self.isDisabled()) {
          e.preventDefault();
          self.toggleExpanded();
        }
      });

      this.header.on('keydown.expandablearea', function (e) {
        self.handleKeys(e);
      }).on('focus.expandablearea', function (e) {
        self.handleFocus(e);
      }).on('blur.expandablearea', function (e) {
        self.handleBlur(e);
      });

      return this;
    }
  };

  $.fn.expandablearea = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$t);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$t, new ExpandableArea(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$u = 'compositeform';

  /**
  * CompositeForm is a specialized responsive form component.
  * @class CompositeForm
  * @constructor
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.breakpoint = 'phone-to-tablet'] Defines the breakpoint at which the composite form will change into its responsive mode
  * @param {string} [settings.trigger = null] Expandable area trigger selector. Passed to expandable area.
  * @param {string} [settings.expandedText = Locale.translate('ShowLess')] Text to use for the expand button (Default localized)
  * @param {string} [settings.collapsedText = Locale.translate('ShowMore')] Text to use for the collapse button (Default localized)
  */
  var COMPOSITEFORM_DEFAULTS = {
    breakpoint: 'phone-to-tablet',
    trigger: null,
    expandedText: Locale.translate('ShowLess'),
    collapsedText: Locale.translate('ShowMore')
  };

  function CompositeForm(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COMPOSITEFORM_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Component API
  CompositeForm.prototype = {

    /**
    * Initialize the component
    * @private
    * @returns {object} The component api for chaining.
    */
    init: function init() {
      return this.build().handleEvents();
    },


    /**
    * Adds markup to the control and stores references to some sub-elements
    * @private
    * @returns {object} The component api for chaining.
    */
    build: function build() {
      var componentClassList = this.element[0].classList;
      if (!componentClassList.contains('composite-form')) {
        componentClassList.add('composite-form');
      }

      // Get expandable area reference, if applicable
      var expandableArea = this.element.find('.expandable-area');
      if (expandableArea.length) {
        this.hasSummary = true;
        this.expandableArea = expandableArea;
        this.expandableAreaAPI = this.expandableArea.data('expandablearea');
        if (!this.expandableAreaAPI) {
          this.expandableArea.expandablearea({ trigger: this.settings.trigger });
          this.expandableAreaAPI = this.expandableArea.data('expandablearea');
        }

        // Get expandable trigger
        this.expander = this.expandableAreaAPI.expander;
        this.setExpanderText(this.settings.expandedText);
      } else {
        this.hasSummary = false;
      }

      // Check size and append class, if necessary
      this.checkResponsive();

      return this;
    },


    /**
     * Sets up event handlers for this control and its sub-elements
     * @param {string} expanderText - the text content
     * @returns {undefined}
     */
    handleEvents: function handleEvents() {
      var self = this;

      $('body').off('resize.' + COMPONENT_NAME$u).on('resize.' + COMPONENT_NAME$u, function (e) {
        self.checkResponsive(e);
      });

      this.element.on('updated.' + COMPONENT_NAME$u, function () {
        self.updated();
      });

      function changeExpanderText() {
        var isExpanded = self.expandableAreaAPI.isExpanded();
        self.setExpanderText(self.settings[isExpanded ? 'expandedText' : 'collapsedText']);
      }

      if (this.hasSummary) {
        this.expandableArea.on('expand.' + COMPONENT_NAME$u, changeExpanderText).on('collapse.' + COMPONENT_NAME$u, changeExpanderText);
      }

      return this;
    },


    /**
     * Checks if we've passed the breakpoint for switching into Responsive mode.
     * @returns {undefined}
     */
    checkResponsive: function checkResponsive() {
      var cl = this.element[0].classList;

      if (breakpoints.isBelow(this.settings.breakpoint)) {
        cl.add('is-in-responsive-mode');
      } else {
        cl.remove('is-in-responsive-mode');
        if (this.isSideOriented() && !this.expandableAreaAPI.isExpanded()) {
          this.expandableAreaAPI.open();
        }
      }
    },


    /**
     * Sets the text content of the Composite Form's Expandable Area Expander.
     * @param {string} expanderText - the text content
     * @returns {undefined}
     */
    setExpanderText: function setExpanderText(expanderText) {
      if (!this.hasSummary) {
        return;
      }

      if (!(expanderText instanceof String) || !expanderText.length) {
        return;
      }

      var textSpan = this.expander.find('span');
      if (!textSpan) {
        textSpan = this.expander;
      }
      textSpan.text(expanderText);
    },


    /**
     * Determines if this component is configured for "on-side" orientation of the Summary area.
     * @returns {boolean} If the component is currently side oriented.
     */
    isSideOriented: function isSideOriented() {
      return this.element[0].classList.contains('on-side');
    },


    /**
     * Re-invokes the Composite Form
     * @returns {object} The component API for chaining.
     */
    updated: function updated() {
      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The component API for chaining.
     */
    teardown: function teardown() {
      $('body').off('resize.' + COMPONENT_NAME$u);
      this.element.off('updated.' + COMPONENT_NAME$u);

      if (this.hasSummary) {
        this.expandableArea.off('expand.' + COMPONENT_NAME$u + ' collapse.' + COMPONENT_NAME$u);
      }

      return this;
    },


    /**
     * Destroys the component instance by removing it from its associated element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$u);
    }
  };

  /**
   * jQuery Component Wrapper for Composite Form
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.compositeform = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$u);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$u, new CompositeForm(this, settings));
      }
    });
  };

  var COMPONENT_NAME$v = 'contextualactionpanel';

  /**
  * A more complex modal for complex in page interactions.
  * @class ContextualActionPanel
  * @param {string} element The component element.
  * @param {string} settings The component settings.
  * @param {string} [settings.id = `contextual-action-modal-cnt`]
  * The id to use for the CAP, or defaults to generated.
  * @param {array} [settings.buttons = null] A list of buttons that will sit in the toolbar's Buttonset area.
  * @param {string} [settings.title = 'Contextual Action Panel'] String that sits in the toolbar's title field.
  * @param {content} [settings.content = null] Pass content through to CAP.
  * @param {boolean} [settings.initializeContent = true] Initialize content before opening with defaults.
  * @param {string} [settings.trigger = 'click'] Can be 'click' or 'immediate'.
  * @param {boolean} [settings.centerTitle = false] If true the title will be centered.
  * @param {boolean} [settings.useFlexToolbar] If true the new flex toolbar will be used (For CAP)
  */
  var CONTEXTUALACTIONPANEL_DEFAULTS = {
    id: 'contextual-action-modal-' + (parseInt($('.modal').length, 10) + 1),
    buttons: null,
    title: 'Contextual Action Panel', //
    content: null, //
    initializeContent: true, // initialize content before opening
    trigger: 'click',
    showCloseButton: false,
    centerTitle: false
  };

  function ContextualActionPanel(element, settings) {
    this.settings = utils.mergeSettings(element, settings, CONTEXTUALACTIONPANEL_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  ContextualActionPanel.prototype = {

    /**
     * @returns {Modal|undefined} instance of an IDS modal, or undefined if one doesn't exist
     */
    get modalAPI() {
      var api = void 0;
      if (this.panel && this.panel.length) {
        api = this.panel.data('modal');
      }
      return api;
    },

    /**
    * Initialize the CAP.
    * @private
    */
    init: function init() {
      this.setup().build().handleEvents();
    },


    /**
    * Setup internal variables.
    * NOTE: Does not do any building.
    * @private
    * @returns {object} The Api for chaining.
    */
    setup: function setup() {
      this.panel = this.element.next('.contextual-action-panel');

      var dataModal = this.element.data('modal');
      if (typeof dataModal === 'string') {
        var panelFromID = $('#' + dataModal);
        if (panelFromID.length) {
          this.panel = panelFromID;
        }
      }

      // Handle case with popup triggered from a menu
      if (this.element.closest('.popupmenu').length === 1) {
        this.panel = this.element.closest('.popupmenu').next('.contextual-action-panel');
      }

      if (this.panel[0]) {
        this.panel[0].style.display = 'none';
      }
      this.panel.addClass('is-animating');

      return this;
    },


    /**
    * Add markup to build up the component.
    * @private
    * @returns {object} The Api for chaining.
    */
    build: function build() {
      var self = this;

      // Build the Content if it's not present
      if (this.panel.length === 0) {
        if (this.settings.content instanceof jQuery) {
          if (this.settings.content.is('.contextual-action-panel')) {
            this.panel = this.settings.content;
          } else {
            this.settings.content.wrap('<div class="contextual-action-panel"></div>');
            this.panel = this.settings.content.parent();
          }

          this.panel.addClass('modal').appendTo('body');

          if (this.settings.content.is('iframe')) {
            this.settings.content.ready(function () {
              self.completeBuild();
              self.settings.content.show();
            });
            return self;
          }
          this.settings.content.show();
        } else {
          this.panel = $('<div class="contextual-action-panel">' + this.settings.content + '</div>').appendTo('body');
          this.panel.addClass('modal').attr('id', this.settings.id);
        }
      }

      this.completeBuild();
      return this;
    },


    /**
    * Finalize build up/
    * @private
    * @returns {object} The Api for chaining.
    */
    completeBuild: function completeBuild() {
      var children = void 0;
      var isIframe = false;
      var contents = void 0;
      var hasSearchfield = false;
      var predefined = true;

      // Invoke Icons
      this.panel.find('svg').icon();

      // Get a reference to `.modal-content`
      var modalContent = this.panel.find('.modal-content');
      if (modalContent.length === 0) {
        children = this.panel.children();
        if (children.is('iframe')) {
          contents = children.contents();
          this.toolbar = contents.find('.toolbar, .flex-toolbar');
          isIframe = true;
        }

        if (!isIframe) {
          children.wrapAll('<div class="modal-content"></div>').wrapAll('<div class="modal-body"></div>');
          this.panel.addClass('modal');
        }
      }

      // Build/reference the header
      var modalHeader = this.panel.find('.modal-header');
      if (modalHeader.length === 0) {
        modalHeader = $('<div class="modal-header"></div>');
        modalHeader.insertBefore(this.panel.find('.modal-body'));
      }
      this.header = modalHeader;

      // Detect existence of buttonset for later
      var buttonset = this.panel.find('.toolbar .buttonset, .flex-toolbar .buttonset');

      // Build/reference the CAP header toolbar
      if (!this.toolbar) {
        this.toolbar = this.panel.find('.toolbar, .flex-toolbar');
      }
      if (!this.toolbar.length) {
        predefined = false;
        if (this.settings.buttons) {
          this.settings.buttons.forEach(function (button) {
            if (button.type === 'input') {
              hasSearchfield = true;
            }
          });
        }

        if (this.settings.title && this.settings.centerTitle) {
          var toolbarSearchfieldSection = hasSearchfield ? '<div class="toolbar-section search"></div>' : '';
          var toolbarHTML = '<div class="flex-toolbar">\n          <div class="toolbar-section static"></div>\n          <div class="toolbar-section title center-text">\n            <h2>' + this.settings.title + '</h2>\n          </div>\n          ' + toolbarSearchfieldSection + '\n          <div class="toolbar-section buttonset static"></div>\n        </div>';

          this.toolbar = $(toolbarHTML);
        } else if (!buttonset.length) {
          var toolbarCSSClass = this.settings.useFlexToolbar ? 'flex-toolbar' : 'toolbar';
          var toolbarTitleSection = this.settings.useFlexToolbar ? '<div class="toolbar-section title"><h2>' + this.settings.title + '</h2></div>' : '';
          var toolbarButtonsetCSSClass = this.settings.useFlexToolbar ? 'toolbar-section buttonset' : 'buttonset';
          var toolbarButtonsetSection = '<div class="' + toolbarButtonsetCSSClass + '"></div>';
          var _toolbarSearchfieldSection = this.settings.useFlexToolbar && hasSearchfield ? '<div class="toolbar-section search"></div>' : '';
          var _toolbarHTML = '<div class="' + toolbarCSSClass + '">\n          ' + toolbarTitleSection + '\n          ' + _toolbarSearchfieldSection + '\n          ' + toolbarButtonsetSection + '\n        </div>';

          var toolbar = $(_toolbarHTML);
          toolbar.appendTo(this.panel.find('.modal-header'));
          this.toolbar = toolbar;
          buttonset = toolbar.children('.buttonset');
        }
      }
      this.toolbar.appendTo(this.header);

      // Only add certain elements if a Toolbar was generated with JS-options
      // and not by HTML markup.
      if (!predefined) {
        if (!buttonset || !buttonset.length && !this.settings.centerTitle) {
          buttonset = $('<div class="toolbar-section buttonset"></div>');
          buttonset.appendTo(this.toolbar);
        }

        var toolbarTitle = this.toolbar.find('.title');
        if (!toolbarTitle.length) {
          var centerTextCSS = this.settings.centerTitle ? ' center-text' : '';
          toolbarTitle = $('\n          <div class="toolbar-section title' + centerTextCSS + '">\n            <h2>' + this.settings.title + '</h2>\n          </div>\n        ');

          if (buttonset) {
            toolbarTitle.insertBefore(buttonset);
          } else {
            this.toolbar.prepend(toolbarTitle);
          }
        }

        if (!toolbarTitle.length) {
          toolbarTitle = $('\n          <div class="title">\n            ' + this.settings.title + '\n          </div>\n        ');
          this.toolbar.prepend(toolbarTitle);
        }
      }

      // Move to the body element to break stacking context issues.
      if (!isIframe) {
        this.panel.detach().appendTo('body');
      }

      this.element.attr('data-modal', this.settings.id);
      if (!this.panel.attr('id')) {
        this.panel.attr('id', this.settings.id);
      }

      this.panel.modal({
        buttons: this.settings.buttons,
        centerTitle: this.settings.centerTitle,
        useFlexToolbar: this.settings.useFlexToolbar,
        trigger: this.settings.trigger ? this.settings.trigger : 'click'
      });

      this.buttons = this.panel.find('.buttonset').children('button');

      this.closeButton = this.panel.find('.modal-header').find('.btn-close, [name="close"], button.close-button');
      if (!predefined && this.settings.showCloseButton && !this.closeButton.length) {
        this.closeButton = $('\n        <button class="btn-close" type="button">\n          <svg class="icon icon-close" focusable="false" aria-hidden="true" role="presentation">\n            <use xlink:href="#icon-close"></use>\n          </svg>\n          <span>Close</span>\n        </button>\n      ');

        if (!this.settings.useFlexToolbar) {
          var CAPToolbarButton = $('<div class="close-button"></div>').append(this.closeButton);
          this.header.append(CAPToolbarButton);
        } else {
          var standaloneSection = $('<div class="toolbar-section static"></div>').append(this.closeButton);
          var more = this.toolbar.find('.toolbar-section.more');
          standaloneSection.after(more.length ? more : buttonset);
        }
      }

      if (this.closeButton.length) {
        this.toolbar.addClass('has-close-button');
      }

      if (this.toolbar.is('.toolbar')) {
        this.toolbar.toolbar();
      }
      if (this.toolbar.is('.flex-toolbar')) {
        this.toolbar.toolbarflex();
      }

      utils.fixSVGIcons(this.element);
      return this;
    },


    /**
    * Attach event handlers.
    * @private
    * @returns {object} The Api for chaining.
    */
    handleEvents: function handleEvents() {
      var self = this;

      // Convenience method that takes an event from the Modal control's panel element,
      // and triggers any listeners that may be looking at the Contextual Action Panel's
      // trigger instead.
      function passEvent(e) {
        self.element.triggerHandler(e.type);
      }

      this.panel.addClass('is-animating').on('open.contextualactionpanel', function (e) {
        passEvent(e);
        self.panel.removeClass('is-animating');
      }).on('beforeclose.contextualactionpanel', function () {
        self.panel.addClass('is-animating');
      }).on('close.contextualactionpanel', function (e) {
        passEvent(e);
      }).on('beforeopen.contextualactionpanel', function (e) {
        if (self.settings.initializeContent) {
          $(this).initialize();
        }
        passEvent(e);
      }).on('afteropen.contextualactionpanel', function () {
        if (self.toolbar) {
          self.toolbar.trigger('recalculate-buttons');
        }

        // Select the proper element on the toolbar
        if (self.toolbar.length) {
          var selected = self.toolbar.find('.buttonset > .is-selected');
          if (!selected.length) {
            selected = self.toolbar.find('.buttonset > *:first-child');
            if (selected.is('.searchfield-wrapper')) {
              selected = selected.children('.searchfield');
            }
          }
          if (!selected.length && self.toolbar.is('.flex-toolbar')) {
            selected = self.toolbar.find('button').first();
            selected.focus();
            return;
          }
          var toolbarData = self.toolbar.data('toolbar');
          if (toolbarData) {
            toolbarData.setActiveButton(selected, true);
          }
        }

        // Focus the first focusable element inside the Contextual Panel's Body
        self.panel.find('.modal-body-wrapper').find(':focusable').first().focus();
        utils.fixSVGIcons(self.panel);
      });

      if (self.closeButton && self.closeButton.length) {
        self.closeButton.on('click.contextualactionpanel', function () {
          self.handleToolbarSelected();
        });
      }

      return this;
    },


    /**
    * Toolbar select event handler.
    * @private
    * @returns {void}
    */
    handleToolbarSelected: function handleToolbarSelected() {
      this.close();
    },


    /**
    * Detach events and restore markup.
    * @private
    * @returns {void}
    */
    teardown: function teardown() {
      var self = this;
      var buttonset = self.toolbar.children('.buttonset');

      this.panel.off('open.contextualactionpanel close.contextualactionpanel ' + 'beforeopen.contextualactionpanel afterclose.contextualactionpanel');

      buttonset.children('*:not(.searchfield)').off('click.contextualactionpanel');

      var menuButtons = buttonset.children('.btn-menu');
      menuButtons.each(function () {
        var popup = $(this).data('popupmenu');
        if (popup) {
          popup.destroy();
        }
      });

      if (self.header) {
        self.header.remove();
      }

      var children = self.panel.find('.modal-body').children();
      children.first().unwrap().unwrap();

      self.element.removeAttr('data-modal');

      if (self.closeButton && self.closeButton.length) {
        self.closeButton.off('click.contextualactionpanel');
        delete self.closeButton;
      }

      // Trigger an afterclose event on the Contextual Action Panel's trigger element
      // (different from the panel, which is already removed).
      self.element.trigger('afterteardown');
    },


    /**
    * Close the Contextual Action Panel if open and call destroy.
    * @returns {void}
    */
    close: function close() {
      var destroy = void 0;
      if (this.settings.trigger === 'immediate') {
        destroy = true;
      }

      if (this.modalAPI) {
        this.modalAPI.close(destroy);
      }
    },


    /**
    * Add a disabled attribute to the main component element.
    * @returns {void}
    */
    disable: function disable() {
      this.element.prop('disabled', true);
      if (this.panel.hasClass('is-visible')) {
        this.close();
      }
    },


    /**
    * Remove disabled attribute from the main component element.
    * @returns {void}
    */
    enable: function enable() {
      this.element.prop('disabled', false);
    },


    /**
     * Update the component and optionally apply new settings.
     *
     * @param  {object} settings the settings to update to.
     * @returns {object} The plugin api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      this.setup();

      this.modalAPI.updated(settings);
      return this;
    },


    /**
    * Destroy and remove added markup and events
    * @returns {void}
    */
    destroy: function destroy() {
      // ModalAPI calls `capAPI.teardown()` at the correct timing
      if (this.modalAPI && this.modalAPI.isOpen) {
        this.modalAPI.close(true);
      }
      $.removeData(this.element[0], COMPONENT_NAME$v);
    }
  };

  /**
   * jQuery Component Wrapper for Contextual Action Panel
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.contextualactionpanel = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$v);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$v, new ContextualActionPanel(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$w = 'tooltip';

  /**
   * Tooltip and Popover Control
   * @class Tooltip
   * @constructor
   *
   * @param {htmlelement|jquery[]} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string|function} [settings.content] Takes title attribute or feed content. Can be a string or jQuery markup.
   * @param {object} [settings.offset={top: 10, left: 10}] How much room to leave.
   * @param {string} [settings.placement='top'] Supports 'top'|'bottom'|'right'|'offset'.
   * @param {string} [settings.trigger='hover'] Supports click and immediate and hover (and maybe in future focus).
   * @param {string} [settings.title] Title for Infor Tips.
   * @param {string} [settings.beforeShow] Call back for ajax tooltip.
   * @param {string} [settings.popover] force it to be a popover (no content).
   * @param {string} [settings.closebutton] Show X close button next to title in popover.
   * @param {boolean} [settings.isError=false] Add error classes.
   * @param {boolean} [settings.isErrorColor=false] Add error color only not description.
   * @param {string} [settings.tooltipElement] ID selector for an alternate element to use to contain the tooltip classes.
   * @param {object} [settings.parentElement] jQuery-wrapped element that gets.
    passed to the 'place' behavior as the element to place the tooltip against.
   * @param {boolean} [settings.keepOpen=false] Forces the tooltip to stay open in situations where it would normally close.
   * @param {string} [settings.extraClass] Extra css class.
   * @param {object} [settings.placementOpt] Placement options.
   * @param {string} [settings.maxWidth] Toolip max width.
   * @param {boolean} [settings.initializeContent] Init the content in the tooltip.
   * @param {string} [settings.headerClass] If set this color will be used on the header (if a popover).
   */

  var TOOLTIP_DEFAULTS = {
    content: null,
    offset: { top: 10, left: 10 },
    placement: 'top',
    trigger: 'hover',
    title: null,
    beforeShow: null,
    popover: null,
    closebutton: null,
    isError: false,
    isErrorColor: false,
    tooltipElement: null,
    parentElement: null,
    keepOpen: false,
    extraClass: null,
    placementOpts: {},
    maxWidth: null,
    initializeContent: true,
    headerClass: null
  };

  function Tooltip(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TOOLTIP_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  Tooltip.prototype = {

    /**
     * @returns {boolean} whether or not the tooltip/popover is currently showing
     */
    get visible() {
      return DOM.hasClass(this.element[0], 'is-hidden') === false;
    },

    /**
     * @returns {Popupmenu|undefined} if a Popupmenu API exists on the trigger element
     */
    get popupmenuAPI() {
      return this.element.data('popupmenu');
    },

    /**
     * Initializes the component
     * @private
     * @returns {void}
     */
    init: function init() {
      this.uniqueId = utils.uniqueId(this.element, 'tooltip');
      this.isTouch = Environment.features.touch;
      this.setup();
      this.appendTooltip();

      // Initial Content Setting.
      // Don't do this if we're using an "immediate" trigger because _setContent()_ is handled at
      // display time in that case.
      var shouldRender = this.settings.trigger !== 'immediate';
      if (shouldRender) {
        this.setContent(this.settings.content, true);
      }

      this.handleEvents();
    },


    /**
     * Builds internal references
     * @private
     * @returns {void}
     */
    setup: function setup() {
      // "this.activeElement" is the target element that the Tooltip will display itself against
      this.activeElement = this.settings.parentElement instanceof $ && this.settings.parentElement.length ? this.settings.parentElement : this.element;

      this.descriptionId = $('.tooltip-description').length + 1;
      this.description = this.element.parent().find('.tooltip-description');
      if (!this.description.length && this.settings.isError) {
        this.description = $('<span id="tooltip-description-' + this.descriptionId + '" class="tooltip-description audible"></span>').insertAfter(this.element);
      }

      if (this.element.is('.dropdown, .multiselect')) {
        this.activeElement = this.element.nextAll('.dropdown-wrapper:first').find('>.dropdown');
      }

      var titleAttr = this.element.attr('title');
      if (!this.settings.popover && titleAttr && titleAttr.length || !this.settings.popover && this.settings.title) {
        this.settings.content = this.settings.title ? this.settings.title : titleAttr;
        this.element.removeAttr('title');
      }

      if (this.settings.trigger === 'hover' && this.isTouch) {
        this.element.addClass('longpress-target');
      }

      this.isPopover = this.settings.content !== null && _typeof(this.settings.content) === 'object' || this.settings.popover === true;

      this.settings.closebutton = !!(this.settings.closebutton || this.element.data('closebutton'));

      if (this.element.data('extraClass') && this.element.data('extraClass').length) {
        this.settings.extraClass = this.element.data('extraClass');
      }

      this.isRTL = Locale.isRTL();
    },


    /**
     * Adds ARIA attributes on some elements for better accessiblity.
     * @private
     * @returns {void}
     */
    addAria: function addAria() {
      if (!this.content) {
        return;
      }

      this.description.text(this.content);
      this.content = this.addClassToLinks(this.content, 'links-clickable');

      if (!this.isPopover) {
        this.element.removeAttr('title').attr('aria-describedby', this.description.attr('id'));
      }

      if (this.isPopover && this.settings.trigger === 'click') {
        this.element.attr('aria-haspopup', true);
      }
    },


    /**
     * @param {jquery[]|string} content HTML or String-based content.
     * @param {string} [thisClass] optional, additional CSS class that gets appeneded to any anchor tags inside of the content.
     * @returns {string} the appended content
     */
    addClassToLinks: function addClassToLinks(content, thisClass) {
      var isjQuery = content instanceof $ && content.length > 0;
      if (isjQuery) {
        return content;
      }

      var d = $('<div/>').html(content);
      $('a', d).addClass(thisClass);
      return d.html();
    },


    /**
     * Gets a reference to the element being used for the tooltip and positions it in the correct spot on the page.
     * @private
     * @returns {void}
     */
    appendTooltip: function appendTooltip() {
      this.tooltip = this.settings.tooltipElement ? $(this.settings.tooltipElement) : $('#tooltip');
      if (!this.tooltip.length) {
        var name = this.settings.tooltipElement ? this.settings.tooltipElement.substring(1, this.settings.tooltipElement.length) : 'tooltip';
        this.tooltip = $('<div class="' + (this.isPopover ? 'popover' : 'tooltip') + ' bottom is-hidden" role="tooltip" id="' + name + '"><div class="arrow"></div><div class="tooltip-content"></div></div>');
      }

      this.tooltip.place({
        container: this.scrollparent,
        parent: this.activeElement,
        placement: this.settings.placement,
        strategy: 'flip'
      });

      this.setTargetContainer();
    },


    /**
     * Sets up all event listeners for this component
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;
      var delay = 400;
      var timer = void 0;

      function showOnTimer() {
        clearTimeout(timer);
        timer = setTimeout(function () {
          if (self.element.is(':visible')) {
            self.show();
          }
        }, delay);
      }

      function hideOnTimer() {
        clearTimeout(timer);
        timer = setTimeout(function () {
          self.hide();
        }, delay);
      }

      function showImmediately() {
        clearTimeout(timer);
        self.show();
      }

      function hideImmediately() {
        clearTimeout(timer);
        self.hide();
      }

      if (this.settings.trigger === 'hover' && !this.settings.isError) {
        (this.element.is('.dropdown, .multiselect, span.longpress-target') ? this.activeElement : this.element).on('mouseenter.' + COMPONENT_NAME$w, function () {
          if (self.isTouch) {
            return;
          }
          showOnTimer();
        }).on('mouseleave.' + COMPONENT_NAME$w, function () {
          hideOnTimer();
        }).on('click.' + COMPONENT_NAME$w, function () {
          if (self.isTouch) {
            return;
          }
          showImmediately();
        }).on('longpress.' + COMPONENT_NAME$w, function () {
          showImmediately();
        }).on('updated.' + COMPONENT_NAME$w, function () {
          self.updated();
        });
      }

      function toggleTooltipDisplay() {
        if (!self.visible) {
          hideImmediately();
        } else {
          showImmediately();
        }
      }

      if (this.settings.trigger === 'click') {
        this.element.on('click.' + COMPONENT_NAME$w, function () {
          toggleTooltipDisplay();
        });
      }

      if (this.settings.trigger === 'immediate') {
        timer = setTimeout(function () {
          toggleTooltipDisplay();
        }, 1);
      }

      var isFocusable = this.settings.trigger === 'focus';
      if (isFocusable) {
        this.element.on('focus.' + COMPONENT_NAME$w, function () {
          showImmediately();
        }).on('blur.' + COMPONENT_NAME$w, function () {
          if (!self.settings.keepOpen) {
            hideImmediately();
          }
        });
      }

      // Close the popup/tooltip on orientation changes (but not when keyboard is open)
      $(window).on('orientationchange.' + COMPONENT_NAME$w, function () {
        if (!self.visible) {
          return;
        }
        hideImmediately();
      }, false);
    },


    /**
     * Sets the content used inside the Tooltip element.
     * @private
     * @param {jquery[]|string|function} content incoming content to be set
     * @param {boolean} dontRender causes the tooltip to prevent a visual refresh
      after changing its content, meaning it will keep the previous content visible until this tooltip is closed or manually re-drawn.
     * @returns {boolean} whether or not the render was successful
     */
    setContent: function setContent(content, dontRender) {
      var self = this;
      var settingsContent = this.settings.content;
      var noIncomingContent = content === undefined || content === null;
      var noSettingsContent = settingsContent === undefined || settingsContent === null;

      function doRender() {
        if (dontRender === true) {
          return;
        }
        self.addAria();
        self.render();
      }

      // If all sources of content are undefined, just return false and don't show anything.
      if (noIncomingContent && noSettingsContent) {
        return false;
      }

      // If the settingsContent type is a function, we need to re-run that function
      // to update the content.
      // NOTE: If you need to use a function to generate content, understand that the
      //  tooltip/popover will not cache your content for future reuse.  It will ALWAYS
      //  override incoming content.
      if (typeof settingsContent === 'function') {
        content = settingsContent;
      }

      // Use the pre-set content if we have no incoming content
      if (noIncomingContent) {
        content = settingsContent;
      }

      // If the incoming/preset content is exactly the same as the stored content,
      // don't continue with this step. Deep object comparison for jQuery objects
      // is done further down the chain.
      if (content === this.content) {
        doRender();
        return true;
      }

      // jQuery-wrapped elements don't get manipulated.
      // Simply store the reference, render, and return.
      if (content instanceof $ && content.length) {
        this.content = content.addClass('hidden');
        doRender();
        return true;
      }

      // Handle setting of content based on its Object type.
      // If type isn't handled, the tooltip will not display.
      if (typeof content === 'string') {
        if (!content.length) {
          return false;
        }

        // Could be a translation definition
        content = Locale.translate(content, true) || content;

        // Could be an ID attribute.
        // If it matches an element already on the page, grab that element's content
        // and store the reference only.
        if (content.indexOf('#') === 0) {
          var contentCheck = $('' + content);
          if (contentCheck.length) {
            this.content = contentCheck;
            doRender();
            return true;
          }
          return false;
        }

        // functions
      } else if (typeof content === 'function') {
        var callbackResult = content.call(this.element);
        if (!callbackResult || typeof callbackResult !== 'string' || !callbackResult.length) {
          return false;
        }
        content = callbackResult;

        // if type isn't handled, return false
      } else {
        return false;
      }

      // Store an internal copy of the processed content
      this.content = xssUtils.sanitizeHTML(content);

      // Wrap tooltip content in <p> tags if there isn't already one present.
      // Only happens for non-jQuery markup.
      this.content = '<p>' + this.content + '</p>';

      doRender();
      return true;
    },


    /**
     * Renders internal content either as a Tooltip or Popover.
     * @private
     * @returns {void}
     */
    render: function render() {
      if (this.isPopover) {
        return this.renderPopover();
      }
      return this.renderTooltip();
    },


    /**
     * Renders internal content as a Tooltip.
     * @private
     * @returns {void}
     */
    renderTooltip: function renderTooltip() {
      var titleArea = this.tooltip[0].querySelectorAll('.tooltip-title')[0];
      var contentArea = this.tooltip[0].querySelectorAll('.tooltip-content')[0];
      var extraClass = this.settings.extraClass;
      var content = this.content;
      var tooltip = this.tooltip[0];
      var classes = 'tooltip is-hidden';

      if (extraClass) {
        classes += ' ' + extraClass;
      }
      tooltip.setAttribute('class', classes);

      if (titleArea) {
        titleArea.style.display = 'none';
      }

      if (!contentArea.previousElementSibling.classList.contains('arrow')) {
        contentArea.insertAdjacentHTML('beforebegin', '<div class="arrow"></div>');
      }

      var tooltipHTML = typeof this.content === 'string' ? content : content[0].innerHTML;
      DOM.html(contentArea, tooltipHTML, '<div><p><span><ul><li><a><abbr><b><i><kbd><small><strong><sub><svg><use><br>');
    },


    /**
     * Renders internal content as a Tooltip.
     * @private
     * @returns {void}
     */
    renderPopover: function renderPopover() {
      var self = this;
      var extraClass = this.settings.extraClass;
      var contentArea = this.tooltip.find('.tooltip-content');
      var title = this.tooltip[0].querySelector('.tooltip-title');
      var content = this.content;
      var classes = 'popover is-hidden';

      if (extraClass) {
        classes += ' ' + extraClass;
      }

      this.tooltip[0].setAttribute('class', classes);

      if (typeof content === 'string') {
        content = $(content);
        contentArea.html(content);
        contentArea.find('.hidden').removeClass('hidden');
      } else {
        contentArea.html(content);
      }

      var popoverWidth = contentArea.width();

      if (!this.settings.placementOpts) {
        this.settings.placementOpts = {};
      }

      if (!this.settings.placementOpts.parent) {
        this.settings.placementOpts.parent = this.element;
      }

      content[0].classList.remove('hidden');
      contentArea[0].firstElementChild.classList.remove('hidden');

      var parentWidth = this.settings.placementOpts.parent.width();

      if (Locale.isRTL()) {
        this.settings.placementOpts.parentXAlignment = parentWidth > popoverWidth ? 'left' : 'right';
      } else {
        this.settings.placementOpts.parentXAlignment = parentWidth > popoverWidth ? 'right' : 'left';
      }

      if (this.settings.title !== null) {
        if (!title) {
          var titleFrag = document.createDocumentFragment();
          title = document.createElement('div');
          DOM.html(title, this.settings.title, '*');
          title.classList.add('tooltip-title');

          if (this.settings.headerClass) {
            DOM.addClass(title, this.settings.headerClass, 'filled');
          }
          titleFrag.appendChild(title);
          this.tooltip[0].insertBefore(titleFrag, this.tooltip[0].firstChild);
        } else {
          title.style.display = '';
          title.childNodes[0].nodeValue = this.settings.title;
        }
      } else if (title) {
        title.style.display = 'none';
      }

      if (this.settings.closebutton && title && !title.firstElementChild) {
        var closeBtnX = $('<button type="button" class="btn-icon l-pull-right btn-close">' + $.createIcon({ classes: ['icon-close'], icon: 'close' }) + '<span>Close</span>' + '</button>').on('click', function () {
          self.hide(true);
        });

        title.appendChild(closeBtnX[0]);
      }

      if (this.settings.initializeContent) {
        content.initialize();
      }
    },


    /**
     * Alias for _show()_.
     * @private
     * @returns {void}
     */
    open: function open() {
      return this.show();
    },


    /**
     * Causes the tooltip to become shown
     * @param {object} newSettings an object containing changed settings that will be
     *  applied to the Tooltip/Popover before it's displayed.
     * @param {boolean} ajaxReturn causes an AJAX-powered Tooltip/Popover not to refresh.
     */
    show: function show(newSettings, ajaxReturn) {
      var self = this;
      this.isInPopup = false;

      if (newSettings) {
        this.settings = utils.mergeSettings(this.element[0], newSettings, this.settings);
      }

      // Don't open if this is an Actions Button with an open popupmenu
      if (this.popupmenuAPI && this.popupmenuAPI.isOpen) {
        return;
      }

      if (this.settings.beforeShow && !ajaxReturn) {
        var response = function response(content) {
          if (typeof content === 'boolean' && !content) {
            return;
          }
          self.content = content;
          self.show({ content: content }, true);
        };

        if (typeof this.settings.beforeShow === 'string') {
          window[this.settings.beforeShow](response, this.element);
          return;
        }

        this.settings.beforeShow(response, this.element);
        return;
      }

      var okToShow = true;

      okToShow = this.setContent(this.content);
      if (okToShow === false) {
        return;
      }

      /**
       * Fires before show the tooltip.
       *
       * @event beforeshow
       * @memberof Tooltip
       * @property {object} event - The jquery event object
       * @property {object} tooltip - instance
       */
      okToShow = this.element.triggerHandler('beforeshow', [this.tooltip]);
      if (okToShow === false) {
        return;
      }

      this.tooltip[0].removeAttribute('style');
      this.tooltip[0].classList.add(this.settings.placement);

      if (this.settings.isError || this.settings.isErrorColor) {
        this.tooltip[0].classList.add('is-error');
      }

      this.position();
      utils.fixSVGIcons(this.tooltip);
      /**
       * Fires on show the tooltip.
       *
       * @event show
       * @memberof Tooltip
       * @property {object} event - The jquery event object
       * @property {object} tooltip - instance
       */
      this.element.trigger('show', [this.tooltip]);

      var mouseUpEventName = this.isTouch ? 'touchend' : 'mouseup';

      setTimeout(function () {
        $(document).on(mouseUpEventName + '.' + COMPONENT_NAME$w + '-' + self.uniqueId, function (e) {
          var target = $(e.target);

          if (self.settings.isError || self.settings.trigger === 'focus') {
            return;
          }

          if (target.is(self.element) && target.is('svg.icon')) {
            return;
          }

          if ($('#editor-popup').length && $('#colorpicker-menu').length) {
            return;
          }

          if (target.closest('.popover').length === 0 && target.closest('.dropdown-list').length === 0) {
            self.hide();
          }

          // Closes patepicker dialog closes when clicking on a parent popover
          if (target.closest('.popover').length === 1 && target.closest('.popover').not('.monthview-popup').length && self.element.prev().is('.datepicker')) {
            self.hide(e);
          }
        }).on('keydown.' + COMPONENT_NAME$w + '-' + self.uniqueId, function (e) {
          if (e.which === 27 || self.settings.isError) {
            self.hide();
          }
        });

        if (self.settings.isError && !self.element.is(':visible, .dropdown') && self.element.is('[aria-describedby]')) {
          self.hide();
        }

        if (window.orientation === undefined) {
          $('body').on('resize.' + COMPONENT_NAME$w, function () {
            self.hide();
          });
        }

        // Hide on Page scroll
        $('body').on('scroll.' + COMPONENT_NAME$w, function () {
          self.hide();
        });

        self.element.closest('.modal-body-wrapper').on('scroll.tooltip', function () {
          self.hide();
        });

        self.element.closest('.scrollable').on('scroll.tooltip', function () {
          self.hide();
        });

        self.element.closest('.datagrid-body').on('scroll.tooltip', function () {
          self.hide();
        });

        // Click to close
        if (self.settings.isError) {
          self.tooltip.on('click.' + COMPONENT_NAME$w, function () {
            self.hide();
          });
        }
        /**
         * Fires after show the tooltip.
         *
         * @event aftershow
         * @memberof Tooltip
         * @property {object} event - The jquery event object
         * @property {object} tooltip - instance
         */
        self.element.trigger('aftershow', [self.tooltip]);
      }, 400);
    },


    /**
     * Places the tooltip element itself in the correct DOM element.
     * If the current element is inside a scrollable container, the tooltip element
     *  goes as high as possible in the DOM structure.
     * @returns {void}
     */
    setTargetContainer: function setTargetContainer() {
      var targetContainer = $('body');

      // adjust the tooltip if the element is being scrolled inside a scrollable DIV
      this.scrollparent = this.element.closest('.page-container.scrollable');
      if (this.scrollparent.length) {
        targetContainer = this.scrollparent;
      }

      if (this.settings.parentElement) {
        targetContainer = this.settings.parentElement;
      }

      // this.tooltip.detach().appendTo(targetContainer);
      targetContainer[0].appendChild(this.tooltip[0]);
    },


    /**
     * Placement behavior's "afterplace" handler.
     * DO NOT USE FOR ADDITIONAL POSITIONING.
     * @private
     * @param {jquery.event} e custom `afterPlace` event
     * @param {placementobject} placementObj object containing placement settings
     * @returns {void}
     */
    handleAfterPlace: function handleAfterPlace(e, placementObj) {
      this.tooltip.data('place').setArrowPosition(e, placementObj, this.tooltip);
      this.tooltip.triggerHandler('tooltipafterplace', [placementObj]);
    },


    /**
     * Resets the current position of the tooltip.
     * @returns {this} component instance
     */
    position: function position() {
      this.setTargetContainer();
      this.tooltip[0].classList.remove('is-hidden');

      var self = this;
      var distance = this.isPopover ? 20 : 10;
      var tooltipPlacementOpts = this.settings.placementOpts || {};
      var opts = $.extend({}, {
        x: 0,
        y: distance,
        container: this.scrollparent,
        containerOffsetX: tooltipPlacementOpts.containerOffsetX || this.settings.offset.left,
        containerOffsetY: tooltipPlacementOpts.containerOffsetY || this.settings.offset.top,
        parent: tooltipPlacementOpts.parent || this.activeElement,
        placement: tooltipPlacementOpts.placement || this.settings.placement,
        strategies: ['flip', 'nudge']
      }, tooltipPlacementOpts);

      if (opts.placement === 'left' || opts.placement === 'right') {
        opts.x = distance;
        opts.y = 0;
      }

      this.tooltip.one('afterplace.tooltip', function (e, placementObj) {
        self.handleAfterPlace(e, placementObj);
      });

      // Tool tip may be cleaned up on a modal or CAP
      if (this.tooltip.data('place')) {
        this.tooltip.data('place').place(opts);
      } else {
        this.tooltip.place(opts);
        this.tooltip.data('place').place(opts);
      }
      return this;
    },


    /**
     * Alias for _hide()_ that works with the global _closeChildren()_ method.
     * @private
     * @returns {void}
     */
    close: function close() {
      return this.hide();
    },


    /**
     * Hides the Tooltip/Popover
     * @param {boolean} [force] Force the tooltip to hide no matter the settings.
     * @returns {void}
     */
    hide: function hide(force) {
      if (this.settings.keepOpen && !force || !this.visible) {
        return;
      }

      if (this.isInPopup) {
        this.settings.content.addClass('hidden');
        return;
      }

      this.tooltip[0].classList.add('is-hidden');
      this.tooltip[0].style.left = '';
      this.tooltip[0].style.top = '';
      this.tooltip.find('.arrow').removeAttr('style');

      this.detachOpenEvents();

      if ($('.popover').not('.is-hidden').length === 0) {
        $(document).off('mouseup.tooltip keydown.tooltip');
        $('body').off('resize.tooltip');
      }

      /**
       * Fires when hide the tooltip.
       *
       * @event hide
       * @memberof Tooltip
       * @property {object} event - The jquery event object
       * @property {object} tooltip - instance
       */
      this.element.triggerHandler('hide', [this.tooltip]);
    },


    /**
     * Causes the tooltip to store updated settings and re-render itself.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      var self = this;
      if (self.settings.trigger === 'immediate') {
        setTimeout(function () {
          self.show();
        }, 100);
      } else {
        self.setContent();
      }

      return this;
    },


    /**
     * Removes any events which would cause the tooltip/popover to re-open.
     * @private
     * @returns {void}
     */
    detachOpenEvents: function detachOpenEvents() {
      this.tooltip.off('click.' + COMPONENT_NAME$w);

      $(document).off(['keydown.' + COMPONENT_NAME$w + '-' + self.uniqueId, 'mouseup.' + COMPONENT_NAME$w + '-' + self.uniqueId, 'touchend.' + COMPONENT_NAME$w + '-' + self.uniqueId].join(' '));

      $('body').off(['resize.' + COMPONENT_NAME$w, 'scroll.' + COMPONENT_NAME$w].join(' '));

      this.element.closest('.modal-body-wrapper').off('scroll.' + COMPONENT_NAME$w);
      this.element.closest('.scrollable').off('scroll.' + COMPONENT_NAME$w);
      this.element.closest('.datagrid-body').off('scroll.' + COMPONENT_NAME$w);
    },


    /**
     * Tears down this component instance, removing all internal flags and unbinding events.
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.description.remove();
      this.descriptionId = undefined;
      this.activeElement = undefined;

      this.element.removeAttr('aria-describedby').removeAttr('aria-haspopup');
      if (!this.tooltip.hasClass('is-hidden')) {
        this.hide();
      }

      if (this.tooltip && this.tooltip.data('place')) {
        this.tooltip.data('place').destroy();
      }

      this.element.off(['mouseenter.' + COMPONENT_NAME$w, 'mouseleave.' + COMPONENT_NAME$w, 'longpress.' + COMPONENT_NAME$w, 'click.' + COMPONENT_NAME$w, 'updated.' + COMPONENT_NAME$w, 'focus.' + COMPONENT_NAME$w, 'blur.' + COMPONENT_NAME$w].join(' '));

      this.detachOpenEvents();

      $(window).off('orientationchange.' + COMPONENT_NAME$w);

      return this;
    },


    /**
     * Destroys this component instance
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$w);
    }
  };

  /**
   * jQuery Component Wrapper for Tooltip/Popover
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.tooltip = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$w);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$w, new Tooltip(this, settings));
      }
    });
  };

  // The Tooltip Component and Popover Component use the same prototype with different settings.
  // Simply setup the Popover to be the same thing as the Tooltip.
  $.fn.popover = $.fn.tooltip;

  // Name of this component.
  var COMPONENT_NAME$x = 'dropdown';

  // Dropdown Settings and Options
  var moveSelectedOpts = ['none', 'all', 'group'];
  var reloadSourceStyles = ['none', 'open', 'typeahead'];

  /**
  * The Dropdown allows users to select from a list. Like an Html Select.
  * @class Dropdown
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.closeOnSelect = true]  When an option is selected, the list will close if set to "true".  List stays open if "false".
  * @param {string} [settings.cssClass = null]  Append an optional css class to dropdown-list
  * @param {string} [settings.filterMode = 'contains']  Search mode to use between 'startsWith' and 'contains', false will not allow client side filter
  * @param {boolean} [settings.noSearch = false]  If true, disables the ability of the user to enter text
  * in the Search Input field in the open combo box
  * @param {boolean} [settings.showEmptyGroupHeaders = false]  If true, displays optgroup headers in the list
  * even if no selectable options are present underneath.
  * @param {boolean} [settings.source]  A function that can do an ajax call.
  * @param {boolean} [settings.sourceArguments = {}]  If a source method is defined, this flexible object can be
  * passed into the source method, and augmented with parameters specific to the implementation.
  * @param {boolean|string} [settings.reload = 'none']  Determines how a Dropdown list will repopulate its contents, when operating via AJAX.
  * @param {boolean} [settings.reloadSourceOnOpen = false]  If set to true, will always perform an ajax call
  * whenever the list is opened.  If false, the first AJAX call's results are cached.
  * @param {boolean} [settings.empty = false]  Initialize Empty Value
  * @param {boolean} [settings.delay = 300]  Typing buffer delay in ms
  * @param {number} [settings.maxWidth = null] If set the width of the dropdown is limited to this pixel width.
  * Fx 300 for the 300 px size fields. Default is size of the largest data.
  * @param {object} [settings.placementOpts = null]  Gets passed to this control's Place behavior
  * @param {function} [settings.onKeyDown = null]  Allows you to hook into the onKeyDown. If you do you can access the keydown event data. And optionally return false to cancel the keyDown action.
  */
  var DROPDOWN_DEFAULTS = {
    closeOnSelect: true,
    cssClass: null,
    filterMode: 'contains',
    maxSelected: undefined, // (multiselect) sets a limit on the number of items that can be selected
    moveSelected: 'none',
    moveSelectedToTop: undefined,
    multiple: false, // Turns the dropdown into a multiple selection box
    noSearch: false,
    showEmptyGroupHeaders: false,
    showSelectAll: false, // (Multiselect) shows an item the top of the list labeled "select all".
    source: undefined,
    sourceArguments: {},
    reload: reloadSourceStyles[0],
    empty: false,
    delay: 300,
    maxWidth: null,
    placementOpts: null,
    onKeyDown: null
  };

  function Dropdown(element, settings) {
    this.settings = utils.mergeSettings(element, settings, DROPDOWN_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Actual DropDown Code
  Dropdown.prototype = {

    /**
     * @returns {array|string} currently-selected options
     */
    get value() {
      var reload = this.settings.reload;
      var multiple = this.settings.multiple;

      if (reload === 'typeahead') {
        if (multiple) {
          return this.selectedValues;
        }
        return this.element.val();
      }

      var result = [];
      var options = this.element[0].options;
      var opt = void 0;

      for (var i = 0; i < options.length; i++) {
        opt = options[i];
        if (opt.selected) {
          result.push(opt.value || opt.text);
        }
      }

      if (!multiple && result.length === 1) {
        return result[0];
      }
      return result;
    },

    /**
     * @returns {boolean} whether or not the text inside the in-page pseudo element too big to fit
     */
    get overflowed() {
      var span = this.pseudoElem.find('span').css('max-width', '');
      if (span.width() > this.pseudoElem.width()) {
        span.css('max-width', '100%');
        return true;
      }
      return false;
    },

    /**
     * Initialize the dropdown.
     * @private
     * @returns {object} The api for chaining
     */
    init: function init() {
      var orgId = this.element.attr('id');
      orgId = orgId ? xssUtils.stripTags(orgId) : '';

      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = this.element.parent().is('.inline');

      this.timer = null;
      this.filterTerm = '';

      if (!orgId) {
        orgId = utils.uniqueId(this.element, 'dropdown');
        DOM.setAttribute(this.element[0], 'id', orgId);
        DOM.setAttribute(this.element.parent().find('label').first()[0], 'for', orgId);
      }

      if (Environment.os.name === 'ios' || Environment.os.name === 'android') {
        this.settings.noSearch = true;
      }

      // convert <select> tag's size css classes for the pseudo element
      var elemClassList = this.element[0].classList;
      if (elemClassList.length === 0) {
        this.element[0].classList = 'dropdown';
      }
      var pseudoClassString = elemClassList.contains('dropdown-xs') ? 'dropdown input-xs' : //eslint-disable-line
      elemClassList.contains('dropdown-sm') ? 'dropdown input-sm' : //eslint-disable-line
      elemClassList.contains('dropdown-lg') ? 'dropdown input-lg' : 'dropdown'; //eslint-disable-line

      // Detect Inline Styles
      var style = this.element.attr('style');
      this.isHidden = style && style.indexOf('display: none') >= 0;

      // Build the wrapper if it doesn't exist
      var baseElement = this.isInlineLabel ? this.inlineLabel : this.element;
      this.wrapper = baseElement.next('.dropdown-wrapper');
      this.isWrapped = this.wrapper.length > 0;

      if (!this.isWrapped) {
        this.wrapper = $('<div class="dropdown-wrapper"></div>').insertAfter(baseElement);
      }

      if (this.isWrapped) {
        this.pseudoElem = this.wrapper.find('.' + pseudoClassString);
        this.trigger = this.wrapper.find('.trigger');
      } else {
        this.pseudoElem = $('div#' + orgId + '-shdo');
      }

      if (elemClassList.contains('text-align-reverse')) {
        pseudoClassString += ' text-align-reverse';
      } else if (elemClassList.contains('text-align-center')) {
        pseudoClassString += ' text-align-center';
      }

      // Build sub-elements if they don't exist
      this.label = $('label[for="' + xssUtils.stripTags(orgId) + '"]');

      if (!this.pseudoElem.length) {
        this.pseudoElem = $('<div class="' + pseudoClassString + '">');
      } else {
        this.pseudoElem[0].setAttribute('class', pseudoClassString);
      }

      if (!this.isWrapped) {
        this.pseudoElem.append($('<span></span>'));
      }
      var toExclude = ['data-validate'];
      var attributes = DOM.getAttributes(this.element[0]);
      var attributesToCopy = this.getDataAttributes(attributes, toExclude);

      this.pseudoElem.attr(attributesToCopy.obj).attr({
        role: 'combobox',
        'aria-autocomplete': 'list',
        'aria-controls': 'dropdown-list',
        'aria-readonly': 'true',
        'aria-expanded': 'false',
        'aria-label': this.label.text()
      });

      // Pass disabled/readonly from the original element, if applicable
      // "disabled" is a stronger setting than "readonly" - should take precedent.
      function handleStates(self) {
        var disabled = self.element.prop('disabled');
        var readonly = self.element.prop('readonly');

        if (disabled) {
          return self.disable();
        }

        if (readonly) {
          return self.readonly();
        }

        return self.enable();
      }
      handleStates(this);

      if (!this.isWrapped) {
        this.wrapper.append(this.pseudoElem, this.trigger);
      }

      // Check for and add the icon
      this.icon = this.wrapper.find('.icon');
      if (!this.icon.length) {
        this.icon = $.createIconElement('dropdown');
        this.wrapper.append(this.icon);
      }

      // Setup the incoming options that can be set as properties/attributes
      if (this.element.prop('multiple') && !this.settings.multiple) {
        this.settings.multiple = true;
      }
      if (this.settings.multiple && !this.element.prop('multiple')) {
        this.element.prop('multiple', true);
      }

      // Add the internal hash for typeahead filtering, if applicable
      if (this.settings.reload === 'typeahead') {
        this.selectedValues = [];
      } else {
        delete this.selectedValues;
      }

      var dataSource = this.element.attr('data-source');
      if (dataSource && dataSource !== 'source') {
        this.settings.source = dataSource;
      }
      var dataMaxselected = this.element.attr('data-maxselected');
      if (dataMaxselected && !isNaN(dataMaxselected)) {
        //eslint-disable-line
        this.settings.maxSelected = parseInt(dataMaxselected, 10);
      }

      // TODO: deprecate "moveSelectedToTop" in favor of "moveSelected"
      // _getMoveSelectedSetting()_ converts the old setting to the new text type.
      function getMoveSelectedSetting(incomingSetting, useText) {
        switch (incomingSetting) {
          case useText ? 'true' : true:
            return 'all';
          case useText ? 'false' : false:
            return 'none';
          default:
            if (moveSelectedOpts.indexOf(incomingSetting) > -1) {
              return incomingSetting;
            }
            return 'none';
        }
      }

      // Backwards compatibility for deprecated "moveSelectedToTop" setting.
      if (this.settings.moveSelectedToTop !== undefined) {
        this.settings.moveSelected = this.settings.moveSelectedToTop;
      }

      var dataMoveSelected = this.element.attr('data-move-selected');
      if (dataMoveSelected) {
        this.settings.moveSelected = getMoveSelectedSetting(dataMoveSelected, true);
      } else {
        this.settings.moveSelected = getMoveSelectedSetting(this.settings.moveSelected);
      }

      // Backwards compatibility with `settings.reloadSourceOnOpen`
      if (this.settings.reloadSourceOnOpen) {
        this.settings.reload = 'open';
        delete this.settings.reloadSourceOnOpen;
      }

      var dataCloseOnSelect = this.element.attr('data-close-on-select');
      if (dataCloseOnSelect && !this.settings.closeOnSelect) {
        this.settings.closeOnSelect = dataCloseOnSelect === 'true';
      }
      var dataNoSearch = this.element.attr('data-no-search');
      if (dataNoSearch && !this.settings.noSearch) {
        this.settings.noSearch = dataNoSearch === 'true';
      }

      // Persist sizing defintions
      var sizingStrings = ['-xs', '-sm', '-mm', '-md', '-lg'];
      var classString = this.element.attr('class');
      var s = null;

      for (var i = 0; i < sizingStrings.length; i++) {
        s = sizingStrings[i];
        if (classString.match(s)) {
          this.pseudoElem.addClass('dropdown' + s);
        }
      }

      // Cached dataset (from AJAX, if applicable)
      this.dataset = [];

      this.listfilter = new ListFilter({
        filterMode: this.settings.filterMode
      });

      this.setListIcon();
      this.setDisplayedValues();
      this.setInitial();
      this.setWidth();

      if (this.overflowed) {
        this.setTooltip();
      } else if (this.tooltipApi) {
        this.removeTooltip();
      }

      this.element.triggerHandler('rendered');

      return this.handleEvents();
    },


    /**
     * Used for preventing menus from popping open/closed when they shouldn't.
     * Gets around the need for timeouts everywhere
     * @private
     * @returns {boolean} If the timeout should be cancelled.
      */
    inputTimer: function inputTimer() {
      if (this.inputTimeout) {
        return false;
      }

      var self = this;

      this.inputTimeout = setTimeout(function () {
        clearTimeout(self.inputTimeout);
        self.inputTimeout = null;
      }, 100);

      return true;
    },


    /**
     * Set Width on the field
     * @private
     */
    setWidth: function setWidth() {
      var style = this.element[0].style;

      if (style.width) {
        this.pseudoElem[0].style.width = style.width;
      }
      if (style.position === 'absolute') {
        this.pseudoElem[0].style.position = 'absolute';
        this.pseudoElem[0].style.left = style.left;
        this.pseudoElem[0].style.top = style.top;
        this.pseudoElem[0].style.bottom = style.bottom;
        this.pseudoElem[0].style.right = style.right;
      }
    },


    /**
     * Set list item icon
     * @private
     * @param  {object} listIconItem The icon info to use on the list.
     */
    setItemIcon: function setItemIcon(listIconItem) {
      var self = this;
      var specColor = null;

      if (!listIconItem.icon) {
        listIconItem.isIcon = false;
        listIconItem.html = '';
        self.listIcon.items.push(listIconItem);
        return;
      }

      // Set icon properties
      if (_typeof(listIconItem.icon) === 'object') {
        listIconItem.obj = listIconItem.icon;
        listIconItem.icon = listIconItem.icon.icon;

        // Color
        if (listIconItem.obj.color) {
          specColor = listIconItem.obj.color.indexOf('#') === 0;
          if (specColor) {
            listIconItem.specColor = listIconItem.obj.color;
          } else {
            listIconItem.classList = ' ' + listIconItem.obj.color;
          }
        } else if (listIconItem.obj.class) {
          specColor = listIconItem.obj.class.indexOf('#') === 0;
          if (specColor) {
            listIconItem.specColor = listIconItem.obj.class;
          } else {
            listIconItem.classList = ' ' + listIconItem.obj.class;
          }
        }

        // Color Over
        if (listIconItem.obj.colorOver) {
          specColor = listIconItem.obj.colorOver.indexOf('#') === 0;
          if (specColor) {
            listIconItem.specColorOver = listIconItem.obj.colorOver;
          } else {
            listIconItem.classListOver = ' ' + listIconItem.obj.colorOver;
          }
        } else if (listIconItem.obj.classOver) {
          specColor = listIconItem.obj.classOver.indexOf('#') === 0;
          if (specColor) {
            listIconItem.specColorOver = listIconItem.obj.classOver;
          } else {
            listIconItem.classListOver = ' ' + listIconItem.obj.classOver;
          }
        }
      }

      // Set flags
      listIconItem.isIcon = listIconItem.icon && listIconItem.icon.length;

      if (listIconItem.classList && listIconItem.classList.length) {
        listIconItem.isClassList = true;
      }
      if (listIconItem.classListOver && listIconItem.classListOver.length) {
        listIconItem.isClassListOver = true;
      }

      // Build icon
      listIconItem.html = $.createIcon({
        icon: listIconItem.isIcon ? listIconItem.icon : '',
        class: 'listoption-icon' + (listIconItem.isClassList ? ' ' + listIconItem.classList : '')
      });

      self.listIcon.items.push(listIconItem);
    },


    /**
     * Set all icons on the list.
     * @private
     */
    setListIcon: function setListIcon() {
      var self = this;
      var hasIcons = self.settings.multiple ? false : self.element.find('[data-icon]').length > 0;
      var opts = hasIcons ? this.element.find('option') : [];

      self.listIcon = { hasIcons: hasIcons, items: [] };

      if (hasIcons) {
        var count = 0;

        opts.each(function (i) {
          var iconAttr = $(this).attr('data-icon');
          var icon = null;

          if (typeof iconAttr !== 'string' || !iconAttr.length) {
            return;
          }

          if (iconAttr.indexOf('{') !== 0) {
            icon = iconAttr;
          } else {
            icon = $.fn.parseOptions(this, 'data-icon');
          }
          self.setItemIcon({ html: '', icon: icon });

          if (self.listIcon.items[i] && self.listIcon.items[i].isIcon) {
            count++;
          }
        });

        hasIcons = count > 0;
      }

      if (hasIcons) {
        self.pseudoElem.prepend($.createIcon({ icon: '', class: 'listoption-icon' }));
        self.listIcon.pseudoElemIcon = self.pseudoElem.find('> .listoption-icon');
        self.listIcon.idx = -1;
      }

      self.listIcon.hasIcons = hasIcons;
    },


    /**
     * Triggers tooltip in multiselect
     * @returns {void}
     */
    setTooltip: function setTooltip() {
      var opts = this.element.find('option:selected');
      var optText = this.getOptionText(opts);
      this.tooltipApi = this.pseudoElem.find('span').tooltip({
        content: optText,
        parentElement: this.pseudoElem,
        trigger: 'hover'
      });
    },


    /**
     * Removes a tooltip
     * @returns {void}
     */
    removeTooltip: function removeTooltip() {
      this.tooltipApi.destroy();
      this.tooltipApi = null;
    },


    /**
     * Set over color for list item icon,
     * if run without pram {target}, it will make on only
     * @private
     * @param  {object} target The dom target.
     */
    setItemIconOverColor: function setItemIconOverColor(target) {
      var self = this;
      if (self.listIcon.hasIcons) {
        var targetIcon = target ? target.find('.listoption-icon') : null;
        self.list.find('li').each(function (i) {
          var li = $(this);
          var icon = li.find('.listoption-icon');
          var iconRef = self.listIcon.items[i];

          if (!iconRef) {
            return;
          }

          // make it on
          if (li.is('.is-focused')) {
            if (iconRef.isClassListOver) {
              icon.removeClass(iconRef.classListOver).addClass(iconRef.classList);
            }
          }
          // make it over
          if (targetIcon && li.is(target)) {
            if (iconRef.isClassListOver) {
              targetIcon.removeClass(iconRef.classList);
              targetIcon.addClass(iconRef.classListOver);
            }
          }
        });
      }
    },


    /**
     * Update the icon.
     * @private
     * @param {object} opt The dom target.
     */
    updateItemIcon: function updateItemIcon(opt) {
      var self = this;
      if (self.listIcon.hasIcons) {
        var target = self.listIcon.pseudoElemIcon;
        var i = opt.index();
        var idx = self.listIcon.idx;
        var iconRef = self.listIcon.items[i];
        var icon = iconRef && iconRef.isIcon ? iconRef.icon : '';

        // Return out if this item has no icon
        if (!iconRef) {
          return;
        }

        // Reset class and color
        if (idx > -1) {
          var iconAtIndex = self.listIcon.items[idx];
          if (iconAtIndex) {
            target.removeClass(iconAtIndex.classList + ' ' + iconAtIndex.classListOver);
            target[0].style.fill = '';
          }
        }

        // Update new stuff
        self.listIcon.idx = i;
        target.changeIcon(icon);
        if (iconRef.isClassList) {
          target.addClass(iconRef.classList);
        }
      }
    },


    /**
     * Update the visible list object.
     * @param {string} [term = undefined] an optional search term that will cause highlighting of text
     * @private
     */
    updateList: function updateList(term) {
      var self = this;
      var isMobile = self.isMobile();
      var listExists = self.list !== undefined && self.list !== null && self.list.length > 0;
      var listContents = '';
      var ulContents = '';
      var upTopOpts = 0;
      var hasOptGroups = this.element.find('optgroup').length;
      var reverseText = '';
      var isMultiselect = this.settings.multiple === true;
      var moveSelected = '' + this.settings.moveSelected;
      var showSelectAll = this.settings.showSelectAll === true;

      if (this.element[0].classList.contains('text-align-reverse')) {
        reverseText = ' text-align-reverse';
      } else if (this.element[0].classList.contains('text-align-center')) {
        reverseText = ' text-align-center';
      }

      if (!listExists) {
        listContents = '<div class="dropdown-list' + reverseText + (isMobile ? ' mobile' : '') + (this.settings.multiple ? ' multiple' : '') + '" id="dropdown-list" role="application" ' + (this.settings.multiple ? 'aria-multiselectable="true"' : '') + '>' + ('<label for="dropdown-search" class="audible">' + Locale.translate('Search') + '</label>') + ('<input type="text" class="dropdown-search' + reverseText + '" role="combobox" aria-expanded="true" id="dropdown-search" aria-autocomplete="list">') + ('<span class="trigger">' + (isMobile ? $.createIcon({ icon: 'close', classes: ['close'] }) : $.createIcon('dropdown')) + '<span class="audible">' + (isMobile ? Locale.translate('Close') : Locale.translate('Collapse')) + '</span>') + '</span>' + '<ul role="listbox">';
      }

      // Get a current list of <option> elements
      // If none are available, simply return out
      var opts = this.element.find('option');
      var groups = this.element.find('optgroup');
      var selectedFilterMethod = ':selected';
      var groupsSelectedOpts = [];

      // For typeahead reloading, the <option> tags are not used for determining what's already
      // selected.  Use the internal storage of selected values instead.
      if (this.settings.reload === 'typeahead') {
        selectedFilterMethod = function selectedFilterMethod(i, opt) {
          if (!self.selectedValues) {
            return false;
          }
          return self.selectedValues.indexOf(opt.value) > -1;
        };
      }

      var selectedOpts = opts.filter(selectedFilterMethod);

      // Re-inforce typeahead-reloaded options' `selected` properties
      if (this.settings.reload === 'typeahead') {
        selectedOpts.prop('selected', true);
      }

      function buildLiHeader(textContent) {
        return '<li role="presentation" class="group-label" focusable="false">\n        ' + textContent + '\n      </li>';
      }

      function buildLiOption(option, index) {
        var liMarkup = '';
        var text = option.innerHTML;
        var attributes = DOM.getAttributes(option);
        var value = attributes.getNamedItem('value');
        var title = attributes.getNamedItem('title');
        var hasTitle = title ? '" title="' + title.value + '"' : '';
        var badge = attributes.getNamedItem('data-badge');
        var badgeColor = attributes.getNamedItem('data-badge-color');
        var badgeHtml = '';
        var isSelected = option.selected ? ' is-selected' : '';
        var isDisabled = option.disabled ? ' is-disabled' : '';
        var liCssClasses = option.className ? ' ' + option.className.value : '';
        var aCssClasses = liCssClasses.indexOf('clear') > -1 ? ' class="clear-selection"' : '';
        var tabIndex = ' tabIndex="' + (index && index === 0 ? 0 : -1) + '"';
        var toExclude = ['data-badge', 'data-badge-color', 'data-val', 'data-icon'];
        var copiedDataAttrs = ' ' + self.getDataAttributes(attributes, toExclude).str;
        var trueValue = (value && 'value' in value ? value.value : text).replace(/"/g, '/quot/');
        var iconHtml = '';

        if (self.listIcon.hasIcons && self.listIcon.items[index]) {
          iconHtml = self.listIcon.items[index].html;
        }

        if (badge) {
          badgeHtml = '<span class="badge ' + (badgeColor ? badgeColor.value : 'azure07') + '">' + badge.value + '</span>';
        }

        if (liCssClasses.indexOf('clear') > -1 && text === '') {
          text = Locale.translate('ClearSelection');
        }

        // Highlight search term
        if (term && term.length > 0) {
          var exp = self.getSearchRegex(term);
          text = text.replace(exp, '<i>$1</i>').trim();
        }

        liMarkup += '<li class="dropdown-option' + isSelected + isDisabled + liCssClasses + '" data-val="' + trueValue + '" ' + copiedDataAttrs + tabIndex + hasTitle + ' role="presentation">\n        <a id="list-option-' + index + '" href="#" ' + aCssClasses + ' role="option">' + iconHtml + text + badgeHtml + '</a></li>';

        return liMarkup;
      }

      // In multiselect scenarios, shows an option at the top of the list that will
      // select all available options if checked.
      if (isMultiselect && showSelectAll) {
        var allSelected = opts.not('[disabled], .hidden').length === selectedOpts.not('[disabled], .hidden').length;

        ulContents += '<li role="presentation" class="dropdown-select-all-list-item' + (allSelected ? ' is-selected' : '') + '">' + ('<a role="option" href="#" id="dropdown-select-all-anchor" class="dropdown-select-all-anchor">' + Locale.translate('SelectAll') + '</a>') + '</li>';
      }

      // Move selected options in each group to just underneath their corresponding group headers.
      if (moveSelected === 'group') {
        // If no optgroups exist, change to "all" and skip this part.
        if (!groups || !groups.length) {
          moveSelected = 'all';
        } else {
          // Break apart selectedOpts into groups.
          // These selected items are applied when the header is generated.
          groups.each(function (i, g) {
            var els = selectedOpts.filter(function () {
              return $.contains(g, this);
            });
            groupsSelectedOpts.push(els);
          });
        }
      }

      // Move all selected options to the top of the list if the setting is true.
      // Also adds a group heading if other option groups are found in the <select> element.
      if (moveSelected === 'all') {
        opts = opts.not(selectedOpts);

        // Show a "selected" header if there are selected options
        if (selectedOpts.length > 0) {
          ulContents += buildLiHeader(Locale.translate('Selected') + ' ' + (self.isInlineLabel ? self.inlineLabelText.text() : this.label.text()));
        }

        selectedOpts.each(function (i) {
          ulContents += buildLiOption(this, i);
          upTopOpts++;
        });

        // Only show the "all" header beneath the selected options if there
        // are no other optgroups present
        if (!hasOptGroups && opts.length > 0) {
          ulContents += buildLiHeader(Locale.translate('All') + ' ' + (self.isInlineLabel ? self.inlineLabelText.text() : this.label.text()));
        }
      }

      opts.each(function (i) {
        var count = i + upTopOpts;
        var option = $(this);
        var parent = option.parent();
        var optgroupIsNotDrawn = void 0;
        var optgroupIndex = void 0;

        // Add Group Header if this is an <optgroup>
        // Remove the group header from the queue.
        if (parent.is('optgroup') && groups.length) {
          optgroupIndex = parent.index();
          optgroupIsNotDrawn = groups.index(parent) > -1;

          if (optgroupIsNotDrawn) {
            groups = groups.not(parent);
            ulContents += buildLiHeader('' + parent.attr('label'));

            // Add all selected items for this group
            if (moveSelected === 'group') {
              groupsSelectedOpts[optgroupIndex].each(function (j) {
                ulContents += buildLiOption(this, j);
                upTopOpts++;
              });
            }
          }
        }

        if (moveSelected !== 'none' && option.is(':selected')) {
          return;
        }

        ulContents += buildLiOption(this, count);
      });

      // Render the new list contents to the page.
      // Build the entire thing and set references if this is the first opening.
      // Otherwise, simply replace the elements inside the <ul>.
      if (!listExists) {
        listContents += ulContents + '</ul>' + '</div>';

        // Append markup to the DOM
        this.list = $(listContents);

        // Get references
        this.listUl = this.list.find('ul');
        this.searchInput = this.list.find('#dropdown-search');
      } else {
        this.listUl.html(ulContents);
      }

      if (this.listIcon.hasIcons) {
        this.list.addClass('has-icons');
        this.listIcon.pseudoElemIcon.clone().appendTo(this.list);
      }

      if (hasOptGroups) {
        this.listUl.addClass('has-groups');
      }

      if ($.fn.tooltip) {
        this.listUl.find('[title]').addClass('has-tooltip').tooltip();
      }

      this.position();

      if (this.isOpen()) {
        this.highlightOption(this.listUl.find('li:visible:not(.separator):not(.group-label):not(.is-disabled)').first());
      }
    },


    /**
     * Sets the displayed value of the Pseudo-Element based on currently-selected options.
     * @private
     */
    setDisplayedValues: function setDisplayedValues() {
      var opts = this.element.find('option:selected');
      var text = this.getOptionText(opts);

      if (opts.hasClass('clear')) {
        text = '';
      }

      if (this.settings.empty && opts.length === 0) {
        this.pseudoElem.find('span').text('');
        return;
      }

      // Displays the text on the pseudo-element
      var maxlength = this.element.attr('maxlength');
      if (maxlength) {
        text = text.substr(0, maxlength);
      }
      text = text.trim();
      this.pseudoElem.find('span').text(text);

      // Set the "previousActiveDescendant" to the first of the items
      this.previousActiveDescendant = opts.first().val();

      this.updateItemIcon(opts);
      this.setBadge(opts);
    },


    /**
     * Copy classes from the two objects
     * @private
     * @param  {object} from The from element
     * @param  {object} to  The to element
     * @param  {string} prop The property to set
     */
    copyClass: function copyClass(from, to, prop) {
      if (from.hasClass(prop)) {
        to.addClass(prop);
      }
    },


    /**
     * Copy initial stuff from the drop down to the pseudo element.
     * @private
     */
    setInitial: function setInitial() {
      if (this.element.is(':disabled')) {
        this.disable();
      }
      if (this.element.is('[readonly]')) {
        this.readonly();
      }
      if (this.isHidden) {
        this.pseudoElem.hide().prev('label').hide();
        this.pseudoElem.next('svg').hide();
      }

      // set placeholder text on pseudoElem span element
      if (this.element.attr('placeholder')) {
        this.pseudoElem.find('span').attr('data-placeholder-text', this.element.attr('placeholder'));
      }
    },


    /**
     * Figure out which keys to ignore on typehead.
     * @private
     * @param  {element} input The input element.
     * @param  {object} e  The event.
     * @returns {boolean} False if the key should be ignored.
     */
    ignoreKeys: function ignoreKeys(input, e) {
      var charCode = e.which;

      // Needed for browsers that use keypress events to manipulate the window.
      if (e.altKey && charCode === 38) {
        e.stopPropagation();
        e.preventDefault();
        return false;
      }

      if (input.is(':disabled') || input.hasClass('is-readonly')) {
        return; // eslint-disable-line
      }

      if (e.ctrlKey) {
        if (this.settings.onKeyDown) {
          var ret = this.settings.onKeyDown(e);
          if (ret === false) {
            e.stopPropagation();
            e.preventDefault();
            return false;
          }
        }
      }

      return true;
    },


    /**
     * Handle events while search is focus'd
     * @private
     * @returns {void}
     */
    handleSearchEvents: function handleSearchEvents() {
      var _this = this;

      if (this.settings.noSearch) {
        this.searchInput.prop('readonly', true);
      }

      // Used to determine how spacebar should function.
      // False means space will select/deselect.  True means
      // Space will add a space inside the search input.
      if (!this.filterTerm) {
        this.searchKeyMode = false;
      }

      this.searchInput.on('keydown.' + COMPONENT_NAME$x, function (e) {
        var searchInput = $(_this);
        if (!_this.ignoreKeys(searchInput, e)) {
          return false;
        }

        return _this.handleKeyDown(searchInput, e);
      }).on('input.' + COMPONENT_NAME$x, function (e) {
        _this.isFiltering = true;
        _this.handleAutoComplete(e);
      });
    },


    /**
     * Filter the list elements by term.
     * @private
     * @param  {string} term The search term
     */
    filterList: function filterList(term) {
      var typeahead = false;
      // 'typeahead' reloading skips client-side filtering in favor of server-side
      if (this.settings.source && this.settings.reload === 'typeahead') {
        typeahead = true;
        this.callSource();
      }

      var self = this;
      var selected = false;
      var list = $('.dropdown-option', this.listUl);
      var headers = $('.group-label', this.listUl);
      var hasIcons = false;
      var results = void 0;

      if (!list.length || !this.list || this.list && !this.list.length) {
        return;
      }

      if (!term) {
        term = '';
      }

      if (!typeahead && term && term.length) {
        results = this.listfilter.filter(list, term);
      } else {
        results = list;
      }

      this.list.addClass('search-mode');
      this.list.find('.trigger').find('.icon').attr('class', 'icon search').changeIcon('search');
      this.searchInput.removeAttr('aria-activedescendant');

      this.unhighlightOptions();

      if (!results || !results.length && !term) {
        this.resetList();
        return;
      }

      results.removeClass('hidden');
      list.not(results).add(headers).addClass('hidden');
      list.filter(results).each(function (i) {
        var li = $(this);
        li.attr('tabindex', i === 0 ? '0' : '-1');

        if (!selected) {
          self.highlightOption(li);
          selected = true;
        }

        // Highlight Term
        var exp = self.getSearchRegex(term);
        var text = li.text().replace(exp, '<i>$1</i>').trim();
        var icon = li.children('a').find('svg').length !== 0 ? new XMLSerializer().serializeToString(li.children('a').find('svg')[0]) : '';

        if (icon) {
          hasIcons = true;
        }

        li.children('a').html(icon + text);
      });

      headers.each(function () {
        var children = $(this).nextUntil('.group-label, .selector').not('.hidden');
        if (self.settings.showEmptyGroupHeaders || children.length) {
          $(this).removeClass('hidden');
        }
      });

      term = '';
      this.position();

      if (hasIcons && this.list.find('svg').length > 2) {
        this.list.find('svg').last().changeIcon('icon-empty-circle');
      }
    },


    /**
     * Removes filtering from an open Dropdown list and turns off "search mode"
     * @private
     */
    resetList: function resetList() {
      // 'typeahead' reloading skips client-side filtering in favor of server-side
      if (this.settings.source && this.settings.reload === 'typeahead') {
        this.filterTerm = '';
        this.searchKeyMode = false;
        this.callSource(null, true);
        return;
      }

      if (!this.list || this.list && !this.list.length) {
        return;
      }

      this.list.removeClass('search-mode');
      var lis = this.listUl.find('li');
      var hasIcons = false;
      lis.removeAttr('style').each(function () {
        var a = $(this).children('a');
        var li = $(this);

        var text = a.text();
        var icon = li.children('a').find('svg').length !== 0 ? new XMLSerializer().serializeToString(li.children('a').find('svg')[0]) : '';

        if (icon) {
          hasIcons = true;
        }

        a.html(icon + text);
      });

      // Adjust height / top position
      if (this.list.hasClass('is-ontop')) {
        this.list[0].style.top = this.pseudoElem.offset().top - this.list.height() + this.pseudoElem.outerHeight() - 2 + 'px';
      }

      if (this.settings.multiple) {
        this.updateList();
      }

      lis.removeClass('hidden');
      this.position();

      if (hasIcons && this.list.find('svg').length > 2) {
        this.list.find('svg').last().changeIcon('icon-empty-circle');
      }

      if (this.list.find('svg').length === 2) {
        this.list.find('svg').last().remove();
      }
    },


    /**
     * Select the blank item (if present)
     * @private
     */
    selectBlank: function selectBlank() {
      var blank = this.element.find('option').filter(function () {
        return !this.value || $.trim(this.value).length === 0;
      });

      if (!blank.length) {
        return;
      }

      // TODO: Refactor this in v4.9.0 to call `selectOption` instead.  Can't currently
      // do that because `selectOption` depends on the list being open.
      blank[0].selected = true;
      blank[0].setAttribute('selected', true);
      this.element.triggerHandler('updated');
      this.element.triggerHandler('change');
    },


    /**
     * Handle the key down event actions.
     * @private
     * @param  {object} input The dom element.
     * @param  {object} e The event element.
     * @returns {boolean} Returns the event in some situations.
     */
    handleKeyDown: function handleKeyDown(input, e) {
      var selectedIndex = this.element[0].selectedIndex || -1;
      var options = this.element[0].options;
      var key = e.which;
      var self = this;
      var excludes = 'li:visible:not(.separator):not(.group-label):not(.is-disabled)';
      var next = void 0;

      if (this.isLoading()) {
        return;
      }

      if (self.settings.onKeyDown) {
        var ret = self.settings.onKeyDown(e);
        if (ret === false) {
          e.stopPropagation();
          e.preventDefault();
          return false; //eslint-disable-line
        }
      }

      if (self.isOpen()) {
        options = this.listUl.find(excludes);
        selectedIndex = -1;
        $(options).each(function (index) {
          if ($(this).is('.is-focused')) {
            selectedIndex = index;
          }
        });
      }

      switch (key) {//eslint-disable-line
        case 37: // backspace
        case 8: // del & backspace
        case 46:
          {
            // del
            if (!self.isOpen()) {
              self.selectBlank();
              // Prevent Backspace from returning to the previous page.
              e.stopPropagation();
              e.preventDefault();
              return false; //eslint-disable-line
            }
            break;
          }
        case 9:
          {
            // tab - save the current selection
            // If "search mode" is currently off, Tab should turn this mode on and place focus back
            // into the SearchInput.
            // If search mode is on, Tab should 'select' the currently highlighted
            // option in the list, update the SearchInput and close the list.
            if (self.isOpen()) {
              self.closeList('tab');
              this.activate();
            }
            // allow tab to propagate otherwise
            return true; //eslint-disable-line
          }
        case 27:
          {
            // Esc - Close the Combo and Do not change value
            if (self.isOpen()) {
              // Close the option list
              self.element.closest('.modal.is-visible').data('listclosed', true);
              var tdContainer = self.pseudoElem ? self.pseudoElem.parents('td') : null;
              self.closeList('cancel');
              self.activate();

              if (tdContainer) {
                tdContainer.focus();
              }

              e.stopPropagation();
              return false; //eslint-disable-line
            }
            // Allow Esc to propagate if the menu was closed, since some other Controls
            // that rely on dropdown may need to trigger routines when the Esc key is pressed.
            break;
          }
        case 32: // Spacebar
        case 13:
          {
            // enter
            if (self.isOpen()) {
              if (key === 32 && self.searchKeyMode === true) {
                break;
              }

              e.preventDefault();

              if (options.length && selectedIndex > -1) {
                self.selectOption($(options[selectedIndex])); // store the current selection
              }

              if (self.settings.closeOnSelect) {
                self.closeList('select'); // Close the option list
                self.activate();
              }
            }
            e.stopPropagation();
            return false; //eslint-disable-line
          }
        case 38:
          {
            // up
            if (e.shiftKey) {
              return;
            }
            this.searchKeyMode = false;

            if (selectedIndex > 0) {
              next = $(options[selectedIndex - 1]);
              this.highlightOption(next);
              self.setItemIconOverColor(next);
              // NOTE: Do not also remove the ".is-selected" class here!
              // It's not the same as ".is-focused"!
              // Talk to ed coyle if you need to know why.
              next.parent().find('.is-focused').removeClass('is-focused');
              next.addClass('is-focused');
            }

            e.stopPropagation();
            e.preventDefault();
            return false; //eslint-disable-line
          }
        case 40:
          {
            // down
            if (e.shiftKey) {
              return;
            }
            this.searchKeyMode = false;

            if (selectedIndex < options.length - 1) {
              next = $(options[selectedIndex + 1]);
              this.highlightOption(next);
              self.setItemIconOverColor(next);
              // NOTE: Do not also remove the ".is-selected" class here!
              //  It's not the same as ".is-focused"!
              // Talk to ed coyle if you need to know why.
              next.parent().find('.is-focused').removeClass('is-focused');
              next.addClass('is-focused');
            }

            e.stopPropagation();
            e.preventDefault();
            return false; //eslint-disable-line
          }
        case 35:
          {
            // end
            this.searchKeyMode = false;

            var last = $(options[options.length - 1]);
            this.highlightOption(last);

            e.stopPropagation();
            return false; //eslint-disable-line
          }
        case 36:
          {
            // home
            this.searchKeyMode = false;

            var first = $(options[0]);
            this.highlightOption(first);

            e.stopPropagation();
            return false; //eslint-disable-line
          }
      }

      if (!self.isOpen() && !self.isControl(key) && !this.settings.source && !this.settings.noSearch) {
        // Make this into Auto Complete
        self.isFiltering = true;
        self.filterTerm = $.actualChar(e);

        if (self.searchInput && self.searchInput.length) {
          self.searchInput.val($.actualChar(e));
        }
        self.toggleList();
      }

      this.searchKeyMode = true;
      if (self.searchInput) {
        self.searchInput.attr('aria-activedescendant', '');
      }
      return true; // eslint-disable-line
    },


    /**
     * @private
     * @param {jQuery.Event} e incoming keydown event
     * @returns {boolean} whether or not the keydown event is allowed to continue
     */
    handlePseudoElemKeydown: function handlePseudoElemKeydown(e) {
      var target = $(e.target);
      var key = e.key;

      // No need to execute if readonly
      if (target.is('.is-readonly')) {
        return true;
      }

      // "Esc" is used by IE11
      var isEscapeKey = key === 'Esc' || key === 'Escape';

      // Control Keydowns are ignored
      var controlKeys = ['Alt', 'Shift', 'Control', 'Meta'];
      if (controlKeys.indexOf(key) > -1) {
        return false;
      }

      if (!this.ignoreKeys(target, e)) {
        return false;
      }

      if (this.settings.onKeyDown) {
        var ret = this.settings.onKeyDown(e);
        if (ret === false) {
          e.stopPropagation();
          e.preventDefault();
          return false; //eslint-disable-line
        }
      }

      // Down arrow opens the list.
      // Down/Up are for IE/Edge.
      // ArrowDown/ArrowUp are for all others.
      var openKeys = ['ArrowDown', 'ArrowUp', 'Down', 'Up', 'Enter', 'Spacebar', ' '];
      if (openKeys.indexOf(key) > -1) {
        if (!this.isOpen()) {
          this.open();
        }

        // TODO: refactor this out so that `handleKeyDown` is no longer necessary.
        // This is necessary here because in `noSearch` mode, there is no actionable searchInput.
        if (this.settings.noSearch && !e.ctrlKey) {
          this.handleKeyDown(target, e);
        }

        return false;
      }

      // Mac OSX: "backspace" delete key
      // Everything else: DEL key (numpad, control keys)
      var isOSX = Environment.os.name === 'Mac OS X';
      if (!isOSX && key === 'Delete' || isOSX && key === 'Backspace') {
        this.selectBlank();

        // Stop the backspace key from navigating back a page
        if (key === 'Backspace') {
          e.stopPropagation();
          e.preventDefault();
        }
        return true;
      }

      if (isEscapeKey || key === 'Tab') {
        // In nosearch mode, bypass the typeahead autocomplete and pass keydown events
        // along to the list elements
        if (this.settings.noSearch && this.isOpen()) {
          return this.handleKeyDown(target, e);
        }

        // Allow some keys to pass through with no changes in functionality
        return true;
      }

      this.handleAutoComplete(e);
      return true;
    },


    /**
     * Handle the typeahead.
     * @private
     * @param {object} e The event object
     */
    handleAutoComplete: function handleAutoComplete(e) {
      var _this2 = this;

      if (this.isLoading()) {
        return;
      }

      var self = this;
      if (this.timer) {
        clearTimeout(this.timer);
      }

      if (e.type === 'input') {
        this.filterTerm = this.searchInput.val();
      } else {
        this.filterTerm += $.actualChar(e).toLowerCase();

        if (e.key !== this.filterTerm && e.key.toLowerCase() === this.filterTerm && !self.settings.noSearch) {
          this.filterTerm = e.key;
        }
      }

      // if called by `open()`, runs in the context of this Dropdown's API
      function filter() {
        if (self.filterTerm === '') {
          self.resetList();
        } else {
          self.filterList(self.filterTerm.toLowerCase());
        }
      }

      this.timer = setTimeout(function () {
        if (self.settings.noSearch) {
          self.selectStartsWith(self.filterTerm);
          return;
        }

        _this2.searchKeyMode = true;
        if (!self.isOpen()) {
          self.open(filter);
          return;
        }

        filter();
      }, self.settings.delay);
    },


    /**
     * Determine if the key is a control key
     * @private
     * @param  {number} keycode The keycode to check.
     * @returns {boolean} true if the key is a control key.
     */
    isControl: function isControl(keycode) {
      var valid = keycode > 7 && keycode < 48 || // control chars
      keycode > 90 && keycode < 94 || // windows keys
      keycode > 111 && keycode < 146; // function keys

      return valid;
    },


    /**
     * Focus the input element. Since the select is hidden this is needed over normal focus()
     * @private
     * @param  {boolean} [useSearchInput] If true the search is used.
     * @returns {void}
     */
    activate: function activate(useSearchInput) {
      var self = this;
      var input = this.pseudoElem;

      if (useSearchInput || self.isMobile()) {
        input = this.searchInput;
      }

      if (useSearchInput && (input.hasClass('is-readonly') || input.prop('readonly') === true)) {
        return;
      }

      function selectText() {
        if (self.isMobile() || self.filterTerm) {
          return;
        }

        if (input[0].setSelectionRange) {
          input[0].setSelectionRange(0, input[0].value.length); // scroll to left
        } else if (input[0].tagName === 'INPUT') {
          // using Search Input instead of Pseudo Div
          input[0].select();
        }
      }

      selectText();

      // Set focus back to the element
      input[0].focus();
    },


    /**
     * @private
     * @param {string} term incoming search term
     * @returns {RegExp} a valid regex object used to filter search results
     */
    getSearchRegex: function getSearchRegex(term) {
      var regex = void 0;

      try {
        regex = new RegExp('(' + term + ')', 'i');
      } catch (e) {
        // create a "matches all" regex if we can't create a regex from the search term
        regex = /[\s\S]*/i;
      }

      return regex;
    },


    /**
     * Retrieves a string containing all text for currently selected options.
     * @private
     * @param  {array} opts The current option elements.
     * @returns {string} The selection options in a string  delimited by commas.
     */
    getOptionText: function getOptionText(opts) {
      var text = '';

      if (!opts) {
        opts = this.element.find('option:selected');
      }

      opts.each(function () {
        if (text.length > 0) {
          text += ', ';
        }
        text += $(this).text().trim();
      });

      return text;
    },


    /**
     * Open the dropdown list of options
     * @param {function} callback additional items that can be run after the opening process completes
     * @returns {void}
     */
    open: function open(callback) {
      var self = this;

      if (!this.inputTimer()) {
        return;
      }

      if (this.element.is(':disabled') || this.pseudoElem.hasClass('is-disabled') || this.pseudoElem.hasClass('is-readonly')) {
        return;
      }

      function completeOpen() {
        self.updateList();
        self.openList();

        if (callback && typeof callback === 'function') {
          callback.call(this);
        }
      }

      if (!self.callSource(completeOpen)) {
        completeOpen();
      }
    },


    /**
     * Popup the list of options for selection.
     * @private
     */
    openList: function openList() {
      var current = this.previousActiveDescendant ? this.list.find('.dropdown-option[data-val="' + this.previousActiveDescendant.replace(/"/g, '/quot/') + '"]') : this.list.find('.is-selected');
      var self = this;
      var threshold = 10;
      var isEmpty = true;
      var pos = void 0;

      this.touchPrevented = false;

      if (current.length > 0) {
        isEmpty = true;
      }

      if (Environment.os.name === 'ios') {
        $('head').triggerHandler('disable-zoom');
      }

      // Close any other drop downs.
      $('select').each(function () {
        var data = $(this).data();
        if (data.dropdown) {
          data.dropdown.closeList('cancel');
        }
      });

      // Close any open popup menus
      var otherMenus = $('.popupmenu.is-open').filter(function () {
        return $(this).parents('.popupmenu').length === 0;
      }); // close others.

      otherMenus.each(function () {
        var trigger = $(this).data('trigger');
        if (!trigger || !trigger.length) {
          return;
        }

        var api = $(this).data('trigger').data('popupmenu');
        if (api && typeof api.close === 'function') {
          api.close();
        }
      });

      if (!this.isOpen()) {
        this.list.appendTo('body');
      }
      this.list.show();

      // Persist the "short" input field
      var isShort = this.element.closest('.field-short').length === 1;

      this.list.addClass(isShort ? 'dropdown-short' : '');

      this.pseudoElem.attr('aria-expanded', 'true').addClass('is-open');

      this.pseudoElem.attr('aria-label', this.label.text());
      this.searchInput.attr('aria-activedescendant', current.children('a').attr('id'));

      // In a grid cell
      this.isInGrid = this.pseudoElem.closest('.datagrid-row').length === 1;
      if (this.pseudoElem.parent().hasClass('is-inline')) {
        this.isInGrid = false;
      }

      if (this.isInGrid) {
        var rowHeight = this.pseudoElem.closest('.datagrid').attr('class').replace('datagrid', '');
        this.list.addClass('datagrid-dropdown-list ' + rowHeight);
      }

      if (this.pseudoElem.closest('.datagrid-filter-wrapper').length === 1) {
        this.list.addClass('datagrid-filter-dropdown');
      }

      var cssClass = this.settings.cssClass;
      if (cssClass && typeof cssClass === 'string') {
        this.list.addClass(cssClass);
      }

      this.position();

      // Limit the width
      if (this.settings.maxWidth) {
        this.list.css('max-width', this.settings.maxWidth + 'px');
      }

      // Set the contents of the search input.
      // If we've got a stored typeahead
      if (this.filterTerm) {
        this.searchInput.val(this.filterTerm);
      } else {
        this.searchInput.val(this.pseudoElem.find('span').text().trim());
      }

      var noScroll = this.settings.multiple;
      this.highlightOption(current, noScroll);
      if (this.settings.multiple && this.listUl.find('.is-selected').length > 0) {
        this.highlightOption(this.listUl.find('.dropdown-option').eq(0));
        setTimeout(function () {
          self.listUl.scrollTop(0);
        }, 0);
      }

      if (!this.settings.multiple && !isEmpty) {
        this.searchInput.val(current.find('a').text());
      }

      this.handleSearchEvents();
      this.activate(true); // Focus the Search Input

      /**
      *  Fires as the dropdown list is opened.
      *
      * @event listopened
      * @memberof Dropdown
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      this.element.trigger('listopened');

      if (this.isMobile()) {
        // iOS-specific keypress event that listens for when you click the "done" button
        self.searchInput.on('keypress.dropdown', function (e) {
          if (e.which === 13) {
            self.closeList('select');
          }
        });
      }

      self.list.removeClass('dropdown-tall').on('touchend.list click.list', 'li', function (e) {
        if (self.touchPrevented) {
          return;
        }

        var itemSelected = self.selectListItem($(this));
        e.preventDefault();
        if (!itemSelected) {
          return;
        }
        e.stopPropagation();
      }).on('mouseenter.list', 'li', function () {
        self.highlightOption($(this), true);
      });

      // Some list-closing events are on a timer to prevent immediate list close
      // There would be several things to check with a setTimeout, so this is done with a CSS
      // class to keep things a bit cleaner
      setTimeout(function () {
        self.list.addClass('is-closable');
      }, 100);

      // Is the jQuery Element a component of the current Dropdown list?
      function isDropdownElement(target) {
        return target.closest('.dropdown, .multiselect').length > 0 || target.closest('.dropdown-list').length > 0 || self.touchmove === true;
      }

      // Triggered when the user scrolls the page.
      // Ignores Scrolling on Mobile, and will not close the list if accessing an item within the list
      function scrollDocument(e) {
        var focus = $('*:focus'); // dont close on timepicker arrow down and up
        if (self.touchPrevented || isDropdownElement($(e.target)) || focus.is('.timepicker')) {
          self.touchPrevented = false;
          return;
        }
        self.closeList('cancel');
      }

      // Triggered when the user clicks anywhere in the document
      // Will not close the list if the clicked target is anywhere inside the dropdown list.

      function clickDocument(e) {
        var target = $(e.target);
        if (self.touchPrevented || isDropdownElement(target) && !target.is('.icon')) {
          e.preventDefault();

          self.touchPrevented = false;
          return;
        }

        self.closeList('cancel');
      }

      function touchStartCallback(e) {
        self.touchPrevented = false;

        pos = {
          x: e.originalEvent.touches[0].pageX,
          y: e.originalEvent.touches[0].pageY
        };

        $(document).on('touchmove.dropdown', function (evt) {
          var newPos = {
            x: evt.originalEvent.touches[0].pageX,
            y: evt.originalEvent.touches[0].pageY
          };

          if (newPos.x >= pos.x + threshold || newPos.x <= pos.x - threshold || newPos.y >= pos.y + threshold || newPos.y <= pos.y - threshold) {
            self.touchPrevented = true;
          }
        });
      }

      function touchEndCallback(e) {
        //eslint-disable-line
        $(document).off('touchmove.dropdown');
        e.preventDefault();

        if (self.touchPrevented) {
          e.stopPropagation();
          return false;
        }

        clickDocument(e);
      }

      // Need to detect whether or not scrolling is happening on a touch-capable device
      // The dropdown list should not close on mobile if scrolling is occuring, but should close
      // if the user is simply tapping outside the list.
      $(document).on('touchstart.dropdown', touchStartCallback).on('touchend.dropdown touchcancel.dropdown', touchEndCallback).on('click.dropdown', clickDocument);

      var modalScroll = $('.modal.is-visible .modal-body-wrapper');
      var parentScroll = self.element.closest('.scrollable').length ? self.element.closest('.scrollable') : $(document);
      parentScroll = self.element.closest('.scrollable-y').length ? self.element.closest('.scrollable-y') : parentScroll;
      parentScroll = modalScroll.length ? modalScroll : parentScroll;
      parentScroll.on('scroll.dropdown', scrollDocument);

      $('body').on('resize.dropdown', function () {
        self.position();

        // in desktop environments, close the list on viewport resize
        if (window.orientation === undefined) {
          self.closeList('cancel');
        }
      });

      // In mobile environments, close the list on an orientation change.
      // Don't do this on mobile against a resize because of the software keyboard's potential
      // to cause a "resize" event to fire.
      if (window.orientation !== undefined) {
        $(window).on('orientationchange.dropdown', function () {
          self.closeList('cancel');
        });
      }

      if (Environment.os.name === 'ios') {
        $('head').triggerHandler('enable-zoom');
      }
    },


    /**
     * Set size and positioning of the list
     * @private
     */
    position: function position() {
      var self = this;
      var positionOpts = {
        parentXAlignment: 'left',
        placement: 'bottom',
        strategies: ['flip', 'shrink-y']
      };

      function dropdownAfterPlaceCallback(e, placementObj) {
        // Turn upside-down if flipped to the top of the pseudoElem
        if (placementObj.wasFlipped === true) {
          self.list.addClass('is-ontop');
          self.listUl.prependTo(self.list);
        }

        // Set the <UL> height to 100% of the `.dropdown-list` minus the size of the search input
        var ulHeight = parseInt(self.listUl[0].offsetHeight, 10);
        var listHeight = parseInt(self.list[0].offsetHeight, 10) + 5;
        var searchInputHeight = $(this).hasClass('dropdown-short') ? 24 : 34;
        var isToBottom = parseInt(self.list[0].offsetTop, 10) + parseInt(self.list[0].offsetHeight, 10) >= window.innerHeight;
        var isSmaller = searchInputHeight < listHeight - searchInputHeight * 2 && ulHeight + searchInputHeight >= listHeight;

        if (isSmaller && !isToBottom) {
          self.listUl[0].style.height = listHeight - searchInputHeight * 2 + 'px';
        }

        if (isSmaller && isToBottom) {
          self.listUl[0].style.height = listHeight - searchInputHeight * 2 + 'px';
          self.list[0].style.height = parseInt(self.list[0].style.height, 10) - 10 + 'px';
        }

        if (placementObj.wasFlipped) {
          self.listUl[0].style.height = parseInt(self.listUl[0].style.height, 10) + (searchInputHeight - 5) + 'px';
        }

        return placementObj;
      }

      // Reset styles that may have been appended to the list
      this.list[0].removeAttribute('style');
      this.listUl[0].removeAttribute('style');

      var parentElement = this.pseudoElem;
      if (this.isInGrid) {
        parentElement = this.element.closest('.datagrid-cell-wrapper');
      }

      // If the list would end up being wider parent,
      // use the list's width instead of the parent's width
      var parentElementStyle = window.getComputedStyle(parentElement[0]);
      var parentElementBorderWidth = parseInt(parentElementStyle.borderLeftWidth, 10) * 2;
      var parentElementWidth = Math.round(parseInt(parentElement[0].clientWidth, 10) + parentElementBorderWidth);

      // Temporarily shrink the value of the search input, and compare the size of the list to
      // the parent element.
      this.searchInput[0].style.cssText = 'width: ' + parentElementWidth + 'px !important';
      var listDefaultWidth = Math.round(this.list.width());
      var useParentWidth = listDefaultWidth <= parentElementWidth;
      this.searchInput[0].style.width = '';

      // Add parent info to positionOpts
      positionOpts.parent = parentElement;
      positionOpts.useParentWidth = useParentWidth;

      // use negative height of the pseudoElem to get the Dropdown list to overlap the input.
      var isRetina = window.devicePixelRatio > 1;
      var isChrome = Environment.browser.name === 'chrome';

      positionOpts.y = -(parseInt(parentElement[0].clientHeight, 10) + parseInt(parentElementStyle.borderTopWidth, 10) + parseInt(parentElementStyle.borderBottomWidth, 10) - (!isChrome && isRetina ? 1 : 0));
      positionOpts.x = 0;
      if (self.settings.placementOpts && self.settings.placementOpts.x) {
        positionOpts.x = self.settings.placementOpts.x;
      }

      this.list.one('afterplace.dropdown', dropdownAfterPlaceCallback).place(positionOpts);
      this.list.data('place').place(positionOpts);
    },


    /**
     * @param {jQuery[]} target a jQuery-wrapped <option> or <li> tag representing an option.
     * @returns {boolean} whether or not the item was successfully selected.
     */
    selectListItem: function selectListItem(target) {
      var ddOption = target.closest('li');

      if (ddOption.length) {
        target = ddOption;
      }

      if (target.is('.separator, .group-label')) {
        return false;
      }

      if (target.is('.dropdown-select-all-anchor')) {
        target = target.parent();
      }

      // If this is the Select All option, select/deselect all.
      if (this.settings.multiple && target[0].classList.contains('dropdown-select-all-list-item')) {
        var doSelectAll = !target[0].classList.contains('is-selected');
        target[0].classList[doSelectAll ? 'add' : 'remove']('is-selected');
        this.selectAll(doSelectAll);
        return true; //eslint-disable-line
      }

      var val = target.attr('data-val').replace(/"/g, '/quot/');
      var cur = this.element.find('option[value="' + val + '"]');
      // Try matching the option's text if 'cur' comes back empty or overpopulated.
      // Supports options that don't have a 'value' attribute
      // And also some special &quote handling
      if (cur.length === 0 || cur.length > 1) {
        cur = this.element.find('option').filter(function () {
          var elem = $(this);
          var attr = elem.attr('value');
          return elem.text() === val || attr && attr.replace(/"/g, '/quot/') === val;
        });
      }

      if (cur.is(':disabled')) {
        return false; //eslint-disable-line
      }

      this.selectOption(cur);

      if (this.settings.closeOnSelect) {
        this.closeList('select');
      }

      if (this.isMobile()) {
        return true; //eslint-disable-line
      }

      this.activate(!this.settings.closeOnSelect);

      // Check/uncheck select all depending on no. of selected items
      if (this.settings.showSelectAll && this.list) {
        var opts = this.element.find('option');
        var selectedOpts = opts.filter(':selected');

        if (opts.length > selectedOpts.length) {
          this.list.find('.dropdown-select-all-list-item').removeClass('is-selected');
        } else {
          this.list.find('.dropdown-select-all-list-item').addClass('is-selected');
        }
      }

      return true; //eslint-disable-line
    },


    /**
    * Close the list of options if open.
    * @returns {void}
    */
    close: function close() {
      return this.closeList('cancel'); // See "js/lifecycle.js"
    },


    /**
     * Close the list of options if open.
     * @private
     * @param  {string} [action] The action that trigger the closing (cancel fx) this
     * is passed to the events.
     * @returns {void}
     */
    closeList: function closeList(action) {
      //  Also see "js/lifecycle.js" alias that works with the global "closeChildren" method.
      if (!this.list || !this.list.is(':visible') || !this.isListClosable()) {
        return;
      }

      if (!this.inputTimer()) {
        return;
      }

      if (this.touchmove) {
        this.touchmove = false;
      }

      // Rendering-related resets
      this.filterTerm = '';
      this.searchKeyMode = false;
      this.setDisplayedValues();

      this.searchInput.off(['input.' + COMPONENT_NAME$x, 'keydown.' + COMPONENT_NAME$x].join(' '));

      // Destroy any tooltip items
      this.listUl.find('.has-tooltip').each(function () {
        var api = $(this).data('tooltip');
        if (api) {
          api.destroy();
        }
      });

      this.list.off(['click.' + COMPONENT_NAME$x, 'touchmove.' + COMPONENT_NAME$x, 'touchend.' + COMPONENT_NAME$x, 'touchcancel.' + COMPONENT_NAME$x, 'mousewheel.' + COMPONENT_NAME$x, 'mouseenter.' + COMPONENT_NAME$x].join(' ')).remove();

      this.pseudoElem.removeClass('is-open').attr('aria-expanded', 'false');

      this.searchInput.removeAttr('aria-activedescendant');

      $(document).off(['click.' + COMPONENT_NAME$x, 'scroll.' + COMPONENT_NAME$x, 'touchmove.' + COMPONENT_NAME$x, 'touchend.' + COMPONENT_NAME$x, 'touchcancel.' + COMPONENT_NAME$x].join(' '));

      $('body').off('resize.dropdown');
      $(window).off('orientationchange.dropdown');

      /**
      * Fires as the dropdown list is closed
      *
      * @event listclosed
      * @memberof Dropdown
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      this.element.trigger('listclosed', action);
      this.activate();
      this.list = null;
      this.searchInput = null;
      this.listUl = null;
    },


    /**
    * Scroll to a particular option and make it in view.
    * @private
    * @param  {object} current The option element to scroll to.
    * @returns {void}
    */
    scrollToOption: function scrollToOption(current) {
      var self = this;
      if (!current) {
        return;
      }
      if (current.length === 0) {
        return;
      }
      // scroll to the currently selected option
      self.listUl.scrollTop(0);
      self.listUl.scrollTop(current.offset().top - self.listUl.offset().top - self.listUl.scrollTop() - 40);
    },


    /**
    * Blur and Close List
    * @private
    * @returns {void}
    */
    handleBlur: function handleBlur() {
      var self = this;
      self.closeList('cancel');

      return true;
    },


    /*
    * Function that is used to chekc if the field is loading from an ajax call.
    * @returns {void} Returns true if the field is attempting to load via AJAX.
    */
    isLoading: function isLoading() {
      return this.element.is('.is-loading') && this.element.is('.is-blocked');
    },


    /**
     * Return true/false depending on if the list is open.
     * @returns {boolean} The current state (open = true).
     */
    isOpen: function isOpen() {
      return !!this.pseudoElem.hasClass('is-open');
    },


    /**
     * Toggle the current state of the list between open and closed.
     * @private
     */
    toggle: function toggle() {
      if (this.isOpen() || this.isLoading()) {
        this.closeList('cancel');
        return;
      }
      this.open();
    },


    /**
     * Toggle the current state of the list between open and closed.
     * This method is slated to be removed in a future v4.10.0 or v5.0.0.
     * @deprecated as of v4.4.0.  Please use `toggle()` instead.
     * @private
     * @returns {void}
     */
    toggleList: function toggleList() {
      return deprecateMethod(this.toggle, this.toggleList).apply(this);
    },


    /**
     * Highlight the option that is being typed.
     * @private
     * @param {object} listOption The option element
     * @param {boolean} noScroll If true will scroll to the option
     */
    highlightOption: function highlightOption(listOption, noScroll) {
      //eslint-disable-line
      if (!listOption) {
        return;
      }

      if (listOption.length === 0) {
        listOption = this.list.find('.dropdown-option').eq(0);
      }

      if (listOption.is('.separator, .group-label')) {
        return;
      }

      // Get corresponding option from the list
      var option = this.element.find('option[value="' + listOption.attr('data-val') + '"]');

      if (option.hasClass('.is-disabled') || option.is(':disabled')) {
        return; //eslint-disable-line
      }

      if (!this.isOpen()) {
        return;
      }

      this.setItemIconOverColor();
      this.list.find('.is-focused').removeClass('is-focused').attr({ tabindex: '-1' });
      if (!option.hasClass('clear')) {
        this.setItemIconOverColor(listOption);
        listOption.addClass('is-focused').attr({ tabindex: '0' });
      }

      // Set activedescendent for new option
      // this.pseudoElem.attr('aria-activedescendant', listOption.attr('id'));
      this.searchInput.attr('aria-activedescendant', listOption.children('a').attr('id'));

      if (!noScroll || noScroll === false || noScroll === undefined) {
        this.scrollToOption(listOption);
      }
    },


    /**
     * Un Highlight the option that is being typed.
     * @private
     * @param  {object} listOptions The option element
     * @param  {boolean} noScroll If true will scroll to the option
     */
    unhighlightOptions: function unhighlightOptions(listOptions, noScroll) {
      if (!listOptions || !listOptions.length) {
        listOptions = this.list.find('.is-selected');
      }
      this.setItemIconOverColor();
      listOptions.removeClass('is-focused').attr({ tabindex: '-1' });

      this.searchInput.removeAttr('aria-activedescendant');

      if (!noScroll || noScroll === false || noScroll === undefined) {
        this.scrollToOption(listOptions.first());
      }
    },


    /**
     * Toggle all selection for items.
     * @private
     * @param {boolean} doSelectAll true to select and false will clear selection for all items.
     * @returns {void}
     */
    selectAll: function selectAll(doSelectAll) {
      var selector = {
        options: 'option:not(.is-disabled):not(:disabled)',
        items: 'li.dropdown-option:not(.separator):not(.group-label):not(.is-disabled)'
      };
      var options = [].slice.call(this.element[0].querySelectorAll(selector.options));
      var items = [].slice.call(this.listUl[0].querySelectorAll(selector.items));
      var last = options[options.length - 1];
      var text = '';

      if (doSelectAll) {
        // Select all
        items.forEach(function (node) {
          return node.classList.add('is-selected');
        });
        options.forEach(function (node) {
          node.selected = true;
          node.setAttribute('selected', true);
        });

        text = this.getOptionText($(options));
        var maxlength = this.element[0].getAttribute('maxlength');
        if (maxlength) {
          text = text.substr(0, maxlength);
        }
      } else {
        // Clear all
        items.forEach(function (node) {
          return node.classList.remove('is-selected');
        });
        options.forEach(function (node) {
          node.selected = false;
          node.setAttribute('selected', true);
        });
      }
      this.previousActiveDescendant = last.value || '';

      this.pseudoElem[0].querySelector('span').textContent = text;
      this.searchInput[0].value = text;
      this.updateItemIcon(last);

      if (this.list[0].classList.contains('search-mode')) {
        this.resetList();
      }
      this.activate(true);
      this.setBadge(last);

      this.element.trigger('change').triggerHandler('selected');
    },


    /**
     * Convenience method for running _selectOption()_ on a set of list options.
     * Accepts an array or jQuery selector containing valid list options and selects/deselects them.
     * @private
     * @param {object} options incoming options
     * @param {boolean} noTrigger if true, causes the 'selected' and 'change' events
     * not to fire on each list item.
     */
    selectOptions: function selectOptions(options, noTrigger) {
      // Use a jQuery selector if the incoming options are inside an array
      if (Array.isArray(options)) {
        options = $(options);
      }

      var self = this;
      options.each(function () {
        self.selectOption($(this), noTrigger);
      });

      self.element.trigger('change').triggerHandler('selected');
    },


    /**
     * Select an option and conditionally trigger events.
     * Accepts an array or jQuery selector containing valid list options and selects/deselects them.
     * @private
     * @param {object} option - the incoming li option
     * @param {boolean} noTrigger - if true, causes the 'selected' and 'change' events not to
     * fire on the list item.
     */
    selectOption: function selectOption(option, noTrigger) {
      if (!option || !option.length) {
        return;
      }
      var li = void 0;

      if (option.is('li')) {
        li = option;
        option = this.element.find('option[value="' + option.attr('data-val') + '"]');

        // Try matching the option's text if 'cur' comes back empty.
        // Supports options that don't have a 'value' attribute.
        if (option.length === 0) {
          option = this.element.find('option').filter(function () {
            return $(this).text() === li.attr('data-val');
          });
        }
      }

      var value = option.val();
      if (!option) {
        return;
      }

      if (!li && typeof value === 'string') {
        value = value.replace(/"/g, '/quot/');
        li = this.listUl.find('li[data-val="' + value + '"]');
      }

      if (option.hasClass('is-disabled') || option.is(':disabled')) {
        return;
      }

      var optionVal = option.val();
      var val = this.element.val();
      var text = '';
      var trimmed = '';
      var clearSelection = false;

      if (this.settings.reload === 'typeahead') {
        val = this.selectedValues || [];
      }

      // Sets to false if the option is being removed from a multi-select instead of added
      var isAdded = true;

      if (option.hasClass('clear') || !li) {
        clearSelection = true;
      }

      if (this.settings.multiple) {
        // Working with a select multiple allows for the "de-selection" of items in the list
        if (!val) {
          val = [];
        }
        if ($.inArray(optionVal, val) !== -1) {
          val = $.grep(val, function (optionValue) {
            return optionValue !== optionVal;
          });
          li.removeClass('is-selected');
          this.previousActiveDescendant = undefined;
          isAdded = false;
        } else {
          if (!isNaN(this.settings.maxSelected) && //eslint-disable-line
          this.element.find('option:selected').length >= this.settings.maxSelected) {
            return;
          }

          val = typeof val === 'string' ? [val] : val;
          val.push(optionVal);
          li.addClass('is-selected');
          this.previousActiveDescendant = option.val();
        }

        var newOptions = this.element.find('option').filter(function () {
          return $.inArray($(this)[0].value, val) !== -1;
        });
        text = this.getOptionText(newOptions);
      } else {
        // Working with a single select
        val = optionVal;
        this.listUl.find('li.is-selected').removeClass('is-selected');
        if (!clearSelection) {
          li.addClass('is-selected');
        }
        this.previousActiveDescendant = option.val();
        text = option.text();
      }

      if (!clearSelection) {
        this.element.find('option').each(function () {
          //eslint-disable-line
          if (this.value === optionVal) {
            $(this).prop('selected', true);
            return false;
          }
        });
      }

      // Change the values of both inputs and swap out the active descendant
      if (!clearSelection) {
        this.pseudoElem.find('span').text(text);
        this.searchInput.val(text);
      } else {
        this.pseudoElem.find('span').text('');
        this.searchInput.val('');
      }

      if (this.element.attr('maxlength')) {
        trimmed = text.substr(0, this.element.attr('maxlength'));
        this.pseudoElem.find('span').text(trimmed);
        this.searchInput.val(trimmed);
      }

      // Set the new value on the <select>
      this.selectedValues = val;
      this.element.val(val);
      this.updateItemIcon(option);

      /**
      * Fires after the value in the input is changed by any means.
      * @event change
      * @memberof Dropdown
      * @property {object} event The jquery event object
      */
      if (!noTrigger) {
        // Fire the change event with the new value if the noTrigger flag isn't set
        this.element.trigger('change').triggerHandler('selected', [option, isAdded]);

        if (this.overflowed) {
          this.setTooltip();
        } else if (this.tooltipApi) {
          this.removeTooltip();
        }
      }

      /**
      * Fires after the value in the input is changed by user interaction.
      * @event input
      * @memberof Dropdown
      * @property {object} event The jquery event object
      */

      // If multiselect, reset the menu to the unfiltered mode
      if (this.settings.multiple) {
        if (this.list.hasClass('search-mode')) {
          this.resetList();
        }
        this.activate(true);
      }

      this.setBadge(option);
    },


    /**
     * Select an option by the value.
     * @param {string} value - A string containing the value to look for. (Case insensitive)
     */
    selectValue: function selectValue(value) {
      if (typeof value !== 'string') {
        return;
      }

      var option = this.element.find('option[value="' + value + '"]');
      if (!option || !option.length) {
        return;
      }

      this.element.find('option:selected').prop('selected', false);
      option.prop('selected', true);
      this.updated();
    },


    /**
     * Select the next item that starts with a given character (text of the option).
     * @param {string} char - The starting letter to match for. (Case insensitive)
     */
    selectStartsWith: function selectStartsWith(char) {
      if (typeof char !== 'string') {
        return;
      }

      var elem = this.element[0];
      this.filterTerm = '';

      var newIdx = -1;
      var totalMatches = 0;

      // Log search matches
      if (!this.searchMatches || !this.searchMatches[char]) {
        this.searchMatches = {};
        this.searchMatches[char] = [];
      }

      for (var i = 0; i < elem.options.length; i++) {
        var option = elem.options[i];
        // Check if its a match (Case insensitive)
        var isMatch = option.innerText.toLowerCase().indexOf(char) === 0;

        if (isMatch) {
          if (this.searchMatches[char].indexOf(i) === -1) {
            this.searchMatches[char].push(i);
            newIdx = i;
            break;
          }
          totalMatches++;
          continue;
        }
      }

      if (newIdx === -1) {
        if (!this.searchMatches[char].length) {
          return;
        }

        if (totalMatches === this.searchMatches[char].length) {
          newIdx = this.searchMatches[char][0];
          this.searchMatches[char].length = 1; // reset
        }
      }

      elem.selectedIndex = newIdx;
      this.updated();
      this.element.trigger('change');
    },


    /**
     * Set the bade on the option from the config.
     * @private
     * @param {string} option - A string containing the value to look for. (Case insensitive)
     */
    setBadge: function setBadge(option) {
      // Badge Support
      if (this.badges) {
        var badge = this.element.parent().find('.badge');

        if (badge.length === 0) {
          this.element.parent().find('.dropdown-wrapper').append('<span class="badge">1</span>');
          badge = this.element.parent().find('.badge');
        }

        badge.attr('class', 'badge ' + (option.attr('data-badge-color') ? option.attr('data-badge-color') : 'azure07')).text(option.attr('data-badge'));
      }
    },


    /**
     * Execute the source ajax option
     * @private
     * @param {function} callback  The function call back.
     * @param {boolean} doReset  if defined, acts as a "reset" source call, where the search term will be ignored.
     * @returns {function} The callback for execution.
     */
    callSource: function callSource(callback, doReset) {
      var self = this;
      var searchTerm = '';

      if (!doReset && this.isOpen() && !this.element.hasClass('search-mode')) {
        searchTerm = this.searchInput.val();
      }

      // Return false and let the normal display codepath run.
      if (!this.settings.source) {
        return false;
      }

      this.isFiltering = false;

      var sourceType = _typeof(this.settings.source);
      var response = function response(data, isManagedByTemplate) {
        // to do - no results back do not open.
        var list = '';
        var val = self.element.val();

        function replaceDoubleQuotes(content) {
          return content.replace(/"/g, '\'');
        }

        function buildOption(option) {
          if (option === null || option === undefined) {
            return;
          }

          var isString = typeof option === 'string';
          var stringContent = option;
          var id = '';
          var selected = '';
          var textContent = '';

          if (isString) {
            option = {
              value: stringContent
            };
          }

          if (option.value !== undefined) {
            option.value = replaceDoubleQuotes(option.value);
            textContent = option.label;
          }

          if (option.id !== undefined) {
            if (!isNaN(option.id)) {
              //eslint-disable-line
              option.id = '' + option.id;
            }
            option.id = replaceDoubleQuotes(option.id);
            id = ' id="' + option.id + '"';
          }

          if (option.label !== undefined) {
            option.label = replaceDoubleQuotes(option.label);
            textContent = option.label;
          }

          var selectedValues = self.selectedValues && self.selectedValues.indexOf(val) > -1;
          if (option.value === val || selectedValues) {
            option.selected = true;
            selected = ' selected';
          }

          // Render the option element
          list += '<option' + id + ' value="' + option.value + '"' + selected + '>\n          ' + textContent + '\n        </option>';
        }

        // If the incoming dataset is different than the one we started with,
        // replace the contents of the list, and rerender it.
        if (!self.isFiltering && !utils.equals(data, self.dataset)) {
          self.dataset = data;

          if (!isManagedByTemplate) {
            self.element.empty();
            for (var i = 0; i < data.length; i++) {
              var opts = void 0;

              if (data[i].group) {
                opts = data[i].options;
                list += '<optgroup label="' + data[i].group + '">';
                for (var ii = 0; ii < opts.length; ii++) {
                  buildOption(opts[ii]);
                }
                list += '</optgroup>';
              } else {
                buildOption(data[i]);
              }
            }

            self.element.append(list);
          }
          self.updateList(searchTerm);
        }

        self.element.triggerHandler('complete'); // For Busy Indicator
        self.element.trigger('requestend', [searchTerm, data]);

        if (typeof callback !== 'function') {
          return;
        }
        callback();
      };

      self.element.triggerHandler('start'); // For Busy Indicator
      self.element.trigger('requeststart');

      if (sourceType === 'function') {
        // Call the 'source' setting as a function with the done callback.
        this.settings.source(response, searchTerm, this.settings.sourceArguments);
      } else if (sourceType === 'object') {
        // Use the 'source' setting as pre-existing data.
        // Sanitize accordingly.
        var sourceData = $.isArray(this.settings.source) ? this.settings.source : [this.settings.source];
        response(sourceData);
      } else {
        // Attempt to resolve source as a URL string.  Do an AJAX get with the URL
        var sourceURL = this.settings.source.toString();
        var request = $.getJSON(sourceURL);

        request.done(function (data) {
          response(data);
        }).fail(function () {
          response([]);
        });
      }

      return true;
    },


    /**
     * Get data attributes from passed list of attributes
     * @private
     * @param {array} attr - List of all attributes.
     * @param {array} attrToExclude - List of attributes to be excluded from passed list.
     * @returns {object} It will return an object containing two keys
     * str - string of attributes
     * obj - object of attributes
     */
    getDataAttributes: function getDataAttributes(attr, attrToExclude) {
      if (!attr) {
        return;
      } else if (typeof attr === 'string') {
        attr = [attr];
      }

      var toExclude = attrToExclude || [];
      if (typeof toExclude === 'string') {
        toExclude = [toExclude];
      }
      var attrToCopy = {
        obj: {},
        str: '',
        isExclude: function isExclude(attrib) {
          return $.inArray(attrib, toExclude) > -1;
        }
      };
      for (var key in attr) {
        //eslint-disable-line
        if (!attr.hasOwnProperty(key)) {
          //eslint-disable-line
          continue; //eslint-disable-line
        }
        attrToCopy.name = '' + attr[key].name;
        attrToCopy.isData = attrToCopy.name.substr(0, 5) === 'data-';
        if (attrToCopy.isData && !attrToCopy.isExclude(attrToCopy.name)) {
          attrToCopy.obj[attrToCopy.name] = attr[key].value;
          attrToCopy.str += ' ' + attrToCopy.name + '="' + attr[key].value + '"';
        }
      }
      return { str: attrToCopy.str, obj: attrToCopy.obj }; //eslint-disable-line
    },


    /**
     * Public API for setting the `<select>`'s value.
     * This method is slated to be removed in a future v4.10.0 or v5.0.0.
     * @private
     * @deprecated as of v4.4.0. It's preferrable to set the input value and call `updated()` on the component API.
     * @param {string} code - The value to match and set on the value element.
     */
    setCode: function setCode(code) {
      warnAboutDeprecation(this.setCode, this.element.val);

      var self = this;
      var doSetting = function doSetting() {
        self.element.val(code);
        self.updated();
      };

      if (!self.callSource(doSetting)) {
        doSetting();
      }
    },


    /**
     * Returns true if the object is a mobile element.
     * @private
     * @returns {boolean} code - True if this is a mobile device
     */
    isMobile: function isMobile() {
      return ['ios', 'android'].indexOf(Environment.os.name) > -1;
    },


    /**
     * Returns true if the element already has the closable class.
     * @private
     * @returns {object} The list
     */
    isListClosable: function isListClosable() {
      return this.list.hasClass('is-closable');
    },


    /**
     * Disable the input element.
     */
    disable: function disable() {
      this.element.prop('disabled', true).prop('readonly', false);

      if (this.pseudoElem.is($(document.activeElement))) {
        this.pseudoElem.blur();
      }

      this.pseudoElem.addClass('is-disabled').removeClass('is-readonly').attr('tabindex', '-1').prop('readonly', false).prop('disabled', true);
      this.closeList('cancel');
    },


    /**
    * Returns true if the dropdown is disabled.
    * @returns {boolean} True if the element is disabled.
    */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Enable the input element.
     */
    enable: function enable() {
      this.element.prop('disabled', false).prop('readonly', false);
      this.pseudoElem.prop('disabled', false).prop('readonly', false).attr('tabindex', '0').removeClass('is-disabled').removeClass('is-readonly');
    },


    /**
     * Make the input element readonly.
     */
    readonly: function readonly() {
      this.element.prop('disabled', false).prop('readonly', true);
      this.pseudoElem.removeClass('is-disabled').addClass('is-readonly').attr('tabindex', this.element.attr('tabindex') || '0').prop('disabled', false).prop('readonly', true);
      this.closeList('cancel');
    },


    /**
     * Tear down events and restore to original state.
     * @param  {object} settings The settings object to use.
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.closeList('cancel');

      if (this.pseudoElem && this.pseudoElem.hasClass('is-open')) {
        this.pseudoElem.removeClass('is-open').attr('aria-expanded', 'false');
      }

      // Update the 'multiple' property
      if (this.settings.multiple && this.settings.multiple === true) {
        this.element.prop('multiple', true);
      } else {
        this.element.prop('multiple', false);
      }

      // update "readonly" prop
      if (this.element.prop('readonly') === true) {
        this.readonly();
      } else {
        this.pseudoElem.removeClass('is-readonly');
      }

      // update "disabled" prop
      this.pseudoElem[this.element.prop('disabled') ? 'addClass' : 'removeClass']('is-disabled');

      // update the list and set a new value, if applicable
      this.updateList();
      this.setDisplayedValues();

      this.element.trigger('has-updated');

      return this;
    },


    /**
     * Tear down events and restore to original state.
     */
    destroy: function destroy() {
      if (this.selectedValues) {
        delete this.selectedValues;
      }

      $.removeData(this.element[0], COMPONENT_NAME$x);
      this.closeList('cancel');
      this.label.remove();
      this.pseudoElem.off().remove();
      this.icon.remove();
      this.wrapper.remove();
      this.listfilter.destroy();
      this.element.removeAttr('style');

      var list = document.body.querySelector('#dropdown-list');
      if (list && this.isOpen()) {
        list.parentNode.removeChild(list);
      }
    },


    /**
     * Setup the internal event handlers.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this3 = this;

      var self = this;

      this.pseudoElem.on('keydown.dropdown', function (e) {
        return _this3.handlePseudoElemKeydown(e);
      }).on('click.dropdown', function (e) {
        // landmark would like the click event to bubble up if ctrl and shift are pressed
        if (!(e.originalEvent.ctrlKey && e.originalEvent.shiftKey)) {
          e.stopPropagation();
        }
      }).on('mouseup.dropdown', function (e) {
        if (e.button === 2) {
          return;
        }
        self.toggleList();
      }).on('touchend.dropdown touchcancel.dropdown', function (e) {
        e.stopPropagation();
        self.toggleList();
        e.preventDefault();
      });

      self.element.on('activated.dropdown', function () {
        self.label.trigger('click');
      }).on('updated.dropdown', function (e) {
        e.stopPropagation();
        self.updated();
      }).on('openlist.dropdown', function () {
        self.toggleList();
      });

      // for form resets.
      self.element.closest('form').on('reset.dropdown', function () {
        setTimeout(function () {
          self.element.triggerHandler('updated');
        }, 1);
      });

      // Handle Label click
      this.label.on('click', function () {
        self.pseudoElem.focus();
      });
    }
  };

  /**
   * jQuery Component Wrapper for the Dropdown
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.dropdown = function (settings) {
    // Keep the Chaining and Init the Controls or Settings
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$x);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$x, new Dropdown(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$y = 'timepicker';

  // Timepicker Modes
  var TIMEPICKER_MODES = ['standard', 'range'];

  // Timepicker defaults
  var TIMEPICKER_DEFAULTS = function TIMEPICKER_DEFAULTS() {
    return {
      locale: '',
      timeFormat: undefined,
      minuteInterval: 5,
      secondInterval: 5,
      mode: TIMEPICKER_MODES[0],
      roundToInterval: true,
      parentElement: null,
      returnFocus: true
    };
  };

  /**
   * The Timepicker Component provides a click/touch user interface for setting a time.
   * @class TimePicker
   * @param {HTMLElement|jQuery[]} element the base element
   * @param {object} [settings] incoming settings
   * @param {string} [settings.locale] The name of the locale to use for this instance. If not set the current locale will be used.
   * @param {string} [settings.timeFormat = 'h:mm a'] The time format, defaults to the current locales time format.
   * @param {number} [settings.minuteInterval = 5]  Integer from 1 to 60.  Multiples of this value
   *  are displayed as options in the minutes dropdown.
   * @param {number} [settings.secondInterval = 5]  Integer from 1 to 60.
   * @property {string} [settings.mode = 'standard']  Can be set to 'standard', 'range',
   * @property {boolean} [settings.roundToInterval = true]  if `false`, does not automatically round user-entered values
   * from the pickers to their nearest interval.
   * @param {null|jQuery[]} [settings.parentElement] if defined as a jQuery-wrapped element, will be used as the target element.
   * @property {string} [settings.returnFocus = true]  If set to false, focus will not be returned to
   *  the calling element. It usually should be for accessibility purposes.
   */
  function TimePicker(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, TIMEPICKER_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  TimePicker.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setLocale();
      if (!this.settings.locale) {
        this.setCurrentCalendar().build();
      }
    },


    /**
     * Set current locale to be used.
     * @private
     * @returns {void}
     */
    setLocale: function setLocale() {
      var _this = this;

      this.locale = Locale.currentLocale;
      if (this.settings.locale) {
        Locale.getLocale(this.settings.locale).done(function (locale) {
          _this.locale = Locale.cultures[locale];
          _this.setCurrentCalendar();
        });
      }
    },


    /**
     * Sets current calendar information.
     * @private
     * @returns {object} The api object for chaining.
     */
    setCurrentCalendar: function setCurrentCalendar() {
      this.currentCalendar = Locale.calendar(this.locale.name, this.settings.calendarName);
      if (this.settings.timeFormat === undefined) {
        this.settings.timeFormat = this.currentCalendar.timeFormat || 'h:mm a';
      }
      this.isRTL = this.locale.direction === 'right-to-left';
      this.build();
      return this;
    },


    /**
     * Configure any settings for the Timepicker
     * @private
     * @returns {this} component instance
     */
    setup: function setup() {
      function sanitizeIntervals(value, type) {
        if (!type || ['minute', 'second'].indexOf(type) < 0) {
          type = 'minute';
        }

        var defaultInterval = TIMEPICKER_DEFAULTS()[type + 'Interval'];
        if (value === undefined || isNaN(value)) {
          return defaultInterval;
        }
        var intValue = parseInt(value, 10);
        return intValue > 0 && intValue < 60 ? intValue : defaultInterval;
      }

      function sanitizeTimeFormat(value) {
        if (!value || !value.toUpperCase().match('H') || !value.match('mm')) {
          return TIMEPICKER_DEFAULTS().timeFormat;
        }

        return value;
      }

      function sanitizeRoundToInterval(value) {
        return value === true;
      }

      function sanitizeMode(value) {
        var modes = ['standard', 'range'];
        return $.inArray(value, modes) > -1 ? value : TIMEPICKER_DEFAULTS().mode;
      }

      this.id = utils.uniqueId(this.element, 'timepicker') + '-id';
      this.hoursId = 'timepicker-hours-' + this.id.toString();
      this.minutesId = 'timepicker-minutes-' + this.id.toString();
      this.secondsId = 'timepicker-seconds-' + this.id.toString();
      this.periodId = 'timepicker-period-' + this.id.toString();

      if (this.element.is('[data-round-to-interval]')) {
        this.settings.roundToInterval = sanitizeRoundToInterval(this.element.attr('data-round-to-interval'));
      }
      if (this.element.is('[data-minute-interval]')) {
        this.settings.minuteInterval = sanitizeIntervals(this.element.attr('data-minute-interval'), 'minute');
      }

      this.settings.timeFormat = sanitizeTimeFormat(parseInt(this.element.attr('data-force-hour-mode'), 10) === 24 ? 'HH:mm' : this.settings.timeFormat);
      this.settings.minuteInterval = sanitizeIntervals(this.settings.minuteInterval, 'minute');
      this.settings.secondInterval = sanitizeIntervals(this.settings.secondInterval, 'second');
      this.settings.mode = sanitizeMode(this.settings.mode);
      this.settings.roundToInterval = sanitizeRoundToInterval(this.settings.roundToInterval);

      this.dayPeriods = this.currentCalendar.dayPeriods;

      return this;
    },


    /**
     * Add any markup
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      this.setup();

      // With this option forgoe the input and append the dropdowns/popup to the parent element
      if (this.settings.parentElement) {
        this.settings.parentElement.empty();
        this.trigger = $();
        this.buildStandardPopup();
        this.setupStandardEvents();
        return this;
      }

      // Append a Button
      this.trigger = this.element.next('svg.icon');
      if (this.trigger.length === 0) {
        this.trigger = $.createIconElement('clock').insertAfter(this.element);
      }

      this.addAria().addMask().handleEvents().roundMinutes();
      return this;
    },


    /**
     * Adds ARIA-related attributes
     * @private
     * @returns {void}
     */
    addAria: function addAria() {
      this.element.attr({
        'aria-expanded': 'false',
        role: 'combobox'
      });

      // TODO: Confirm this with Accessibility Team
      this.label = $('label[for="' + this.element.attr('id') + '"]');
      this.label.find('.audible').remove();
      this.label.append('<span class="audible">' + Locale.translate('UseArrow', { locale: this.locale.name }) + '</span>');
      return this;
    },


    /**
     * Sets up a `keydown` event listener.
     * @private
     * @returns {void}
     */
    handleKeys: function handleKeys() {
      var self = this;

      this.element.on('keydown.timepicker', function (e) {
        var handled = false;

        // Esc closes an open popup with no action
        if (e.which === 27 && self.isOpen()) {
          handled = true;
          self.closeTimePopup();
        }

        // Arrow Down or Alt first opens the dialog
        if (e.which === 40 && !self.isOpen()) {
          handled = true;
          self.openTimePopup();
        }

        if (handled) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        return true;
      });
    },


    /**
     * Sets up a `blur` event listener.
     * @private
    */
    handleBlur: function handleBlur() {
      var self = this;

      this.element.on('blur.timepicker', function () {
        self.roundMinutes();

        // The action of closing the popup menu is set on a timer because technically
        // there are no fields focused on frame 0 of the popup menu's existence, which
        // would cause it to close immediately on open.
        setTimeout(function () {
          if (self.isOpen() && self.popup.find(':focus').length === 0) {
            self.closeTimePopup();
          }
        }, 20);
      });
    },


    /**
     * Checks a time format value to see if it is a Military (24-hour) format.
     * @private
     * @param {string} value - a string value representing a time format.
     * @returns {boolean} whether or not the time format is 24-hour
     */
    is24HourFormat: function is24HourFormat(value) {
      if (!value) {
        value = this.settings.timeFormat;
      }
      return (value.match('H') || []).length > 0;
    },


    /**
     * @private
     * @param {number} value incoming value
     * @returns {string} the hour text
     */
    hourText: function hourText(value) {
      return ((this.settings.timeFormat.toUpperCase().match('HH') || []).length > 0 && value < 10 ? '0' : '') + value;
    },


    /**
     * Checks a time format value to see if it includes seconds.
     * @private
     * @param {string} value a string value representing a time format.
     * @returns {boolean} whether or not seconds are included in the time format
     */
    hasSeconds: function hasSeconds(value) {
      if (!value) {
        value = this.settings.timeFormat;
      }
      return (value.match('ss') || []).length > 0;
    },


    /**
     * Checks to see if a time format contains a space for presenting the day period.
     * @private
     * @param {string} value a string value representing a time format.
     * @returns {boolean} whther or not the time format has day periods.
     */
    hasDayPeriods: function hasDayPeriods(value) {
      if (!value) {
        value = this.settings.timeFormat;
      }
      return (value.match('a') || []).length > 0;
    },


    /**
     * Gets a Locale-defined version of the time separator.
     * @returns {string} containing the time separator
     */
    getTimeSeparator: function getTimeSeparator() {
      return this.currentCalendar.dateFormat.timeSeparator;
    },


    /**
     * Rounds the current value of the minutes picker to its nearest interval value.
     * @private
     */
    roundMinutes: function roundMinutes() {
      if (!stringUtils.toBoolean(this.settings.roundToInterval)) {
        return;
      }

      // separate out the minutes value from the rest of the value.
      var val = this.element.val();
      var timeSeparator = this.getTimeSeparator();
      var parts = val ? val.split(timeSeparator) : [];
      var interval = this.settings.minuteInterval;

      if (!parts[1]) {
        return;
      }

      if (!this.is24HourFormat(this.settings.timeFormat)) {
        var periodParts = parts[1].split(' ');
        parts[1] = periodParts[0];
        if (periodParts[1]) {
          parts.push(periodParts[1]);
        }
      }

      parts[1] = parseInt(parts[1], 10);
      if (parts[1] % interval === 0) {
        return;
      }

      parts[1] = Math.round(parts[1] / interval) * interval;

      parts[1] = parts[1].toString();
      parts[1] = (parts[1].length < 2 ? '0' : '') + parts[1];

      if (parts[1] === '60') {
        parts[1] = '00';
        parts[0] = (parseInt(parts[0], 10) + 1).toString();
      }

      var newVal = parts[0] + timeSeparator + parts[1] + ' ' + (parts[2] ? parts[2] : '');
      this.element.val(newVal);
    },


    /**
     * Adds Masked Input and Validation components to the input field at build time.
     * @private
     * @returns {void}
     */
    addMask: function addMask() {
      if (this.element.data('mask') && _typeof(this.element.data('mask')) === 'object') {
        this.element.data('mask').destroy();
      }
      this.element.data('mask', undefined);

      var maskOptions = {
        keepCharacterPositions: true,
        process: 'date',
        patternOptions: {
          format: this.settings.timeFormat
        }
      };

      var validation = 'time';
      var events = { time: 'blur change enter' };

      if (!this.element[0].getAttribute('data-validate')) {
        this.element.attr('data-validate', validation).attr('data-validation-events', JSON.stringify(events)).validate();
      }

      if (maskOptions) {
        this.element.mask(maskOptions);
      }
      return this;
    },


    /**
     * Constructs all markup and subcomponents needed to build the standard Timepicker popup.
     * @private
     * @returns {void}
     */
    buildStandardPopup: function buildStandardPopup() {
      var self = this;
      var popupContent = $('<div class="timepicker-popup-content"></div>');
      var timeSeparator = this.getTimeSeparator();
      var textValue = '';
      var selected = void 0;

      this.initValues = self.getTimeFromField();
      var timeParts = $('<div class="time-parts"></div>').appendTo(popupContent);

      // Build the inner-picker HTML
      var is24HourFormat = this.is24HourFormat();
      var hasSeconds = this.hasSeconds();
      var hasDayPeriods = this.hasDayPeriods();
      var hourCounter = is24HourFormat ? 0 : 1;
      var maxHourCount = is24HourFormat ? 24 : 13;

      this.hourSelect = $('<select id="' + this.hoursId + '" data-options="{\'noSearch\': \'true\'}" class="hours dropdown"></select>');

      while (hourCounter < maxHourCount) {
        selected = '';
        if (parseInt(self.initValues.hours, 10) === hourCounter) {
          selected = ' selected';
        }
        self.hourSelect.append($('<option' + selected + '>' + self.hourText(hourCounter) + '</option>'));
        hourCounter++;
      }
      timeParts.append($('<label for="' + this.hoursId + '" class="audible">' + Locale.translate('Hours', { locale: this.locale.name }) + '</label>'));
      timeParts.append(this.hourSelect);
      timeParts.append($('<span class="label colons">' + timeSeparator + '</span>'));

      // Minutes Picker
      var minuteCounter = 0;
      this.minuteSelect = $('<select id="' + this.minutesId + '" data-options="{\'noSearch\': \'true\'}" class="minutes dropdown"></select>');

      while (minuteCounter <= 59) {
        textValue = minuteCounter < 10 ? '0' + minuteCounter : minuteCounter;

        selected = '';
        if (parseInt(self.initValues.minutes, 10) === minuteCounter) {
          selected = ' selected';
        }
        self.minuteSelect.append($('<option' + selected + '>' + textValue + '</option>'));
        minuteCounter += self.settings.minuteInterval;
      }

      // If the value inside the picker doesn't match an interval, add the value
      // as the currently selected option, right at the top
      if (!this.minuteSelect.find('option[selected]').length) {
        this.minuteSelect.prepend($('<option selected>' + self.initValues.minutes + '</option>'));
      }

      timeParts.append($('<label for="' + this.minutesId + '" class="audible">' + Locale.translate('Minutes', { locale: this.locale.name }) + '</label>'));
      timeParts.append(this.minuteSelect);

      // Seconds Picker
      if (hasSeconds) {
        var secondCounter = 0;
        this.secondSelect = $('<select id="' + this.secondsId + '" data-options="{\'noSearch\': \'true\'}" class="seconds dropdown"></select>');

        while (secondCounter <= 59) {
          textValue = secondCounter < 10 ? '0' + secondCounter : secondCounter;

          selected = '';
          if (parseInt(self.initValues.seconds, 10) === secondCounter || !self.initValues.seconds && textValue === '00') {
            selected = ' selected';
          }
          this.secondSelect.append($('<option' + selected + '>' + textValue + '</option>'));
          secondCounter += self.settings.secondInterval;
        }

        // If the value inside the picker doesn't match an interval, add the value
        // as the currently selected option, right at the top
        if (!this.secondSelect.find('option[selected]').length) {
          this.secondSelect.prepend($('<option selected>' + self.initValues.seconds + '</option>'));
        }

        timeParts.append($('<span class="label colons">' + timeSeparator + '</span>'));
        timeParts.append($('<label for="' + this.secondsId + '" class="audible">' + Locale.translate('Seconds', { locale: this.locale.name }) + '</label>'));
        timeParts.append(this.secondSelect);
      }

      if (!is24HourFormat && hasDayPeriods) {
        this.periodSelect = $('<select id="' + this.periodId + '" data-options="{\'noSearch\': \'true\'}" class="period dropdown"></select>');
        timeParts.append($('<span class="label colons"></span>'));
        var localeDays = this.currentCalendar.dayPeriods;
        var localeCount = 0;
        var regexDay = new RegExp(self.initValues.period, 'i');
        var realDayValue = 'AM'; // AM

        while (localeCount < 2) {
          realDayValue = localeCount === 0 ? 'AM' : 'PM'; // ? AM : PM
          selected = '';
          if (regexDay.test(localeDays[localeCount])) {
            selected = ' selected';
          }
          this.periodSelect.append($('<option value="' + realDayValue + '"' + selected + '>' + localeDays[localeCount] + '</option>'));

          localeCount++;
        }
        timeParts.append($('<label for="' + this.periodId + '" class="audible">' + Locale.translate('TimePeriod', { locale: this.locale.name }) + '</label>'));
        timeParts.append(this.periodSelect);
      }

      if (this.settings.parentElement) {
        this.settings.parentElement.append(popupContent);
        // self.afterShow(this.settings.parentElement);
        self.popup = this.settings.parentElement.find('.timepicker-popup-content').addClass('timepicker-popup').attr('id', 'timepicker-popup');
      } else {
        popupContent.append('<div class="modal-buttonset"><button type="button" class="btn-modal-primary set-time">' + Locale.translate('SetTime', { locale: this.locale.name }) + '</button></div>');

        var placementParent = this.element;
        var placementParentXAlignment = this.isRTL ? 'right' : 'left';
        var parent = this.element.parent();

        if (parent.is('.datagrid-cell-wrapper')) {
          placementParentXAlignment = 'center';
          placementParent = this.element.next('.icon');
        }

        this.trigger.popover({
          content: popupContent,
          trigger: 'immediate',
          placement: 'bottom',
          placementOpts: {
            parent: placementParent,
            parentXAlignment: placementParentXAlignment,
            strategies: ['flip', 'nudge', 'shrink']
          },
          tooltipElement: '#timepicker-popup'
        }).on('show.timepicker', function (e, ui) {
          self.afterShow(ui);
        }).on('hide.timepicker', function () {
          if (self.settings.returnFocus) {
            self.element.focus();
          }
        });
      }

      // Make adjustments to the popup HTML specific to the timepicker
      if (this.trigger.data('tooltip')) {
        self.popup = this.trigger.data('tooltip').tooltip;
        var tooltip = self.popup;
        tooltip.addClass('timepicker-popup');
      }
    },


    /**
     * Handler for the Timepicker Popover's custom `show` event.
     * @private
     * @param {object} ui timepicker popup element
     * @returns {void}
     */
    afterShow: function afterShow(ui) {
      var self = this;

      ui.find('button').button();

      // Set default values based on what's retrieved from the Timepicker's input field.
      this.hourSelect.val(this.initValues.hours);
      this.hourSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.hours);
      this.minuteSelect.val(this.initValues.minutes);
      this.minuteSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.minutes);

      if (this.secondSelect) {
        this.secondSelect.val(this.initValues.seconds);
        this.secondSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.seconds);
      }

      if (self.hasDayPeriods()) {
        this.periodSelect.val(this.initValues.period);
        this.periodSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.period);
      }

      ui.find('div.dropdown').first().focus();
      ui.find('.set-time').off('click.timepicker').on('click.timepicker', function (e) {
        e.preventDefault();
        self.setTimeOnField();
        self.closeTimePopup();
      });

      // Handle Tabbing on the dialog
      if (!this.settings.parentElement) {
        ui.on('keydown.timepicker', 'button, div.dropdown', function (e) {
          var key = e.keyCode || e.charCode || 0;

          if (key === 9) {
            self.containFocus(e);
            e.stopPropagation();
            e.preventDefault();
            return false;
          }
          return true;
        });
      }
    },


    /**
     * Focus the next prev focusable element on the popup
     * @private
     * @param {jQuery.Event} e the event object
     * @returns {void}
     */
    containFocus: function containFocus(e) {
      var reverse = e.shiftKey;

      // Set focus on (opt: next|prev) focusable element
      var focusables = this.popup.find(':focusable');
      var index = focusables.index($(':focus'));
      var next = index + 1 >= focusables.length ? 0 : index + 1;
      var prev = index - 1 < 0 ? focusables.length : index - 1;

      index = !reverse ? next : prev;

      focusables.eq(index).focus();
    },


    /**
     * Sets up events that need to be bound to a standard time picker.
     * @private
     * @returns {void}
     */
    setupStandardEvents: function setupStandardEvents() {
      var self = this;

      self.popup.on('touchend.timepicker touchcancel.timepicker', '.set-time', function (e) {
        e.preventDefault();
        e.target.click();
      }).on('keydown.timepicker', 'input.dropdown', function (e) {
        var handled = false;

        // Pressing Esc when focused on a closed dropdown menu causes the entire popup to close.
        if (e.which === 27) {
          handled = true;
          self.closeTimePopup();
          self.element.focus();
        }

        // Pressing Spacebar while the popup is open submits with the new time value.
        if (e.which === 32) {
          handled = true;
          self.popup.find('.set-time').click();
        }

        // Left & Right Arrows will switch between the available dropdowns
        if (e.which === 37 || e.which === 39) {
          handled = true;
          var inputs = self.popup.find('input[id$="-shdo"]');

          if (e.which === 37) {
            var prev = inputs.eq(inputs.index(this) - 1);
            if (!prev || prev.length === 0) {
              prev = inputs.eq(inputs.length);
            }
            prev.focus();
          }

          if (e.which === 39) {
            var next = inputs.eq(inputs.index(this) + 1);
            if (!next || next.length === 0) {
              next = inputs.eq(0);
            }
            next.focus();
          }
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }

        return true;
      });

      // Listen to the popover/tooltip's "hide" event to properly close out the
      // popover's inner controls.
      self.trigger.on('hide.timepicker', function () {
        self.onPopupHide();
      });
    },


    /**
     * Constructs all markup and subcomponents needed to build a Timepicker popup
     * containing a time range.
     * @private
     * @returns {void}
     */
    buildRangePopup: function buildRangePopup() {
      // TODO: Build this
    },


    /**
     * Sets up events that need to be bound to a range timepicker.
     * @private
     * @returns {void}
     */
    setupRangeEvents: function setupRangeEvents() {
      // TODO: Build this
    },


    /**
     * Gets the value of the Timepicker field as an object separated into hours,
     * minutes, (optional) seconds, and (optional) day period.
     * @param {string} [value] this method can optionally be passed
     * a string-based time value to calculate instead of the current field's value.
     * @returns {object} containing key/value pairs representing time parts.
     */
    getTimeFromField: function getTimeFromField(value) {
      var self = this;
      var val = value || this.element.val();
      var sep = this.getTimeSeparator();
      var parts = void 0;
      var endParts = void 0;
      var timeparts = {};

      val = val.replace(/[T\s:.-]/g, sep).replace(/z/i, '');
      parts = val.split(sep);

      // Check the last element in the array for a time period, and add it as an array
      // member if necessary
      if (!this.is24HourFormat()) {
        endParts = parts[parts.length - 1].split(' ');
        parts.pop();
        parts = parts.concat(endParts);
      }

      function isDayPeriod(thisValue) {
        return self.dayPeriods.indexOf(thisValue) > -1;
      }

      function removeLeadingWhitespace(thisValue) {
        return thisValue.replace(/^\s+|\s+$/g, '');
      }

      function addLeadingZero(thisValue) {
        if (!thisValue || isNaN(thisValue)) {
          return '00';
        }
        thisValue = parseInt(thisValue, 10);
        thisValue = thisValue < 10 ? '0' + thisValue : thisValue;
        return thisValue;
      }

      // Handle Hours
      if (!parts[0] || !parts[0].length || isNaN(parts[0])) {
        parts[0] = '1';
      }

      parts[0] = parseInt(parts[0], 10);
      if (!isNaN(parts[0])) {
        parts[0] = '' + parseInt(parts[0], 10);
      }
      timeparts.hours = self.hourText(parts[0]);

      // Handle Minutes
      if (parts[1]) {
        // remove leading whitespace
        parts[1] = removeLeadingWhitespace(parts[1]);
        parts[1] = addLeadingZero(parts[1]);
        timeparts.minutes = parts[1];
      } else {
        timeparts.minutes = '00';
      }

      // Handle Seconds/Period (slot 3)
      function handleSlot2(thisValue) {
        // Should not kick off at all if we don't pass it a value, OR if this field
        // is 24-hour display with no seconds
        if (!thisValue) {
          if (self.hasSeconds()) {
            thisValue = '00';
            timeparts.seconds = thisValue;
          }

          if (!self.is24HourFormat()) {
            thisValue = self.translateDayPeriod('AM');
            timeparts.period = thisValue;
          }

          return;
        }

        thisValue = removeLeadingWhitespace(thisValue);

        // Has seconds
        if (self.hasSeconds()) {
          thisValue = addLeadingZero(thisValue);
          timeparts.seconds = thisValue;
          return;
        }
        // No seconds, but has a day period
        if (!isDayPeriod(thisValue)) {
          thisValue = self.translateDayPeriod('AM');
        }
        timeparts.period = thisValue;
      }
      handleSlot2(parts[2]);

      // Handle Period after seconds (slot 4)
      if (parts[3]) {
        parts[3] = removeLeadingWhitespace(parts[3]);
        timeparts.period = parts[3];
      } else if (!this.is24HourFormat() && this.hasSeconds()) {
        timeparts.period = this.translateDayPeriod('AM');
      }

      return timeparts;
    },


    /**
     * Translate Day Period
     * @private
     * @param {string} period should be "am", "pm", "AM", "PM", or "i"
     * @returns {string} the translated day period.
     */
    translateDayPeriod: function translateDayPeriod(period) {
      if (/am|pm|AM|PM/i.test(period)) {
        var periods = this.currentCalendar.dayPeriods || ['AM', 'PM'];
        return periods[/AM|am/i.test(period) ? 0 : 1];
      }
      return period;
    },


    /**
     * Retrieves the values from the Timepicker popup's pickers and uses those values to set
     * the contents of the Timepicker field.
     * @returns {void}
     */
    setTimeOnField: function setTimeOnField() {
      var hours = $('#' + this.hoursId).val() || '';
      var minutes = $('#' + this.minutesId).val() || '';
      var seconds = $('#' + this.secondsId).val() || '';
      var period = ($('#' + this.periodId).val() || '').toUpperCase();
      var sep = this.getTimeSeparator();
      var timeString = '' + hours + sep + minutes + (this.hasSeconds() ? sep + seconds : '');

      period = !this.is24HourFormat() && period === '' ? $('#' + this.periodId + '-shdo').val() : period;
      timeString += period ? ' ' + this.translateDayPeriod(period) : '';

      /**
      * Fires when the value is changed by typing or the picker.
      * @event change
      * @memberof TimePicker
      * @property {object} event - The jquery event object
      */
      this.element.val(timeString).trigger('change');

      this.element.focus();
    },


    /**
     * Return whether or not the Timepicker popup is open.
     * @returns {boolean} whether or not the Timepicker popup is open.
     */
    isOpen: function isOpen() {
      return !!(this.popup && this.popup.is(':visible'));
    },


    /**
     * Opens the Timepicker popup, intializing all the dropdown elements and
     * setting up internal events.
     * @returns {void}
     */
    openTimePopup: function openTimePopup() {
      var self = this;

      // Get all current settings.
      self.setup();

      if (this.element.is(':disabled') || this.element.attr('readonly')) {
        return;
      }

      if (this.popup && !this.popup.hasClass('is-hidden')) {
        self.closeTimePopup();
      }

      this.element.addClass('is-active is-open');

      // Build a different Time Popup based on settings
      if (self.settings.mode === 'range') {
        self.buildRangePopup();
        self.setupRangeEvents();
      } else {
        self.buildStandardPopup();
        self.setupStandardEvents();
      }

      this.element.attr({ 'aria-expanded': 'true' });
      this.popup.find('div.dropdown').first().focus();
    },


    /**
     * Triggers the "hide" method on the tooltip plugin.  The Timepicker officially
     * "closes" after the popover's hide event fully completes because certain events
     * need to be turned off and certain markup needs to be removed only AFTER
     * the popover is hidden.
     * @returns {void}
     */
    closeTimePopup: function closeTimePopup() {
      if (this.trigger.data('tooltip')) {
        this.trigger.data('tooltip').hide();
      }
    },


    /**
     * Handles the time popover's "hide" event
     * @private
     * @returns {void}
     */
    onPopupHide: function onPopupHide() {
      if (this.settings.mode === 'standard') {
        var ddHours = $('#' + this.hoursId);
        var ddMinutes = $('#' + this.minutesId);
        var ddSeconds = $('#' + this.secondsId);
        var ddPeriod = $('#' + this.periodId);

        if (ddHours && ddHours.data('dropdown') && typeof ddHours.data('dropdown').destroy === 'function') {
          ddHours.data('dropdown').destroy();
        }
        if (ddMinutes && ddMinutes.data('dropdown') && typeof ddMinutes.data('dropdown').destroy === 'function') {
          ddMinutes.data('dropdown').destroy();
        }
        if (this.hasSeconds()) {
          if (ddSeconds && ddSeconds.data('dropdown') && typeof ddSeconds.data('dropdown').destroy === 'function') {
            ddSeconds.data('dropdown').destroy();
          }
        }
        if (this.hasDayPeriods()) {
          if (ddPeriod && ddPeriod.data('dropdown') && typeof ddPeriod.data('dropdown').destroy === 'function') {
            ddPeriod.data('dropdown').destroy();
          }
        }
        this.popup.off('click.timepicker touchend.timepicker touchcancel.timepicker keydown.timepicker');
      }
      this.element.attr({ 'aria-expanded': 'false' });
      this.trigger.off('hide.timepicker show.timepicker');
      this.trigger.data('tooltip').destroy();
      this.trigger.data('tooltip', undefined);
      $('#timepicker-popup').remove();
      this.element.removeClass('is-active is-open');
    },


    /**
     * Toggles the visibility of the Timepicker popup.
     * @returns {void}
     */
    toggleTimePopup: function toggleTimePopup() {
      if (this.isOpen()) {
        this.closeTimePopup();
      } else {
        this.openTimePopup();
      }
    },


    /**
     * Getter method for retrieving the value of the Timepicker.
     * @param {boolean} removePunctuation Gets rid of all the value's punctuation on return.
     * @returns {string} the current timepicker value
     */
    value: function value(removePunctuation) {
      var val = this.element.val();
      if (!removePunctuation || removePunctuation === false) {
        return val;
      }

      var timeSeparator = this.currentCalendar.dateFormat.timeSeparator;
      var sepRegex = new RegExp(timeSeparator, 'g');

      // Remove punctuation
      val = val.replace(sepRegex, '');

      // Add leading zero for times without a double digit hour
      var parts = val.split(' ');
      if (parts[0].length < 4) {
        val = '0' + parts[0] + (parts[1] ? parts[1] : '');
      }

      return val;
    },


    /**
     * Enables the Timepicker
     * @returns {void}
     */
    enable: function enable() {
      this.element.removeAttr('disabled readonly').closest('.field').removeClass('is-disabled');
    },


    /**
    * Set input to readonly.
    * @returns {void}
    */
    readonly: function readonly() {
      this.enable();
      this.element.attr('readonly', 'readonly');
    },


    /**
     * Disables the Timepicker
     * @returns {void}
     */
    disable: function disable() {
      this.enable();
      this.element.attr('disabled', 'disabled').closest('.field').addClass('is-disabled');
    },


    /**
     * Detects whether or not the component is disabled
     * @returns {boolean} whether or not the component is disabled
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Updates the component instance.  Can be used after being passed new settings.
     * @param {object} [settings] incoming settings
     * @returns {this} component instanceof
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
     * Removes all event bindings, subcomponents and unnecessary markup from this component instance.
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.trigger.off('keydown.timepicker');
      this.element.off('focus.timepicker blur.timepicker keydown.timepicker');
      if (this.popup) {
        this.closeTimePopup();
      }

      this.trigger.remove();

      var mask = this.element.data('mask');
      if (mask && typeof mask.destroy === 'function') {
        mask.destroy();
      }

      $.removeData(this.element[0], 'validate');
      $.removeData(this.element[0], 'validationEvents');
      this.element.removeAttr('data-validate').removeData('validate validationEvents');

      this.label.find('.audible').remove();
      $('#timepicker-popup').remove();
      return this;
    },


    /**
     * Destroys the component instance.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$y);
    },


    /**
     * Sets up event listeners for the timepicker instance.
     * @fires TimePicker#events
     * @listens click  &nbsp;-&nbsp;
     * @listens touchstart  &nbsp;-&nbsp;
     * @listens touchmove  &nbsp;-&nbsp;
     * @listens touchend  &nbsp;-&nbsp;
     * @listens blur  &nbsp;-&nbsp;
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;
      this.trigger.off('click.timepicker').on('click.timepicker', function () {
        self.toggleTimePopup();
      });

      this.handleKeys();
      this.handleBlur();

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Timepicker
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} textarea elements being acted on.
   */
  $.fn.timepicker = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$y);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$y, new TimePicker(this, settings));
      }
    });
  };

  // The validation rules object.
  // This contains all base rules for validation that come bundled as part of Soho.
  // These rules can be extended.
  function ValidationRules() {
    var self = this;

    // define standard validation types
    this.ValidationTypes = [];
    this.ValidationTypes.error = {
      type: 'error',
      titleMessageID: 'Error',
      pagingMessageID: 'ErrorOnPage',
      errorsForm: true
    };
    this.ValidationTypes.alert = {
      type: 'alert',
      titleMessageID: 'Alert',
      pagingMessageID: 'AlertOnPage',
      errorsForm: false
    };

    this.ValidationTypes.success = {
      type: 'success',
      titleMessageID: 'Success',
      pagingMessageID: 'SuccessOnPage',
      errorsForm: false
    };

    // TODO: deprecate confirm in favor of success
    this.ValidationTypes.confirm = this.ValidationTypes.success;

    this.ValidationTypes.info = {
      type: 'info',
      titleMessageID: 'Info',
      pagingMessageID: 'InfoOnPage',
      errorsForm: false
    };
    this.ValidationTypes.icon = {
      type: 'icon',
      titleMessageID: 'Icon',
      pagingMessageID: 'IconOnPage',
      errorsForm: false,
      icon: 'user-profile'
    };

    this.rules = {
      required: {
        isNotEmpty: function isNotEmpty(value, field) {
          var supportsPlaceholder = !!('placeholder' in document.createElement('input'));

          if (!supportsPlaceholder && field && (value === field.attr('placeholder') || value === Locale.translate('Required'))) {
            return false;
          }

          if (typeof value === 'string') {
            // strip out any HTML tags and focus only on text content.
            value = $.trim(value.replace(/<\/?[^>]*>/g, ''));
            if ($.trim(value).length === 0) {
              return false;
            }
            return true;
          }

          if (typeof value === 'number') {
            if (isNaN(value)) {
              return false;
            }
            return true;
          }

          if ($.isArray(value)) {
            return value.length > 0;
          }

          return !!value;
        },


        // Check if at least one radio button checked in group
        isRadioChecked: function isRadioChecked(field) {
          var name = field.attr('name');
          return name && name.length && $('input[name="' + name + '"]:radio:checked').length;
        },
        check: function check(value, field) {

          this.message = Locale.translate('Required');
          var valid = true;

          valid = field.is(':radio') ? this.isRadioChecked(field) : this.isNotEmpty(value, field);
          return valid;
        },

        message: 'Required',
        type: 'error',
        id: 'required'
      },

      // date: Validate date, datetime (24hr or 12hr am/pm)
      date: {
        check: function check(value, field) {
          this.message = Locale.translate('InvalidDate');

          if (value instanceof Date) {
            return value && value.getTime && !isNaN(value.getTime());
          }

          var dateFormat = value.indexOf(':') > -1 ? Locale.calendar().dateFormat.datetime : Locale.calendar().dateFormat.short;

          if (field && field.data('datepicker')) {
            dateFormat = field.data('datepicker').pattern;
          }

          var isStrict = !(dateFormat === 'MMMM d' || dateFormat === 'yyyy');
          var parsedDate = Locale.parseDate(value, dateFormat, isStrict);
          return !(parsedDate === undefined && value !== '');
        },

        message: 'Invalid Date',
        type: 'error',
        id: 'date'
      },

      // Validate date, disable dates
      availableDate: {
        check: function check(value, field) {
          this.message = Locale.translate('UnavailableDate');
          var check = true;

          if (value === '') {
            return check;
          }

          if (!self.rules.date.check(value, field)) {
            // not a validate date so that will fail instead
            check = false;
            this.message = '';
            return check;
          }

          var datepickerApi = field.data('datepicker');
          var options = datepickerApi ? datepickerApi.settings : {};
          var hasOptions = Object.keys(options).length > 0;
          var d = void 0;
          var i = void 0;
          var l = void 0;
          var min = void 0;
          var max = void 0;
          var dateObj = value;
          if (typeof dateObj === 'string') {
            var format = options.dateFormat !== 'locale' ? options.dateFormat : Locale.calendar().dateFormat.short;
            if (options.showTime) {
              var timeFormat = options.timeFormat || Locale.calendar().timeFormat;
              format += ' ' + timeFormat;
            }
            dateObj = Locale.parseDate(dateObj, format);
          }
          var d2 = options.useUTC ? Locale.dateToUTC(dateObj) : dateObj;

          // TODO: The developer will have to set disabled dates in arabic as arrays,
          // will come back to this for now its not supported in arabic.
          if (d2 instanceof Array) {
            return check;
          }

          if (d2 && hasOptions) {
            min = options.useUTC ? Locale.dateToUTC(new Date(options.disable.minDate)).setHours(0, 0, 0, 0) : new Date(options.disable.minDate).setHours(0, 0, 0, 0);
            max = options.useUTC ? Locale.dateToUTC(new Date(options.disable.maxDate)).setHours(0, 0, 0, 0) : new Date(options.disable.maxDate).setHours(0, 0, 0, 0);

            // dayOfWeek
            if (options.disable.dayOfWeek.indexOf(d2.getDay()) !== -1) {
              check = false;
            }

            d2 = d2.setHours(0, 0, 0, 0);

            // min and max
            if (d2 <= min || d2 >= max) {
              check = false;
            }

            // dates
            if (options.disable.dates.length && typeof options.disable.dates === 'string') {
              options.disable.dates = [options.disable.dates];
            }
            for (i = 0, l = options.disable.dates.length; i < l; i++) {
              d = options.useUTC ? Locale.dateToUTC(options.disable.dates[i]) : new Date(options.disable.dates[i]);

              if (d2 === d.setHours(0, 0, 0, 0)) {
                check = false;
                break;
              }
            }
          }
          if (hasOptions) {
            check = !!(check && !options.disable.isEnable || !check && options.disable.isEnable);
          }

          return check;
        },

        message: 'Unavailable Date',
        type: 'error',
        id: 'availableDate'
      },

      // Range date
      rangeDate: {
        check: function check(value, field) {
          var _this = this;

          this.message = Locale.translate('rangeDate');
          var check = true;
          var api = field.data('datepicker');
          if (api) {
            var s = api.settings;
            var parts = value.split(s.range.separator);
            var checkRule = function checkRule(rule, newvalue) {
              field.val(newvalue);
              _this.message = self.rules[rule].message + ' (' + newvalue + ')';
              if (!self.rules[rule].check(newvalue, field)) {
                check = false;
              }
            };
            if (parts.length === 2) {
              checkRule('date', parts[0]);
              if (check) {
                checkRule('date', parts[1]);
              }
              if (check) {
                checkRule('availableDate', parts[0]);
              }
              if (check) {
                checkRule('availableDate', parts[1]);
              }
            }
          }
          field.val(value);
          return check;
        },

        message: 'Range Dates',
        type: 'error',
        id: 'rangeDate'
      },

      email: {
        check: function check(value) {
          this.message = Locale.translate('EmailValidation');
          var regex = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,16}(?:\.[a-z]{2})?)$/i;

          return value.length ? regex.test(value) : true;
        },

        message: 'EmailValidation',
        type: 'error',
        id: 'email'
      },

      enableSubmit: {
        check: function check(value, field) {
          var submit = field.closest('.signin').find('button[type="submit"]');
          var ok = value.length && (self.rules.email.check(value) || self.rules.passwordConfirm.check(value, field));

          if (ok) {
            submit.enable();
          } else {
            submit.disable();
          }
          return true;
        },

        message: '',
        type: 'error',
        id: 'enableSubmit'
      },

      emailPositive: {
        check: function check(value, field) {
          if ($.trim(value).length && !field.is('[readonly]')) {
            self.rules.emailPositive.positive = true;
            this.message = Locale.translate('EmailValidation');

            var isValid = self.rules.email.check(value, field);

            if (isValid) {
              this.message = '';
            }

            return isValid;
          }
          self.rules.emailPositive.positive = false;
          return true;
        },

        message: 'EmailValidation',
        type: 'error',
        id: 'emailPositive'
      },

      passwordReq: {
        check: function check(value) {
          this.message = Locale.translate('PasswordValidation');
          /* Must be at least 10 characters which contain at least
          ** one lowercase letter,
          ** one uppercase letter,
          ** one numeric digit
          ** and one special character */
          var regex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[^a-zA-Z0-9])(?!.*\s).{10,}$/;
          return value.length ? value.match(regex) : true;
        },

        message: 'PasswordValidation',
        type: 'error',
        id: 'passwordReq'
      },

      passwordConfirm: {
        check: function check(value, field) {
          this.message = Locale.translate('PasswordConfirmValidation');
          var passwordValue = $('input[type="password"]:not(' + field.attr('id') + ')', field.closest('.signin')).eq(0).val(),
              // eslint-disable-line
          check = value === passwordValue && self.rules.passwordReq.check(passwordValue); // eslint-disable-line
          return value.length ? check : true;
        },

        message: 'PasswordConfirmValidation',
        type: 'error',
        id: 'passwordConfirm'
      },

      time: {
        check: function check(value, field) {
          value = value.replace(/ /g, '');
          this.message = Locale.translate('InvalidTime');
          var timepicker = field && field.data('timepicker');
          var timepickerSettings = timepicker ? field.data('timepicker').settings : {};
          var pattern = timepickerSettings && timepickerSettings.timeFormat ? timepickerSettings.timeFormat : Locale.calendar().timeFormat;
          var is24Hour = (pattern.match('HH') || []).length > 0;
          var maxHours = is24Hour ? 24 : 12;
          var sep = value.indexOf(Locale.calendar().dateFormat.timeSeparator);
          var valueHours = 0;
          var valueMins = 0;
          var valueSecs = 0;
          var valueM = void 0;
          var timeparts = void 0;

          if (value === '') {
            return true;
          }

          valueHours = parseInt(value.substring(0, sep), 10);
          valueMins = parseInt(value.substring(sep + 1, sep + 3), 10);

          // getTimeFromField
          if (timepicker) {
            timeparts = timepicker.getTimeFromField();

            valueHours = timeparts.hours;
            valueMins = timeparts.minutes;

            if (timepicker.hasSeconds()) {
              valueSecs = timeparts.seconds;
            }
          }

          if (valueHours.toString().length < 1 || isNaN(valueHours) || parseInt(valueHours, 10) < 0 || parseInt(valueHours, 10) > maxHours) {
            return false;
          }
          if (valueMins.toString().length < 1 || isNaN(valueMins) || parseInt(valueMins, 10) < 0 || parseInt(valueMins, 10) > 59) {
            return false;
          }
          if (valueSecs.toString().length < 1 || isNaN(valueSecs) || parseInt(valueSecs, 10) < 0 || parseInt(valueSecs, 10) > 59) {
            return false;
          }

          // AM/PM
          if (!is24Hour) {
            if (parseInt(valueHours, 10) < 1) {
              return false;
            }
            var period0 = new RegExp(Locale.calendar().dayPeriods[0], 'i');
            var period1 = new RegExp(Locale.calendar().dayPeriods[1], 'i');

            valueM = value.match(period0) || value.match(period1) || [];
            if (valueM.length === 0) {
              return false;
            }
          }

          return true;
        },

        message: 'Invalid Time',
        type: 'error',
        id: 'time'
      },

      // Test validation function which always returns false
      test: {
        check: function check(value) {
          return value === '1';
        },

        message: 'Value is not valid (test).',
        type: 'error',
        id: 'test'
      }
    };
  }

  var Validation = new ValidationRules();

  // Component Name
  var COMPONENT_NAME$z = 'toast';

  // Default Component Settings
  var TOAST_DEFAULTS = {
    title: '(Title)',
    message: '(Content)',
    position: 'top right',
    audibleOnly: false,
    progressBar: true,
    timeout: 6000,
    allowLink: false
  };

  /**
   * Toast Component.  This component produces small, temporary messages in
   *  one of the application's corners.
   * @constructor
   * @param {HTMLElement} element the target location for the Toast message
   * @param {object} [settings] incoming settings
   * @param {string} [settings.title = '(Title)'] Text that is displayed in the Toast's title.
   * @param {string} [settings.message = '(Content)' ] Text that's displayed in the Toast's body.
   * @param {string} [settings.position = 'top right'] Text that propagates into CSS classes that position the Toast in specific places
   * Can be top left, bottom left, bottom rightx
   * @param {boolean} [settings.audibleOnly = false] if true, causes the toast to be invisble on the screen, but still read out lout by screen readers.
   * @param {boolean} [settings.progressBar = true] causes the toast to have a visible progress bar that will be completely
   * disappeared when the toast should be removed.
   * @param {number} [settings.timeout = 6000] the amount of time the toast should be present on-screen.
   * @param {boolean} [settings.allowLink = false] if true, allows user to put links in the toast message.
   */
  function Toast(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings, TOAST_DEFAULTS);
    this.init();
  }

  // Toast Methods
  Toast.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.show();
    },


    /**
     * Show a Single Toast Message
     * @private
     * @returns {void}
     */
    show: function show() {
      var self = this;
      var settings = self.settings;
      var maxHideTime = parseFloat(math.convertDelayToFPS(settings.timeout));
      var isPausePlay = false;
      var percentage = 100;
      var container = $('#toast-container');
      var toast = $('\n      <div class="toast">\n        <span class="toast-title">' + xssUtils.stripHTML(settings.title) + '</span>\n        <span class="toast-message">' + xssUtils.stripHTML(settings.message) + '</span>\n      </div>');
      if (settings.allowLink) {
        toast = $('\n        <div class="toast">\n          <span class="toast-title">' + xssUtils.stripHTML(settings.title) + '</span>\n          <span class="toast-message">' + xssUtils.stripTags(settings.message, '<a>') + '</span>\n        </div>');
      }
      var closeBtn = $('\n      <button type="button" class="btn-icon btn-close" title="' + Locale.translate('Close') + '" aria-hidden="true">\n        ' + $.createIcon('close') + '\n        <span class="audible">' + Locale.translate('Close') + '</span>\n      </button>\n    ');
      var progress = $('<div class="toast-progress"></div>');

      if (!container.length) {
        container = $('<div id="toast-container" class="toast-container" aria-relevant="additions" aria-live="polite"></div>').appendTo('body');
      }

      container.removeClass('toast-top-left toast-top-right toast-bottom-right toast-bottom-left').addClass('toast-' + settings.position.replace(' ', '-'));

      settings.timeout = settings.audibleOnly ? 100 : settings.timeout;

      if (settings.progressBar) {
        toast.append(progress);
      }

      // Build the RenderLoop integration
      var timer = new RenderLoopItem({
        duration: math.convertDelayToFPS(settings.timeout),
        timeoutCallback: function timeoutCallback() {
          self.remove(toast);
        },
        updateCallback: function updateCallback(data) {
          percentage = (data.duration - data.elapsedTime) / maxHideTime * 100;

          if (Locale.isRTL()) {
            percentage = 100 - percentage;
          }

          if (settings.progressBar) {
            progress[0].style.width = percentage + '%';
          }
        }
      });
      renderLoop.register(timer);

      container.append(toast);
      toast.addClass(settings.audibleOnly ? 'audible' : 'effect-scale');
      toast.append(closeBtn);

      $(document).on('keydown keyup', function (e) {
        e = e || window.event;
        if (e.ctrlKey && e.altKey && e.keyCode === 80) {
          // [Control + Alt + P] - Pause/Play toggle
          isPausePlay = e.type === 'keydown';
          timer[isPausePlay ? 'pause' : 'resume']();
        }
      });

      toast.on('mousedown.toast touchstart.toast mouseup.toast touchend.toast', function (e) {
        isPausePlay = !!/mousedown|touchstart/i.test(e.type);
        timer[isPausePlay ? 'pause' : 'resume']();
      });

      closeBtn.on('click', function () {
        timer.destroy();
        self.remove(toast);
      });
    },


    /**
     * Remove the Message and Animate
     * @private
     * @param {jQuery[]|HTMLElement} toast the toast message to be removed
     * @returns {void}
     */
    remove: function remove(toast) {
      if (this.settings.audibleOnly) {
        toast.remove();
        return;
      }

      toast.addClass('effect-scale-hide');

      var closeTimer = new RenderLoopItem({
        duration: 20,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: function timeoutCallback() {
          toast.remove();
        }
      });
      renderLoop.register(closeTimer);
    },


    /**
     * @param {object} [settings] incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, TOAST_DEFAULTS);
      }
      this.show();
    },


    /**
     * Teardown
     * @returns {void}
     */
    destroy: function destroy() {
      $('#toast-container').remove();
      $.removeData(this.element[0], COMPONENT_NAME$z);
    }
  };

  /**
   * jQuery Plugin Wrapper for Toast
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.toast = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$z);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$z, new Toast(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$A = 'Validator';

  /**
   * Validation Message Defaults
   * @namespace
   * @property {boolean} inline
   * @property {string} message
   * @property {string} type
   * @property {boolean} showTooltip
   */
  var VALIDATION_MESSAGE_DEFAULTS = {
    inline: true,
    message: '',
    type: 'error',
    showTooltip: false
  };

  /**
   * @class Validator
   * @constructor
   * @param {jQuery[]|HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   */
  function Validator(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, VALIDATION_MESSAGE_DEFAULTS);
    this.init();
  }

  // Plugin Object
  Validator.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.fields = 'input, textarea, select, div[data-validate], div[data-validation]';
      this.isPlaceholderSupport = !!('placeholder' in document.createElement('input')); // placeholder native support is-exists

      // If we initialize with a form find all inputs
      this.inputs = this.element.find(this.fields);

      // Or Just use the current input
      if (this.element.is(this.fields)) {
        this.inputs = $().add(this.element);
      }

      this.element.addClass('validation-active');
      this.timeout = null;

      this.attachEvents();
    },


    /**
     * Gets a list of events
     * @private
     * @param {string} events a single event name, or a JSON-representation of several events
     * @returns {void}
     */
    extractEvents: function extractEvents(events) {
      if (events.indexOf('{') > -1) {
        events = JSON.parse(events.replace(/'/g, '"'));
      }

      if ((typeof events === 'undefined' ? 'undefined' : _typeof(events)) === 'object') {
        var e = '';
        for (var k in events) {
          // eslint-disable-line
          if (e.indexOf(events[k]) === -1) {
            e += events[k] + ' ';
          }
        }
        e = e.split(' ').join('.validate ');
        events = e;
      }

      return events;
    },


    /**
     * @private
     * @param {string} events a single event name, or a JSON-representation of several events
     * @param {string} type a type of event to filter against
     * @returns {array} of event types in string format
     */
    filterValidations: function filterValidations(events, type) {
      var validations = [];

      if (!events) {
        return [];
      }

      if (events.indexOf('{') > -1) {
        events = JSON.parse(events.replace(/'/g, '"'));
      }

      if ((typeof events === 'undefined' ? 'undefined' : _typeof(events)) === 'object') {
        for (var k in events) {
          // eslint-disable-line
          if (type && events[k].indexOf(type) > -1) {
            validations.push(k);
          }
        }
      }

      return validations;
    },


    /**
     * Set error icon opacity for tooltip types, to avoid overlap text in the field
     * @private
     * @param {object} field validation element
     * @returns {void}
     */
    setErrorIconOpacity: function setErrorIconOpacity(field) {
      if (field.is(':text') && field.is('[data-error-type="tooltip"]')) {
        var textWidth = this.calculateTextWidth(field.val());
        var fieldWidth = field.outerWidth() - 35; // 35: icon width + padding/margin
        field.closest('.field, .field-short').find('.icon-error')[textWidth > fieldWidth ? 'addClass' : 'removeClass']('lower-opacity');
      }
    },


    /**
     * Calculate the width for given text
     * @param {string} text to calculate the width
     * @param {string} font used with given text (e.g. `14px arial`).
     * @returns {number} the calculated width
     */
    calculateTextWidth: function calculateTextWidth(text, font) {
      // use cached canvas for better performance, else, create new canvas
      this.canvas = this.canvas || (this.canvas = document.createElement('canvas'));
      var context = this.canvas.getContext('2d');
      context.font = font || '14px arial';
      var metrics = context.measureText(text);
      return metrics.width;
    },


    /**
     * @private
     */
    attachEvents: function attachEvents() {
      var self = this;
      var attribs = '[data-validate],[data-validation]';

      // Attach required
      this.inputs.each(function () {
        var field = $(this);
        var attr = field.attr('data-validate') || field.attr('data-validation');

        if (attr && attr.indexOf('required') > -1) {
          field.addClass('required');
        }
      });

      // Link on to the current object and perform validation.
      this.inputs.filter('input, textarea, div').filter(attribs).not('input[type=checkbox], input[type=file]').each(function () {
        var field = $(this);
        var eventAttr = field.attr('data-validation-events');
        var events = self.extractEvents(eventAttr || 'blur.validate change.validate keyup.validate');

        // Custom enter event
        if (events.indexOf('enter.validate') > -1) {
          field.off('keypress.enter.validate').on('keypress.enter.validate', function (e) {
            var thisField = $(this);
            if (e.which === 13) {
              self.validate(thisField, true, e);
            }
          });
        }

        field.off(events).on(events, function (e) {
          if (e.type === 'keyup') {
            // Skip on Tab
            if (e.keyCode === 9) {
              return;
            }
            self.setErrorIconOpacity(field);
          }

          var thisField = $(this);
          var handleEventData = thisField.data('handleEvent' + [e.type || '']);

          if (thisField.is('[readonly]') && !thisField.parent().is('.field-fileupload')) {
            return;
          }

          if (handleEventData && handleEventData.type === e.type && e.handleObj.namespace === 'validate' && !thisField.closest('.modal:visible').length) {
            return;
          }
          thisField.data('handleEvent' + [e.type || ''], e.handleObj);

          setTimeout(function () {
            if (thisField.closest('.modal-engaged').length && !thisField.closest('.modal-body').length) {
              return;
            }

            self.validate(field, true, e);
          }, 300);
        });
      });

      this.inputs.filter('input[type=checkbox]').filter(attribs).off('click.validate').on('click.validate', function (e) {
        self.validate($(this), true, e);
      });

      this.inputs.filter(':radio').off('click.validate').on('click.validate', function (e) {
        var first = $(this).parent().find('.radio').first();
        self.validate(first, true, e);
      });

      var selects = this.inputs.filter('select').filter(attribs);

      if (selects.length) {
        selects.off('change.validate listopened.validate listclosed.validate').on('change.validate', function (e) {
          self.validate($(this), true, e);
        }).on('listopened.validate', function () {
          var thisField = $(this);
          var tooltip = thisField.data('tooltip');

          thisField.next('.dropdown-wrapper').next('.error-message').hide();
          if (tooltip && document.activeElement === thisField.data('dropdown').searchInput[0]) {
            tooltip.hide();
          }
          $('#validation-tooltip').hide();
        }).on('listclosed.validate', function () {
          var thisField = $(this);
          var tooltip = thisField.data('tooltip');
          var dropdownApi = thisField.data('dropdown');

          if (Environment.features.touch) {
            dropdownApi.pseudoElem.focus();
            setTimeout(function () {
              dropdownApi.pseudoElem.blur();
            }, 100);
          }

          if (dropdownApi && dropdownApi.wrapper) {
            tooltip = dropdownApi.wrapper.find('.icon-error').data('tooltip');
          }

          thisField.next('.dropdown-wrapper').next('.error-message').show();
          if (tooltip && document.activeElement !== thisField.data('dropdown').searchInput[0]) {
            tooltip.show();
          }
        });

        selects.filter(function () {
          return $(this).data('dropdown') !== undefined;
        }).each(function () {
          var pseudoElem = $(this).data('dropdown').pseudoElem;
          pseudoElem.off('blur.validate').on('blur.validate', function (e) {
            var select = $(this).closest('.field, .field-short').find('select');
            self.validate(select, true, e);
          });
        });
      }

      // Attach to Form Submit and Validate
      if (this.element.is('form') && this.element.attr('data-validate-on')) {
        var submitHandler = function submitHandler(e) {
          e.stopPropagation();
          e.preventDefault();

          self.validateForm(function (isValid) {
            self.element.off('submit.validate');
            self.element.triggerHandler('validated', isValid);
            self.element.data('isValid', isValid);
            self.element.on('submit.validate', submitHandler);
          });
        };

        this.element.off('submit.validate').on('submit.validate', submitHandler);
      }
    },


    /**
     * Validates all elements inside of a form
     * @private
     * @param {function} callback method to call when the form's validation completes.
     */
    validateForm: function validateForm(callback) {
      var _$;

      var self = this;
      var deferreds = [];

      self.inputs = this.element.find(self.fields);
      self.inputs.each(function (e) {
        var field = $(this);
        if (field.attr('data-validate')) {
          if (field.attr('data-disable-validation') === 'true' || field.hasClass('disable-validation')) {
            return;
          }

          var dfds = self.validate(field, false, e);
          for (var i = 0; i < dfds.length; i++) {
            deferreds.push(dfds[i]);
          }
        }
      });

      (_$ = $).when.apply(_$, deferreds).then(function () {
        callback(true);
      }, function () {
        callback(false);
      });
    },


    /**
     * Set disable/enable primary button in modal
     * @private
     * @param {jQuery[]|HTMLElement} field the target element
     * @param {jQuery[]|HTMLElement} modalBtn the button that needs to be set to primary.
     * @returns {void}
     */
    setModalPrimaryBtn: function setModalPrimaryBtn(field, modalBtn) {
      var modal = field.closest('.modal');
      var modalFields = modal.find('[data-validate]:visible, select[data-validate], :checkbox[data-validate]');
      var allValid = true;

      if (modalFields.length > 0) {
        modalFields.each(function () {
          var modalField = $(this);

          if (modalField.closest('.datagrid-filter-wrapper').length > 0) {
            return;
          }
          var isVisible = modalField[0].offsetParent !== null;
          if (modalField.is('.required')) {
            if (isVisible && modalField.is('.editor') && !modalField.html()) {
              allValid = false;
            }
            if ((isVisible || modalField.is('select, :checkbox')) && !modalField.val() && !modalField.is('.editor')) {
              allValid = false;
            }
          }
          if ((isVisible || modalField.is('select, :checkbox')) && !modalField.isValid()) {
            allValid = false;
          }
        });
      }

      if (allValid) {
        modalBtn.removeAttr('disabled');
      } else {
        modalBtn.attr('disabled', 'disabled');
      }
    },


    /**
     * Gets the current value of a field
     * @private
     * @param {jQuery[]} field the field being checked.
     * @returns {any} the value of the field.
     */
    value: function value(field) {
      if (field.is('input[type=checkbox]')) {
        return field.prop('checked');
      }
      if (field.is('div')) {
        // contentEditable div (Rich Text)
        return field[0].innerHTML;
      }
      return field.val();
    },


    /**
     * Get the types of validation from a field.
     * @private
     * @param {jQuery[]} field the field being checked
     * @param {jQuery.Event} e the `validate` event
     * @returns {array} an array of types
     */
    getTypes: function getTypes(field, e) {
      var filters = this.filterValidations(field.attr('data-validation-events'), e.type);
      var validations = void 0;

      if (field.is('input.dropdown') && field.prev().prev('select').attr('data-validate')) {
        validations = field.prev().prev('select').attr('data-validate').split(' ');
      } else if (field.is('input.dropdown') && field.prev().prev('select').attr('data-validation')) {
        validations = field.prev().prev('select').attr('data-validation').split(' ');
      } else if (field.attr('data-validation')) {
        validations = field.attr('data-validation').split(' ');
      } else if (field.attr('data-validate')) {
        validations = field.attr('data-validate').split(' ');
      } else {
        validations = [];
      }

      // Filter out not needed events
      if (filters.length > 0) {
        validations = validations.filter(function (n) {
          return filters.indexOf(n) !== -1;
        });
      }

      // Filter out specific events that should not use keyup
      if (e.type === 'keyup') {
        validations = validations.filter(function (n) {
          return n !== 'date' && n !== 'time';
        });
      }

      return validations;
    },


    /**
     * Set icon on parent tabs/expandable
     * @private
     * @param {jQuery[]} field the field being appended to.
     * @param {string} type the type of icon being appended.
     * @returns {void}
     */
    setIconOnParent: function setIconOnParent(field, type) {
      var errorIcon = $.createIcon({ classes: ['icon-' + type], icon: type });
      var parent = field.closest('.tab-panel, .expandable-pane');
      var iconTarget = parent.attr('id');
      var parentContainer = field.closest('.tab-container, .tab-panel-container, .expandable-area');
      var iconContainer = void 0;
      var dropdown = void 0;
      var dropdownParent = void 0;

      // Tabs
      if (parentContainer.is('.tab-panel-container')) {
        parentContainer = parentContainer.prev('.tab-container');
      }
      if (parentContainer.is('.tab-container')) {
        // Default Tabs
        iconContainer = $('.tab-list a[href="#' + iconTarget + '"]', parentContainer).closest('.tab');

        // Tabs with Counts
        if (iconContainer.length) {
          if ($('.count', iconContainer).length) {
            iconContainer = $('.count', iconContainer);
          }
        } else {
          // Dropdown Tabs (with popupmenu)
          iconTarget = $('a[href="#' + iconTarget + '"]', '.popupmenu').closest('.popupmenu').attr('id');
          iconContainer = $('.tab-list .tab[aria-controls="' + iconTarget + '"]', parentContainer);
          dropdown = iconTarget;
        }
      } else if (parentContainer.is('.expandable-area')) {
        // Expandable
        iconContainer = $('.expandable-header[aria-controls="' + iconTarget + '"] .title', parentContainer);
      } else {
        // No action
        return;
      }

      // if Dropdown Tabs set each menu item to check
      if (dropdown && dropdown.length) {
        dropdownParent = parent.add($($(dropdown).attr('href')));
        $('a[role="menuitem"]', '#' + dropdown).each(function () {
          dropdownParent = dropdownParent.add($($(this).attr('href')));
        });
      }
      var menuitem = $('a[href="#' + parent.attr('id') + '"]', '#' + iconTarget);

      // Add icon
      if (!!parent && $('.' + type, parent).length || !!dropdownParent && $('.' + type, dropdownParent).length) {
        // if Dropdown Tabs and current menu item has no error remove icon
        if (!$('.' + type, parent).length) {
          menuitem.removeClass('is-' + type);
          $('.icon-' + type, menuitem).remove();
        }

        // if Dropdown Tabs and current menu item has error add icon
        if ($('.' + type, parent).length && $('.' + type, dropdownParent).length && !$('.icon-' + type, menuitem).length) {
          menuitem.addClass('is-' + type).append(errorIcon);
        }

        // Add icon to main tab area
        if (!$('.icon-' + type, iconContainer).length) {
          iconContainer.addClass('is-' + type).append(errorIcon);
        }
      } else {
        // Remove icon
        iconContainer = iconContainer.add(menuitem);
        iconContainer.removeClass('is-' + type);
        $('.icon-' + type, iconContainer).remove();
      }
    },


    /**
     * @private
     * @param {jQuery[]} field the field being validated
     * @param {boolean} showTooltip whether or not this field should display its validation message in a tooltip
     * @param {jQuery.Event} e the `validate` event
     * @returns {array} of jQuery deferred objects
     */
    validate: function validate(field, showTooltip, e) {
      field.data('handleEvent' + [e.type || ''], null);

      if (field.attr('data-disable-validation') === 'true' || field.hasClass('disable-validation') || field.is(':disabled')) {
        return [];
      }

      // call the validation function inline on the element
      var self = this;
      var types = self.getTypes(field, e) || [];
      var rule = void 0;
      var dfd = void 0;
      var dfds = [];
      var results = [];
      var i = void 0;
      var l = void 0;
      var validationType = void 0;
      var value = self.value(field);
      var placeholder = field.attr('placeholder');

      function manageResult(result, showResultTooltip, type, dfrd) {
        rule = Validation.rules[type];
        // Only remove if "false", not any other value ie.. undefined
        if (rule.positive === false) {
          self.removePositive(field);
        }

        validationType = Validation.ValidationTypes[rule.type] || Validation.ValidationTypes.error;
        var isInline = field.attr('data-' + validationType.type + '-type') !== 'tooltip';

        if (!result) {
          if (!self.isPlaceholderSupport && value === placeholder && rule.message !== Locale.translate('Required')) {
            return;
          }
          self.addMessage(field, rule, isInline, showResultTooltip);
          results.push(rule.type);

          if (validationType.errorsForm) {
            dfrd.reject();
          } else {
            dfrd.resolve();
          }
        } else if ($.grep(results, function (res) {
          return res === validationType.type;
        }).length === 0) {
          dfrd.resolve();

          if (rule.positive) {
            // FIX: In Contextual Action Panel control not sure why but need to add error,
            // otherwise "icon-success" get misaligned,
            // so for this fix adding and then removing error here

            self.addMessage(field, rule, isInline, showResultTooltip);
            self.removeMessage(field, rule, true);
            dfrd.resolve();

            self.addPositive(field);
          }
        } else if (!validationType.errorsForm) {
          // Rules that do not error the form need to resolve
          dfrd.resolve();
        }

        self.setIconOnParent(field, rule.type);
        var loc = self.getField(field);
        var data = loc.data(validationType.type + 'message');

        if (result && data && data.filter(function (rules) {
          return rules.id === rule.id || rule.message;
        }).length > 0) {
          self.removeMessage(field, rule, true);
        }

        // Test Enabling primary button in modal
        var modalBtn = field.closest('.modal').find('.btn-modal-primary').not('.no-validation');
        if (modalBtn.length) {
          self.setModalPrimaryBtn(field, modalBtn);
        }

        if (rule.type === 'error') {
          field.closest('form').triggerHandler('aftervalidate', { field: field, rule: rule, isValid: result });
        }
      }

      for (i = 0, l = types.length; i < l; i++) {
        rule = Validation.rules[types[i]];

        dfd = $.Deferred();

        if (!rule) {
          continue;
        }

        if ($('#calendar-popup').is(':visible')) {
          continue; // dont show validation message while selecting
        }

        if (rule.async) {
          rule.check(value, field, manageResult, dfd);
        } else {
          manageResult(rule.check(value, field), showTooltip, types[i], dfd);
        }
        dfds.push(dfd);
      }

      return dfds;
    },


    /**
     * Retrive the actionble element that should have an error class/icon appended to it.
     * @private
     * @param {jQuery[]} field the field being checked
     * @returns {jQuery[]} the field to be checked
     */
    getField: function getField(field) {
      if (field.is('select') && field.data('dropdown') !== undefined) {
        field = field.data('dropdown').pseudoElem;
      }
      return field;
    },


    /**
     * Returns true if the given object has an error
     * @param {jQuery[]} field the field being checked
     * @returns {boolean} whether or not the field currently has an error
     */
    hasError: function hasError(field) {
      return this.getField(field).hasClass('error');
    },


    /**
     * Adds a validation message/icon to a form field.
     * @private
     * @param {jQuery[]} field the field to be appended
     * @param {object} rule The validation message text
     * @param {boolean} inline whether or not the text should appear inside the input field
     *  (like a placeholder), or underneath the input field
     * @param {boolean} showTooltip whether or not the legacy validation Tooltip will contain the
     * message instead of placing it underneath
     */
    addMessage: function addMessage(field, rule, inline, showTooltip) {
      if (rule.message === '') {
        return;
      }

      if (field.is('.dropdown, .multiselect') && $('#dropdown-list').is(':visible')) {
        return;
      }

      var loc = this.getField(field);
      var dataMsg = loc.data(rule.type + 'message');
      var validationType = Validation.ValidationTypes[rule.type] || Validation.ValidationTypes.error;

      loc.addClass(rule.type === 'icon' ? 'custom-icon' : rule.type);

      // Inline messages are now an array
      if (dataMsg && dataMsg === rule.message) {
        // No need to add new message
        return;
      }

      if (dataMsg && dataMsg.filter(function (rules) {
        return (rules.id || rules.message) === (rule.id || rule.message) && rules.message === rule.message;
      }).length > 0) {
        // No need to add new message
        return;
      }

      var appendedMsg = rule.message;

      if (dataMsg) {
        for (var i = 0; i < dataMsg.length; i++) {
          appendedMsg = '\u2022 ' + dataMsg[i].message;
        }
        appendedMsg += '<br>\u2022 ' + rule.message;
      }

      if (!dataMsg) {
        dataMsg = [];
      }

      // Find the message by id and remove
      field.closest('.field, .field-short').find('[data-rule-id="' + (rule.id || rule.message) + '"]').remove();
      if (field.hasClass('dropdown') || field.hasClass('multiselect')) {
        field.parent().find('.dropdown-wrapper > [data-rule-id="' + (rule.id || rule.message) + '"]').off('click.validate').remove();
      }

      // Remove the rule if it exists in the dataMsg
      dataMsg = dataMsg.filter(function (rules) {
        return rules.id !== rule.id;
      });

      dataMsg.push({ id: rule.id, message: rule.message, type: rule.type });
      loc.data(validationType.type + 'message', dataMsg);

      // Add Aria
      if ($.fn.toast !== undefined) {
        $('body').toast({
          title: Locale.translate(validationType.titleMessageID),
          audibleOnly: true,
          message: appendedMsg
        });
      }

      if (!inline) {
        this.showTooltipMessage(field, appendedMsg, validationType.type, showTooltip);
        return;
      }

      field.data('isValid', false);
      this.showInlineMessage(field, rule);
    },


    /**
     * Shows an error icon
     * @private
     * @param {jQuery[]} field the field being appended
     * @param {string} type the error type
     * @returns {jQuery[]} the new icon's markup
     */
    showIcon: function showIcon(field, type) {
      var loc = this.getField(field).addClass(type === 'icon' ? 'custom-icon' : type);
      var svg = $.createIconElement({ classes: ['icon-' + type], icon: type });
      var closestField = loc.closest('.field, .field-short');
      var parent = field.parent();

      if (closestField.find('svg.icon-' + type).length === 0) {
        if (parent.is('.editor-container')) {
          field.parent().addClass('is-error');
        }

        if (field.parent(':not(.editor-container)').find('.btn-actions').length === 1) {
          parent.find('.btn-actions').before(svg);
        } else if (parent.find('.data-description').length === 1) {
          parent.find('.data-description').before(svg);
        } else if (parent.find('.field-info').length === 1) {
          parent.find('.field-info').before(svg);
        } else if (field.is('textarea')) {
          field.after(svg);
        } else if (field.is('.dropdown, .multiselect')) {
          parent.find('.dropdown-wrapper').append(svg);
        } else if (field.is('.spinbox')) {
          parent.append(svg);
        } else if (field.is('.lookup')) {
          parent.append(svg);
        } else {
          parent.append(svg);
        }

        $('.icon-success', closestField).remove();
      } else {
        svg = closestField.find('svg.icon-error');
      }

      return svg;
    },


    /**
     * Shows an tooltip error
     * @private
     * @param {jQuery[]} field the field being appended
     * @param {string} message text content containing the validation message.
     * @param {string} type the validation type (error, alert, info, etc)
     * @param {boolean} showTooltip whether or not to initially show the tooltip
     */
    showTooltipMessage: function showTooltipMessage(field, message, type, showTooltip) {
      if (field.is(':radio')) {
        return;
      }

      var icon = this.showIcon(field, type);
      var representationField = field;

      // Add error classes to pseudo-markup for certain controls
      if (field.is('.dropdown, .multiselect') && field.data('dropdown') !== undefined) {
        var input = field.data('dropdown').pseudoElem;
        representationField = input;
        input.addClass(type === 'icon' ? 'custom-icon' : type);
      }
      field.closest('.field, .field-short').find('.formatter-toolbar').addClass(type === 'icon' ? 'custom-icon' : type);

      var tooltipAPI = icon.data('tooltip');

      // Error tooltips should be positioned on the 'x' so that they sit directly
      // underneath the fields that they are indicating.
      function tooltipPositionCallback(placementObj) {
        var fieldRect = representationField[0].getBoundingClientRect();
        var elRect = tooltipAPI.tooltip[0].getBoundingClientRect();
        var rtl = $('html').is('[dir="rtl"]');
        var currX = placementObj.x;
        var xAdjustment = 0;

        if (rtl) {
          if (elRect.left < fieldRect.left) {
            xAdjustment += fieldRect.left - elRect.left;
          }
        } else if (elRect.right > fieldRect.right) {
          xAdjustment += (elRect.right - fieldRect.right) * -1;
        }

        placementObj.setCoordinate('x', currX + xAdjustment);
        if (!placementObj.nudges) {
          placementObj.nudges = {};
        }
        placementObj.nudges.x = xAdjustment;

        return placementObj;
      }

      // Build Tooltip
      if (!tooltipAPI) {
        icon.tooltip({
          content: message,
          placement: 'bottom',
          placementOpts: {
            callback: tooltipPositionCallback
          },
          trigger: 'focus',
          isError: true,
          tooltipElement: '#validation-tooltip'
        });
        tooltipAPI = icon.data('tooltip');
      } else {
        tooltipAPI.content = message;
      }

      field.on('focus.validate', function () {
        if (!tooltipAPI) {
          return;
        }
        tooltipAPI.show();
      }).on('blur.validate', function () {
        if (!tooltipAPI) {
          return;
        }
        tooltipAPI.hide();
      });

      if (tooltipAPI) {
        field.attr('data-error-type', 'tooltip');
      }

      this.setErrorIconOpacity(field);

      if (showTooltip && tooltipAPI) {
        tooltipAPI.show();
      }
    },


    /**
     * Shows an tooltip error
     * @private
     * @param {jQuery[]} field the field being toggled
     * @param {string} message text content containing the validation message
     * @param {string} type (error, alert, info, etc.)
     * @param {HTMLElement} markup existing HTML markup to use
     * @param {boolean} isShow whether or not the message is already showing
     */
    toggleRadioMessage: function toggleRadioMessage(field, message, type, markup, isShow) {
      var all = void 0;
      var loc = void 0;
      var name = field.attr('name');

      if (name && name.length) {
        all = $(':radio[name="' + name + '"], :radio[name="' + name + '"] + label');
        loc = field.parent().is('.inline') ? $(':radio[name="' + name + '"]:last').parent() : $(':radio[name="' + name + '"]:last + label');

        if (isShow) {
          all.addClass(type === 'icon' ? 'custom-icon' : type);
          $(markup).addClass('radio-group-' + type).insertAfter(loc);
        } else {
          all.removeClass(type);
          loc.next('.radio-group-' + type).remove();
        }
      }
    },


    /**
     * Shows an inline error message on a field
     * @private
     * @param {jQuery[]} field the field being modified
     * @param {string} rule The validation rule data.
     * @param {string} type the validation type (error, warn, info, etc).
     * @param {string} icon if type is icon then here pass icon string
     */
    showInlineMessage: function showInlineMessage(field, rule) {
      var loc = this.getField(field);
      var validationType = Validation.ValidationTypes[rule.type] || Validation.ValidationTypes.error;
      rule.icon = rule.icon || validationType.icon;

      var markup = void 0;
      if (rule.type === 'icon') {
        markup = '' + ('<div class="custom-icon-message" data-rule-id="' + (rule.id || rule.message) + '">\n          ' + $.createIcon({ classes: ['icon-custom'], icon: rule.icon }) + '\n          <pre class="audible">\n            ' + Locale.translate(validationType.titleMessageID) + '\n          </pre>\n          <p class="message-text">' + rule.message + '</p>\n        </div>');
      } else {
        markup = '' + ('<div class="' + validationType.type + '-message" data-rule-id="' + (rule.id || rule.message) + '">\n          ' + $.createIcon({ classes: ['icon-' + validationType.type], icon: validationType.type }) + '\n          <pre class="audible">\n            ' + Locale.translate(validationType.titleMessageID) + '\n          </pre>\n          <p class="message-text">' + rule.message + '</p>\n        </div>');
      }

      loc.addClass(rule.type === 'icon' ? 'custom-icon' : rule.type);

      if (field.is(':radio')) {
        this.toggleRadioMessage(field, rule.message, validationType.type, markup, true);
      } else {
        // All other components
        loc.closest('.field, .field-short').find('.formatter-toolbar').addClass(validationType.type === 'icon' ? 'custom-icon' : validationType.type);
        loc.closest('.field, .field-short').append(markup);
        loc.closest('.field, .field-short').find('.colorpicker-container').addClass(validationType.type === 'icon' ? 'custom-icon' : validationType.type);
      }

      if (field.is('.spinbox')) {
        loc.closest('.spinbox-wrapper').addClass(validationType.type === 'icon' ? 'custom-icon' : validationType.type);
      }

      // Remove positive errors
      if (validationType.type === 'error') {
        field.parent().find('.icon-success').remove();
      }

      // Trigger an event
      field.triggerHandler(validationType.type, { field: field, message: rule.message });
      field.closest('form').triggerHandler(validationType.type, { field: field, message: rule.message });
    },


    /**
     * Shows an inline error message on a field
     * @private
     * @param {jQuery[]} field the field being modified
     */
    addPositive: function addPositive(field) {
      var svg = $.createIcon({ icon: 'success', classes: 'icon-success' });

      if (!$('.icon-success', field.parent('.field, .field-short')).length) {
        field.parent('.field, .field-short').append(svg);
      }
    },


    /**
     * Remove the message form the field if there is one and mark the field valid, if no other messages.
     * @private
     * @param {jQuery[]} field the field which is having its error removed
     * @param {string} rule The validation rule to remove
     * @param {boolean} triggerEvents If true events will be fired
    */
    removeMessage: function removeMessage(field, rule) {
      var triggerEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      // see if anything to remove
      var loc = this.getField(field);
      var oldData = loc.data(rule.type + 'message');
      var ruleId = rule.id || rule.message;

      if (!rule) {
        return;
      }

      if (rule.type === 'error' && !oldData || oldData.filter(function (rules) {
        return rules.id === ruleId;
      }).length === 0) {
        return;
      }

      // Remove the message from the array
      var newData = oldData.filter(function (rules) {
        return rules.id !== ruleId;
      });
      var noMoreMessages = newData.length === 0;

      if (noMoreMessages) {
        loc.removeData(rule.type + 'message');
      } else {
        loc.data(rule.type + 'message', newData);
      }

      // Find the message by id and remove
      field.closest('.field, .field-short').find('[data-rule-id="' + (rule.id || rule.message) + '"]').remove();

      if (field.hasClass('dropdown') || field.hasClass('multiselect')) {
        field.parent().find('.dropdown-wrapper > [data-rule-id="' + (rule.id || rule.message) + '"]').off('click.validate').remove();
      }

      // Trigger valid and remove error / message classes
      if (noMoreMessages && rule.type === 'error' && triggerEvents) {
        field.triggerHandler('valid', { field: field, message: '' });
        field.closest('form').triggerHandler('valid', { field: field, message: '' });
      }

      if (!noMoreMessages) {
        return;
      }

      field.removeClass(rule.type + ' custom-icon').data('isValid', true);

      if (field.hasClass('dropdown') || field.hasClass('multiselect')) {
        field.next().next().removeClass(rule.type + ' custom-icon');
        field.next().find('div.dropdown').removeClass(rule.type + ' custom-icon');
      }

      if (field.is(':radio')) {
        this.toggleRadioMessage(field, '', rule.type, '', false);
      }

      if (field.hasClass('spinbox')) {
        field.closest('.spinbox-wrapper').removeClass(rule.type + ' custom-icon');
      }
      if (field.hasClass('colorpicker')) {
        field.parent('.colorpicker-container').removeClass(rule.type);
      }
      if (field.closest('.field-fileupload').length > 0) {
        field.closest('.field-fileupload').find('input.' + rule.type).removeClass(rule.type);
      }

      // Remove tooltip style message and tooltip
      if (field.attr('data-' + rule.type + '-type') === 'tooltip') {
        var errorIcon = field.closest('.field, .field-short').find('.icon-error');
        var tooltipAPI = errorIcon.data('tooltip');
        // Destroy tooltip
        if (tooltipAPI) {
          tooltipAPI.destroy();
        }
        if (this.inputs) {
          this.inputs.filter('input, textarea').off('focus.validate');
        }
        // Remove icon
        field.parent().find('.dropdown-wrapper > .icon-' + rule.type).off('click.validate').remove(); // SVG Error Icon
        field.parent().find('.icon-' + rule.type).remove();
        field.next('.icon-' + rule.type).off('click.validate').remove();
        field.parent('.field, .field-short').find('.icon-' + rule.type).remove();
        field.next('.inforCheckboxLabel').next('.icon-' + rule.type).remove();
      }
    },


    /**
     * Shows an inline error message on a field
     * @private
     * @param {jQuery[]} field the field being modified
     */
    removePositive: function removePositive(field) {
      $('.icon-success', field.parent('.field, .field-short')).remove();
    },


    /**
     * Reset all form errors and values
     * @param {jQuery[]} form The form to reset.
     */
    resetForm: function resetForm(form) {
      var formFields = form.find('input, select, textarea');

      // Clear Errors
      formFields.removeClass('error');
      form.find('.error').removeClass('error');
      form.find('.icon-error').remove();
      form.find('.icon-success').remove();
      form.find('.error-message').remove();

      // Clear Warnings
      formFields.removeClass('alert');
      form.find('.alert').removeClass('alert');
      form.find('.icon-alert').remove();
      form.find('.alert-message').remove();

      // Clear Informations
      formFields.removeClass('info');
      form.find('.info').removeClass('info');
      form.find('.icon-info').remove();
      form.find('.info-message').remove();

      setTimeout(function () {
        $('#validation-errors').addClass('is-hidden');
      }, 300);

      // Remove Dirty
      formFields.data('isDirty', false).removeClass('isDirty');
      form.find('.isDirty').removeClass('isDirty');

      // reset form data
      if (form.is('form')) {
        form[0].reset();
      }

      var validationTypes = $.fn.validation.ValidationTypes;
      Object.keys(validationTypes).forEach(function (validationType) {
        formFields.removeData(validationType + 'message');
      });
    },


    /**
     * See if any form errors and check for any empty required fields.
     * @param {jQuery[]} form The form to check.
     * @returns {boolean} True if the form is valid, false otherwise.
     */
    isFormValid: function isFormValid(form) {
      if ($(form).find('.error-message').length > 0) {
        return false;
      }

      var formFields = $(form).find('[data-validate*="required"]');
      for (var i = 0; i < formFields.length; i++) {
        var field = $(formFields[i]);
        var value = this.value(field);

        if ((field.is(':visible') || field.is('select')) && !value) {
          return false;
        }
      }

      return true;
    },


    /**
     * Update method
     * @param {object} [settings] incoming settings
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }
    }
  };

  // Component Name
  var VALIDATE_COMPONENT_NAME = 'validate';

  // Settings specific to error messages.
  // Used for backwards compatibility.
  var ERROR_MESSAGE_DEFAULTS = {
    type: 'error',
    inline: true
  };

  /**
   * jQuery Component Wrapper for the Validation Component
   */
  $.fn.validation = Validation;

  /**
   * Returns the specific type message data object for a Field
   * @param {object} [settings] incoming settings
   * @returns {string} messages as a string for the specific type
   */
  $.fn.getMessage = function (settings) {
    if (!settings) {
      settings = { type: 'error' };
    }
    var dataAttr = settings.type + 'message';
    var messages = $.fn.getField($(this)).data(dataAttr);
    var strMessages = '';

    if (messages) {
      if (messages.length === 1) {
        return messages[0].message;
      }

      for (var i = 0; i < messages.length; i++) {
        strMessages += '\u2022 ' + messages[i].message;
      }
    }

    return strMessages;
  };

  /**
   * Returns all messages on an object as an array.
   * @param {object} [settings] incoming settings
   * @returns {array} message data for the specific type
   */
  $.fn.getMessages = function (settings) {
    if (!settings) {
      settings = { type: 'error' };
    }
    var dataAttr = settings.type + 'message';

    var messages = $.fn.getField($(this)).data(dataAttr);
    if (!messages) {
      messages = [];
    }
    return messages;
  };

  /**
   * Retrive the actionble element that should have an error class/icon appended to it.
   * @private
   * @param {jQuery[]} field the field being checked
   * @returns {jQuery[]} the field to be checked
   */
  $.fn.getField = function (field) {
    if (field.is('select') && field.data('dropdown') !== undefined) {
      field = field.data('dropdown').pseudoElem;
    }
    return field;
  };

  /**
   * Returns the errormessage data object for a Field.
   * This method is slated to be removed in a future v4.10.0 or v5.0.0.
   * @deprecated as of v4.4.0.  Please use `$.fn.getMessage()` instead.
   * @param {object} [settings] incoming settings
   * @returns {object} error message data
   */
  $.fn.getErrorMessage = function (settings) {
    warnAboutDeprecation('$.fn.getMessage', '$.fn.getErrorMessage');
    settings = utils.extend({}, settings, ERROR_MESSAGE_DEFAULTS);
    return $(this).getMessage(settings);
  };

  /**
   * ScrollIntoView and sets focus on an element
   * @param {boolean} [alignToTop] true (default) element will be aligned to the
   *  top of the visible area of the scrollable ancestor
   * @param {object} [settings] incoming settings
   */
  $.fn.scrollIntoView = function (alignToTop, settings) {
    if (typeof alignToTop !== 'boolean') {
      alignToTop = undefined;
    }

    var instance = new Validator(this, settings);
    var elem = instance.getField($(this));
    elem[0].scrollIntoView(alignToTop);
    elem.focus();
  };

  /**
   * Add a Message to a Field
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements receiving messages
   */
  $.fn.addMessage = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$A);
      if (!instance) {
        instance = $.data(this, COMPONENT_NAME$A, new Validator(this, settings));
      }

      var rule = {
        message: settings.message,
        type: settings.type,
        triggerEvents: settings.triggerEvents,
        icon: settings.icon,
        id: settings.id || settings.message
      };

      instance.addMessage($(this), rule, settings.inline, settings.showTooltip);
    });
  };

  /**
   * Add an error Message to a Field.
   * This method is slated to be removed in a future v4.10.0 or v5.0.0.
   * @deprecated as of v4.4.0.  Please use `$.fn.addMessage()` instead.
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements receiving errors
   */
  $.fn.addError = function (settings) {
    warnAboutDeprecation('$.fn.addMessage', '$.fn.addError');
    var inline = true;
    if (typeof settings.inline === 'boolean' && settings.inline === false) {
      inline = false;
    }
    settings = utils.extend({}, settings, ERROR_MESSAGE_DEFAULTS);
    settings.inline = inline;
    return this.each(function () {
      $(this).addMessage(settings);
    });
  };

  /**
   * Remove a Message from a Field
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements having errors removed
   */
  $.fn.removeMessage = function (settings) {
    if (!settings) {
      settings = { type: 'error' };
    }

    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$A);
      if (!instance) {
        instance = $.data(this, COMPONENT_NAME$A, new Validator(this, settings));
      }

      var field = $(this);
      var dataAttr = settings.type + 'message';
      var errors = $.fn.getField(field).data(dataAttr);
      if (!errors) {
        return;
      }

      for (var i = 0; i < errors.length; i++) {
        instance.removeMessage(field, errors[i], settings.triggerEvents);
      }
      instance.setIconOnParent(field, settings.type);

      $.removeData(this, COMPONENT_NAME$A);
    });
  };

  /**
   * Remove an error Message from a Field.
   * This method is slated to be removed in a future v4.10.0 or v5.0.0.
   * @deprecated as of v4.4.0.  Please use `$.fn.removeMessage()` instead.
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements having errors removed
   */
  $.fn.removeError = function (settings) {
    warnAboutDeprecation('$.fn.removeMessage', '$.fn.removeError');
    settings = utils.extend({}, settings, ERROR_MESSAGE_DEFAULTS);
    return this.each(function () {
      return $(this).removeMessage(settings);
    });
  };

  /**
   * The Actual Validate Component
   * @param {object|string} [settings] incoming settings, or an API method name
   * @param {object} args that can be passed to an API method, if called via string settings
   * @returns {jQuery[]} components being acted on
   */
  $.fn.validate = function (settings, args) {
    var settingsAreAPIFunction = typeof settings === 'string';

    return this.each(function () {
      var instance = $.data(this, VALIDATE_COMPONENT_NAME);
      if (instance && typeof instance !== 'string') {
        // If settings are a string, assume the string is a function on the instance API
        // that needs to be called, and attempt to call it.
        if (settingsAreAPIFunction) {
          if (typeof instance[settings] === 'function') {
            instance[settings](args);
          } else {
            log('warn', 'No method with name "' + settings + '" found on "' + VALIDATE_COMPONENT_NAME + '" component API.');
          }
          return;
        }

        // Settings are object-based, and can be handled normally
        instance.updated(settings);
      } else {
        instance = $.data(this, VALIDATE_COMPONENT_NAME, new Validator(this, settings));
      }
    });
  };

  /**
   * Soho Validation Utilities
   * ========================================
   */

  /**
   * jQuery Utility function wrapper for checking whether or not a field passes validation.
   * @returns {boolean} whether or not the field is valid
   */
  $.fn.isValid = function () {
    var isValidAttr = $(this).data('isValid');
    return isValidAttr === undefined || isValidAttr === null ? true : isValidAttr;
  };

  /**
   * Check validation manually.
   * @returns {void}
   */
  $.fn.validateField = function () {
    var field = $(this);
    var api = Soho.components.Validator.prototype; //eslint-disable-line

    if (api && api.validate) {
      api.validate(field, false, 0);
    }
  };

  /**
   * Clear out the stuff on the Form
   */
  $.fn.resetForm = function () {
    var api = Soho.components.Validator.prototype; //eslint-disable-line
    api.resetForm(this);
  };

  // Component Name
  var COMPONENT_NAME$B = 'datepicker';

  /**
   * A component to support date entry.
   * @class DatePicker
   * @constructor
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {boolean} [settings.showTime=false] If true the time selector will be shown.
   * @param {boolean} [settings.useCurrentTime=false] If true current time will be used for the time portion otherwise 12:00 midnight is used
   * @param {string} [settings.timeFormat] Format to use time section fx HH:mm,
   *  defaults current locale settings.
   * @param {number} [settings.minuteInterval]
   * @param {number} [settings.secondInterval]
   * @param {string} [settings.mode] Time picker options: 'standard', 'range',
   *  this controls the time picker.
   * @param {boolean} [settings.roundToInterval] In time picker mode, if a non-matching
   *  minutes value is entered,
   *  rounds the minutes value to the nearest interval when the field is blurred.
   * @param {string} [settings.dateFormat='locale'] Defaults to current locale but can be
   * @param {string} [settings.placeholder=false] Text to show in input element while empty.
   * @param {number} [settings.firstDayOfWeek=null] Set first day of the week. '1' would be Monday.
   * @param {object} [settings.disable] Disable dates in various ways.
   * For example `{minDate: 'M/d/yyyy', maxDate: 'M/d/yyyy'}`. Dates should be in format M/d/yyyy
   * or be a Date() object or string that can be converted to a date with new Date().
   * @param {array} [settings.disable.dates] Disable specific dates.
   * Example `{dates: ['12/31/2018', '01/01/2019'}`.
   * @param {string|date} [settings.disable.minDate] Disable up to a minimum date.
   * Example `{minDate: '12/31/2016'}`.
   * @param {string|date} [settings.disable.maxDate] Disable up to a maximum date.
   * Example `{minDate: '12/31/2019'}`.
   * @param {array} [settings.disable.dayOfWeek] Disable a specific of days of the week 0-6.
   * Example `{dayOfWeek: [0,6]}`.
   * @param {boolean} [settings.disable.isEnable=false] Inverse the disable settings.
   * If true all the disable settings will be enabled and the rest will be disabled.
   * So you can inverse the settings.
   * @param {boolean} [settings.disable.retrictMonths=false] Restrict month selections on datepicker.
   * It requires minDate and maxDate for the feature to activate.
   * For example if you have more non specific dates to disable then enable ect.
   * @param {boolean} [settings.showLegend=false] If true a legend is show to associate dates.
   * @param {boolean} [settings.showMonthYearPicker=false] If true the month and year will render as dropdowns.
   * @param {boolean} [settings.hideDays=false] If true the days portion of the calendar will be hidden.
   *  Usefull for Month/Year only formats.
   * @param {number} [settings.advanceMonths=5] The number of months in each direction to show in
   *  the dropdown for months (when initially opening)
   * @param {array} [settings.legend]  Legend Build up
   * for example `[{name: 'Public Holiday', color: '#76B051', dates: []},
   * {name: 'Weekends', color: '#EFA836', dayOfWeek: []}]`
   * @param {object} [settings.range] Range between two dates with various options.
   * @param {boolean} [settings.range.useRange=false] Use range of two dates options.
   * @param {string|date} [settings.range.start] Start date in range.
   * @param {string|date} [settings.range.end] End date in range.
   * @param {string} [settings.range.separator=' - '] Visual separator between two dates.
   * @param {number} [settings.range.minDays=0] Minimum days to be in range.
   * @param {number} [settings.range.maxDays=0] Maximum days to be in range.
   * @param {boolean} [settings.range.selectForward=false] Range only in forward direction.
   * @param {boolean} [settings.range.selectBackward=false] Range only in backward direction.
   * @param {boolean} [settings.range.includeDisabled=false] Include disable dates in range of dates.
   * @param {string} [settings.calendarName] The name of the calendar to use in instance of multiple calendars. At this time only ar-SA and ar-EG locales have either 'gregorian' or 'islamic-umalqura' as valid values.
   * @param {string} [settings.locale] The name of the locale to use for this instance. If not set the current locale will be used.
   * @param {boolean} [settings.useUTC=false] If true the dates will use UTC format. This is only partially
   * implemented https://jira.infor.com/browse/SOHO-3437
   * @param {boolean} [settings.autoSize=false] If true the field will be sized to the width of the date.
   * @param {boolean} [settings.hideButtons=false] If true bottom and next/prev buttons will be not shown.
   */
  var DATEPICKER_DEFAULTS = {
    showTime: false,
    useCurrentTime: false,
    timeFormat: undefined,
    minuteInterval: undefined,
    secondInterval: undefined,
    mode: undefined,
    roundToInterval: undefined,
    dateFormat: 'locale', // or can be a specific format
    placeholder: false,
    firstDayOfWeek: null,
    disable: {
      dates: [],
      minDate: '',
      maxDate: '',
      dayOfWeek: [],
      isEnable: false,
      restrictMonths: false
    },
    showLegend: false,
    showMonthYearPicker: false,
    hideDays: false,
    advanceMonths: 5,
    legend: [
    // Legend Build up example
    // Color in level 6 - http://usmvvwdev53:424/controls/colors
    { name: 'Public Holiday', color: '#76B051', dates: [] }, { name: 'Weekends', color: '#EFA836', dayOfWeek: [] }],
    range: {
      useRange: false, // true - if datepicker using range dates
      start: '', // Start date '03/05/2018'
      end: '', // End date '03/21/2018'
      separator: ' - ', // separator string between two dates
      minDays: 0, // Minimum days
      maxDays: 0, // Maximum days
      selectForward: false, // Only in forward direction
      selectBackward: false, // Only in backward direction
      includeDisabled: false // if true range will include disable dates in it
    },
    calendarName: null,
    locale: '',
    useUTC: false,
    autoSize: false,
    hideButtons: false
  };

  function DatePicker(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, DATEPICKER_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  DatePicker.prototype = {
    init: function init() {
      this.build();
      this.handleEvents();
    },


    /**
     * Add markup
     * @private
     * @returns {void}
     */
    build: function build() {
      // Add "is-disabled" css class to closest ".field" if element is disabled
      if (this.element.is(':disabled')) {
        this.element.closest('.field').addClass('is-disabled');
      }

      // Append a trigger button
      this.trigger = $.createIconElement('calendar').insertAfter(this.element);

      // Hide icon if datepicker input is hidden
      if (this.element.hasClass('hidden')) {
        this.trigger.addClass('hidden');
      }

      // Set the current calendar
      this.setLocale();
      this.addAria();
      this.setCurrentCalendar();
      this.setSize();
    },


    /**
     * Set current locale to be used.
     * @private
     * @returns {void}
     */
    setLocale: function setLocale() {
      var _this = this;

      this.locale = Locale.currentLocale;
      if (this.settings.locale) {
        Locale.getLocale(this.settings.locale).done(function (locale) {
          _this.locale = Locale.cultures[locale];
          _this.setCurrentCalendar();
        });
      }
    },


    /**
     *  Sets current calendar information.
     * @private
     * @returns {void}
     */
    setCurrentCalendar: function setCurrentCalendar() {
      this.currentCalendar = Locale.calendar(this.locale.name, this.settings.calendarName);
      this.isIslamic = this.currentCalendar.name === 'islamic-umalqura';
      this.isRTL = this.locale.direction === 'right-to-left';
      this.conversions = this.currentCalendar.conversions;
      this.isFullMonth = this.settings.dateFormat.indexOf('MMMM') > -1;
      this.setFormat();
      this.mask();
    },


    /**
     * Set size attribute based on current contents
     * @private
     * @returns {void}
     */
    setSize: function setSize() {
      if (!this.settings.autoSize) {
        return;
      }
      var elem = this.element[0];
      var padding = 45;
      elem.classList.add('input-auto');
      elem.style.width = stringUtils.textWidth(elem.value, 16) + padding + 'px';
    },


    /**
     * Add aria
     * @private
     * @returns {void}
     */
    addAria: function addAria() {
      this.label = $('label[for="' + this.element.attr('id') + '"]');
      this.label.append('<span class="audible">' + Locale.translate('PressDown', this.locale.name) + '</span>');
    },


    /**
     * Handle Keyboard Stuff
     * @private
     * @param {object} elem to handle.
     * @returns {void}
     */
    handleKeys: function handleKeys(elem) {
      var _this2 = this;

      var s = this.settings;

      // Handle Tab key while popup is open - the rest is handled in monthview.js now
      if (elem.is('#monthview-popup')) {
        elem.off('keydown.datepicker').on('keydown.datepicker', '.monthview-table', function (e) {
          var handled = false;
          var key = e.keyCode || e.charCode || 0;

          // Tab closes Date Picker and goes to next field on the modal
          if (key === 9) {
            _this2.containFocus(e);
            handled = true;
          }

          // Esc closes Date Picker and goes back to field
          if (key === 27) {
            _this2.closeCalendar();
            _this2.element.focus();
            e.stopImmediatePropagation();
            handled = true;
          }

          // 't' selects today
          if (key === 84) {
            _this2.closeCalendar();
            _this2.element.focus();
            handled = true;
          }

          if (handled) {
            e.stopPropagation();
            e.preventDefault();
            return false;
          }
          return true;
        });

        elem.off('keydown.datepicker-tab').on('keydown.datepicker-tab', 'td, input, div.dropdown, button', function (e) {
          var key = e.keyCode || e.charCode || 0;

          // Tab closes Date Picker and goes to next field on the modal
          if (key === 9) {
            if (s.range.useRange && $(e.target).is('.next')) {
              _this2.calendarAPI.days.find('td:visible:last').attr('tabindex', 0).focus();
            } else {
              _this2.containFocus(e);
            }
            e.stopPropagation();
            e.preventDefault();
            return false;
          }
          return true;
        });

        return;
      }

      // Handle keys on the input field
      elem.off('keydown.datepicker').on('keydown.datepicker', function (e) {
        var handled = false;
        var key = e.keyCode || e.charCode || 0;

        // Arrow Down or Alt first opens the dialog
        if (key === 40 && !_this2.isOpen()) {
          handled = true;
          _this2.openCalendar();

          setTimeout(function () {
            _this2.setFocusAfterOpen();
          }, 200);
        }

        // 't' selects today
        if (key === 84) {
          handled = true;
          _this2.setToday();
        }

        if (handled) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }
        return true;
      });
    },


    /**
     * Focus the next prev focusable element on the popup
     * @private
     * @param {object} e event.
     * @returns {void}
     */
    containFocus: function containFocus(e) {
      var reverse = e.shiftKey;

      // Set focus on (opt: next|prev) focusable element
      var focusables = this.popup.find(':focusable');
      var index = focusables.index($(':focus'));

      if (!reverse) {
        index = index + 1 >= focusables.length ? 0 : index + 1;
      } else {
        index = index - 1 < 0 ? focusables.length : index - 1;
      }

      var elem = focusables.eq(index);
      elem.focus();

      if (elem.is('td')) {
        elem.addClass('is-selected' + (this.settings.range.useRange ? ' range' : ''));
        this.currentDate.setDate(elem.text());
        this.currentDate.setMonth(this.calendar.find('.month').attr('data-month'));
        this.insertDate(this.currentDate);
        elem.focus();
      }
    },


    /**
     * Parse the Date Format Options
     * @private
     * @returns {void}
     */
    setFormat: function setFormat() {
      var s = this.settings;
      var localeDateFormat = (typeof Locale === 'undefined' ? 'undefined' : _typeof(Locale)) === 'object' && this.currentCalendar.dateFormat ? this.currentCalendar.dateFormat : null;
      var localeTimeFormat = (typeof Locale === 'undefined' ? 'undefined' : _typeof(Locale)) === 'object' && this.currentCalendar.timeFormat ? this.currentCalendar.timeFormat : null;

      if ((typeof localeDateFormat === 'undefined' ? 'undefined' : _typeof(localeDateFormat)) === 'object' && localeDateFormat.short !== undefined) {
        localeDateFormat = localeDateFormat.short;
      }

      if (s.dateFormat === 'locale') {
        this.pattern = localeDateFormat + (s.showTime ? ' ' + (s.timeFormat || localeTimeFormat) : '');
      } else {
        this.pattern = s.dateFormat + (s.showTime && s.timeFormat ? ' ' + s.timeFormat : '');
      }

      this.show24Hours = (this.pattern.match('H') || []).length > 0;
      this.isSeconds = (this.pattern.match('ss') || []).length > 0;
    },


    /**
     * Add masking with the mask function
     * @private
     * @returns {void}
     */
    mask: function mask() {
      this.setFormat();
      var s = this.settings;
      var maskOptions = {
        process: 'date',
        keepCharacterPositions: true,
        patternOptions: {
          format: this.pattern
        }
      };
      var validation = 'date availableDate';
      var events = { date: 'change blur enter', availableDate: 'change blur' };

      if (s.range.useRange) {
        maskOptions.process = 'rangeDate';
        maskOptions.patternOptions.delimeter = s.range.separator;
        validation = 'rangeDate';
        events = { rangeDate: 'change blur' };
      }

      maskOptions.processOnInitialize = false;

      if (this.isFullMonth) {
        this.pattern = this.settings.dateFormat;
      } else {
        this.element.mask(maskOptions);
      }

      if (this.element[0] && this.element[0].getAttribute && !this.element[0].getAttribute('data-validate')) {
        this.element.attr({
          'data-validate': validation,
          'data-validation-events': JSON.stringify(events)
        }).validate();
      }

      this.setPlaceholder();
    },


    /**
     * Set placeholder
     * @private
     * @returns {void}
     */
    setPlaceholder: function setPlaceholder() {
      var _this3 = this;

      var formatDate = function formatDate(d) {
        return Locale.formatDate(d, {
          pattern: _this3.pattern,
          locale: _this3.locale.name
        });
      };
      var s = this.settings;
      var placeholder = this.pattern;

      if (s.placeholder && (!this.element.attr('placeholder') || this.element.attr('placeholder') === 'M / D / YYYY')) {
        if (s.range.useRange) {
          placeholder = s.range.first && s.range.first.date ? formatDate(s.range.first.date) + s.range.separator + this.pattern : this.pattern + s.range.separator + this.pattern;
        }
        this.element[0].setAttribute('placeholder', placeholder);
      }
    },


    /**
     * Check if the calendar div is open or not
     * @private
     * @returns {boolean} whether or not the calendar div is open.
     */
    isOpen: function isOpen() {
      return this.popup && this.popup.is(':visible') && !this.popup.hasClass('is-hidden');
    },


    /**
     * Open the calendar popup.
     * This method is slated to be removed in a future v4.15.0 or v5.0.0.
     * @deprecated as of v4.9.0. Please use `openCalendar()` instead.
     * @returns {void}
     */
    open: function open() {
      return deprecateMethod(this.openCalendar, this.open).apply(this);
    },


    /**
     * Open the calendar in a popup
     * @private
     * @returns {void}
     */
    openCalendar: function openCalendar() {
      var _this4 = this;

      var self = this;
      var s = this.settings;
      var timeOptions = {};

      if ((this.element.is(':disabled') || this.element.attr('readonly')) && this.element.closest('.monthview').length === 0) {
        return;
      }

      $('#validation-tooltip').addClass('is-hidden');

      /**
      * Fires as the calendar popup is opened.
      * @event listopened
      * @memberof DatePicker
      * @property {object} event - The jquery event object
      */
      this.element.addClass('is-active is-open').trigger('listopened');
      this.timepickerContainer = $('<div class="datepicker-time-container"></div>');
      this.footer = $('' + ('<div class="popup-footer">\n        <button type="button" class="cancel btn-tertiary">\n          ' + Locale.translate('Clear', this.locale.name) + '\n        </button>\n        <button type="button" class="is-today btn-tertiary">\n          ' + Locale.translate('Today', this.locale.name) + '\n        </button>\n      </div>'));

      if (s.hideDays) {
        this.footer = $('' + ('<div class="popup-footer">\n          <button type="button" class="select-month btn-tertiary">\n            ' + Locale.translate('Select', this.locale.name) + '\n          </button>\n        </div>'));
      }

      if (s.hideButtons) {
        this.footer = $('');
      }

      // Timepicker options
      if (s.showTime) {
        if (s.timeFormat === undefined) {
          // Getting time-format from date-format (dateFormat: 'M/d/yyyy HH:mm:ss')
          timeOptions.timeFormat = this.pattern.slice(this.pattern.indexOf(' ')).trim();
        } else {
          timeOptions.timeFormat = s.timeFormat;
        }
        if (s.minuteInterval !== undefined) {
          timeOptions.minuteInterval = s.minuteInterval;
        }
        if (s.secondInterval !== undefined) {
          timeOptions.secondInterval = s.minuteInterval;
        }
        if (s.mode !== undefined) {
          timeOptions.mode = s.mode;
        }
        if (s.roundToInterval !== undefined) {
          timeOptions.roundToInterval = s.roundToInterval;
        }
      }

      this.calendarContainer = $('<div class="monthview-container"></div>');

      // Show Month
      this.setValueFromField();

      // Set timepicker
      if (this.settings.showTime) {
        // Set to 12:00
        if (this.element.val() === '' && this.currentDate && this.currentDate.getDate() && !this.settings.useCurrentTime) {
          this.currentDate.setHours(0);
          this.currentDate.setMinutes(0);
          this.currentDate.setSeconds(0);
        }

        timeOptions.parentElement = this.timepickerContainer;
        timeOptions.locale = this.settings.locale;
        this.time = this.getTimeString(this.currentDate, this.show24Hours);
        this.timepicker = this.timepickerContainer.timepicker(timeOptions).data('timepicker');
        this.timepickerContainer.find('.dropdown').dropdown();

        this.timepickerContainer.on('change.datepicker', function () {
          _this4.currentDate = _this4.setTime(_this4.currentDate);
          _this4.setValue(_this4.currentDate, true, true);
        });

        // Wait for timepicker to initialize
        setTimeout(function () {
          _this4.timepicker.initValues = _this4.timepicker.getTimeFromField(_this4.time);
          _this4.timepicker.afterShow(_this4.timepickerContainer);
          return; // eslint-disable-line
        }, 1);
      }

      this.todayDate = new Date();
      this.todayMonth = this.todayDate.getMonth();
      this.todayYear = this.todayDate.getFullYear();
      this.todayDay = this.todayDate.getDate();

      if (this.isIslamic) {
        this.todayDateIslamic = this.conversions.fromGregorian(this.todayDate);
        this.todayYear = this.todayDateIslamic[0];
        this.todayMonth = this.todayDateIslamic[1];
        this.todayDay = this.todayDateIslamic[2];
      }

      this.settings.month = this.currentMonth;
      this.settings.year = this.currentYear;
      if (this.isIslamic) {
        this.settings.activeDateIslamic = this.activeDate instanceof Date ? this.conversions.fromGregorian(this.activeDate) : this.activeDate;
      }

      if (this.settings.onOpenCalendar) {
        // In some cases, month picker wants to set a specifc time.
        this.settings.activeDate = this.settings.onOpenCalendar();
        if (this.isIslamic) {
          this.settings.activeDateIslamic = this.conversions.fromGregorian(this.settings.activeDate);
        }
      } else {
        this.settings.activeDate = this.currentDate || this.todayDate;
        this.settings.activeDateIslamic = this.currentIslamicDate || this.todayDateIslamic;
      }

      this.settings.isPopup = true;
      this.settings.headerStyle = 'simple';

      // Handle day change
      this.settings.onSelected = function (node, args) {
        _this4.currentDate = new Date(args.year, args.month, args.day);
        if (self.settings.range.useRange && self.settings.range.first) {
          return;
        }
        self.insertDate(_this4.currentDate);

        if (args.close) {
          self.closeCalendar();
          self.element.focus();
        }
      };

      this.calendarAPI = new MonthView(this.calendarContainer, this.settings);
      this.calendar = this.calendarAPI.element;

      if (s.showTime) {
        this.calendar.addClass('is-timepicker');
      }
      if (s.hideDays) {
        this.calendar.addClass('is-monthyear');
      }
      this.calendar.append(s.showTime ? this.timepickerContainer : '', this.footer);

      var placementParent = this.element;
      var placementParentXAlignment = this.isRTL ? 'right' : 'left';
      var parent = this.element.parent();

      if (parent.is('.datagrid-cell-wrapper')) {
        placementParentXAlignment = 'center';
        placementParent = this.element.next('.icon');
      }

      var popoverOpts = {
        content: this.calendar,
        placementOpts: {
          parent: placementParent,
          parentXAlignment: placementParentXAlignment,
          strategies: ['flip', 'nudge', 'shrink']
        },
        placement: 'bottom',
        popover: true,
        trigger: 'immediate',
        extraClass: 'monthview-popup',
        tooltipElement: '#monthview-popup',
        initializeContent: false
      };

      this.trigger.popover(popoverOpts).off('show.datepicker').on('show.datepicker', function () {
        if (Environment.os.name === 'ios') {
          $('head').triggerHandler('disable-zoom');
        }

        // Horizontal view on mobile
        if (window.innerHeight < 400 && _this4.popupClosestScrollable) {
          _this4.popup.find('.arrow').hide();
          _this4.popup.css('min-height', _this4.popupClosestScrollable[0].scrollHeight + 2 + 'px');
          _this4.popupClosestScrollable.css('min-height', '375px');
        }

        // Hide calendar until range to be pre selected
        if (s.range.useRange && s.range.first && s.range.first.date && s.range.second && s.range.second.date) {
          _this4.popup.addClass('is-hidden');
        }

        if (_this4.settings.hideButtons) {
          _this4.popup.addClass('hide-buttons');
        }
      }).off('hide.datepicker').on('hide.datepicker', function () {
        if (Environment.os.name === 'ios') {
          _this4.trigger.one('hide', function () {
            $('head').triggerHandler('enable-zoom');
          });
        }

        _this4.popupClosestScrollable.add(_this4.popup).css('min-height', '');
        _this4.closeCalendar();
      });

      this.handleKeys($('#monthview-popup'));
      $('.monthview-footer a', this.calendar).button();

      this.popup = $('#monthview-popup');
      this.popupClosestScrollable = this.popup.closest('.scrollable');
      this.popup.attr('role', 'dialog');
      this.originalDate = this.element.val();
      this.calendarAPI.currentDate = this.currentDate;
      this.calendarAPI.currentIslamicDate = this.currentIslamicDate;
      this.calendarAPI.validatePrevNext();

      // Calendar Day Events
      this.calendarAPI.days.off('click.datepicker').on('click.datepicker', 'td', function () {
        var td = $(this);
        if (td.hasClass('is-disabled')) {
          self.calendarAPI.activeTabindex(td, true);
        } else {
          if (!(s.range.useRange && s.range.first)) {
            self.calendarAPI.days.find('.is-selected').removeClass('is-selected range').removeAttr('aria-selected');
          }

          var cell = $(this);
          cell.addClass('is-selected' + (s.range.useRange ? ' range' : '')).attr('aria-selected', 'true');

          var cellDate = self.calendarAPI.getCellDate(cell);
          var day = cellDate.day;
          var month = cellDate.month;
          var year = cellDate.year;

          self.currentDate = new Date(year, month, day);

          if (self.isIslamic) {
            self.currentDateIslamic[0] = year;
            self.currentDateIslamic[1] = month;
            self.currentDateIslamic[2] = day;
            self.currentYear = year;
            self.currentMonth = month;
            self.currentDay = day;
            self.currentDate = self.conversions.toGregorian(year, month, day);
          }

          self.insertDate(self.isIslamic ? self.currentDateIslamic : self.currentDate);

          if (s.range.useRange) {
            self.isFocusAfterClose = true;
          } else {
            self.closeCalendar();
            self.element.focus();
          }
        }
      });

      // Calendar Footer Events
      this.footer.off('click.datepicker').on('click.datepicker', 'button', function (e) {
        var btn = $(this);

        if (btn.hasClass('cancel')) {
          /**
          * Fires after the value in the input is changed by any means.
          *
          * @event change
          * @memberof DatePicker
          * @property {object} event - The jquery event object
          */
          self.element.val('').trigger('change').trigger('input');
          self.currentDate = null;
          self.closeCalendar();
        }

        if (btn.hasClass('select-month')) {
          var year = parseInt(self.calendarAPI.header.find('.year select').val(), 10);
          var month = parseInt(self.calendarAPI.header.find('.month select').val(), 10);

          self.currentDate = new Date(year, month, 1);

          if (self.isIslamic) {
            self.currentDateIslamic[0] = year;
            self.currentDateIslamic[1] = month;
            self.currentDateIslamic[2] = 1;
            self.currentYear = year;
            self.currentMonth = month;
            self.currentDay = 1;
            self.currentDate = self.conversions.toGregorian(year, month, 1);
          }

          self.insertDate(self.isIslamic ? self.currentDateIslamic : self.currentDate);
          if (s.range.useRange) {
            self.isFocusAfterClose = false;
          } else {
            self.closeCalendar();
          }
        }

        if (btn.hasClass('is-today')) {
          self.setToday();
          if (!s.range.useRange) {
            self.closeCalendar();
          }
        }
        self.element.focus();
        e.preventDefault();
      });

      setTimeout(function () {
        self.setFocusAfterOpen();
      }, 50);
    },


    /**
     * Close the calendar popup.
     * This method is slated to be removed in a future v4.15.0 or v5.0.0.
     * @deprecated as of v4.9.0. Please use `closeCalendar()` instead.
     * @returns {void}
     */
    close: function close() {
      return deprecateMethod(this.closeCalendar, this.close).apply(this);
    },


    /**
     * Close the calendar in a popup
     * @private
     * @returns {void}
     */
    closeCalendar: function closeCalendar() {
      // Remove range entries
      var cell = this.calendarAPI && this.calendarAPI.days.length ? this.calendarAPI.days.find('td.is-selected') : null;
      this.resetRange(cell);

      // Close timepicker
      if (this.settings.showTime && this.timepickerControl && this.timepickerControl.isOpen()) {
        this.timepickerControl.closeTimePopup();
      }

      if (this.popup && this.popup.length) {
        this.popup.hide().remove();
      }

      var popoverAPI = this.trigger.data('tooltip');
      if (popoverAPI) {
        popoverAPI.destroy();
      }

      if (this.element.hasClass('is-active')) {
        /**
        * Fires as the calendar popup is closed.
        *
        * @event listclosed
        * @memberof DatePicker
        * @property {object} event - The jquery event object
        */
        this.element.trigger('listclosed');
        this.element.removeClass('is-active is-open');
      }
    },


    /**
     * Set focus after opening the calendar
     * @private
     * @returns {void}
     */
    setFocusAfterOpen: function setFocusAfterOpen() {
      var s = this.settings;
      if (!this.calendar) {
        return;
      }

      if (s.hideDays) {
        this.calendar.find('div.dropdown:first').focus();
        return;
      }

      if (s.range.useRange) {
        if (s.range.first && s.range.first.label && (!s.range.second || s.range.second && !s.range.second.date)) {
          this.setRangeFirstPart(s.range.first.date);
        }
        this.calendarAPI.setRangeSelected();
        if (s.range.second && s.range.first.date && s.range.second.date) {
          this.element.val(this.getRangeValue());
        }
        // Pre selection compleated now show the calendar
        this.popup.removeClass('is-hidden');
      }
      this.calendarAPI.activeTabindex(this.calendar.find('.is-selected'), true);
    },


    /**
     * Set range first part
     * @private
     * @param {object} date .
     * @returns {void}
     */
    setRangeFirstPart: function setRangeFirstPart(date) {
      var _this5 = this;

      var s = this.settings;
      var dateObj = function dateObj(d) {
        return new Date(d.year, d.month, d.day);
      };
      var labelDate = function labelDate(d) {
        return Locale.formatDate(d, { date: 'full', locale: _this5.locale.name });
      };
      var minCell = this.calendarAPI.days.find('td:visible:first');
      var maxCell = this.calendarAPI.days.find('td:visible:last');
      var label = labelDate(date);
      var cell = this.calendarAPI.days.find('[aria-label="' + label + '"]');
      var row = cell.closest('tr');
      this.currentDate = date;

      s.range.first = { date: date, label: label, cell: cell, row: row, rowIdx: row.index(), cellIdx: cell.index() };
      s.range.extra = {
        minCell: minCell,
        maxCell: maxCell,
        min: dateObj(this.calendarAPI.getCellDate(minCell)),
        max: dateObj(this.calendarAPI.getCellDate(maxCell)),
        cellLength: row.children('td').length
      };
      this.calendarAPI.settings.range.first = s.range.first;
      this.calendarAPI.settings.range.extra = s.range.extra;
    },


    /**
     * Put the date in the field and select on the calendar
     * @private
     * @param {object} date .
     * @param {boolean} isReset .
     * @returns {void}
     */
    insertDate: function insertDate(date, isReset) {
      var s = this.settings;
      var year = date instanceof Array ? date[0] : date.getFullYear();
      var month = date instanceof Array ? date[1] : date.getMonth();
      var day = (date instanceof Array ? date[2] : date.getDate()).toString();

      // Make sure Calendar is showing that month
      if (this.calendarAPI.currentMonth !== month || this.calendarAPI.currentYear !== year) {
        this.calendarAPI.showMonth(month, year);
      }

      if (!this.isOpen()) {
        return;
      }

      // Show the Date in the UI
      var dateTd = this.calendarAPI.days.find('td:not(.alternate)').filter(function () {
        return $(this).text().toLowerCase() === day;
      });

      if (dateTd.hasClass('is-disabled')) {
        this.calendarAPI.activeTabindex(dateTd, true);
      } else {
        if (this.settings.showTime) {
          if (isReset) {
            this.time = this.getTimeString(date, this.show24Hours);

            if (this.settings.roundToInterval) {
              $('#timepicker-minutes').val('');
              date = this.setTime(date);
            }
          } else {
            date = this.setTime(date);
          }
        }

        this.setValue(date, true);
        if (s.range.useRange) {
          this.calendarAPI.days.find('.is-selected').removeAttr('aria-selected').removeAttr('tabindex');
        } else {
          this.calendarAPI.days.find('.is-selected').removeClass('is-selected range').removeAttr('aria-selected').removeAttr('tabindex');
        }
        dateTd.addClass('is-selected' + (s.range.useRange ? ' range' : '')).attr({ 'aria-selected': true });
        this.calendarAPI.activeTabindex(dateTd, true);
      }
    },


    /**
     * Set the Formatted value in the input
     * @private
     * @param {object} date The date to set in date format.
     * @param {boolean} trigger If true will trigger the change event.
     * @param {boolean} isTime will pass to set range.
     * @returns {void}
     */
    setValue: function setValue(date, trigger, isTime) {
      var s = this.settings;
      this.currentDate = date;

      if (date instanceof Array) {
        this.currentIslamicDate = date;
        this.currentDate = this.conversions.toGregorian(date[0], date[1], date[2]);
      }

      if (s.range.useRange) {
        if (!isTime) {
          this.setRangeToElem(date, false);
        }
      } else {
        this.element.val(Locale.formatDate(date, {
          pattern: this.pattern,
          locale: this.locale.name
        }));
      }

      if (trigger) {
        if (s.range.useRange) {
          if (!isTime) {
            this.element.trigger('change', [s.range.data]).trigger('input', [s.range.data]);
          }
        } else {
          this.element.trigger('change').trigger('input');
        }
      }

      this.setSize();
    },


    /**
     * Set range value to element
     * @private
     * @param {object} date .
     * @param {boolean} isSingleDate .
     * @returns {void}
     */
    setRangeToElem: function setRangeToElem(date, isSingleDate) {
      var _this6 = this;

      var s = this.settings;
      var formatDate = function formatDate(d) {
        return Locale.formatDate(d, {
          pattern: _this6.pattern,
          locale: _this6.locale.name
        });
      };
      var labelDate = function labelDate(d) {
        return Locale.formatDate(d, { date: 'full', locale: _this6.locale.name });
      };
      var value = formatDate(date);
      var handled = false;

      // Closed calendar
      if (!this.isOpen() && !isSingleDate) {
        handled = true;
        var d = date || new Date();
        this.currentMonth = d.getMonth();
        this.currentYear = d.getFullYear();
        this.currentDay = d.getDate();
        this.currentDate = d;

        s.range.first = s.range.first || {};
        s.range.second = s.range.second || {};
        s.range.first.date = d;
        s.range.second.date = d;
        value = this.getRangeValue();
      } else {
        // Opened calendar
        var label = labelDate(date);
        var cell = this.calendarAPI.days.find('[aria-label="' + label + '"]');
        var row = cell.closest('tr');

        if (s.range.second) {
          this.resetRange(cell);
        }

        var time = {};
        if (s.range.first) {
          time.date = date.getTime();
          time.firstdate = s.range.first.date.getTime();
          time.min = this.calendarAPI.getDifferenceToDate(s.range.first.date, s.range.minDays);
          time.max = this.calendarAPI.getDifferenceToDate(s.range.first.date, s.range.maxDays);
        }

        if (!s.range.first || isSingleDate) {
          this.setRangeFirstPart(date);
          value = this.getRangeValue();
          this.setPlaceholder();
        } else if (!s.range.second && s.range.selectBackward && time.date > time.firstdate || s.range.selectForward && time.date < time.firstdate || s.range.maxDays > 0 && time.date > time.max.aftertime || time.date < time.max.beforetime) {
          this.resetRange(cell);
          this.setRangeFirstPart(date);
          value = this.getRangeValue();
          this.setPlaceholder();
        } else {
          // Set second part for range
          handled = true;
          this.currentDate = date;
          // minDays
          if (s.range.minDays > 0) {
            if (time.date > time.firstdate && time.date < time.min.aftertime) {
              date = time.min.after;
            } else if (time.date < time.firstdate && time.date > time.min.beforetime) {
              date = time.min.before;
            }
            cell = this.calendarAPI.days.find('[aria-label="' + label + '"]');
            row = cell.closest('tr');
          }
          if (time.date > time.firstdate) {
            s.range.second = { date: date, label: label, cell: cell, row: row, rowIdx: row.index(), cellIdx: cell.index() };
          } else {
            s.range.second = s.range.first;
            s.range.first = { date: date, label: label, cell: cell, row: row, rowIdx: row.index(), cellIdx: cell.index() };
          }
          value = this.getRangeValue();
        }
      }

      // Set range value(first only or both parts) on element
      this.element.val(value);

      // Set data to use in triggerHandler
      if (!handled) {
        s.range.data = {
          value: value,
          dates: [s.range.first.date],
          startDate: s.range.first.date,
          start: formatDate(s.range.first.date)
        };
      } else {
        s.range.data = {
          value: value,
          dates: this.calendarAPI.getDateRange(s.range.first.date, s.range.second.date),
          startDate: s.range.first.date,
          start: formatDate(s.range.first.date),
          endDate: s.range.second.date,
          end: formatDate(s.range.second.date)
        };

        this.closeCalendar();
        if (this.isFocusAfterClose) {
          delete this.isFocusAfterClose;
          this.element.focus();
        }
      }
    },


    /**
     * Reset range values
     * @private
     * @param {object} cell to keep selection.
     * @returns {void}
     */
    resetRange: function resetRange(cell) {
      if (this.settings.range.useRange) {
        delete this.settings.range.first;
        delete this.settings.range.second;
        delete this.settings.range.extra;
        if (this.calendarAPI) {
          delete this.calendarAPI.settings.range.first;
          delete this.calendarAPI.settings.range.second;
          delete this.calendarAPI.settings.range.extra;
        }
        if (this.calendarAPI && this.calendarAPI.days.length) {
          this.calendarAPI.days.find('td').removeClass('range range-next range-prev range-selection end-date is-selected');
        }
        if (cell) {
          cell.addClass('is-selected');
        }
      }
    },


    /**
     * Set the range value from the field
     * @private
     * @returns {void}
     */
    setRangeValueFromField: function setRangeValueFromField() {
      var _this7 = this;

      var formatDate = function formatDate(d) {
        return Locale.formatDate(d, {
          pattern: _this7.pattern,
          locale: _this7.locale.name
        });
      };
      var parseDate = function parseDate(d) {
        return Locale.parseDate(d, {
          pattern: _this7.pattern,
          locale: _this7.locale.name
        }, false);
      };
      var getTime = function getTime(d) {
        return d && typeof d.getTime === 'function' ? d.getTime() : new Date().getTime();
      };
      var alignDates = function alignDates(dates) {
        var d1 = parseDate(dates[0]);
        var d2 = parseDate(dates[1]);
        if (d1 && d2) {
          d1 = getTime(d1);
          d2 = getTime(d2);
          return d1 > d2 ? [dates[1], dates[0]] : [dates[0], dates[1]];
        }
        return dates;
      };
      var s = this.settings;
      var field = {};

      field.value = s.range.value || this.element.val().trim();
      field.isEmpty = field.value === '';

      // Field value dates
      if (!field.isEmpty && field.value.indexOf(s.range.separator) > -1) {
        field.dates = alignDates(field.value.split(s.range.separator));
      } else if (!field.isEmpty && field.value.indexOf(s.range.separator.slice(0, -1)) > -1) {
        field.dates = field.value.split(s.range.separator.slice(0, -1));
      }

      // Start/End dates
      if (!s.range.data && s.range.start && s.range.end && field.isEmpty) {
        var dates = void 0;
        if (typeof s.range.start === 'string' && typeof s.range.end === 'string') {
          dates = alignDates([s.range.start, s.range.end]);
        } else if (typeof s.range.start !== 'string' && typeof s.range.end === 'string') {
          dates = alignDates([formatDate(s.range.start), s.range.end]);
        } else if (typeof s.range.start === 'string' && typeof s.range.end !== 'string') {
          dates = alignDates([s.range.start, formatDate(s.range.end)]);
        } else {
          dates = alignDates([formatDate(s.range.start), formatDate(s.range.end)]);
        }
        s.range.start = formatDate(dates[0]);
        s.range.end = formatDate(dates[1]);
      }

      s.range.first = s.range.first || {};
      s.range.second = s.range.second || {};

      // Start date
      if (s.range.data && s.range.data.startDate) {
        s.range.first.date = s.range.data.startDate;
      } else if (s.range.start && typeof s.range.start === 'string') {
        s.range.first.date = parseDate(s.range.start);
      } else if (field.dates) {
        s.range.first.date = parseDate(field.dates[0]);
      }

      // End date
      if (s.range.data && s.range.data.endDate) {
        s.range.second.date = s.range.data.endDate;
      } else if (s.range.end && typeof s.range.end === 'string') {
        s.range.second.date = parseDate(s.range.end);
      } else if (field.dates) {
        s.range.second.date = parseDate(field.dates[1]);
      }

      if (this.calendarAPI) {
        this.calendarAPI.setRangeSelected();
      }

      if (field.isEmpty || !field.isEmpty && !s.range.data) {
        var value = formatDate(s.range.first.date);
        if (value) {
          this.element.val(value);
        }
      } else {
        return false;
      }
      return true;
    },


    /**
     * Get the value from the field and set the internal variables or use current date
     * @private
     * @returns {void}
     */
    setValueFromField: function setValueFromField() {
      var s = this.settings;
      this.setCurrentCalendar();

      if (s.range.useRange && this.element.val().trim() === '') {
        delete s.range.data;
        this.resetRange();
      }

      if (s.range.useRange && (this.element.val().trim() !== '' || s.range.start && s.range.end || s.range.data && s.range.data.startDate && s.range.data.endDate)) {
        if (!this.setRangeValueFromField()) {
          if (this.currentDate && typeof this.currentDate.getMonth === 'function') {
            this.currentMonth = this.currentDate.getMonth();
            this.currentYear = this.currentDate.getFullYear();
            this.currentDay = this.currentDate.getDate();
          }
          return;
        }
      }

      var self = this;
      var fieldValue = this.element.val();
      var gregorianValue = fieldValue;

      if (this.isIslamic && fieldValue) {
        var islamicValue = Locale.parseDate(this.element.val(), {
          pattern: this.pattern,
          locale: this.locale.name
        });
        gregorianValue = this.conversions.toGregorian(islamicValue[0], islamicValue[1], islamicValue[2]);
      }

      this.currentDate = gregorianValue || new Date();
      if (typeof this.currentDate === 'string') {
        this.currentDate = Locale.parseDate(this.currentDate, {
          pattern: this.pattern,
          locale: this.locale.name
        }, false);
      }

      if (this.currentDate === undefined) {
        this.currentDate = Locale.parseDate(gregorianValue, {
          pattern: this.pattern,
          locale: this.locale.name
        }, false);
      }

      if (this.isIslamic) {
        this.currentDateIslamic = this.conversions.fromGregorian(this.currentDate);
        this.currentYear = this.currentDateIslamic[0];
        this.currentMonth = this.currentDateIslamic[1];
        this.currentDay = this.currentDateIslamic[2];
      } else {
        this.currentDate = this.currentDate || new Date();
        this.currentMonth = this.currentDate.getMonth();
        this.currentYear = this.currentDate.getFullYear();
        this.currentDay = this.currentDate.getDate();
      }

      // Check and fix two digit year for main input element
      var dateFormat = self.pattern;
      var isStrict = !(dateFormat === 'MMMM d' || dateFormat === 'yyyy');
      var parsedDate = Locale.parseDate(self.element.val().trim(), {
        pattern: dateFormat,
        locale: this.locale.name
      }, isStrict);

      if (parsedDate !== undefined && self.element.val().trim() !== '' && !s.range.useRange) {
        self.setValue(Locale.parseDate(self.element.val().trim(), {
          pattern: self.pattern,
          locale: this.locale.name
        }, false));
      }

      if (s.range.useRange && s.range.first && s.range.first.date && s.range.second && !s.range.second.date) {
        this.setRangeToElem(this.currentDate, true);
      }
    },


    /**
     * Set input to enabled.
     * @returns {void}
     */
    enable: function enable() {
      this.element.removeAttr('disabled readonly').closest('.field').removeClass('is-disabled');
    },


    /**
     * Set input to disabled.
     * @returns {void}
     */
    disable: function disable() {
      this.enable();
      this.element.attr('disabled', 'disabled').closest('.field').addClass('is-disabled');
    },


    /**
     * Detects whether or not the component is disabled
     * @returns {boolean} whether or not the component is disabled
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Set input to readonly.
     * @returns {void}
     */
    readonly: function readonly() {
      this.enable();
      this.element.attr('readonly', 'readonly');
    },


    /**
     * Set to todays date in current format.
     * @private
     * @returns {void}
     */
    setToday: function setToday() {
      var s = this.settings;
      this.currentDate = new Date();

      if (!this.settings.useCurrentTime) {
        this.currentDate.setHours(0, 0, 0, 0);

        if (this.element.val() !== '') {
          if (this.timepicker && this.timepicker.hourSelect) {
            this.currentDate.setHours(this.timepicker.hourSelect.val());
          }

          if (this.timepicker && this.timepicker.minuteSelect) {
            this.currentDate.setMinutes(this.timepicker.minuteSelect.val());
          }

          if (this.timepicker && this.timepicker.secondSelect) {
            this.currentDate.setSeconds(this.timepicker.secondSelect.val());
          }
        }
      }

      if (this.isIslamic) {
        var islamicDateParts = this.conversions.fromGregorian(this.currentDate);
        this.currentDateIslamic = islamicDateParts;
      }

      if (this.isOpen()) {
        this.insertDate(this.isIslamic ? this.currentDateIslamic : this.currentDate, true);
      } else {
        if (s.range.useRange) {
          this.setRangeToElem(this.currentDate);
        } else {
          var options = { pattern: this.pattern, locale: this.locale.name };
          var islamicDateText = Locale.formatDate(this.isIslamic ? this.currentDateIslamic : this.currentDate, options);
          this.element.val(islamicDateText);
        }
        /**
        * Fires after the value in the input is changed by user interaction.
        *
        * @event input
        * @memberof DatePicker
        * @property {object} event - The jquery event object
        */
        if (s.range.useRange) {
          this.element.trigger('change', [s.range.data]).trigger('input', [s.range.data]);
        } else {
          this.element.trigger('change').trigger('input');
        }
      }
    },


    /**
     * Set time
     * @private
     * @param {object} date .
     * @returns {void}
     */
    setTime: function setTime(date) {
      var hours = this.popup.find('.dropdown.hours').val();
      var minutes = this.popup.find('.dropdown.minutes').val();
      var seconds = this.isSeconds ? this.popup.find('.dropdown.seconds').val() : 0;
      var period = this.popup.find('.dropdown.period');

      hours = period.length && period.val() === 'PM' && hours < 12 ? parseInt(hours, 10) + 12 : hours;
      hours = period.length && period.val() === 'AM' && parseInt(hours, 10) === 12 ? 0 : hours;

      date = new Date(date);
      date.setHours(hours, minutes, seconds);
      return date;
    },


    /**
     * Get Time String
     * @private
     * @param {object} date .
     * @param {boolean} isHours24 .
     * @returns {string} time
     */
    getTimeString: function getTimeString(date, isHours24) {
      var twodigit = function twodigit(number) {
        return (number < 10 ? '0' : '') + number;
      };
      var d = date || new Date();
      var h = d.getHours();
      var m = twodigit(d.getMinutes());
      var s = twodigit(d.getSeconds());
      var h12 = (h % 12 || 12) + ':' + m + (this.isSeconds ? ':' + s : '') + ' ' + (h < 12 ? 'AM' : 'PM');
      var h24 = h + ':' + m + ' + ' + (this.isSeconds ? ':' + s : '');

      return isHours24 ? h24 : h12;
    },


    /**
     * Get the current date from the field. In date format
     * @returns {Date} the set date object
     */
    getCurrentDate: function getCurrentDate() {
      return this.currentDate;
    },


    /**
     * Updates the component instance. Can be used after being passed new settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, DATEPICKER_DEFAULTS);
      }
      return this.teardown().init();
    },


    /**
     * Get range value to insert in element
     * @private
     * @returns {string} range dates to display in element
     */
    getRangeValue: function getRangeValue() {
      var _this8 = this;

      var s = this.settings;
      var formatDate = function formatDate(d) {
        return Locale.formatDate(d, {
          pattern: _this8.pattern,
          locale: _this8.locale.name
        });
      };

      if (s.range.useRange && s.range.first && s.range.first.date && s.range.second && s.range.second.date) {
        return '' + (formatDate(s.range.first.date) + s.range.separator + formatDate(s.range.second.date));
      } else if (s.range.useRange && s.range.first && s.range.first.date) {
        return s.placeholder ? '' + (formatDate(s.range.first.date) + s.range.separator + this.pattern) : formatDate(s.range.first.date);
      }
      return '';
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {void}
     */
    teardown: function teardown() {
      if (this.isOpen()) {
        this.closeCalendar();
      }

      this.element.off('blur.datepicker');
      this.trigger.remove();
      this.element.attr('data-mask', '');
      this.element.removeAttr('placeholder');
      if (this.calendarAPI) {
        this.calendarAPI.destroy();
      }
      if (this.calendar && this.calendar.length) {
        this.calendar.remove();
      }

      if (this.popup && this.popup.length) {
        this.popup.remove();
      }

      var maskApi = this.element.data('mask');
      if (maskApi) {
        maskApi.destroy();
      }

      this.element.off('keydown.datepicker blur.validate change.validate keyup.validate focus.validate');

      this.element.removeAttr('data-validate').removeData('validate validationEvents');

      return this;
    },


    /**
     * Destroy and remove added markup, reset back to default
     * @returns {void}
     */
    destroy: function destroy() {
      this.closeCalendar();
      this.teardown();
      if (this.element[0]) {
        $.removeData(this.element[0], COMPONENT_NAME$B);
      }
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;
      var s = this.settings;

      this.trigger.on('click.datepicker', function () {
        if (self.isOpen()) {
          self.closeCalendar();
        } else {
          self.openCalendar();
        }
      });

      this.handleKeys(this.element);

      // Fix two digit year for main input element
      self.element.on('blur.datepicker', function () {
        if (self.element.val().trim() !== '') {
          self.setValueFromField();
        }
      });

      // Set initialize value
      if (!this.isOpen() && s.range.useRange && !s.range.first) {
        this.setRangeValueFromField();
        var value = this.getRangeValue();
        if (value) {
          this.element.val(value);
        }
      }
    }
  };

  /**
   * jQuery Component Wrapper for Datepicker
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.datepicker = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$B);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$B, new DatePicker(this, settings));
      }
    });
  };

  /* eslint-disable no-useless-escape */

  var COMPONENT_NAME$C = 'editor';

  /**
  * The Editor Component displays and edits markdown.
  *
  * @class Editor
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  * @param {string} [settings.buttons =
  * { editor: [ 'header1', 'header2', 'separator', 'bold', 'italic', 'underline', 'strikethrough',
  * 'separator', 'foreColor', 'backColor', 'separator', 'justifyLeft', 'justifyCenter', 'justifyRight', 'separator', 'quote', 'orderedlist',
  * 'unorderedlist', 'separator', 'anchor', 'separator', 'image', 'separator', 'source' ], source: [ 'visual' ] }]
  * An array with all the visible buttons in it.
  * @param {string} [settings.excludeButtons = { editor: ['backColor'], source: [] }] An array with all the buttons in it to excloude
  * @param {string} [settings.firstHeader = 'h3'] Allows you to set if the first header inserted is a h3 or h4 element.
  * You should set this to match the structure of the parent page for accessibility
  * @param {boolean} [settings.secondHeader = 'h4'] Allows you to set if the second header inserted is a h3 or
  * h4 element. You should set this to match the structure of the parent page for accessibility
  * @param {string} [settings.pasteAsPlainText = false] If true, when you paste into the editor the element will be unformatted to plain text.
  * @param {string} [settings.anchor = { url: 'http://www.example.com', class: 'hyperlink', target: 'NewWindow', isClickable: false, showIsClickable: false }] An object with settings related to controlling link behavior when inserted example: `{url: 'http://www.example.com', class: 'hyperlink', target: 'NewWindow', isClickable: false, showIsClickable: false},` the url is the default url to display. Class should normally stay hyperlink and represents the styling class. target can be 'NewWindow' or 'SameWindow', isClickable make the links appear clickable in the editor, showIsClickable will show a checkbox to allow the user to make clickable links in the link popup.
  * @param {string} [settings.image = { url: 'https://imgplaceholder.com/250x250/368AC0/ffffff/fa-image' }] Info object to populate the image dialog defaulting to ` {url: 'http://lorempixel.com/output/cats-q-c-300-200-3.jpg'}`
  * @param {function} [settings.onLinkClick = null] Call back for clicking on links to control link behavior.
  * @param {function} [settings.showHtmlView = false] If set to true, editor should be displayed in HTML view initialy.
  * @param {function} [settings.preview = false] If set to true, editor should be displayed in preview mode with noneditable content.
  */
  var EDITOR_DEFAULTS = {
    buttons: {
      editor: ['header1', 'header2', 'separator', 'bold', 'italic', 'underline', 'strikethrough', 'separator', 'foreColor', 'backColor', 'separator', 'justifyLeft', 'justifyCenter', 'justifyRight', 'separator', 'quote', 'orderedlist', 'unorderedlist', 'separator', 'anchor', 'separator', 'image', 'separator', 'clearFormatting', 'separator', 'source'],
      source: ['visual']
    },
    excludeButtons: {
      editor: ['backColor'],
      source: []
    },
    delay: 200,
    firstHeader: 'h3',
    secondHeader: 'h4',
    placeholder: null,
    pasteAsPlainText: false,
    // anchor > target: 'SameWindow'|'NewWindow'| any string value
    anchor: { url: 'http://www.example.com', class: 'hyperlink', target: 'NewWindow', isClickable: false, showIsClickable: false },
    image: { url: 'https://imgplaceholder.com/250x250/368AC0/ffffff/fa-image' },
    onLinkClick: null,
    showHtmlView: false,
    preview: false
  };

  function Editor(element, settings) {
    this.settings = utils.mergeSettings(element, settings, EDITOR_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Editor Methods
  Editor.prototype = {
    init: function init() {
      var _this = this;

      var s = this.settings;
      this.isIe = Environment.browser.name === 'ie';
      this.isIeEdge = Environment.browser.name === 'edge';
      this.isIe11 = this.isIe && Environment.browser.version === '11';
      this.isMac = Environment.os.name === 'Mac OS X';
      this.isFirefox = Environment.browser.name === 'firefox';
      this.textarea = null;

      this.parentElements = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre'];
      this.id = utils.uniqueId(this.element, 'editor') + '-id';

      this.container = this.element.parent('.field, .field-short').addClass('editor-container');

      // Preview mode
      if (!this.previewRendered && (this.element.hasClass('is-preview') || this.settings.preview)) {
        this.container[0].classList.add('is-preview');
        this.element[0].classList.remove('is-disabled', 'is-readonly', 'is-preview');
        this.element[0].setAttribute('contenteditable', false);
        this.element[0].removeAttribute('aria-multiline');
        this.element[0].removeAttribute('role');
        return;
      }

      s.anchor = $.extend({}, EDITOR_DEFAULTS.anchor, s.anchor);
      s.image = $.extend({}, EDITOR_DEFAULTS.image, s.image);

      s.anchor.defaultUrl = s.anchor.url;
      s.anchor.defaultClass = s.anchor.class;
      s.anchor.defaultTargetText = s.anchor.target;
      s.anchor.defaultIsClickable = s.anchor.isClickable;

      s.anchor.targets = s.anchor.targets || {
        SameWindow: '',
        NewWindow: '_blank'
      };

      $.each(this.settings.anchor.targets, function (key, val) {
        if (_this.settings.anchor.defaultTargetText.toLowerCase() === key.toLowerCase()) {
          _this.settings.anchor.target = val;
          _this.settings.anchor.defaultTarget = val;
        }
      });

      if (!s.anchor.defaultTarget) {
        if (s.anchor.target && $.trim(s.anchor.target).length) {
          s.anchor.defaultTarget = s.anchor.target;
        } else {
          s.anchor.defaultTargetText = Locale.translate('SameWindow');
          s.anchor.defaultTarget = s.anchor.targets[s.anchor.defaultTargetText];
        }
      }

      this.setup();
      if (this.element.hasClass('is-readonly')) {
        this.readonly();
      }

      if (this.settings.showHtmlView) {
        this.toggleSource();
      }

      return this;
    },
    setup: function setup() {
      this.isActive = true;
      this.modals = {};

      this.initElements().bindSelect().bindPaste().setPlaceholders().bindWindowActions().setupKeyboardEvents().onPasteTriggered();
    },
    initElements: function initElements() {
      // Make it an editor
      this.element.attr({
        contentEditable: true,
        'aria-multiline': true,
        role: 'textbox'
      });

      // Bind functionality for Pre elements. We dont use this yet but could if we
      // want to edit code blocks.
      this.element.attr('data-editor', true);
      this.bindParagraphCreation().bindTab();

      this.initToolbar().bindButtons().bindModals().bindAnchorPreview();

      // Build the textarea that will be used as source view and for content serialization
      this.initTextarea();
      return this;
    },


    // Returns true if the source view is currently active.
    sourceViewActive: function sourceViewActive() {
      return this.element.hasClass('source-view-active');
    },


    // Bind Events for the place holder
    setPlaceholders: function setPlaceholders() {
      var _this2 = this;

      this.element.on('blur.editor', function () {
        return _this2.togglePlaceHolder();
      }).on('keypress.editor', function () {
        return _this2.togglePlaceHolder();
      });

      this.togglePlaceHolder();
      return this;
    },
    togglePlaceHolder: function togglePlaceHolder() {
      if (this.element.text().trim() === '') {
        this.element.addClass('editor-placeholder');
      } else {
        this.element.removeClass('editor-placeholder');
      }
    },


    // Returns the currently visible element - either the main editor window,
    // or the source-view textarea
    getCurrentElement: function getCurrentElement() {
      return this.sourceViewActive() ? this.textarea : this.element;
    },
    bindParagraphCreation: function bindParagraphCreation() {
      var _this3 = this;

      var currentElement = this.getCurrentElement();
      currentElement.on('keyup.editor', function (e) {
        var node = _this3.getSelectionStart();
        var tagName = void 0;

        if (node && node.getAttribute('data-editor') && node.children.length === 0) {
          document.execCommand('formatBlock', false, 'p');
        }

        if (e.which === 13) {
          node = _this3.getSelectionStart();
          tagName = node.tagName.toLowerCase();

          if (tagName !== 'li' && !_this3.isListItemChild(node)) {
            if (!e.shiftKey) {
              document.execCommand('formatBlock', false, 'p');
            }
            if (tagName === 'a') {
              document.execCommand('unlink', false, null);
            }
          }
        }
      });
      return this;
    },
    bindTab: function bindTab() {
      var _this4 = this;

      var currentElement = this.getCurrentElement();

      currentElement.on('keydown.editor', function (e) {
        if (e.which === 9) {
          // Override tab only for pre nodes
          var tag = _this4.getSelectionStart().tagName.toLowerCase();
          if (tag === 'pre') {
            e.preventDefault();
            document.execCommand('insertHtml', null, '    ');
          }
          // Tab to indent list structures!
          if (tag === 'li') {
            // If Shift is down, outdent, otherwise indent
            document.execCommand(e.shiftKey ? 'outdent' : 'indent', e);
          }
        }
      });

      return this;
    },
    initToolbar: function initToolbar() {
      if (this.toolbar) {
        return this;
      }

      this.createToolbar();
      return this;
    },


    // Set excluded buttons
    setExcludedButtons: function setExcludedButtons() {
      var _this5 = this;

      var excludeButtons = function excludeButtons(elements, toExclude) {
        var separatorIndex = -1;
        var numOfExcluded = 0;

        return elements.filter(function (x, i) {
          var r = true;
          // Exclude matching buttons but keep separator/s
          if (toExclude.indexOf(x) > -1 && x !== 'separator') {
            numOfExcluded++;
            r = false;
          } else if (x === 'separator' && i - numOfExcluded - 1 === separatorIndex) {
            // Exclude extra separator/s
            numOfExcluded = 0;
            r = false;
          }
          if (x === 'separator') {
            separatorIndex = i;
          }
          return r;
        });
      };

      // Run only if it needs (excludeButtons)
      var setButtons = function setButtons() {
        var s = _this5.settings;
        var btns = s.buttons;
        var exBtns = s.excludeButtons;

        if (_this5.sourceViewActive()) {
          return exBtns && exBtns.source && exBtns.source.length ? excludeButtons(btns.source, exBtns.source) : btns.source;
        }
        return exBtns && exBtns.editor && exBtns.editor.length ? excludeButtons(btns.editor, exBtns.editor) : btns.editor;
      };
      return setButtons();
    },
    createToolbar: function createToolbar() {
      var btns = this.setExcludedButtons();
      var toolbar = '<div class="toolbar editor-toolbar formatter-toolbar"\n                   id="editor-toolbar-' + this.id + '">';
      var buttonset = '<div class="buttonset">';

      for (var i = 0, l = btns.length; i < l; i += 1) {
        var btn = this.buttonTemplate(btns[i]);
        if (btn) {
          buttonset += btn;
        }
      }

      buttonset += '</div>';
      toolbar += buttonset + '</div>';

      if (this.element.parent().find('.icon-dirty').length) {
        this.toolbar = $(toolbar).insertBefore(this.element.parent().find('.icon-dirty'));
      } else {
        this.toolbar = $(toolbar).insertBefore(this.sourceViewActive() ? this.element.prev() : this.element);
      }
      this.toolbar.toolbar();

      // Invoke Tooltips
      this.toolbar.find('button[title]').tooltip();

      // Invoke colorpicker
      var cpElements = this.toolbar.find('[data-action="foreColor"], [data-action="backColor"]');
      cpElements.colorpicker({ placeIn: 'editor' });
      $('.trigger', cpElements).off('click.colorpicker');

      return this;
    },


    /**
    * Switch between source and editing toolbar.
    * @returns {void}
    */
    switchToolbars: function switchToolbars() {
      this.destroyToolbar();

      // Rebind everything to the new element
      this.setupTextareaEvents();
      this.initToolbar();
      this.bindButtons().bindModals().bindAnchorPreview();
      this.bindSelect().bindPaste().setupKeyboardEvents();
      this.toolbar.find('button').button();
    },
    initTextarea: function initTextarea() {
      var self = this;
      if (this.textarea && !this.settings.showHtmlView) {
        return this;
      }
      this.textarea = this.createTextarea();

      // fill the text area with any content that may already exist within the editor DIV
      this.textarea.text(xssUtils.sanitizeHTML(this.element.html().toString()));

      self.container.on('input.editor keyup.editor', '.editor', debounce(function () {
        self.textarea.html(xssUtils.sanitizeHTML(self.element.html().toString()));
        // setting the value via .val doesn't trigger the change event
        self.element.trigger('change');
      }, 500));

      this.setupTextareaEvents();
      return this.textarea;
    },
    createTextarea: function createTextarea() {
      this.sourceView = $('<div></div>').attr({
        class: 'editor-source editable hidden',
        id: 'editor-source-' + this.id
      }).insertBefore(this.element);

      $('<ul></ul>').addClass('line-numbers').appendTo(this.sourceView);
      var textareaContainer = $('<div class="text-container"></div>').appendTo(this.sourceView);

      var newTextareaID = 'source-textarea-' + ($('[id^="source-textarea-"]').length + 1);

      var labelContents = this.element.prev('.label').addClass('audible').text() + ' - HTML Source View';

      $('<label class="audible" for="' + newTextareaID + '">' + labelContents + '</label>').appendTo(textareaContainer);

      var textarea = $('<textarea id="' + newTextareaID + '" class="editable"></textarea>').appendTo(textareaContainer);
      return textarea;
    },
    triggerClick: function triggerClick(e, btn) {
      $('button[data-action="' + btn + '"]', this.toolbar).trigger('click.editor');
    },
    setupKeyboardEvents: function setupKeyboardEvents() {
      var _this6 = this;

      var self = this;
      var currentElement = this.getCurrentElement();
      var keys = {
        b: 66, // {Ctrl + B} bold
        e: 69, // {Ctrl + E} justifyCenter
        h: 72, // {Ctrl + H} anchor
        i: 73, // {Ctrl + I} italic --------with SHIFT: {Ctrl + Shift + I} image
        l: 76, // {Ctrl + L} justifyLeft
        bl: 55, // {Ctrl + Shift + 7} bullet list
        n: 56, // {Ctrl + Shift + 8} numbered list
        q: 81, // {Ctrl + Q} blockquotes
        r: 82, // {Ctrl + R} justifyRight
        u: 85, // {Ctrl + U} underline
        h3: 51, // {Ctrl + 3} h3
        h4: 52, // {Ctrl + 4} h4
        space: 32, // {Ctrl + Space} Clear Formatting
        sv: 192 // {Ctrl + ~} toggle source -or- visualview
      };

      currentElement.on('keydown.editor', function (e) {
        e = e || window.event;

        if (e.which) {
          keys.charCode = e.which;
        } else if (e.keyCode) {
          keys.charCode = e.keyCode;
        } else {
          keys.charCode = false;
        }

        switch (e.ctrlKey && keys.charCode) {
          case keys.h3:
            _this6.triggerClick(e, 'append-' + _this6.settings.firstHeader);
            break;
          case keys.h4:
            _this6.triggerClick(e, 'append-' + _this6.settings.secondHeader);
            break;
          case keys.b:
            _this6.triggerClick(e, 'bold');
            e.preventDefault();
            break;
          case keys.e:
            _this6.triggerClick(e, 'justifyCenter');
            break;
          case keys.h:
            _this6.triggerClick(e, 'anchor');
            e.preventDefault();
            break;
          case keys.i:
            _this6.triggerClick(e, e.shiftKey ? 'image' : 'italic');
            if (!e.shiftKey) {
              e.preventDefault();
            }
            break;
          case keys.bl:
            if (e.shiftKey) {
              _this6.triggerClick(e, 'insertunorderedlist');
            }
            e.preventDefault();
            break;
          case keys.l:
            if (!e.shiftKey) {
              _this6.triggerClick(e, 'justifyLeft');
            }
            e.preventDefault();
            break;
          case keys.n:
            if (e.shiftKey) {
              _this6.triggerClick(e, 'insertorderedlist');
            }
            break;
          case keys.q:
            _this6.triggerClick(e, 'append-blockquote');
            break;
          case keys.r:
            _this6.triggerClick(e, 'justifyRight');
            break;
          case keys.u:
            _this6.triggerClick(e, 'underline');
            e.preventDefault();
            break;
          case keys.space:
            _this6.triggerClick(e, 'clearFormatting');
            break;
          case keys.sv:
            _this6.triggerClick(e, currentElement === _this6.element ? 'source' : 'visual');
            break;
          default:
            break;
        }
      });

      // Open link in new windows/tab, if clicked with command-key(for mac) or ctrl-key(for windows)
      this.element.on('mousedown.editor', 'a', function (e) {
        var href = $(this).attr('href');
        if (!self.isFirefox && (self.isMac && e.metaKey || !self.isMac && e.ctrlKey)) {
          window.open(href, '_blank');
          e.preventDefault();
        }
      });

      this.element.on('updated.editor', function () {
        _this6.updated();
      });

      return this;
    },
    setupTextareaEvents: function setupTextareaEvents() {
      var _this7 = this;

      // Adjust line numbers on input
      this.textarea.off('.editor').on('input.editor keyup.editor', function () {
        if (!_this7.sourceView.hasClass('hidden')) {
          _this7.adjustSourceLineNumbers();
        }
      }).on('focus.editor', function () {
        _this7.sourceView.addClass('is-focused');
      }).on('blur.editor', function (e) {
        _this7.sourceView.removeClass('is-focused');
        _this7.element.empty().html(xssUtils.sanitizeHTML(_this7.textarea.val()));

        if (_this7.element.data('validate')) {
          _this7.element.data('validate').validate(_this7.element, true, e);
        }
      });

      return this;
    },
    adjustSourceLineNumbers: function adjustSourceLineNumbers() {
      var container = this.textarea.parent();
      var lineHeight = parseInt(getComputedStyle(this.textarea[0]).lineHeight, 10);
      var YPadding = this.textarea.innerHeight() - this.textarea.height();

      this.textarea[0].style.height = '';

      var scrollHeight = this.textarea[0].scrollHeight;
      var lineNumberCount = Math.floor((scrollHeight - YPadding) / lineHeight);
      var numberList = this.sourceView.find('.line-numbers');
      var lastIdx = numberList.find('li').length;

      var list = '';
      var i = 0;

      if (!this.lineNumbers || lineNumberCount !== this.lineNumbers) {
        if (!this.lineNumbers) {
          // Build the list of line numbers from scratch
          this.lineNumbers = lineNumberCount;
          while (i < this.lineNumbers) {
            list += '<li role="presentation"><span>' + (i + 1) + '</span></li>';
            i++;
          }
          numberList.append(list);
        } else if (this.lineNumbers < lineNumberCount) {
          // Add extra line numbers to the bottom
          while (i < lineNumberCount - this.lineNumbers) {
            list += '<li role="presentation"><span>' + (lastIdx + i + 1) + '</span></li>';
            i++;
          }
          numberList.append(list);
        } else if (this.lineNumbers > lineNumberCount) {
          // Remove extra line numbers from the bottom
          i = this.lineNumbers - lineNumberCount;
          numberList.find('li').slice(-i).remove();
        }
        this.lineNumbers = lineNumberCount;
        container[0].style.width = 'calc(100% - ' + (numberList.outerWidth() + 1) + 'px)';
      }
      if (scrollHeight !== this.textarea[0].scrollHeight) {
        this.adjustSourceLineNumbers();
        return;
      }

      this.textarea[0].style.height = numberList[0].scrollHeight + 'px';
    },
    wrapTextInTags: function wrapTextInTags(insertedText, selectedText, action) {
      var tags = void 0;
      var finalText = void 0;
      switch (action) {
        case 'bold':
          tags = ['<b>', '</b>'];
          break;
        case 'italic':
          tags = ['<i>', '</i>'];
          break;
        case 'underline':
          tags = ['<u>', '</u>'];
          break;
        case 'strikethrough':
          tags = ['<strike>', '</strike>'];
          break;
        case 'append-blockquote':
          tags = ['<blockquote>', '</blockquote>'];
          break;
        default:
          tags = ['', ''];
      }

      if (action === 'anchor') {
        var alink = $('<a href="' + insertedText + '">' + selectedText + '</a>');

        if (this.settings.anchor.class && $.trim(this.settings.anchor.class).length) {
          alink.addClass(this.settings.anchor.class);
        }
        if (this.settings.anchor.target && $.trim(this.settings.anchor.target).length) {
          alink.attr('target', this.settings.anchor.target);
        }
        if (this.settings.anchor.isClickable) {
          alink.attr('contenteditable', false);
        } else {
          alink.removeAttr('contenteditable');
        }

        finalText = alink[0].outerHTML;
      } else {
        finalText = tags[0] + insertedText + selectedText + tags[1];
      }
      return finalText;
    },
    insertTextAreaContent: function insertTextAreaContent(text, action) {
      var el = this.textarea[0];
      var val = el.value;

      var sel = void 0;
      var startPos = void 0;
      var endPos = void 0;
      var scrollTop = void 0;

      // Always have empty text
      text = text || '';

      if (document.selection && el.tagName === 'TEXTAREA') {
        // IE textarea support
        $(el).focus();
        sel = document.selection.createRange();
        sel.text = this.wrapTextInTags(text, sel.text, action);
        $(el).focus();
      } else if (el.selectionStart || el.selectionStart === '0') {
        // MOZILLA/NETSCAPE support
        startPos = el.selectionStart;
        endPos = el.selectionEnd;
        scrollTop = el.scrollTop;
        sel = this.wrapTextInTags(text, val.substring(startPos, endPos), action);
        el.value = val.substring(0, startPos) + sel + val.substring(endPos, val.length);
        $(el).focus();
        el.selectionStart = startPos + sel.length;
        el.selectionEnd = startPos + sel.length;
        el.scrollTop = scrollTop;
      } else {
        // IE input[type=text] and other browsers
        el.value += this.wrapTextInTags(text, el.value, action);
        $(el).focus();
        el.value = el.value; // forces cursor to end
      }
    },
    buttonTemplate: function buttonTemplate(btnType) {
      var buttonLabels = this.getButtonLabels(this.settings.buttonLabels);
      var buttonTemplates = {
        bold: '<button type="button" class="btn" title="' + Locale.translate('ToggleBold') + '" data-action="bold" data-element="b">' + buttonLabels.bold + '</button>',

        italic: '<button type="button" class="btn" title="' + Locale.translate('ToggleItalic') + '" data-action="italic" data-element="i">' + buttonLabels.italic + '</button>',

        underline: '<button type="button" class="btn underline" title="' + Locale.translate('ToggleUnderline') + '" data-action="underline" data-element="u">' + buttonLabels.underline + '</button>',

        strikethrough: '<button type="button" class="btn" title="' + Locale.translate('StrikeThrough') + '" data-action="strikethrough" data-element="strike">' + buttonLabels.strikethrough + '</button>',

        foreColor: '<button type="button" class="btn colorpicker-editor-button" title="' + Locale.translate('TextColor') + '" data-action="foreColor" data-element="foreColor">' + buttonLabels.foreColor + '</button>',

        backColor: '<button type="button" class="btn colorpicker-editor-button" title="' + Locale.translate('BackgroundColor') + '" data-action="backColor" data-element="backColor">' + buttonLabels.backColor + '</button>',

        superscript: '<button type="button" class="btn" title="' + Locale.translate('Superscript') + '" data-action="superscript" data-element="sup">' + buttonLabels.superscript + '</button>',

        subscript: '<button type="button" class="btn" title="' + Locale.translate('Subscript') + '" data-action="subscript" data-element="sub">' + buttonLabels.subscript + '</button>',

        separator: '<div class="separator"></div>',

        anchor: '<button type="button" class="btn" title="' + Locale.translate('InsertAnchor') + '" data-action="anchor" data-modal="modal-url-' + this.id + '" data-element="a">' + buttonLabels.anchor + '</button>',

        image: '<button type="button" class="btn" title="' + Locale.translate('InsertImage') + '" data-action="image" data-modal="modal-image-' + this.id + '" data-element="img">' + buttonLabels.image + '</button>',

        header1: '<button type="button" class="btn" title="' + Locale.translate('ToggleH3') + '" data-action="append-' + this.settings.firstHeader + '" data-element="' + this.settings.firstHeader + '">' + buttonLabels.header1 + '</button>',

        header2: '<button type="button" class="btn" title="' + Locale.translate('ToggleH4') + '" data-action="append-' + this.settings.secondHeader + '" data-element="' + this.settings.secondHeader + '">' + buttonLabels.header2 + '</button>',

        quote: '<button type="button" class="btn" title="' + Locale.translate('Blockquote') + '" data-action="append-blockquote" data-element="blockquote">' + buttonLabels.quote + '</button>',

        orderedlist: '<button type="button" class="btn" title="' + Locale.translate('OrderedList') + '" data-action="insertorderedlist" data-element="ol">' + buttonLabels.orderedlist + '</button>',

        unorderedlist: '<button type="button" class="btn" title="' + Locale.translate('UnorderedList') + '" data-action="insertunorderedlist" data-element="ul">' + buttonLabels.unorderedlist + '</button>',

        justifyLeft: '<button type="button" class="btn" title="' + Locale.translate('JustifyLeft') + '" data-action="justifyLeft" >' + buttonLabels.justifyLeft + '</button>',

        justifyCenter: '<button type="button" class="btn" title="' + Locale.translate('JustifyCenter') + '" data-action="justifyCenter">' + buttonLabels.justifyCenter + '</button>',

        justifyRight: '<button type="button" class="btn" title="' + Locale.translate('JustifyRight') + '" data-action="justifyRight" >' + buttonLabels.justifyRight + '</button>',

        clearFormatting: '<button type="button" class="btn" title="' + Locale.translate('ClearFormatting') + '" data-action="clearFormatting" >' + buttonLabels.clearFormatting + '</button>',

        source: '<button type="button" class="btn" title="' + Locale.translate('ViewSource') + '" data-action="source" >' + buttonLabels.source + '</button>',

        visual: '<button type="button" class="btn" title="' + Locale.translate('ViewVisual') + '" data-action="visual" >' + buttonLabels.visual + '</button>'
      };
      return buttonTemplates[btnType] || false;
    },
    getIcon: function getIcon(textName, iconName, className) {
      return '<span class="audible">' + Locale.translate(textName) + '</span>' + $.createIcon({ classes: className || '', icon: iconName });
    },
    getButtonLabels: function getButtonLabels(buttonLabelType) {
      var buttonLabels = {
        bold: this.getIcon('Bold', 'bold'),
        italic: this.getIcon('Italic', 'italic'),
        underline: this.getIcon('Underline', 'underline'),
        superscript: '<span aria-hidden="true"><b>x<sup>1</sup></b></span>',
        subscript: '<span aria-hidden="true"><b>x<sub>1</sub></b></span>',
        strikethrough: this.getIcon('StrikeThrough', 'strike-through'),
        foreColor: this.getIcon('TextColor', 'fore-color'),
        backColor: this.getIcon('BackgroundColor', 'back-color'),
        anchor: this.getIcon('InsertAnchor', 'link'),
        image: this.getIcon('InsertImage', 'insert-image'),
        header1: this.getIcon('ToggleH3', 'h3'),
        header2: this.getIcon('ToggleH4', 'h4'),
        quote: this.getIcon('Blockquote', 'quote'),
        orderedlist: this.getIcon('OrderedList', 'number-list'),
        unorderedlist: this.getIcon('UnorderedList', 'bullet-list'),
        pre: '<span aria-hidden="true"><b>0101</b></span>',
        indent: '<span aria-hidden="true"><b>&rarr;</b></span>',
        outdent: '<span aria-hidden="true"><b>&larr;</b></span>',
        justifyLeft: this.getIcon('JustifyLeft', 'left-text-align'),
        justifyCenter: this.getIcon('JustifyCenter', 'center-text'),
        justifyRight: this.getIcon('JustifyRight', 'right-text-align'),
        clearFormatting: this.getIcon('clearFormatting', 'clear-formatting'),
        source: this.getIcon('ViewSource', 'html', 'html-icon'),
        visual: this.getIcon('ViewSource', 'visual', 'visual-icon')
      };

      var customButtonLabels = void 0;

      if ((typeof buttonLabelType === 'undefined' ? 'undefined' : _typeof(buttonLabelType)) === 'object') {
        customButtonLabels = buttonLabelType;
      }
      if ((typeof customButtonLabels === 'undefined' ? 'undefined' : _typeof(customButtonLabels)) === 'object') {
        for (var attrname in customButtonLabels) {
          if (customButtonLabels.hasOwnProperty(attrname)) {
            // eslint-disable-line
            buttonLabels[attrname] = customButtonLabels[attrname];
          }
        }
      }
      return buttonLabels;
    },


    // Show the Buttons
    activateButton: function activateButton(tag) {
      this.toolbar.find('[data-element="' + tag + '"]').addClass('is-active');
    },


    // Bind Events to Toolbar Buttons
    bindButtons: function bindButtons() {
      var self = this;

      this.toolbar.on('touchstart.editor click.editor', 'button', function (e) {
        var btn = $(this);
        var action = btn.attr('data-action');

        // Don't do anything if it's the More Button
        if (btn.is('.btn-actions')) {
          return;
        }

        e.preventDefault();
        self.getCurrentElement().focus();

        if (self.selection === undefined) {
          self.checkSelection();
        }

        if (!self.sourceViewActive()) {
          btn.toggleClass('is-active');
        }

        if (action) {
          self.execAction(action, e);
        }

        if (self.isIe || self.isIeEdge) {
          self.getCurrentElement().trigger('change');
        }

        return false;
      });

      return this;
    },
    bindModals: function bindModals() {
      var self = this;

      this.modals = {
        url: this.createURLModal(),
        image: this.createImageModal()
      };

      $('[name="em-target-' + this.id + '"]').dropdown();

      $('#modal-url-' + this.id + ', #modal-image-' + this.id).modal().on('beforeopen', function () {
        self.savedSelection = self.saveSelection();

        if ($(this).attr('id') === 'modal-url-' + self.id) {
          if (!self.selectionRange) {
            return undefined;
          }
        }
      }).off('open').on('open', function () {
        var isTouch = Environment.features.touch;
        var id = $(this).attr('id');
        var input = $('input:first', this);
        var button = $('.modal-buttonset .btn-modal-primary', this);

        $('[name="em-url-' + self.id + '"]').val(self.settings.anchor.url);
        $('[name="em-class-' + self.id + '"]').val(self.settings.anchor.class);
        $('[name="em-target-' + self.id + '"]').val(self.settings.anchor.target).trigger('updated');
        $('[name="em-isclickable-' + this.id + '"]').prop('checked', self.settings.anchor.isClickable);

        setTimeout(function () {
          if (isTouch && id === 'modal-image-' + self.id) {
            button.focus();
          } else {
            input.focus().select();
          }
        }, 10);
      }).off('close').on('close', function (e, isCancelled) {
        self.restoreSelection(self.savedSelection);

        if (isCancelled) {
          return;
        }

        // insert image or link
        if ($(this).attr('id') === 'modal-url-' + self.id) {
          var currentLink = $(self.findElementInSelection('a', self.element[0]));
          if (currentLink.length) {
            self.updateCurrentLink(currentLink);
          } else {
            self.createLink($('[name="em-url-' + self.id + '"]', this));
          }
        } else {
          self.insertImage($('#image-' + self.id).val());
        }
      });

      return this;
    },


    /**
    * Function that creates the Url Modal Dialog. This can be customized by making
     a modal with ID `#modal-url-${this.id}`
    * @private
    * @returns {void}
    */
    createURLModal: function createURLModal() {
      var _this8 = this;

      var s = this.settings;
      var urlModal = $('#modal-url-' + this.id);

      if (urlModal.length > 0) {
        return urlModal;
      }

      var targetOptions = '';
      var isTargetCustom = true;

      $.each(s.anchor.targets, function (key, val) {
        targetOptions += '<option value="' + val + '">' + Locale.translate(key) + '</option>';
        if (_this8.settings.anchor.defaultTargetText.toLowerCase() === key.toLowerCase()) {
          isTargetCustom = false;
        }
      });

      if (isTargetCustom) {
        targetOptions += '<option value="' + s.anchor.target + '">' + s.anchor.target + '</option>';
      }
      // TODO: Rename to link when you get strings
      return $('<div class="modal editor-modal-url" id="modal-url-' + this.id + '"></div>').html('<div class="modal-content">\n        <div class="modal-header">\n          <h1 class="modal-title">' + Locale.translate('InsertAnchor') + '</h1>\n        </div>\n        <div class="modal-body">\n          <div class="field">\n            <label for="em-url-' + this.id + '">' + Locale.translate('Url') + '</label>\n            <input id="em-url-' + this.id + '" name="em-url-' + this.id + '" type="text" value="' + s.anchor.url + '">\n          </div>\n          ' + (s.anchor.showIsClickable ? '<div class="field">\n            <input type="checkbox" class="checkbox" id="em-isclickable-' + this.id + '" name="em-isclickable-' + this.id + '" checked="' + s.anchor.isClickable + '">\n            <label for="em-isclickable-' + this.id + '" class="checkbox-label"> ' + Locale.translate('Clickable') + '</label>\n          </div>' : '') + '\n          <div class="field">\n            <label for="em-class-' + this.id + '">' + Locale.translate('CssClass') + '</label>\n            <input id="em-class-' + this.id + '" name="em-class-' + this.id + '" type="text" value="' + s.anchor.class + '">\n          </div>\n          <div class="field">\n            <label for="em-target-' + this.id + '" class="label"> ' + Locale.translate('Target') + '</label>\n            <select id="em-target-' + this.id + '" name="em-target-' + this.id + '" class="dropdown">\n              ' + targetOptions + '\n            </select>\n          </div>\n          <div class="modal-buttonset">\n            <button type="button" class="btn-modal btn-cancel"> ' + Locale.translate('Cancel') + '</button>\n            <button type="button" class="btn-modal-primary"> ' + Locale.translate('Insert') + '</button>\n          </div>\n        </div>\n      </div>').appendTo('body');
    },


    /**
     * Function that creates the Image Dialog. This can be customized by making a
      modal with ID `#modal-image-{this.id}`
     * @private
     * @returns {void}
     */
    createImageModal: function createImageModal() {
      var imageModal = $('#modal-image-' + this.id);

      if (imageModal.length > 0) {
        return imageModal;
      }
      return $('<div class="modal editor-modal-image" id="modal-image-' + this.id + '"></div>\'').html('<div class="modal-content">\n        <div class="modal-header">\n          <h1 class="modal-title">' + Locale.translate('InsertImage') + '</h1>\n        </div>\n        <div class="modal-body">\n          <div class="field">\n            <label for="image-' + this.id + '">' + Locale.translate('Url') + '</label>\n            <input id="image-' + this.id + '" name="image-' + this.id + '" type="text" value="' + this.settings.image.url + '">\n          </div>\n          <div class="modal-buttonset">\n            <button type="button" class="btn-modal btn-cancel">\n              ' + Locale.translate('Cancel') + '</button>\n            <button type="button" class="btn-modal-primary">\n              ' + Locale.translate('Insert') + '</button>\n          </div>\n        </div>\n      </div>').appendTo('body');
    },
    bindAnchorPreview: function bindAnchorPreview() {
      this.element.find('a').tooltip({
        content: function content() {
          return $(this).attr('href');
        }
      });
    },
    updateCurrentLink: function updateCurrentLink(alink) {
      var emUrl = xssUtils.stripTags($('[name="em-url-' + this.id + '"]').val());
      var emClass = xssUtils.stripTags($('[name="em-class-' + this.id + '"]').val());
      var emTarget = xssUtils.stripTags($('[name="em-target-' + this.id + '"]').val());
      var emIsClickable = this.settings.anchor.showIsClickable ? $('[name="em-isclickable-' + this.id + '"]').is(':checked') : this.settings.anchor.isClickable;

      if (alink) {
        alink[0].setAttribute('href', this.fixLinkFormat(emUrl && $.trim(emUrl).length ? emUrl : this.settings.anchor.defaultUrl));
        alink[0].setAttribute('class', emClass && $.trim(emClass).length ? emClass : this.settings.anchor.defaultClass);
        alink[0].setAttribute('data-url', (emUrl && $.trim(emUrl).length ? emUrl : this.settings.anchor.defaultUrl).replace('http://', ''));
      }

      if (emIsClickable) {
        alink.attr('contenteditable', false);
      } else {
        alink.removeAttr('contenteditable');
      }

      if (emTarget && $.trim(emTarget).length) {
        alink.attr('target', emTarget);
      } else {
        alink.removeAttr('target');
      }
    },
    createLink: function createLink(input) {
      var _this9 = this;

      // Restore Selection in the Editor and Variables
      this.restoreSelection(this.savedSelection);

      // Fix and Format the Link
      var cleanValue = xssUtils.stripTags(this.fixLinkFormat(input[0].value));
      input.val(cleanValue);

      // Set selection url/class/target for Link
      this.settings.anchor.url = input.val();
      this.settings.anchor.class = $('[name="em-class-' + this.id + '"]').val();
      this.settings.anchor.target = $('[name="em-target-' + this.id + '"]').val();
      this.settings.anchor.isClickable = this.settings.anchor.showIsClickable ? $('[name="em-isclickable-' + this.id + '"]').is(':checked') : this.settings.anchor.isClickable;

      var alink = $('<a data-url="' + cleanValue + '" href="' + cleanValue + '">' + cleanValue + '</a>');

      if (this.settings.anchor.class && $.trim(this.settings.anchor.class).length) {
        alink.addClass(this.settings.anchor.class);
      }
      if (this.settings.anchor.target && $.trim(this.settings.anchor.target).length) {
        alink.attr('target', this.settings.anchor.target);
      }
      if (this.settings.anchor.isClickable) {
        alink.attr('contenteditable', false);
      } else {
        alink.removeAttr('contenteditable');
      }

      if (this.sourceViewActive()) {
        this.insertTextAreaContent(input.val(), 'anchor');
      } else {
        var sel = void 0;
        var range = void 0;
        var rangeChildren = void 0;
        var rangeStr = void 0;
        var rangeImg = void 0;

        if (!this.selection.isCollapsed || this.isIe11) {
          // get example from: http://jsfiddle.net/jwvha/1/
          // and info: http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div
          if (window.getSelection) {
            // IE9 and non-IE
            sel = window.getSelection();
            if (sel.getRangeAt && sel.rangeCount) {
              range = sel.getRangeAt(0);
              rangeStr = '' + range;
              if (rangeStr.trim() !== '') {
                alink.html(rangeStr);
              }

              rangeChildren = range.commonAncestorContainer.children;
              var len = rangeChildren ? rangeChildren.length : 0;
              for (var i = 0; i < len; i++) {
                var rangeChild = rangeChildren[i];

                if (rangeChild instanceof HTMLImageElement) {
                  rangeImg = rangeChild;
                }
              }
              if (rangeImg) {
                alink.html(rangeImg.outerHTML);
              }

              range.deleteContents();

              // Range.createContextualFragment() would be useful here but is
              // only relatively recently standardized and is not supported in
              // some browsers (IE9, for one)
              var el = document.createElement('div');
              el.innerHTML = alink[0].outerHTML;
              var frag = document.createDocumentFragment();
              var node = void 0;
              var lastNode = void 0;

              while (node = el.firstChild) {
                // eslint-disable-line
                lastNode = frag.appendChild(node);
              }
              range.insertNode(frag);

              // Preserve the selection
              if (lastNode) {
                range = range.cloneRange();
                range.setStartAfter(lastNode);
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
              }
            }
          }
        } else {
          document.execCommand('insertHtml', null, alink[0].outerHTML);
          setTimeout(function () {
            _this9.getCurrentElement().focus();
          }, 1);
        }
        this.bindAnchorPreview();
      }
    },
    fixLinkFormat: function fixLinkFormat(value) {
      if (value.match(/^https?:\/\//)) {
        return value;
      }
      return 'http://' + value;
    },


    // Setup Events For Text Selection
    bindSelect: function bindSelect() {
      var _this10 = this;

      var selectionTimer = '';

      this.selectionHandler = function () {
        clearTimeout(selectionTimer);
        selectionTimer = setTimeout(function () {
          _this10.checkSelection();
        }, _this10.settings.delay);
      };

      var currentElement = this.getCurrentElement();

      currentElement.off('mouseup.editor keyup.editor').on('mouseup.editor keyup.editor', this.selectionHandler);

      return this;
    },
    checkSelection: function checkSelection() {
      var newSelection = void 0;

      if (this.selection === undefined) {
        if (this.sourceViewActive()) {
          newSelection = this.textarea.val().substring(this.textarea[0].selectionStart, this.textarea[0].selectionEnd).toString().trim();
          this.hideToolbarActions();
          return;
        }
      }

      newSelection = window.getSelection();
      var selectionElement = this.getSelectionElement();
      if (!selectionElement) {
        this.hideToolbarActions();
      } else {
        this.checkSelectionElement(newSelection, selectionElement);
      }
      return this;
    },
    getSelectionElement: function getSelectionElement() {
      var range = void 0;
      var current = void 0;
      var parent = void 0;
      var result = void 0;
      var selection = window.getSelection();
      var getElement = function getElement(e) {
        var localParent = e;
        try {
          while (!localParent.getAttribute('data-editor')) {
            localParent = localParent.parentNode;
          }
        } catch (errb) {
          return false;
        }
        return localParent;
      };

      // First try on current node
      try {
        range = selection.getRangeAt(0);
        current = range.commonAncestorContainer;
        parent = current.parentNode;
        result = current.getAttribute('data-editor') ? current : getElement(parent);
        // If not search in the parent nodes.
      } catch (err) {
        result = getElement(parent);
      }
      return result;
    },


    // See if the Editor is Selected and Show Toolbar
    checkSelectionElement: function checkSelectionElement(newSelection, selectionElement) {
      var currentElement = this.sourceViewActive() ? this.sourceView[0] : this.element[0];

      this.selection = newSelection;
      this.selectionRange = this.selection.getRangeAt(0);
      if (currentElement === selectionElement) {
        this.setToolbarButtonStates();
        return;
      }
      this.hideToolbarActions();
    },


    // Set button states for toolbar buttons
    setToolbarButtonStates: function setToolbarButtonStates() {
      this.toolbar.find('button').removeClass('is-active');
      this.checkActiveButtons();
      return this;
    },
    checkActiveButtons: function checkActiveButtons() {
      this.checkButtonState('bold');
      this.checkButtonState('italic');
      this.checkButtonState('underline');
      this.colorpickerButtonState('foreColor');
      if (this.toolbar.find('.buttonset [data-action="backColor"]').length) {
        this.colorpickerButtonState('backColor');
      }

      var parentNode = this.getSelectedParentElement();

      while (parentNode.tagName !== undefined && this.parentElements.indexOf(parentNode.tagName.toLowerCase) === -1) {
        this.activateButton(parentNode.tagName.toLowerCase());

        // we can abort the search upwards if we leave the contentEditable element
        if (this.element.is(parentNode)) {
          break;
        }
        parentNode = parentNode.parentNode;
      }
    },
    checkButtonState: function checkButtonState(command) {
      if (!document.queryCommandState) {
        return;
      }

      if (document.queryCommandState(command)) {
        this.toolbar.find('[data-action="' + command + '"]').addClass('is-active');
      } else {
        this.toolbar.find('[data-action="' + command + '"]').removeClass('is-active');
      }
    },
    rangeSelectsSingleNode: function rangeSelectsSingleNode(range) {
      var startNode = range.startContainer;
      return startNode === range.endContainer && startNode.hasChildNodes() && range.endOffset === range.startOffset + 1;
    },
    getSelectedParentElement: function getSelectedParentElement() {
      var selectedParentElement = null;
      var range = this.selectionRange;

      if (this.rangeSelectsSingleNode(range)) {
        selectedParentElement = range.startContainer.childNodes[range.startOffset];
      } else if (range.startContainer.nodeType === 3) {
        selectedParentElement = range.startContainer.parentNode;
      } else {
        selectedParentElement = range.startContainer;
      }
      return selectedParentElement;
    },


    // Hide Toolbar
    hideToolbarActions: function hideToolbarActions() {
      if (this.toolbar !== undefined) {
        this.toolbar.removeClass('is-active');
      }
    },


    // Handle Pasted In Text
    bindPaste: function bindPaste() {
      var self = this;
      var currentElement = self.getCurrentElement();

      this.pasteWrapper = function (e) {
        var paste = void 0;
        if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
          paste = e.originalEvent.clipboardData.getData('text/plain'); // Standard
        } else {
          paste = window.clipboardData && window.clipboardData.getData ? window.clipboardData.getData('Text') : false; // MS : false
        }

        var p = void 0;
        var paragraphs = void 0;
        var html = '';

        if (self.sourceViewActive()) {
          return this;
        }

        if (paste && !e.defaultPrevented) {
          e.preventDefault();
          paragraphs = paste.split(/[\r\n]/g);

          for (p = 0; p < paragraphs.length; p += 1) {
            if (paragraphs[p] !== '') {
              if (navigator.userAgent.match(/firefox/i) && p === 0) {
                html += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
              } else if (/\.(gif|jpg|jpeg|tiff|png)$/i.test(paragraphs[p])) {
                html += '<img src="' + self.htmlEntities(paragraphs[p]) + '" />';
              } else {
                html += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
              }
            }
          }

          if (document.queryCommandSupported('insertText')) {
            document.execCommand('insertHTML', false, html);
            return false;
          }
          // IE > 7
          self.pasteHtmlAtCaret(html);
        }
      };

      this.pasteWrapperHtml = function (e) {
        if (self.sourceViewActive()) {
          return this;
        }
        var types = void 0;
        var clipboardData = void 0;
        var pastedData = void 0;
        var paste = void 0;
        var p = void 0;
        var paragraphs = void 0;

        if (e.clipboardData || e.originalEvent) {
          if (e.clipboardData && e.clipboardData.types) {
            clipboardData = e.clipboardData;
          } else if (e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
            clipboardData = e.originalEvent.clipboardData;
          }
        }

        if (clipboardData && clipboardData.types) {
          types = clipboardData.types;
          if (types instanceof DOMStringList && types.contains('text/html') || types.indexOf && types.indexOf('text/html') !== -1 || self.isIeEdge) {
            pastedData = e.originalEvent.clipboardData.getData('text/html');
          }
          if (types instanceof DOMStringList && types.contains('text/plain')) {
            pastedData = e.originalEvent.clipboardData.getData('text/plain');
          }
          if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object' && types[0] && types[0] === 'text/plain' && !types[1]) {
            pastedData = e.originalEvent.clipboardData.getData('text/plain');
          }
        } else {
          paste = window.clipboardData ? window.clipboardData.getData('Text') : '';
          paragraphs = paste.split(/[\r\n]/g);
          pastedData = '';
          for (p = 0; p < paragraphs.length; p += 1) {
            if (paragraphs[p] !== '') {
              if (navigator.userAgent.match(/firefox/i) && p === 0) {
                pastedData += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
              } else if (/\.(gif|jpg|jpeg|tiff|png)$/i.test(paragraphs[p])) {
                pastedData += '<img src="' + self.htmlEntities(paragraphs[p]) + '" />';
              } else {
                pastedData += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
              }
            }
          }
        }

        self.pastedData = self.isIe11 ? pastedData : self.getCleanedHtml(pastedData);

        /**
        * Fires before paste.
        *
        * @event beforepaste
        * @memberof Editor
        * @type {object}
        * @property {object} event - The jquery event object
        * @property {string} pastedData .
        */
        $.when(self.element.triggerHandler('beforepaste', [{ pastedData: self.pastedData }])).done(function () {
          if (self.pastedData && !e.defaultPrevented) {
            if (!self.isIe11 && !self.isIeEdge) {
              e.preventDefault();
            }

            if (document.queryCommandSupported('insertText')) {
              document.execCommand('insertHTML', false, self.pastedData);
              return false;
            }
            self.pasteHtmlAtCaret(self.pastedData);
          }

          /**
          * Fires after paste.
          *
          * @event afterpaste
          * @memberof Editor
          * @type {object}
          * @property {object} event - The jquery event object
          * @property {string} pastedData .
          */
          self.element.triggerHandler('afterpaste', [{ pastedData: self.pastedData }]);
          self.pastedData = null;
        });
        if (!self.isIe11) {
          return false;
        }
      };

      currentElement.on('paste.editor', self.settings.pasteAsPlainText ? self.pasteWrapper : self.pasteWrapperHtml);

      return this;
    },
    pasteHtmlAtCaret: function pasteHtmlAtCaret(html) {
      var self = this;
      var templIE11 = 'x-text-content-templ-x';

      var sel = void 0;
      var range = void 0;
      if (window.getSelection) {
        sel = window.getSelection();
        if (sel.getRangeAt && sel.rangeCount) {
          range = sel.getRangeAt(0);
          range.deleteContents();

          if (self.isIe11) {
            html = templIE11;
          }

          // Range.createContextualFragment() would be useful here but is
          // only relatively recently standardized and is not supported in
          // some browsers
          var el = document.createElement('div');

          el.innerHTML = html;

          var frag = document.createDocumentFragment();
          var node = void 0;
          var lastNode = void 0;

          while (node = el.firstChild) {
            // eslint-disable-line
            lastNode = frag.appendChild(node);
          }
          range.insertNode(frag);

          // Preserve the selection
          if (lastNode) {
            range = range.cloneRange();
            range.setStartAfter(lastNode);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
          }

          // IE 11
          if (self.isIe11) {
            var maxRun = 50;
            var deferredIE11 = $.Deferred();

            var waitForPastedData = function waitForPastedData(elem, savedContent) {
              maxRun--;
              if (maxRun < 0) {
                deferredIE11.reject();
                return;
              }
              // If data has been processed by browser, process it
              if (elem.childNodes && elem.childNodes.length > 0) {
                // Retrieve pasted content via innerHTML
                // (Alternatively loop through elem.childNodes or elem.getElementsByTagName here)
                html = elem.innerHTML;
                // self.pastedData = getCleanedHtml(elem.innerHTML);
                // Restore saved content
                elem.innerHTML = '';
                elem.appendChild(savedContent);
                deferredIE11.resolve();
              } else {
                // Else wait 5ms and try again
                setTimeout(function () {
                  waitForPastedData(elem, savedContent);
                }, 5);
              }
            };

            // Everything else: Move existing element contents to a DocumentFragment for safekeeping
            var savedContent = document.createDocumentFragment();
            while (self.element[0].childNodes.length > 0) {
              savedContent.appendChild(self.element[0].childNodes[0]);
            }
            // Then wait for browser to paste content into it and cleanup
            waitForPastedData(self.element[0], savedContent);

            $.when(deferredIE11).done(function () {
              var str = '';
              var thisNode = self.element.find(':contains(+ ' + templIE11 + ')').filter(function () {
                return this.textContent === templIE11;
              });

              if (!thisNode.length) {
                thisNode = self.element.find(':contains(+ ' + templIE11 + ')').filter(function () {
                  return this.textContent.indexOf(templIE11) > -1 && this.tagName !== 'UL';
                });
              }

              html = self.getCleanedHtml(html);

              // Working with list
              // Start with "<li"
              var pasteHtml = '';
              if (/(^(\s+?)?<li)/ig.test(html)) {
                // Pasted data starts and ends with "li" tag
                if (/((\s+?)?<\/li>(\s+?)?$)/ig.test(html)) {
                  // ends with "</li>"
                  // Do not add "ul" if pasting on "li" node
                  if (!thisNode.is('li')) {
                    html = '<ul>' + html + '</ul>';
                  }
                  pasteHtml = html;
                } else if (thisNode.is('li')) {
                  // Missing at the end "</li>" tag
                  // Pasting on "li" node
                  pasteHtml = html + '</li>';
                } else {
                  // Not pasting on "li" node

                  // If ul was closed and have extra nodes after list close
                  str = html.match(/<\/ul|<\/ol/gi) || [];
                  // Pasted data contains "ul or ol" tags
                  if (str.length) {
                    pasteHtml = html;
                  } else {
                    pasteHtml = html + '</li></ul>';
                  }
                }
              } else if (/((\s+?)?<\/li>(\s+?)?$)/ig.test(html)) {
                // Ends with "</li>" tag, but not started with "li" tag

                // Pasting on "li" node
                if (thisNode.is('li')) {
                  pasteHtml = '<li>' + html;
                } else {
                  str = html.match(/<ul|<ol/gi) || [];
                  // Pasted data contains "ul or ol" tags
                  if (str.length) {
                    html += str[str.length - 1].replace(/<(ul|ol)/gi, '<$1>');
                  } else {
                    html = '<ul>' + html + '</ul>';
                  }
                  pasteHtml = html;
                }
              }

              if (pasteHtml) {
                DOM.html(thisNode, pasteHtml, '*');
              }

              // Default case
              str = self.element[0].innerHTML;
              if (str.indexOf(templIE11) > -1) {
                str = str.replace(templIE11, html);
              }
              self.element[0].innerHTML = self.getCleanedHtml(str);
            });
          }
        }
      } else if (document.selection && document.selection.type !== 'Control') {
        document.selection.createRange().pasteHTML(html);
      }
    },


    // Get cleaned extra from html
    getCleanedHtml: function getCleanedHtml(pastedData) {
      var attributeStripper = void 0;
      var s = pastedData || '';

      var badAttributes = ['start', 'xmlns', 'xmlns:o', 'xmlns:w', 'xmlns:x', 'xmlns:m', 'onmouseover', 'onmouseout', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onload', 'onfocus', 'onblur', 'onclick', 'style'];

      // Remove extra word formating
      if (this.isWordFormat(s)) {
        s = this.cleanWordHtml(s);
      }

      // Remove bad attributes
      for (var i = 0, l = badAttributes.length; i < l; i++) {
        attributeStripper = new RegExp(' ' + badAttributes[i] + '="(.*?)"', 'gi');
        s = this.stripAttribute(s, badAttributes[i], attributeStripper);

        attributeStripper = new RegExp(' ' + badAttributes[i] + '=\'(.*?)\'', 'gi');
        s = this.stripAttribute(s, badAttributes[i], attributeStripper);
      }

      // Remove "ng-" directives and "ng-" classes
      s = s.replace(/\sng-[a-z-]+/, '');

      // Remove comments
      s = s.replace(/<!--(.*?)-->/gm, '');

      // Remove extra spaces
      s = s.replace(/\s\s+/g, ' ').replace(/\s>+/g, '>');

      // Remove extra attributes from list elements
      s = s.replace(/<(ul|ol)(.*?)>/gi, '<$1>');

      // Remove empty list
      s = s.replace(/<li><\/li>/gi, '');
      s = s.replace(/<(ul|ol)><\/(ul|ol)>/gi, '');

      // Remove html and body tags
      s = s.replace(/<\/?(html|body)(.*?)>/gi, '');

      // Remove header tag and content
      s = s.replace(/<head\b[^>]*>(.*?)<\/head>/gi, '');

      // Remove empty tags
      s = s.replace(/<[^/>]+>[\s]*<\/[^>]+>/gi, '');

      if (s.indexOf('') > -1) {
        // Replace span and paragraph tags from bulleted list pasting
        s = s.replace(/<\/p>/gi, '</li>');
        s = s.replace(/<p><span><span><\/span><\/span>/gi, '<li>');
        // Remove white space
        s = s.replace(/<\/li>\s<li>/gi, '<\/li><li>');
        // Add in opening and closing ul tags
        s = [s.slice(0, s.indexOf('<li>')), '<ul>', s.slice(s.indexOf('<li>'))].join('');
        s = [s.slice(0, s.lastIndexOf('</li>')), '</ul>', s.slice(s.lastIndexOf('</li>'))].join('');
      }

      return s;
    },
    htmlEntities: function htmlEntities(str) {
      // converts special characters (e.g., <) into their escaped/encoded values (e.g., &lt;).
      // This allows you to display the string without the browser reading it as HTML.
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    },
    bindWindowActions: function bindWindowActions() {
      var _this11 = this;

      var editorContainer = this.element.closest('.editor-container');
      var currentElement = this.getCurrentElement();
      var self = this;

      this.element
      // Work around for Firefox with using keys was not focusing on first child in editor
      // Firefox behaves differently than other browsers
      .on('mousedown.editor', function () {
        _this11.mousedown = true;
      }).on('focus.editor', function () {
        if (_this11.isFirefox && !_this11.mousedown && _this11.element === currentElement) {
          _this11.setFocus();
        }
      })

      // Work around for Chrome's bug wrapping contents in <span>
      // http://www.neotericdesign.com/blog/2013/3/working-around-chrome-s-contenteditable-span-bug
      .on('DOMNodeInserted', function (e) {
        var target = $(e.target);
        var helper = $('<b>helper</b>');

        if (e.target.tagName === 'IMG') {
          target.removeAttr('id style srcset');
        } else if (e.target.tagName === 'SPAN') {
          target.before(helper);
          helper.after(target.contents());
          helper.add(target).remove();
        }
      });

      editorContainer.on('focus.editor', '.editor, .editor-source', function () {
        var elem = $(this);

        editorContainer.addClass('is-active');
        setTimeout(function () {
          if (elem.hasClass('error')) {
            editorContainer.parent().find('.editor-toolbar').addClass('error');
            editorContainer.parent().find('.editor-source').addClass('error');
          }
        }, 100);
      }).on('blur.editor', '.editor, .editor-source', function () {
        editorContainer.removeClass('is-active');
        editorContainer.parent().find('.editor-toolbar').removeClass('error');
        editorContainer.parent().find('.editor-source').removeClass('error');
      });

      if (self.settings.onLinkClick) {
        editorContainer.on('click.editorlinks', 'a', function (e) {
          self.settings.onLinkClick(e, { elem: _this11, url: e.currentTarget.getAttribute('data-url') });
          e.preventDefault();
          e.stopImmediatePropagation();
          e.stopPropagation();
        });
      }

      // Attach Label
      var label = this.element.prevAll('.label');
      for (var i = 0, l = label.length; i < l; i++) {
        label[i].style.cursor = 'default';
      }
      label.on('click.editor', function () {
        currentElement.focus();
      });
      currentElement.attr('aria-label', label.text());
      return this;
    },


    // Restore Text Selection
    restoreSelection: function restoreSelection(savedSel) {
      var sel = window.getSelection();

      if (!savedSel) {
        savedSel = this.savedSelection;
      }

      if (savedSel) {
        sel.removeAllRanges();
        for (var i = 0, len = savedSel.length; i < len; i += 1) {
          sel.addRange(savedSel[i]);
        }
      }
    },


    // Save Text Selection
    saveSelection: function saveSelection() {
      var ranges = void 0;
      var sel = window.getSelection();

      if (sel.getRangeAt && sel.rangeCount) {
        ranges = [];
        for (var i = 0, len = sel.rangeCount; i < len; i += 1) {
          ranges.push(sel.getRangeAt(i));
        }
        return ranges;
      }
      return null;
    },


    // Get the Element the Caret idea from http://bit.ly/1kRmZIL
    getSelectionStart: function getSelectionStart() {
      var node = document.getSelection().anchorNode;
      var startNode = node && node.nodeType === 3 ? node.parentNode : node;
      return startNode;
    },
    getrange: function getrange() {
      return window.getSelection().getRangeAt(0);
    },


    // Find element within the selection
    // http://stackoverflow.com/questions/6052870/how-to-know-if-there-is-a-link-element-within-the-selection
    findElementInSelection: function findElementInSelection(tagname, container) {
      var el = void 0;
      var comprng = void 0;
      var selparent = void 0;
      var rng = this.getrange();

      if (rng) {
        selparent = rng.commonAncestorContainer || rng.parentElement();
        // Look for an element *around* the selected range
        for (el = selparent; el !== container; el = el.parentNode) {
          if (el && el.tagName && el.tagName.toLowerCase() === tagname) {
            return el;
          }
        }

        // Look for an element *within* the selected range
        if (!rng.collapsed && (rng.text === undefined || rng.text) && selparent.getElementsByTagName) {
          el = selparent.getElementsByTagName(tagname);
          comprng = document.createRange ? document.createRange() : document.body.createTextRange();

          for (var i = 0, len = el.length; i < len; i++) {
            // determine if element el[i] is within the range
            if (document.createRange) {
              // w3c
              comprng.selectNodeContents(el[i]);
              if (rng.compareBoundaryPoints(Range.END_TO_START, comprng) < 0 && rng.compareBoundaryPoints(Range.START_TO_END, comprng) > 0) {
                return el[i];
              }
            } else {
              // microsoft
              comprng.moveToElementText(el[i]);
              if (rng.compareEndPoints('StartToEnd', comprng) < 0 && rng.compareEndPoints('EndToStart', comprng) > 0) {
                return el[i];
              }
            }
          }
        }
      }
    },


    // Restore if Selection is a Link
    restoreLinkSelection: function restoreLinkSelection() {
      var currentLink = $(this.findElementInSelection('a', this.element[0]));

      this.settings.anchor.url = this.settings.anchor.defaultUrl;
      this.settings.anchor.class = this.settings.anchor.defaultClass;
      this.settings.anchor.target = this.settings.anchor.defaultTarget;
      this.settings.anchor.isClickable = this.settings.anchor.defaultIsClickable;

      if (currentLink.length) {
        this.settings.anchor.url = currentLink.attr('href');
        this.settings.anchor.class = currentLink.attr('class');
        this.settings.anchor.target = currentLink.attr('target');
        var contenteditable = currentLink.attr('contenteditable');

        if (contenteditable === false || contenteditable === 'false') {
          this.settings.anchor.isClickable = true;
        }
      }
    },


    // Run the CE action.
    execAction: function execAction(action) {
      var currentElement = this.getCurrentElement();

      // Visual Mode
      if (currentElement === this.element) {
        if (action.indexOf('append-') > -1) {
          this.execFormatBlock(action.replace('append-', ''));
        } else if (action === 'anchor') {
          this.restoreLinkSelection();
          this.modals.url.data('modal').open();
        } else if (action === 'image') {
          this.modals.image.data('modal').open();
        } else if (action === 'foreColor' || action === 'backColor') {
          this.colorpickerActions(action);
        } else if (action === 'clearFormatting') {
          this.clearFormatting();
        } else if (action === 'source' || action === 'visual') {
          this.toggleSource();
        } else {
          document.execCommand(action, false, null);
        }
      } else {
        // Source Mode
        switch (action) {
          case 'visual':
            this.toggleSource();
            break;
          case 'anchor':
            this.modals.url.data('modal').open();
            break;
          default:
            this.insertTextAreaContent(null, action);
            break;
        }
      }
    },
    insertImage: function insertImage(url) {
      document.execCommand('insertImage', false, url);
    },
    toggleSource: function toggleSource() {
      if (this.sourceViewActive()) {
        this.element.empty().html(xssUtils.sanitizeHTML(this.textarea.val()));
        this.element.removeClass('source-view-active hidden');
        this.sourceView.addClass('hidden').removeClass('is-focused');
        this.element.trigger('focus.editor');
      } else {
        // Format The Text being pulled from the WYSIWYG editor
        var val = this.element.html().toString().trim().replace(/\s+/g, ' ').replace(/<br( \/)?>/g, '<br>\n').replace(/<\/p> /g, '</p>\n\n').replace(/<\/blockquote>( )?/g, '</blockquote>\n\n');

        this.textarea.val(val).focus();

        // var val = this.element.html().toString();
        // this.textarea.val(this.formatHtml(val)).focus();

        this.element.addClass('source-view-active hidden');
        this.sourceView.removeClass('hidden');
        this.adjustSourceLineNumbers();
        this.textarea.focus();
      }
      this.switchToolbars();
    },


    /**
     * Function to clear formatting on selected area.
     * @private
     * @returns {void}
     */
    clearFormatting: function clearFormatting() {
      var _this12 = this;

      var parentEl = this.getSelectionParentElement();
      var parentTag = parentEl.tagName;
      var align = {};

      // Function to get text-align value if found
      var getTextAlign = function getTextAlign() {
        var isFound = function isFound(el) {
          return el && el.style && el.style.textAlign !== '';
        };
        var elem = parentEl;
        var found = isFound(elem);
        var max = 9999;
        while (!found && max > 0) {
          max--;
          elem = elem ? elem.parentNode : null;
          found = elem && elem === _this12.element[0] || isFound(elem);
        }
        var r = { found: elem && elem !== parentEl && elem !== _this12.element[0] };
        if (r.found) {
          r.elem = elem;
          r.textAlign = elem.style.textAlign;
        }
        return r;
      };

      // Clear other formated tags.
      var clearFormatedTags = function clearFormatedTags() {
        var replaceTag = function replaceTag(elem) {
          var parent = elem.parentNode;
          var p = document.createElement('p');
          p.innerHTML = elem.innerHTML;
          parent.replaceChild(p, elem);
        };
        if (_this12.parentElements.indexOf(parentTag) > -1) {
          if (parentTag !== 'p') {
            document.execCommand('removeFormat', false, null);
            replaceTag(parentEl);
          }
        } else {
          _this12.parentElements.forEach(function (el) {
            if (el !== 'p') {
              var _nodes = [].slice.call(parentEl.querySelectorAll(el));
              _nodes.forEach(function (node) {
                return replaceTag(node);
              });
            }
          });
        }
        // Blockquote or Pre
        var nodes = [].slice.call(_this12.element[0].querySelectorAll('blockquote, pre'));

        var _loop = function _loop(i, l) {
          var found = false;
          var children = [].slice.call(nodes[i].children);
          var checkChildren = function checkChildren(childrenNodes) {
            for (var i2 = 0, l2 = childrenNodes.length; i2 < l2; i2++) {
              var child = childrenNodes[i2];
              var childChildren = [].slice.call(child.children);
              if (child === parentEl) {
                found = true;
              }
              if (childChildren.length && !found) {
                checkChildren(childChildren);
              }
            }
          };
          checkChildren(children);
          if (found) {
            document.execCommand('removeFormat', false, null);
            replaceTag(nodes[i]);
          }
        };

        for (var i = 0, l = nodes.length; i < l; i++) {
          _loop(i, l);
        }
      };

      // Clear all lists belongs to selection area
      var clearLists = function clearLists() {
        var normalizeList = function normalizeList(list) {
          var items = [].slice.call(list.querySelectorAll('li'));
          if (items.length > 0) {
            var fragment = document.createDocumentFragment();
            items.forEach(function (item) {
              var textNode = document.createTextNode(item.textContent);
              fragment.appendChild(textNode);
              fragment.appendChild(document.createElement('br'));
            });
            var target = items[0].parentNode;
            target.parentNode.insertBefore(fragment, target.nextSibling);
            target.parentNode.removeChild(target);
          }
        };
        if (parentTag === 'li') {
          normalizeList(parentEl.parentNode);
        } else if (/ul|ol/.test(parentTag)) {
          normalizeList(parentEl);
        } else {
          var lists = [].slice.call(parentEl.parentNode.querySelectorAll('ul, ol'));
          lists.forEach(function (list) {
            return normalizeList(list);
          });
        }
      };

      // Check if selection contains given node
      var containsNodeInSelection = function containsNodeInSelection(node) {
        var sel = window.getSelection();
        var r = false;
        if (_this12.isIe11) {
          var rangeAt = sel.getRangeAt(0);
          var range = document.createRange();
          range.selectNode(node);
          var s2s = rangeAt.compareBoundaryPoints(Range.START_TO_END, range);
          var s2e = rangeAt.compareBoundaryPoints(Range.START_TO_START, range);
          var e2s = rangeAt.compareBoundaryPoints(Range.END_TO_START, range);
          var e2e = rangeAt.compareBoundaryPoints(Range.END_TO_END, range);
          r = s2s !== s2e || e2s !== e2e || s2s !== e2e;
        } else {
          r = sel.containsNode(node, true);
        }
        return r;
      };

      // Convert hyperlinks to plain text in selected area.
      var hyperlinksToText = function hyperlinksToText() {
        var toText = function toText(a) {
          var parent = a.parentNode;
          var text = a.firstChild;
          parent.insertBefore(text, a);
          parent.removeChild(a);
          parent.normalize();
        };
        if (parentTag === 'a') {
          toText(parentEl);
        } else {
          var links = [].slice.call(parentEl.querySelectorAll('a'));
          links.forEach(function (a) {
            if (containsNodeInSelection(a)) {
              toText(a);
            }
          });
        }
      };

      if (parentEl && parentTag) {
        parentTag = parentTag.toLowerCase();
        align = getTextAlign();
        clearLists();
        clearFormatedTags();
        hyperlinksToText();
      }

      // Some browser (IE, Firefox) use attr 'align' instead style `text-align`
      var gParentEl = parentEl.parentNode;
      if (gParentEl && gParentEl !== this.element[0]) {
        var alignAttrElems = [].slice.call(gParentEl.querySelectorAll('[align]'));
        alignAttrElems.forEach(function (el) {
          return el.removeAttribute('align');
        });
      }
      document.execCommand('removeFormat', false, null);

      // Restore style `text-align`, some browser (chrome, safari) clear `text-align` on parent node with command `removeFormat`
      if (align.found) {
        align.elem.style.textAlign = align.textAlign;
      }
    },


    /**
     * Get selection parent element.
     * @private
     * @returns {object} parent element.
     */
    getSelectionParentElement: function getSelectionParentElement() {
      var parentEl = null;
      var sel = void 0;
      if (window.getSelection) {
        sel = window.getSelection();
        if (sel.rangeCount) {
          parentEl = sel.getRangeAt(0).commonAncestorContainer;
          if (parentEl.nodeType !== 1) {
            parentEl = parentEl.parentNode;
          }
        }
      } else {
        sel = document.selection;
        if (sel && sel.type !== 'Control') {
          parentEl = sel.createRange().parentElement();
        }
      }
      return parentEl;
    },


    // Set ['foreColor'|'backColor'] button icon color in toolbar
    colorpickerButtonState: function colorpickerButtonState(action) {
      var cpBtn = $('[data-action="' + action + '"]', this.toolbar);
      var cpApi = cpBtn.data('colorpicker');
      var preventColors = ['transparent', '#1a1a1a', '#f0f0f0', '#ffffff', '#313236'];

      var color = document.queryCommandValue(action);

      // Set selection color checkmark in picker popup
      // by adding/updating ['data-value'] attribute
      if (cpApi) {
        if (this.isFirefox && action === 'backColor') {
          color = $(window.getSelection().focusNode.parentNode).css('background-color');
        }
        // IE-11 queryCommandValue returns the as decimal
        if (typeof color === 'number') {
          color = cpApi.decimal2rgb(color);
        }
        color = color ? cpApi.rgb2hex(color) : '';
        cpBtn.attr('data-value', color).find('.icon').css('fill', preventColors.indexOf(color.toLowerCase()) > -1 ? '' : color);
      }
      return { cpBtn: cpBtn, cpApi: cpApi, color: color };
    },


    // Colorpicker actions ['foreColor'|'backColor']
    colorpickerActions: function colorpickerActions(action) {
      var _this13 = this;

      var state = this.colorpickerButtonState(action);
      var cpBtn = state.cpBtn;
      var cpApi = state.cpApi;

      cpBtn.on('selected.editor', function (e, item) {
        var value = ('#' + item.data('value')).toLowerCase();
        value = value !== '#' ? value : '';
        cpBtn.attr('data-value', value).find('.icon').css('fill', value);

        if (_this13.isIe || action === 'foreColor') {
          if (value) {
            document.execCommand(action, false, value);
          } else {
            document.execCommand('removeFormat', false, action);
          }
        } else {
          // [action: backColor] - for Chrome/Firefox/Safari

          // FIX: "backColor" - Chrome/Firefox/Safari
          // some reason font/span node not get inserted with "backColor"
          // so use "fontSize" command to add node, then remove size attribute
          // this fix will conflict with combination of font size & background color
          document.execCommand('fontSize', false, '2');
          var parent = _this13.getSelectionParentElement().parentNode;
          var els = parent.getElementsByTagName('font');

          // Clearing all the background style in any element node in selection's parent
          for (var i = 0, j = els.length; i < j; i++) {
            if (els[i].hasAttribute('style')) {
              els[i].style.backgroundColor = '';
            }
          }

          // Using timeout, firefox not executes with current call stack
          setTimeout(function () {
            for (var _i = 0, l = els.length; _i < l; _i++) {
              if (els[_i].hasAttribute('size')) {
                els[_i].style.backgroundColor = value;
                els[_i].removeAttribute('size');
              }
            }
          }, 0);
        }

        setTimeout(function () {
          _this13.getCurrentElement().focus();
        }, 0);
      });

      // Toggle colorpicker
      cpApi.toggleList();
    },
    execFormatBlock: function execFormatBlock(el) {
      var selectionData = this.getSelectionData(this.selection.anchorNode);
      // FF handles blockquote differently on formatBlock
      // allowing nesting, we need to use outdent
      // https://developer.mozilla.org/en-US/docs/Rich-Text_Editing_in_Mozilla
      if (el === 'blockquote' && selectionData.el && selectionData.el.parentNode.tagName.toLowerCase() === 'blockquote') {
        return document.execCommand('outdent', false, null);
      }
      if (selectionData.tagName === el) {
        el = 'p';
      }
      // When IE we need to add <> to heading elements and
      // blockquote needs to be called as indent
      // http://stackoverflow.com/questions/10741831/execcommand-formatblock-headings-in-ie
      // http://stackoverflow.com/questions/1816223/rich-text-editor-with-blockquote-function/1821777#1821777
      if (this.isIe) {
        if (el === 'blockquote') {
          return document.execCommand('indent', false, el);
        }
        el = '<' + el + '>';
      }

      return document.execCommand('formatBlock', false, el);
    },


    // Get What is Selected
    getSelectionData: function getSelectionData(el) {
      var tagName = void 0;

      if (el && el.tagName) {
        tagName = el.tagName.toLowerCase();
      }

      while (el && this.parentElements.indexOf(tagName) === -1) {
        el = el.parentNode;
        if (el && el.tagName) {
          tagName = el.tagName.toLowerCase();
        }
      }

      return { el: el, tagName: tagName };
    },
    isListItemChild: function isListItemChild(node) {
      var parentNode = node.parentNode;
      var tagName = parentNode.tagName.toLowerCase();

      while (this.parentElements.indexOf(tagName) === -1 && tagName !== 'div') {
        if (tagName === 'li') {
          return true;
        }
        parentNode = parentNode.parentNode;
        if (parentNode && parentNode.tagName) {
          tagName = parentNode.tagName.toLowerCase();
        } else {
          return false;
        }
      }
      return false;
    },
    destroyToolbar: function destroyToolbar() {
      // Unbind all events attached to the old element that involve triggering the toolbar hide/show
      var checkJQ = function checkJQ(el) {
        return el || $();
      };
      this.toolbar = checkJQ(this.toolbar);
      this.element = checkJQ(this.element);
      this.textarea = checkJQ(this.textarea);

      var toolbarApi = this.toolbar.data('toolbar');
      if (toolbarApi) {
        toolbarApi.destroy();
      }

      var tooltips = this.toolbar.find('button');
      for (var i = 0, l = tooltips.length; i < l; i++) {
        var tooltip = $(tooltips[i]).data('tooltip');
        if (tooltip && typeof tooltip.destroy === 'function') {
          tooltip.destroy();
        }
      }

      var colorpickers = $('[data-action="foreColor"], [data-action="backColor"]', this.element);
      for (var _i2 = 0, _l = colorpickers.length; _i2 < _l; _i2++) {
        var colorpicker = $(colorpickers[_i2]).data('colorpicker');
        if (colorpicker && typeof colorpicker.destroy === 'function') {
          colorpicker.destroy();
        }
      }

      this.toolbar.off('touchstart.editor click.editor click.editor mousedown.editor');
      this.toolbar.remove();
      this.toolbar = undefined;
      this.element.off('mouseup.editor keypress.editor input.editor keyup.editor keydown.editor focus.editor mousedown.editor DOMNodeInserted.editor updated.editor blur.editor paste.editor');
      this.textarea.off('mouseup.editor click.editor keyup.editor input.editor focus.editor blur.editor');
      this.element.prev('.label').off('click.editor');

      this.element.closest('.editor-container').off('focus.editor blur.editor click.editorlinks');

      var state = this.colorpickerButtonState('foreColor');
      var cpBtn = state.cpBtn;
      cpBtn.off('selected.editor');

      state = this.colorpickerButtonState('backColor');
      cpBtn = state.cpBtn;
      cpBtn.off('selected.editor');

      $(window).off('resize.editor');

      if (this.modals) {
        for (var _i3 = 0, _l2 = this.modals.length; _i3 < _l2; _i3++) {
          var modal = $(this.modals[_i3]);
          var modalApi = modal.data('modal');
          modal.off('beforeclose.editor close.editor open.editor beforeopen.editor');
          if (modalApi && typeof modalApi.destroy === 'function') {
            modalApi.destroy();
          }
        }
      }
      this.modals = {};

      this.element.trigger('destroy.toolbar.editor');
    },


    /**
     * Setup the preview mode.
     * @private
     * @returns {void}
     */
    setPreviewMode: function setPreviewMode() {
      var containerClassList = this.container[0].classList;
      var elementClassList = this.element[0].classList;

      if (!containerClassList.contains('is-preview')) {
        if (!this.isEditable()) {
          var classes = ['is-disabled', 'is-readonly', 'is-preview'];
          containerClassList.remove.apply(containerClassList, classes);
          elementClassList.remove.apply(elementClassList, classes);
        }
        if (this.sourceViewActive()) {
          this.toggleSource();
        }
        containerClassList.add('is-preview');
        elementClassList.remove('is-preview');
        this.element[0].setAttribute('contenteditable', false);
        this.element[0].removeAttribute('aria-multiline');
        this.element[0].removeAttribute('role');

        // Remove tooltip for links in editor
        var links = [].slice.call(this.element[0].querySelectorAll('a'));
        links.forEach(function (link) {
          var tooltipApi = $(link).data('tooltip');
          if (tooltipApi && typeof tooltipApi.destroy === 'function') {
            tooltipApi.destroy();
          }
        });
      }
    },


    /**
     * Destroy preview mode.
     * @private
     * @returns {void}
     */
    destroyPreviewMode: function destroyPreviewMode() {
      if (!this.container[0]) {
        return;
      }

      var classList = this.container[0].classList;
      if (classList.contains('is-preview')) {
        classList.remove('is-preview');
        if (!this.previewRendered) {
          this.previewRendered = true;
          this.init();
        } else {
          this.element[0].setAttribute('aria-multiline', true);
          this.element[0].setAttribute('role', 'textbox');
          this.bindAnchorPreview();
        }
      }
    },


    /**
     * Check for the editor is in preview mode.
     * @returns {boolean} true if editor in preview mode
     */
    isPreview: function isPreview() {
      return this.container[0] ? this.container[0].classList.contains('is-preview') : false;
    },


    /**
     * Check for the editor is in editable mode.
     * @returns {boolean} true if editor is editabled
     */
    isEditable: function isEditable() {
      var _this14 = this;

      var isEnabled = true;
      var isContains = function isContains(el, className) {
        return el.classList.contains(className);
      };
      ['is-disabled', 'is-readonly', 'is-preview'].forEach(function (className) {
        if (isContains(_this14.container[0], className) || isContains(_this14.element[0], className)) {
          isEnabled = false;
        }
      });
      return isEnabled;
    },


    /**
     * Updates the component instance.  Can be used after being passed new settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, EDITOR_DEFAULTS);
      }
      return this.teardown().init();
    },
    teardown: function teardown() {
      this.element.attr('contenteditable', 'false');
      this.element.off('input.editor keyup.editor');
      $('html').off('mouseup.editor');

      this.destroyToolbar();
      if (this.sourceView) {
        this.sourceView.off('.editor');
        this.sourceView.remove();
        this.sourceView = null;
      }

      if ($('[data-editor="true"]').length === 1) {
        $('#modal-url-' + this.id + ', #modal-image-' + this.id).remove();
      }

      return this;
    },


    /**
     * Destroy this component instance and remove all events and reset back to default.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$C);
    },


    /**
    * Disable the editable area.
    * @returns {void}
    */
    disable: function disable() {
      this.destroyPreviewMode();
      this.element.addClass('is-disabled').attr('contenteditable', 'false');
      this.container.addClass('is-disabled');
    },


    /**
    * Enable the editable area.
    * @returns {void}
    */
    enable: function enable() {
      this.destroyPreviewMode();
      this.element.removeClass('is-disabled is-readonly').attr('contenteditable', 'true');
      this.container.removeClass('is-disabled is-readonly');
    },


    /**
    * Make the editable area readonly.
    * @returns {void}
    */
    readonly: function readonly() {
      this.destroyPreviewMode();
      this.element.removeClass('is-readonly').attr('contenteditable', 'false');
      this.container.addClass('is-readonly');
    },


    /**
     * Make the editable mode.
     * @returns {void}
     */
    editable: function editable() {
      this.enable();
    },


    /**
     * Make the preview mode.
     * @returns {void}
     */
    preview: function preview() {
      if (!this.container[0].classList.contains('is-preview')) {
        this.setPreviewMode();
      }
    },


    // Fix to Firefox get focused by keyboard
    setFocus: function setFocus() {
      var el = $.trim(this.element.html()).slice(0, 1) === '<' ? $(':first-child', this.element)[0] : this.element[0];

      window.setTimeout(function () {
        var sel = void 0;
        var range = void 0;
        if (window.getSelection && document.createRange) {
          range = document.createRange();
          range.selectNodeContents(el);
          range.collapse(true);
          sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        } else if (document.body.createTextRange) {
          range = document.body.createTextRange();
          range.moveToElementText(el);
          range.collapse(true);
          range.select();
        }
      }, 1);
    },


    // Called whenever a paste event has occured
    onPasteTriggered: function onPasteTriggered() {
      if (!this.isFirefox && document.addEventListener) {
        document.addEventListener('paste', function (e) {
          if (typeof e.clipboardData !== 'undefined') {
            var copiedData = e.clipboardData.items[0]; // Get the clipboard data
            // If the clipboard data is of type image, read the data
            if (copiedData.type.indexOf('image') === 0) {
              var imageFile = copiedData.getAsFile();
              // We will use HTML5 FileReader API to read the image file
              var reader = new FileReader();

              reader.onload = function (evt) {
                var result = evt.target.result; // base64 encoded image
                document.execCommand('insertImage', false, result);
                // Create an image element and append it to the content editable div
                // var img = document.createElement('img');
                // img.src = result;
                // document.getElementById('editablediv').appendChild(img);
              };
              // Read the image file
              reader.readAsDataURL(imageFile);
            }
          }
        }, false);
      }
    },
    isWordFormat: function isWordFormat(content) {
      return (/<font face="Times New Roman"|class="?Mso|style="[^"]*\bmso-|style='[^'']*\bmso-|w:WordDocument/i.test(content) || /class="OutlineElement/.test(content) || /id="?docs\-internal\-guid\-/.test(content)
      );
    },
    cleanWordHtml: function cleanWordHtml(content) {
      var s = content;

      // Word comments like conditional comments etc
      s = s.replace(/<!--[\s\S]+?-->/gi, '');

      // Remove comments, scripts (e.g., msoShowComment), XML tag, VML content,
      // MS Office namespaced tags, and a few other tags
      s = s.replace(/<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi, '');

      // Convert <s> into <strike> for line-though
      s = s.replace(/<(\/?)s>/gi, '<$1strike>');

      // Replace nbsp entites to char since it's easier to handle
      s = s.replace(/&nbsp;/gi, '\xA0');

      // Convert <span style="mso-spacerun:yes"></span> to string of alternating
      // breaking/non-breaking spaces of same length
      s = s.replace(/<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi, function (str, spaces) {
        return spaces.length > 0 ? spaces.replace(/./, ' ').slice(Math.floor(spaces.length / 2)).split('').join('\xA0') : '';
      });

      // Remove line breaks / Mso classes
      s = s.replace(/(\n|\r| class=(\'|")?Mso[a-zA-Z]+(\'|")?)/g, ' ');

      var badTags = ['style', 'script', 'applet', 'embed', 'noframes', 'noscript'];

      // Remove everything in between and including "badTags"
      for (var i = 0, l = badTags.length; i < l; i++) {
        var re = new RegExp('<' + badTags[i] + '.*?' + badTags[i] + '(.*?)>', 'gi');
        s = s.replace(re, '');
      }

      return s;
    },


    // Strip attributes
    stripAttribute: function stripAttribute(s, attribute, attributeStripper) {
      return attribute === 'style' ? this.stripStyles(s, attributeStripper) : s.replace(attributeStripper, '');
    },


    // Strip styles
    stripStyles: function stripStyles(s, styleStripper) {
      var stylesToKeep = ['color', 'background', 'font-weight', 'font-style', 'text-decoration', 'text-align'];
      return s.replace(styleStripper, function (m) {
        m = m.replace(/( style=|("|\'))/gi, '');
        var attributes = m.split(';');
        var strStyle = '';
        for (var i = 0; i < attributes.length; i++) {
          var entry = attributes[i].split(':');
          strStyle += stylesToKeep.indexOf(entry[0]) > -1 ? entry[0] + ':' + entry[1] + ';' : '';
        }
        return strStyle !== '' ? ' style="' + strStyle + '"' : '';
      });
    },
    getIndent: function getIndent(level) {
      var result = '';
      var i = level * 2;
      if (level > -1) {
        while (i--) {
          result += ' ';
        }
      }
      return result;
    },
    formatHtml: function formatHtml(html) {
      html = html.trim();
      var result = '';
      var indentLevel = 0;
      var tokens = html.split(/</);

      for (var i = 0, l = tokens.length; i < l; i++) {
        var parts = tokens[i].split(/>/);
        if (parts.length === 2) {
          if (tokens[i][0] === '/') {
            indentLevel--;
          }
          result += this.getIndent(indentLevel);
          if (tokens[i][0] !== '/') {
            indentLevel++;
          }
          if (i > 0) {
            result += '<';
          }
          result += parts[0].trim() + ' + >\n';
          if (parts[1].trim() !== '') {
            result += this.getIndent(indentLevel) + parts[1].trim().replace(/\s+/g, ' ') + '\n';
          }
          if (parts[0].match(/^(area|base|br|col|command|embed|hr|img|input|link|meta|param|source)/)) {
            indentLevel--;
          }
        } else {
          result += this.getIndent(indentLevel) + parts[0] + '\n';
        }
      }
      return result.trim();
    },


    /**
     * Clear the editor of its contents.
     */
    clear: function clear() {
      this.element.empty();
      this.textarea.empty();
      this.sourceView.find('.line-numbers').empty();
      this.sourceView.find('.textarea-print').empty();
    }
  };

  // Initialize the plugin (Once)
  $.fn.editor = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$C);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$C, new Editor(this, settings));
      }
    });
  };

  // The name of this component
  var COMPONENT_NAME$D = 'hierarchy';

  /**
   * The displays customizable hierarchical data such as an org chart.
   *
   * @class Hierarchy
   * @param {string} element The component element.
   * @param {string} [settings] The component settings.
   * @param {string} [settings.legend] Pass in custom markdown for the legend structure.
   * @param {string} [settings.legendKey] Key to use for the legend matching
   * @param {array} [settings.dataset=[]] Hierarchical Data to display
   * @param {boolean} [settings.newData=[]] New data to be appended into dataset
   * @param {string} [settings.templateId] Additional product name information to display
   * @param {boolean} [settings.mobileView=false] If true will only show mobile view, default using device info.
   * @param {number} [settings.leafHeight=null] Set the height of the leaf
   * @param {number} [settings.leafWidth=null] Set the width of the leaf
   * @param {string} [settings.beforeExpand=null] A callback that fires before node expansion of a node.
   * @param {boolean} [settings.paging=false] If true show pagination.
   * @param {boolean} [settings.renderSubLevel=false] If true elements with no children will be rendered detached
   * @param {boolean} [settings.layout=string] Which layout should be rendered {'horizontal', 'mobile-only', 'stacked', 'paging'}
   * @param {object} [settings.emptyMessage] An optional settings object for the empty message when there is no data.
   * @param {string} [settings.emptyMessage.title=(Locale ? Locale.translate('NoData')] The text to show
   * @param {string} [settings.emptyMessage.info=''] Longer block of test to show.
   * @param {string} [settings.emptyMessage.icon='icon-empty-no-data'] The icon to show.
   * @param {object} [settings.emptyMessage.button='{}'] The button and text to show with an optional click function.
   */
  var HIERARCHY_DEFAULTS = {
    legend: [],
    legendKey: '',
    dataset: [],
    newData: [],
    templateId: '', // Id to the Html Template
    mobileView: false,
    leafHeight: null,
    leafWidth: null,
    beforeExpand: null,
    paging: false,
    renderSubLevel: false,
    layout: 'horizontal', // stacked, horizontal, paging, mobile-only
    rootClass: 'hierarchy',
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  function Hierarchy(element, settings) {
    this.settings = utils.mergeSettings(element, settings, HIERARCHY_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Hierarchy Methods
  Hierarchy.prototype = {
    init: function init() {
      var s = this.settings;
      this.settings.rootClass = 'hierarchy';

      s.colorClass = ['azure08', 'turquoise02', 'amethyst06', 'slate06', 'amber06', 'emerald07', 'ruby06'];

      // Setup events
      this.handleEvents();

      // Warn about deprecated settings
      if (s.paging) {
        console.warn('\n      Hierarchy,\n      WARNING: Paging setting will be deprecated.\n      Date of Message: 02/12/2019\n      Date of deprecation: 05/15/2019.\n      ');
      }

      if (s.mobileView) {
        console.warn('\n      Hierarchy,\n      WARNING: MobileView setting will be deprecated.\n      Date of Message: 02/12/2019\n      Date of deprecation: 05/15/2019.\n      ');
      }

      // Safety check, check for data
      if (s.dataset === undefined || s.dataset.length === 0 || !Array.isArray(s.dataset)) {
        this.element.emptymessage(s.emptyMessage);
        return;
      }

      if (s.dataset[0] && s.dataset[0].children && s.dataset[0].children.length > 0 || this.isStackedLayout()) {
        this.render(s.dataset[0]);
      } else if (s.dataset && s.dataset.children.length > 0) {
        this.render(s.dataset);
      }

      if (s.leafHeight !== null && s.leafWidth !== null) {
        var style = '\'body .hierarchy .leaf,body .hierarchy .sublevel .leaf,body .hierarchy .container .root.leaf { width: ' + s.leafWidth + 'px;  height: ' + s.leafHeight + 'px;  }\'';

        $('<style type="text/css" id="hierarchyLeafStyles">' + style + '</style>').appendTo('body');
      }

      if (s.layout) {
        this.setLayout(s.layout);
      }
    },


    /**
     * Setup the hierarchy layout.
     * @private
     * @param {string} layout The layout to display
     * @returns {void}
     */
    setLayout: function setLayout(layout) {
      if (this.settings.paging) {
        layout = 'paging';
      }

      if (this.settings.mobileView) {
        layout = 'mobile-only';
      }

      switch (layout) {
        case 'horizontal':
          this.element.addClass('layout-is-horizontal');
          break;
        case 'stacked':
          this.element.addClass('layout-is-stacked');
          break;
        case 'paging':
          this.element.addClass('layout-is-paging');
          break;
        case 'mobile-only':
          this.element.addClass('layout-is-mobile-only');
          break;
        default:
          this.element.addClass('layout-is-horizontal');
      }
    },


    /**
     * Attach all event handlers
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      var s = this.settings;

      // Expand or Collapse
      self.element.off('click.hierarchy').on('click.hierarchy', '.btn', function (e) {
        // Stacked layout doesn't expand/collapse
        if (self.isStackedLayout()) {
          return;
        }

        if (s.newData.length > 0) {
          s.newData = [];
        }

        var nodeId = $(this).closest('.leaf').attr('id');
        var nodeData = $('#' + nodeId).data();
        var domObject = {
          branch: $(this).closest('li'),
          leaf: $(this).closest('.leaf'),
          button: $(this)
        };

        if (nodeData.isExpanded) {
          self.collapse(e, nodeData, domObject);
        } else {
          self.expand(e, nodeData, domObject);
        }
      });

      this.element.on('keypress', '.leaf', function (e) {
        var nodeId = $(this).attr('id');
        var nodeData = $('#' + nodeId);

        if (e.which === 13) {
          if (nodeData.isExpanded) {
            self.collapse(e, nodeData);
          } else {
            self.expand(e, nodeData);
          }
        }
      });

      self.element.off('dblclick.hierarchy').on('dblclick.hierarchy', '.leaf', function (e) {
        var nodeId = e.currentTarget.id;
        var nodeData = $('#' + nodeId).data();
        var dblClickEvent = { event: e, data: nodeData };
        e.stopImmediatePropagation();

        _this.element.trigger('dblclick', dblClickEvent);
      });

      /**
       * Fires when node is selected
       * @event selected
       * @memberof Hierarchy
       * @param {object} event - The jquery event object
       * @param {object} eventInfo - More info to identify the node.
       */
      self.element.on('mouseup', '.leaf, .back button', function (e) {
        var leaf = $(this);
        var target = $(e.target);
        var hierarchy = leaf.closest('.hierarchy').data('hierarchy');
        var nodeData = leaf.data();
        var nodeId = $(this).attr('id');
        var targetInfo = { target: e.target, pageX: e.pageX, pageY: e.pageY };
        var isButton = target.is('button');
        var isNotBack = !target.hasClass('btn-back');
        var isBack = target.is('.btn-back');
        var svgHref = target.find('use').prop('href');
        var isCollapseButton = svgHref ? svgHref.baseVal === '#icon-caret-up' : false;
        var isExpandButton = svgHref ? svgHref.baseVal === '#icon-caret-down' : false;
        var isForward = svgHref ? svgHref.baseVal === '#icon-caret-right' : false;
        var isActions = target.hasClass('btn-actions');
        var isAction = target.is('a') && target.parent().parent().is('ul.popupmenu');
        var isAncestor = leaf.hasClass('ancestor');
        var eventType = 'selected';

        e.stopImmediatePropagation();

        if (isAction && $(target).parent().data('disabled')) {
          return;
        }

        $('.is-selected').removeClass('is-selected');
        $('#' + nodeId).addClass('is-selected');

        // Is collapse event
        if (isButton && isCollapseButton && isNotBack) {
          eventType = isAncestor ? 'back' : 'collapse';
        }

        // Is expand event
        if (isButton && isExpandButton && isNotBack) {
          eventType = 'expand';
        }

        if (isBack) {
          eventType = 'back';
        }

        if (isActions) {
          eventType = 'actions';
          hierarchy.buildActionsMenu(nodeData, leaf);
        }

        if (isAction) {
          eventType = 'action';
        }

        if (isButton && isForward && isNotBack) {
          eventType = 'forward';
        }

        // Is right click event
        if (e.which === 3) {
          eventType = 'rightClick';
        }

        if (!hierarchy) {
          return;
        }

        var eventInfo = {
          id: nodeId,
          data: nodeData,
          actionReference: isAction ? target.data('actionReference') : null,
          targetInfo: targetInfo,
          eventType: eventType,
          isForwardEvent: hierarchy.isForwardEvent(eventType),
          isBackEvent: hierarchy.isBackEvent(eventType),
          isAddEvent: hierarchy.isAddEvent(eventType),
          isExpandEvent: hierarchy.isExpandEvent(eventType),
          isCollapseEvent: hierarchy.isCollapseEvent(eventType),
          isSelectedEvent: hierarchy.isSelectedEvent(eventType),
          isActionsEvent: hierarchy.isActionsEvent(eventType),
          isActionEvent: hierarchy.isActionEvent(eventType),
          allowLazyLoad: hierarchy.allowLazyLoad(nodeData, eventType)
        };

        leaf.trigger('selected', eventInfo);
      });
    },


    /**
     * Manually set selection on a leaf
     * @public
     * @param {string} nodeId id used to find leaf
     */
    selectLeaf: function selectLeaf(nodeId) {
      var leaf = $('#' + nodeId);
      $('.is-selected').removeClass('is-selected');
      leaf.addClass('is-selected');

      var eventInfo = {
        data: leaf.data(),
        actionReference: null,
        isForwardEvent: false,
        isBackEvent: false,
        isAddEvent: false,
        isExpandEvent: false,
        isCollapseEvent: false,
        isSelectedEvent: true,
        isActionsEvent: false,
        isActionEvent: false,
        allowLazyLoad: false
      };

      leaf.trigger('selected', eventInfo);
    },


    /**
     * Update existing leaf actions with new actions
     * @public
     * @param {object} eventInfo eventType, target, data, ect..
     * @param {array} updatedActions -actions to be appended to the menu
     */
    updateActions: function updateActions(eventInfo, updatedActions) {
      var leaf = $(eventInfo.targetInfo.target).closest('.leaf');
      var nodeData = eventInfo.data;
      var popupMenu = $(leaf).find('.popupmenu');
      var lineItemsToRemove = popupMenu.find('li').not(':eq(0)');

      $(lineItemsToRemove).each(function (idx, item) {
        $(item).remove();
      });

      nodeData.menu.actions = updatedActions;
      popupMenu.append(this.getActionMenuItems(nodeData));
    },


    /**
     * @private
     * @param {object} data associated with leaf
     * @param {leaf} leaf jQuery reference in DOM
     */
    buildActionsMenu: function buildActionsMenu(data, leaf) {
      var popupMenu = $(leaf).find('.popupmenu');
      var template = [];

      // Safety
      if (data.menu === undefined) {
        return;
      }

      // Reset & rebuild
      popupMenu.empty();

      if (data.menu.details) {
        popupMenu.addClass('has-detail-fields');
        template.push('<li><div class="detail-fields">' + data.menu.details.map(function (v) {
          return '<div class="dt-fields-row"><div class="dt-fields-cell">' + v.key + '</div><div class="dt-fields-cell">' + v.value + '</div></div>';
        }).join('') + '</div></li>');
      }

      if (data.menu.actions) {
        template.push(this.getActionMenuItems(data));
      }

      template.forEach(function (i) {
        popupMenu.append(i);
      });
    },


    /**
     * @private
     * @param {object} data the data to be iterated
     * @returns {string} returns list items as a string
     */
    getActionMenuItems: function getActionMenuItems(data) {
      var actions = data.menu.actions.map(function (a) {
        if (a.disabled === undefined) {
          a.disabled = false;
        }

        return a;
      });

      // Ignoring next line. Eslint expects template literals vs string concat.
      // However template literals break JSON.stringify() in this case
      /* eslint-disable */
      return '' + actions.map(function (a) {
        return '\n      <li data-disabled=\'' + a.disabled + '\' class=\'' + (a.menu ? 'submenu' : '') + '\'>\n        <a href=\'' + a.url + '\' data-action-reference=\'' + JSON.stringify(a.data) + ('\'>\n          ' + a.value + '\n          ' + (a.menu ? '<svg class="arrow icon-dropdown icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-dropdown"></use></svg>' : '') + '\n        </a>\n        ' + (a.menu ? '<div class="wrapper" role="application" aria-hidden="true">\n          <ul class="popupmenu">\n            ' + a.menu.map(function (i) {
          return '\n            <li data-disabled=\'' + a.disabled + '\'>\n              <a href=\'' + a.url + '\' data-action-reference=\'' + JSON.stringify(a.data) + ('\'>' + i.value + '</a>\n            </li>');
        }).join('') + '\n          </ul>\n        </div>' : '') + '\n      </li>');
      }).join('');
      /* eslint-enable */
    },


    /**
     * Check if event is back
     * @private
     * @param {string} eventType is back
     * @returns {boolean} true if back event
     */
    isBackEvent: function isBackEvent(eventType) {
      return eventType === 'back';
    },


    /**
     * Check if event is forward
     * @private
     * @param {string} eventType is forward
     * @returns {boolean} true if forward event
     */
    isForwardEvent: function isForwardEvent(eventType) {
      return eventType === 'forward';
    },


    /**
     * Check if event is add
     * @private
     * @param {string} eventType is add
     * @returns {boolean} true if add event
     */
    isAddEvent: function isAddEvent(eventType) {
      return eventType === 'add';
    },


    /**
     * Check if event is expand
     * @private
     * @param {string} eventType is expand
     * @returns {boolean} true if expand event
     */
    isExpandEvent: function isExpandEvent(eventType) {
      return eventType === 'expand';
    },


    /**
     * Check if event is collapse
     * @private
     * @param {string} eventType is collapse
     * @returns {boolean} true if collapse event
     */
    isCollapseEvent: function isCollapseEvent(eventType) {
      return eventType === 'collapse';
    },


    /**
     * Check if event is selected
     * @private
     * @param {string} eventType is selected
     * @returns {boolean} true if selected event
     */
    isSelectedEvent: function isSelectedEvent(eventType) {
      return eventType === 'selected';
    },


    /**
     * Checks if is actions event
     * @private
     * @param {string} eventType is actions
     * @returns {boolean} true if actions event
     */
    isActionsEvent: function isActionsEvent(eventType) {
      return eventType === 'actions';
    },


    /**
     * @private
     * @param {string} evenType is action
     * @returns {boolean} true if action
     */
    isActionEvent: function isActionEvent(evenType) {
      return evenType === 'action';
    },


    /**
     * Check to see if lazy load is allowed
     * @private
     * @param {object} data contains info
     * @param {string} eventType is expand
     * @returns {boolean} true if lazy load is allowed
     */
    allowLazyLoad: function allowLazyLoad(data, eventType) {
      if (data === undefined || eventType === undefined) {
        return false;
      }
      return !data.isLoaded && !data.isLeaf && eventType === 'expand';
    },


    /**
     * Process data attached through jquery data
     * @private
     * @param {string} nodeId .
     * @param {string} currentDataObject .
     * @param {string} newDataObject .
     * @param {string} params .
     * @returns {object} data
     */
    data: function data(nodeId, currentDataObject, newDataObject, params) {
      /* eslint-disable no-use-before-define */
      if (params === undefined) {
        params = {};
      }

      var s = this.settings;
      var obj = currentDataObject.isRootNode ? currentDataObject : currentDataObject[0];
      var nodeData = [];

      if (s.newData.length > 0) {
        s.newData = [];
      }

      function addChildrenToObject(thisObj, thisParams) {
        if (thisParams.insert) {
          delete thisObj.isLeaf;
          thisObj.isExpanded = true;
        }
        if (newDataObject.length !== 0 && thisParams.insert) {
          thisObj.children = [newDataObject];
        } else {
          thisObj.children = newDataObject;
        }
      }

      function checkForChildren(self, thisObj, thisNewDataObject) {
        Object.keys(thisObj).forEach(function (prop) {
          if (prop === 'id' && nodeId === thisObj.id) {
            if (!thisObj.isLoaded && !thisObj.isRootNode) {
              addChildrenToObject(thisObj, params);
            }
            nodeData.push(thisObj);
          }
        });
        if (thisObj.children) {
          processData(self, thisObj.children, thisNewDataObject); // eslint-disable-line
        }
      }

      function processData(self, thisObj, thisNewDataObject) {
        if (thisObj.length === undefined) {
          checkForChildren(self, thisObj, thisNewDataObject);
        } else {
          for (var i = 0, l = thisObj.length; i < l; i++) {
            checkForChildren(self, thisObj[i], thisNewDataObject);
          }
        }
      }

      if (newDataObject !== undefined) {
        processData(this, obj, newDataObject);
      }

      if (nodeData.length !== 0) {
        $('#' + nodeData[0].id).data(nodeData[0]);
      }

      return nodeData[0];
      /* eslint-enable no-use-before-define */
    },


    /**
     * Add data as children for the given nodeId.
     * @private
     * @param {string} nodeId .
     * @param {object} currentDataObject info
     * @param {object} newDataObject .
     * @returns {void}
     */
    add: function add(nodeId, currentDataObject, newDataObject) {
      var s = this.settings;
      var id = currentDataObject.id !== undefined ? currentDataObject.id : nodeId;
      var node = $('#' + id);
      var parentContainer = node.parent().hasClass('leaf-container') ? node.parent().parent() : node.parent();
      var selectorObject = {};
      var isSubLevelChild = parentContainer.parent().attr('class') !== 'sub-level';
      var subListExists = parentContainer.children('.sublist').length === 1;

      if (isSubLevelChild) {
        if (subListExists) {
          selectorObject.element = parentContainer.children('.sublist');
        } else {
          selectorObject.el = parentContainer.append('<ul class=\'sublist\'></ul>');
          selectorObject.element = $(selectorObject.el).find('.sublist');
        }
      } else {
        selectorObject.el = parentContainer.children('ul');
        selectorObject.element = $(selectorObject.el);
      }

      if (selectorObject.element.length === 0) {
        selectorObject.el = parentContainer.append('<ul></ul>');
        selectorObject.element = $(selectorObject.el).find('ul');
      }

      if (!currentDataObject.isRootNode) {
        for (var i = 0, l = newDataObject.length; i < l; i++) {
          s.newData.push(newDataObject[i]);
        }
        this.createLeaf(newDataObject, selectorObject.element);
      }

      this.updateState(node, false, null, 'add');
    },


    /**
     * Closes popupmenu
     * @private
     * @param {object} node leaf containing btn-actions
     */
    closePopupMenu: function closePopupMenu(node) {
      var actionButton = node.find('.btn-actions');

      if (actionButton.length !== 0) {
        actionButton.data('popupmenu').close();
      }
    },


    /**
     * Expand the nodes until nodeId is displayed on the page.
     * @private
     * @param {object} event .
     * @param {object} nodeData info
     * @param {object} domObject .
     * @returns {void}
     */
    expand: function expand(event, nodeData, domObject) {
      var s = this.settings;
      var node = domObject.leaf;
      var nodeTopLevel = node.next();

      // close popupmenu if open
      this.closePopupMenu(node);

      nodeTopLevel.animateOpen();
      /**
       * Fires when leaf expanded.
       *
       * @event expanded
       * @memberof Hierarchy
       * @type {object}
       * @param {object} event - The jquery event object
       * @param {array} args [nodeData, dataset]
       */
      this.element.trigger('expanded', [nodeData, s.dataset]);

      if (node.hasClass('root')) {
        nodeTopLevel = nodeTopLevel.next('ul');
        nodeTopLevel.animateOpen();
      }

      node.parent().removeClass('branch-collapsed').addClass('branch-expanded');
      this.updateState(node, false, null, 'expand');
    },


    /**
     * Collapse the passed in nodeId.
     * @private
     * @param {object} event .
     * @param {object} nodeData info
     * @param {object} domObject .
     * @returns {void}
     */
    collapse: function collapse(event, nodeData, domObject) {
      var _this2 = this;

      var s = this.settings;
      var node = domObject.leaf;
      var nodeTopLevel = node.next();

      // close popupmenu if open
      this.closePopupMenu(node);

      nodeTopLevel.animateClosed().on('animateclosedcomplete', function () {
        /**
         * Fires when leaf collapsed.
         *
         * @event collapsed
         * @memberof Hierarchy
         * @type {object}
         * @param {object} event - The jquery event object
         * @param {array} args [nodeData, dataset]
         */
        _this2.element.trigger('collapsed', [nodeData, s.dataset]);
      });

      if (node.hasClass('root')) {
        nodeTopLevel = nodeTopLevel.next('ul');
        nodeTopLevel.animateClosed();
      }

      node.parent().removeClass('branch-expanded').addClass('branch-collapsed');
      this.updateState(node, false, null, 'collapse');
    },


    /**
     * Main render method
     * @private
     * @param {object} data info.
     * @returns {void}
     */
    render: function render(data) {
      var _this3 = this;

      /* eslint-disable no-use-before-define */
      var s = this.settings;
      var thisLegend = s.legend;
      var thisChildren = data.children;
      var rootNodeHTML = [];
      var structure = {
        legend: '<legend><ul></ul></legend>',
        chart: '<ul class="container"><li class="chart"></li></ul>',
        toplevel: s.paging ? '<ul class="child-nodes"></ul>' : '<ul class="top-level"></ul>',
        sublevel: s.paging ? '' : '<ul class="sub-level"></ul>'
      };

      var chartContainer = this.element.append(structure.chart);
      var chart = $('.chart', chartContainer);

      if (thisLegend.length !== 0) {
        this.element.prepend(structure.legend);
        var element = $('legend', chartContainer);
        this.createLegend(element);
      }

      // check to see how many children are not leafs and have children
      if (this.isSingleChildWithChildren()) {
        $(chart).addClass('has-single-child');
      }

      // Create root node
      this.setColor(data);

      if (s.paging && data.parentDataSet) {
        var backMarkup = '' + '<div class="back">' + '<button type="button" class="btn-icon hide-focus btn-back">' + '<svg class="icon" focusable="false" aria-hidden="true" role="presentation">' + '<use xlink:href="#icon-caret-left"></use>' + '</svg>' + '<span>Back</span>' + '</button>' + '</div>';

        // Append back button to chart to go back to view previous level
        var backButton = $(backMarkup).appendTo(chart);

        // Wrap back button and leaf after leaf has been rendered
        setTimeout(function () {
          return backButton.next($('.leaf')).addBack($('.back')).wrapAll('<div class="back-container"></div>');
        });

        // Attach data reference to back button
        backButton.children('button').data(data);

        // Class used to adjust heights and account for back button
        $(chart).addClass('has-back');
      }

      if (data.isMultiRoot) {
        var multiRootHTML = '<div class="leaf multiRoot"><div><h2>' + data.multiRootText + '</h2></div></div>';
        multiRootHTML = xssUtils.sanitizeHTML(multiRootHTML);
        rootNodeHTML.push(multiRootHTML);
        $(rootNodeHTML[0]).addClass('root').appendTo(chart);
      } else if (data.ancestorPath !== null && data.ancestorPath !== undefined) {
        data.ancestorPath.push(data.centeredNode);
        var ancestorHTML = '' + data.ancestorPath.map(function (a) {
          return ' ' + _this3.getTemplate(a) + ' ';
        }).join('');
        ancestorHTML = xssUtils.sanitizeHTML(ancestorHTML);
        rootNodeHTML.push(ancestorHTML);
        $(rootNodeHTML[0]).addClass('root ancestor').appendTo(chart);

        var roots = $('.leaf.root');

        roots.each(function (index, root) {
          _this3.updateState(root, false, data.ancestorPath[index], 'add');

          if (index === roots.length - 1) {
            $(root).addClass('is-selected');
          }
        });
      } else {
        var centeredNode = data.centeredNode;
        var leaf = void 0;

        if (this.isStackedLayout() && centeredNode !== null) {
          leaf = this.getTemplate(centeredNode);
        } else if (!this.isStackedLayout()) {
          leaf = this.getTemplate(data);
        }

        if (leaf) {
          leaf = xssUtils.sanitizeHTML(leaf);
          rootNodeHTML.push(leaf);
          $(rootNodeHTML[0]).addClass('root is-selected').appendTo(chart);
        }

        if (centeredNode && centeredNode !== null) {
          this.updateState($('.leaf.root'), true, centeredNode, undefined);
        } else {
          this.updateState($('.leaf.root'), true, data, undefined);
        }
      }

      function renderSubChildren(self, subArray, thisData) {
        if (subArray !== null && subArray !== undefined) {
          for (var i = 0, l = subArray.length; i < l; i++) {
            var obj = subArray[i];
            subArrayChildren(self, obj, thisData); // eslint-disable-line
          }
        }
      }

      // Create children nodes
      if (thisChildren && thisChildren.length > 0) {
        for (var i = 0, l = thisChildren.length; i < l; i++) {
          var childObject = data.children[i].children;

          // If child has no children then render the element in the top level
          // If paging then render all children in the top level
          // If not paging and child has children then render in the sub level
          if (this.isLeaf(thisChildren[i]) && !s.paging && s.renderSubLevel) {
            this.createLeaf(data.children[i], $(structure.toplevel));
          } else if (s.paging) {
            this.createLeaf(data.children[i], $(structure.toplevel));
          } else {
            this.createLeaf(data.children[i], $(structure.sublevel));
          }

          if (childObject !== undefined && childObject !== null) {
            var subArray = data.children[i].children;
            var self = this;
            renderSubChildren(self, subArray, data);
          }
        }
      }

      function subArrayChildren(self, obj, thisData) {
        Object.keys(obj).forEach(function (prop) {
          if (prop === 'children') {
            var nodeId = obj.id;
            var currentDataObject = obj;
            var newDataObject = obj.children;

            if (newDataObject !== null && newDataObject !== undefined) {
              if (newDataObject.length > 0) {
                self.add(nodeId, currentDataObject, newDataObject);
              }
            }
            return renderSubChildren(self, newDataObject, thisData);
          }
          return true;
        });
      }

      var containerWidth = this.element.find('.container').outerWidth();
      var windowWidth = $(window).width();
      var center = (containerWidth - windowWidth) / 2;
      this.element.scrollLeft(center);

      // Add a no-sublevel class if only two levels (to remove extra border)
      var topLevel = this.element.find('.top-level');
      if (this.element.find('.sub-level').length === 0 && topLevel.length === 1) {
        topLevel.addClass('no-sublevel');
      }

      /* eslint-enable no-use-before-define */
    },


    /**
     * @private
     * @returns {boolean} true if stacked layout
     */
    isStackedLayout: function isStackedLayout() {
      return this.settings.layout && this.settings.layout === 'stacked';
    },


    /**
     * Checks to see if children have children
     * @private
     * @returns {boolean} true if have children
     */
    isSingleChildWithChildren: function isSingleChildWithChildren() {
      if (this.isStackedLayout()) {
        return false;
      }

      var s = this.settings;
      if (s.dataset && s.dataset[0] && s.dataset[0].children) {
        var i = s.dataset[0].children.length;
        var count = 0;

        while (i--) {
          if (!s.dataset[0].children[i].isLeaf) {
            count++;
          }
        }

        return count === 1;
      }
      return false;
    },


    /**
     * Builds leaf template
     * @private
     * @param {object} data leaf data
     * @returns {string} compiled template as HTML string
     */
    getTemplate: function getTemplate(data) {
      var template = Tmpl.compile('{{#dataset}}' + $('#' + xssUtils.stripTags(this.settings.templateId)).html() + '{{/dataset}}', { dataset: data });

      // Init popupmenu after rendered in DOM
      setTimeout(function () {
        var actionButton = $('#btn-' + xssUtils.stripTags(data.id));
        if (actionButton.length !== 0) {
          actionButton.hideFocus().popupmenu();
        }
      }, 1);

      return $(template).prop('outerHTML');
    },


    /**
     * Add the legend from the Settings
     * @private
     * @param {object} element .
     * @returns {void}
     */
    createLegend: function createLegend(element) {
      var s = this.settings;
      var mod = 4;
      var index = 0;

      for (var i = 0, l = s.legend.length; i < l; i++) {
        var thislabel = s.legend[i].label;
        var color = s.colorClass[i];

        if (i - 1 % mod + 1 === mod) {
          element.append('<ul></ul>');
          index++;
        }

        element.children('ul').eq(index).append('' + ('<li>\n          <span>' + thislabel + '</span>\n          <span class="key ' + color + '"></span>\n        </li>'));
      }
    },


    /**
     * Creates a leaf node under element for nodeData
     * @private
     * @param {object} nodeData contains info.
     * @param {object} container .
     * @returns {void}
     */
    createLeaf: function createLeaf(nodeData, container) {
      var self = this;
      var chartClassName = self.settings.rootClass;
      var chart = $('.' + chartClassName + ' .chart', self.container);
      var elClassName = container.attr('class');
      var el = elClassName !== undefined ? $('.' + elClassName) : container;

      if (el.length < 1) {
        if (elClassName === 'top-level') {
          container.insertAfter('.root');
        } else {
          container.appendTo(chart);
        }
      }

      function processDataForLeaf(thisNodeData) {
        self.setColor(thisNodeData);

        var leaf = self.getTemplate(thisNodeData);
        var parent = el.length === 1 ? el : container;
        var branchState = thisNodeData.isExpanded || thisNodeData.isExpanded === undefined ? 'branch-expanded' : 'branch-collapsed';

        if (thisNodeData.isLeaf) {
          branchState = '';
        }

        if ($('#' + thisNodeData.id).length === 1) {
          return;
        }

        parent.append('<li class=' + branchState + '>' + $(leaf)[0].outerHTML + '</li>');

        if (thisNodeData.children) {
          var childrenNodes = '';

          for (var j = 0, l = thisNodeData.children.length; j < l; j++) {
            self.setColor(thisNodeData.children[j]);
            var childLeaf = self.getTemplate(thisNodeData.children[j]);

            if (j === thisNodeData.children.length - 1) {
              childrenNodes += '<li>' + $(childLeaf)[0].outerHTML + '</li>';
            } else {
              childrenNodes += '<li>' + $(childLeaf)[0].outerHTML + '</li>';
            }
          }

          parent = $('#' + xssUtils.stripTags(thisNodeData.id)).parent();
          parent.append('<ul>' + childrenNodes + '</ul>');

          var childLength = thisNodeData.children.length;
          while (childLength--) {
            var lf = $('#' + xssUtils.stripTags(thisNodeData.children[childLength].id));
            self.updateState(lf, false, thisNodeData.children[childLength], undefined);
          }
        }
      }

      if (nodeData.length) {
        for (var i = 0, l = nodeData.length; i < l; i++) {
          var isLast = i === nodeData.length - 1;
          processDataForLeaf(nodeData[i], isLast);
          self.updateState($('#' + xssUtils.stripTags(nodeData[i].id)), false, nodeData[i], undefined);
        }
      } else {
        processDataForLeaf(nodeData, true);
        self.updateState($('#' + xssUtils.stripTags(nodeData.id)), false, nodeData, undefined);
      }
    },


    /**
     * Set leaf colors matching data to key in legend
     * @private
     * @param {object} data contains info.
     * @returns {void}
     */
    setColor: function setColor(data) {
      var _this4 = this;

      var s = this.settings;
      this.setRootColor(data);

      if (this.isStackedLayout()) {
        if (data.ancestorPath && data.ancestorPath !== null) {
          data.ancestorPath.forEach(function (d) {
            _this4.setRootColor(d);
          });
        }

        if (data.centeredNode && data.centeredNode !== null) {
          this.setRootColor(data.centeredNode);
        }
      }

      if (data.children && !data.isRootNode) {
        for (var k = 0, ln = data.children.length; k < ln; k++) {
          for (var j = 0, x = s.legend.length; j < x; j++) {
            if (data.children[k][s.legendKey] === s.legend[j].value) {
              data.children[k].colorClass = s.colorClass[j];
            }
          }
        }
      }
    },


    /**
     * Set the color of the root element.
     * @private
     * @param {object} data  The data object to use.
     */
    setRootColor: function setRootColor(data) {
      var s = this.settings;
      for (var i = 0, l = s.legend.length; i < l; i++) {
        if (data[s.legendKey] === s.legend[i].value) {
          data.colorClass = s.colorClass[i];
          break;
        } else if (data[s.legendKey] === '') {
          data.colorClass = 'default-color';
        }
      }
    },


    /**
     * Check to see if particular node is a leaf
     * @private
     * @param {object} dataNode contains data info
     * @returns {boolean} whether or not a particular node is a leaf
     */
    isLeaf: function isLeaf(dataNode) {
      var s = this.settings;
      if (dataNode.isLeaf) {
        return dataNode.isLeaf;
      }

      if (s.beforeExpand) {
        return dataNode.isLeaf;
      }

      // Node is not a leaf and should display and expand/collapse icon
      if (dataNode.children && dataNode.children.length > 0) {
        return false;
      }

      return true;
    },


    /**
     * Handle all leaf state here,
     * get the current state via .data() and re-attach the new state
     * @private
     * @param {string} leaf .
     * @param {boolean} isRoot .
     * @param {object} nodeData .
     * @param {string} eventType .
     * @returns {void}
     */
    updateState: function updateState(leaf, isRoot, nodeData, eventType) {
      // set data if it has not been set already
      if ($.isEmptyObject($(leaf).data()) && nodeData) {
        var d = nodeData === undefined ? {} : nodeData;
        $(leaf).data(d);
      }

      var s = this.settings;
      var btn = $(leaf).find('.btn');
      var expandCaret = s.paging ? 'caret-right' : 'caret-up';
      var data = $(leaf).data();

      if (data === undefined && nodeData !== undefined) {
        data = nodeData;
      }

      // data has been loaded if it has children
      if (data.children && data.children.length !== 0 || eventType === 'add') {
        data.isExpanded = true;
        data.isLoaded = true;
      }

      if (isRoot) {
        data.isRootNode = true;
        data.isLoaded = true;
      }

      if (data.isExpanded === undefined && data.children || eventType === 'expand') {
        data.isExpanded = true;
      }

      // defaults to collapsed state
      if (data.isExpanded === undefined || eventType === 'collapse') {
        data.isExpanded = false;
      }

      if (data.isExpanded) {
        btn.find('svg.icon').changeIcon(expandCaret);
        btn.addClass('btn-expand').removeClass('btn-collapse');
      } else {
        btn.find('svg.icon').changeIcon('caret-down');
        btn.addClass('btn-collapse').removeClass('btn-expand');
      }

      if (data.isLeaf || data.isRootNode) {
        btn.addClass('btn-hidden');
      }

      if (data.isLeaf) {
        data.isLoaded = false;
        data.isExpanded = false;
      }

      // Keep reference of the parent dataset for paging
      if (this.settings.layout === 'paging' || this.settings.paging) {
        data.parentDataSet = s.dataset;
      }

      // Reset data
      $(leaf).data(data);
    },


    /**
     * Reloads hierarchy control with new dataset
     * @private
     * @param {object} options hierarchy
     * @returns {void}
     */
    reload: function reload(options) {
      this.destroy();
      this.element.hierarchy(options);
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {void}
     */
    unbind: function unbind() {
      this.element.empty();
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, HIERARCHY_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Removes the component from existence
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      this.element.removeData(COMPONENT_NAME$D);
    }
  };

  /**
   * jQuery Component Wrapper for Hierarchy
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.hierarchy = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$D);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$D, new Hierarchy(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$E = 'fieldfilter';

  /**
   * Ability to have a dropdown next to the field.
   *
   * @class FieldFilter
   * @constructor
   *
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {array} [settings.dataset]  Array of data
   * @param {object} [settings.dropdownOpts]  Gets passed to this control's dropdown
   * @param {string} [settings.template] An Html String with the mustache template for the view.
   */
  var FIELDFILTER_DEFAULTS = {
    dataset: [],
    dropdownOpts: {}, // Dropdown custom settings
    template: '' + ('<label>' + Locale.translate('FieldFilter') + '</label>\n    <select class="dropdown no-init field-filter-dropdown">\n      {{#dataset}}\n        <option\n          {{#value}} value="{{value}}"{{/value}}\n          {{#selected}} selected{{/selected}}\n          {{#disabled}} class="is-disabled" disabled{{/disabled}}\n          {{#icon}} data-icon="{{icon}}"{{/icon}}\n        >{{text}}</option>\n      {{/dataset}}\n    </select>')
  };
  function FieldFilter(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, FIELDFILTER_DEFAULTS);
    this.init();
  }

  // FieldFilter Methods
  FieldFilter.prototype = {
    init: function init() {
      this.render();
      this.handleEvents();
      this.setFiltered();
    },


    /**
     * Render the template against the dataset.
     * @private
     * @param {array} dataset  The dataset to use
     * @returns {void}
     */
    render: function render(dataset) {
      var s = this.settings;
      dataset = dataset || s.dataset;
      // Render "mustache" Template
      if ((typeof Tmpl === 'undefined' ? 'undefined' : _typeof(Tmpl)) === 'object' && dataset && s.template) {
        // create a copy of an inlined template
        if (s.template instanceof $) {
          s.template = '' + s.template.html();
        } else if (typeof s.template === 'string') {
          // If a string doesn't contain HTML elments,
          // assume it's an element ID string and attempt to select with jQuery
          if (!stringUtils.containsHTML(s.template)) {
            s.template = $('#' + s.template).html();
          }
        }

        var renderedTmpl = Tmpl.compile(s.template, { dataset: !s.dropdownOpts.source ? dataset : [] }); // eslint-disable-line
        var emptyTmpl = '' + ('<label for="ffdropdown-empty" class="audible">\n          ' + Locale.translate('FieldFilter') + '\n        </label>\n        <select id="ffdropdown-empty" name="ffdropdown-empty" class="dropdown no-init field-filter-dropdown"></select>');

        if (dataset.length > 0) {
          this.element.before(renderedTmpl);
        } else if (dataset.length === 0) {
          this.element.before(renderedTmpl || emptyTmpl);
        }

        // Set element id
        var id = this.element.attr('id') || this.element.attr('name');
        if (typeof id === 'undefined') {
          id = utils.uniqueId(this.element, 'fieldfilter-');
          this.element[0].setAttribute('id', id);
        }
        var ffId = id + '-ff';

        // Set Field
        this.field = this.element.closest('.field');

        // RTL list x-position
        var isRTL = Locale.isRTL();
        s.dropdownOpts = s.dropdownOpts || {};
        if (isRTL && _typeof(s.dropdownOpts) === 'object') {
          if (s.dropdownOpts.placementOpts) {
            s.dropdownOpts.placementOpts.x = this.element.outerWidth();
          } else {
            s.dropdownOpts.placementOpts = { x: this.element.outerWidth() };
          }
        }

        // Set Dropdown
        s.dropdownOpts.cssClass = s.dropdownOpts.cssClass ? s.dropdownOpts.cssClass + ' ffdropdown' : 'ffdropdown';
        s.dropdownOpts.noSearch = true;

        // Find the field filter dropdown
        this.ffdropdown = this.field.find('select.dropdown.field-filter-dropdown');
        this.ffdropdown.dropdown(s.dropdownOpts).prev('label').addClass('audible');

        this.ffdropdown[0].setAttribute('id', ffId);
        this.ffdropdown[0].setAttribute('name', ffId);
        this.ffdropdown.prev('label')[0].setAttribute('for', ffId);

        // Add css classes
        this.field.addClass('fieldfilter-wrapper').find('div.dropdown.field-filter-dropdown span').addClass('audible');

        // Dropdown api
        this.ddApi = this.ffdropdown.data('dropdown');
        if (this.ddApi && this.ddApi.icon) {
          this.ddApi.icon.addClass('ffdropdown-icon');
        }
      }
    },


    /**
     * Set currently filtered item
     * @private
     * @returns {object} The api
     */
    setFiltered: function setFiltered() {
      if (this.ddApi) {
        var item = this.ddApi.element.find('option:selected');
        this.filtered = this.getTriggerData(item);
      }
      return this;
    },


    /**
     * Get currently triggerData for given item args
     * @private
     * @param {object} args selected item.
     * @returns {object} The api
     */
    getTriggerData: function getTriggerData(args) {
      var s = this.settings;
      var dataset = s.dropdownOpts.source && this.ddApi ? this.ddApi.dataset : s.dataset;
      return { idx: args.index(), item: args, data: dataset[args.index()] };
    },


    /**
     * Get current filter type
     * @returns {object} The current filter type
     */
    getFilterType: function getFilterType() {
      this.setFiltered();
      return this.filtered;
    },


    /**
     * Set filter type to given value
     * @param {number|string} value to be set, index or value.
     * @returns {void}
     */
    setFilterType: function setFilterType(value) {
      if (this.ddApi) {
        var newIdx = -1;
        var s = this.settings;
        var dataset = s.dropdownOpts.source && this.ddApi ? this.ddApi.dataset : s.dataset;

        if (typeof value === 'number' && value > -1 && value < dataset.length) {
          newIdx = value;
        } else if (typeof value === 'string') {
          var option = this.ffdropdown.find('option[value="' + value + '"]');
          if (!option.length) {
            option = this.ffdropdown.find('option').filter(function () {
              return $(this).text() === value;
            });
          }
          if (option.length) {
            newIdx = option.index();
          }
        }

        // Make filtered
        if (newIdx !== -1 && newIdx !== this.ffdropdown[0].selectedIndex) {
          this.ffdropdown[0].selectedIndex = newIdx;
          this.ddApi.updated();
          this.ffdropdown.triggerHandler('change');
          this.setFiltered();
          this.element.triggerHandler('filtered', [this.filtered]);
        }
      }
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {object} The api
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.ffdropdown.on('listopened.' + COMPONENT_NAME$E, function () {
        // drowpdownWidth - border (52)
        $('#dropdown-list ul').width(_this.element.outerWidth() + 52);
      }).on('selected.' + COMPONENT_NAME$E, function (e, args) {
        /**
         * Fires after the value in the dropdown is selected.
         * @event filtered
         * @memberof FieldFilter
         * @property {object} event The jquery event object.
         * @property {object} data for selected item.
         */
        var triggerData = _this.getTriggerData(args);
        _this.element.triggerHandler('filtered', [triggerData]);
      });

      return this;
    },
    // END: Handle Events -------------------------------------------------

    /**
     * Set component to readonly.
     * @returns {object} The api
     */
    readonly: function readonly() {
      this.ffdropdown.readonly();
      return this;
    },


    /**
     * Set component to enabled.
     * @returns {object} The api
     */
    enable: function enable() {
      this.ffdropdown.enable();
      return this;
    },


    /**
     * Set component to disabled.
     * @returns {object} The api
     */
    disable: function disable() {
      this.ffdropdown.disable();
      return this;
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.ffdropdown.off('.' + COMPONENT_NAME$E);

      // Remove Dropdown
      if (this.ddApi && typeof this.ddApi.destroy === 'function') {
        this.ddApi.destroy();
      }
      this.ffdropdown.add(this.ffdropdown.prev('label')).remove();

      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element[0], settings, FIELDFILTER_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Teardown process for this plugin
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$E);
    }
  };

  /**
   * jQuery Component Wrapper for FieldFilter
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.fieldfilter = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$E);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$E, new FieldFilter(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$F = 'fieldoptions';

  /**
  * A control bind next to another component to add some extra functionality.
  * @class FieldOptions
  * @constructor
  *
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  */
  var FIELDOPTIONS_DEFAULTS = {};

  function FieldOptions(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, FIELDOPTIONS_DEFAULTS);
    this.init();
  }

  // FieldOptions Methods
  FieldOptions.prototype = {
    init: function init() {
      this.setElements();
      this.handleEvents();
    },


    /**
     * Set all elements used by the Control
     * @private
     * @returns {object} The api
     */
    setElements: function setElements() {
      var _this = this;

      this.isFirefox = Environment.browser.name === 'firefox';
      this.isSafari = Environment.browser.name === 'safari';

      this.field = this.element.closest('.field, .radio-group');
      this.targetElem = this.element;

      var label = this.field.find('label');
      if (label) {
        this.label = label;
      }

      // In some cases, adjust the target element
      if (this.element[0].className.match(/(dropdown|multiselect)/)) {
        this.targetElem = this.element.data('dropdown').pseudoElem;
      }
      if (this.element[0].className.match(/(fileupload)/)) {
        this.targetElem = this.field.find('.fileupload[type="text"]');
      }

      this.field.addClass('is-fieldoptions');

      this.fieldParent = this.element.closest('.field').parent();
      this.trigger = this.field.find('.btn-actions');

      // Fix: Some reason firfox "event.relatedTarget" not working
      // with un-focusable elements(ie.. div) on focusout, use "contentEditable"
      // https://stackoverflow.com/a/43010274
      if (this.isFirefox && this.trigger.length) {
        this.trigger[0].contentEditable = true;
        this.trigger.on('keydown.' + COMPONENT_NAME$F, function (e) {
          var key = e.which || e.keyCode || e.charCode || 0;
          if (key !== 9) {
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }

      // Adjust some setting for popupmenu this trigger(action button)
      setTimeout(function () {
        _this.popupmenuApi = _this.trigger.data('popupmenu');
        if (_this.popupmenuApi) {
          _this.popupmenuApi.settings.returnFocus = false;
          _this.popupmenuApi.settings.offset.y = 10;
        }
      }, 100);

      return this;
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {object} The api
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      var self = this;
      var datepicker = this.element.data('datepicker');
      var timepicker = this.element.data('timepicker');
      var dropdown = this.element.data('dropdown');
      var lookup = this.element.data('lookup') || this.element.hasClass('lookup');
      var isCheckbox = this.element.is('.checkbox');
      var isFileupload = this.element.is('.fileupload');
      var isSearchfield = this.element.is('.searchfield');
      var isColorpicker = this.element.is('.colorpicker');
      var isRadio = this.element.closest('.radio-group').length > 0;
      var isFieldset = this.element.is('.data') && this.element.closest('.summary-form').length > 0;

      // Helper functions
      var isFocus = function isFocus(elem) {
        return $(':focus').is(elem);
      };
      var addFocused = function addFocused(elem) {
        (elem || _this2.element).addClass('is-focused');
      };
      var removeFocused = function removeFocused(elem) {
        (elem || _this2.element).removeClass('is-focused');
      };
      var canActive = function canActive() {
        var r = isFocus(_this2.element);
        r = datepicker && datepicker.isOpen() ? false : r;
        r = timepicker && timepicker.isOpen() ? false : r;
        r = dropdown && dropdown.isOpen() ? false : r;
        return r;
      };
      var doActive = function doActive() {
        self.element.add(self.trigger).add(self.field).add(self.fieldParent).addClass('is-active');
      };
      var doUnactive = function doUnactive() {
        self.element.add(self.trigger).add(self.field).add(self.fieldParent).removeClass('is-active');
      };
      var canUnactive = function canUnactive(e) {
        var r = !isFocus(_this2.element);
        r = _this2.trigger.is(e.relatedTarget) ? false : r;
        r = _this2.trigger.is('.is-open') ? false : r;
        r = datepicker && datepicker.isOpen() ? false : r;
        r = timepicker && timepicker.isOpen() ? false : r;
        r = $(e.relatedTarget).prev().is(_this2.element) ? false : r;
        r = dropdown && dropdown.isOpen() ? false : r;
        r = lookup && lookup.modal && lookup.modal.isOpen() ? false : r;
        r = isColorpicker && _this2.element.is('.is-open') ? false : r;
        return r;
      };
      var onPopupToggle = function onPopupToggle(elem) {
        if (elem.trigger) {
          elem.trigger.off('show.' + COMPONENT_NAME$F).on('show.' + COMPONENT_NAME$F, function () {
            doActive();
          }).off('hide.' + COMPONENT_NAME$F).on('hide.' + COMPONENT_NAME$F, function (e) {
            if (canUnactive(e)) {
              doUnactive();
              _this2.element.removeClass('is-open');
            }
          });
        }
      };
      var getTriggerTopVal = function getTriggerTopVal() {
        var height = _this2.element.height();
        var returns = void 0;

        if (isFieldset) {
          var lineHeight = parseInt(_this2.element.css('line-height'), 10);
          if (height > lineHeight) {
            _this2.element.css({ 'margin-bottom': '', 'padding-bottom': '' });
            returns = (height - lineHeight) / 2 * -1;
          } else {
            _this2.element.css({ 'margin-bottom': '8px', 'padding-bottom': '12px' });
            returns = 6;
          }
        } else if (isRadio) {
          returns = (height - _this2.trigger.height()) / 2 * -1;
        }
        return returns;
      };
      var setTriggerCssTop = function setTriggerCssTop() {
        _this2.trigger.css({ top: getTriggerTopVal() + 'px' });
      };

      // Set field-options visibility.
      // In touch environments, the button should always be visible.
      // In desktop environments, the button should only display when the field is in use.
      if (Environment.features.touch) {
        this.field.addClass('visible');
        this.trigger.on('beforeopen.' + COMPONENT_NAME$F, function (e) {
          if (!canActive(e)) {
            return;
          }
          doActive();
        }).on('close.' + COMPONENT_NAME$F, function (e) {
          if (!canUnactive(e)) {
            return;
          }
          doUnactive();
        });
      } else {
        this.field.removeClass('visible');
        this.field.on('mouseover.' + COMPONENT_NAME$F, function () {
          if (self.element.prop('disabled') || self.element.closest('is-disabled').length) {
            return;
          }

          if (self.field[0].className.indexOf('visible') < 0) {
            self.field[0].classList.add('visible');
          }
        }).on('mouseout.' + COMPONENT_NAME$F, function () {
          if (self.field[0].className.indexOf('visible') > -1) {
            self.field[0].classList.remove('visible');
          }
        });
      }

      // Adjust stack order for dropdown
      if (dropdown) {
        setTimeout(function () {
          var popupmenu = _this2.trigger.data('popupmenu');
          if (popupmenu) {
            popupmenu.menu.closest('.popupmenu-wrapper').css({ 'z-index': '4502' });
          }
        }, 0);
      }
      // Bind active/unactive on show datepicker or timepicker
      if (datepicker || timepicker) {
        if (datepicker) {
          onPopupToggle(datepicker);
        } else {
          onPopupToggle(timepicker);
        }
      }
      // Adjust return focus for timepicker
      if (timepicker) {
        timepicker.settings.returnFocus = false;
      }
      // Move trigger(action-button) in to lookup-wrapper
      if (lookup || isColorpicker) {
        this.field.on('click.' + COMPONENT_NAME$F, '.lookup-wrapper .trigger, .colorpicker-container .trigger', function () {
          doActive();
        });

        if (isColorpicker) {
          this.element.on('beforeopen.' + COMPONENT_NAME$F, function () {
            doActive();
          });
        }
      }
      // Checkbox add parent css class
      if (isCheckbox) {
        this.trigger.addClass('is-checkbox');
      }
      // Bind fileupload events
      if (isFileupload) {
        this.element.on('change.' + COMPONENT_NAME$F, function () {
          _this2.targetElem.focus();
        });
        this.field.on('click.' + COMPONENT_NAME$F, '.trigger, .trigger-close', function () {
          doActive();
        });
      }
      // Move trigger(action-button) in to searchfield-wrapper
      if (isSearchfield) {
        setTimeout(function () {
          _this2.trigger.add(_this2.trigger.next('.popupmenu')).appendTo(_this2.element.closest('.searchfield-wrapper'));
        }, 0);
      }
      // Fieldset - set trigger(action-button) top value and bind events
      if (isFieldset) {
        setTriggerCssTop();
        this.targetElem.add(this.trigger).on('keydown.' + COMPONENT_NAME$F, function (e) {
          var key = e.which || e.keyCode || e.charCode || 0;
          if (key === 13) {
            setTimeout(function () {
              doActive();
            }, 0);
          }
        });
        this.targetElem.attr('tabindex', 0).on('click.' + COMPONENT_NAME$F, function () {
          doActive();
        });
        $(document).on('click.' + COMPONENT_NAME$F, function (e) {
          if (!$(e.target).is(_this2.element)) {
            doUnactive();
          }
        });
        $('body').on('resize.' + COMPONENT_NAME$F, function () {
          setTriggerCssTop();
        });
      }
      // Radio group - set trigger(action-button) top value and bind events
      if (isRadio) {
        setTriggerCssTop();
        this.element.on('focusin.' + COMPONENT_NAME$F, '.radio', function () {
          var delay = _this2.isSafari ? 200 : 0;
          addFocused();
          setTimeout(function () {
            doActive();
          }, delay);
        }).on('focusout.' + COMPONENT_NAME$F, '.radio', function () {
          removeFocused();
        });
        $('body').on('resize.' + COMPONENT_NAME$F, function () {
          setTriggerCssTop();
        });
      }

      // Element events
      this.targetElem.on('focusin.' + COMPONENT_NAME$F, function () {
        doActive();
        if (isRadio && _this2.isSafari) {
          addFocused();
        }
      }).on('focusout.' + COMPONENT_NAME$F, function (e) {
        var delay = _this2.isSafari ? 200 : 0;
        if (isRadio && _this2.isSafari) {
          removeFocused();
        }
        setTimeout(function () {
          if (canUnactive(e)) {
            doUnactive();
          }
        }, delay);
      });

      // Trigger(action button) events
      this.trigger.on('focusin.' + COMPONENT_NAME$F + ' click.' + COMPONENT_NAME$F, function () {
        doActive();
      }).on('focusout.' + COMPONENT_NAME$F, function (e) {
        if (canUnactive(e)) {
          doUnactive();
        }
      }).on('selected.' + COMPONENT_NAME$F, function () {
        _this2.popupmenuApi.settings.returnFocus = true;
      }).on('close.' + COMPONENT_NAME$F, function (e) {
        if (canUnactive(e)) {
          doUnactive();
        }
      });

      // FIX: Safari - by default does not get focus on some elements while using tab key
      // https://stackoverflow.com/a/29106095
      if (this.isSafari || isFileupload) {
        if (isRadio) {
          this.element.attr('tabindex', 0);
        }
        this.targetElem.on('keydown.' + COMPONENT_NAME$F, function (e) {
          var key = e.which || e.keyCode || e.charCode || 0;
          if (key === 9 && !e.shiftKey) {
            if (isRadio) {
              _this2.targetElem.find(':checked, .radio:first').not(':disabled').focus();
              _this2.targetElem.find('.radio').off('keydown.' + COMPONENT_NAME$F).on('keydown.' + COMPONENT_NAME$F, function (e2) {
                var key2 = e2.which || e2.keyCode || e2.charCode || 0;
                if (key2 === 9 && !e.shiftKey) {
                  setTimeout(function () {
                    _this2.trigger.focus();
                  }, 0);
                }
              });
            } else {
              _this2.trigger.focus();
            }
            doActive();
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }

      this.element.on('listopened.' + COMPONENT_NAME$F, function () {
        doActive();
      }).on('listclosed.' + COMPONENT_NAME$F, function () {
        doUnactive();
      });

      return this;
    },
    // END: Handle Events -------------------------------------------------

    /**
    * Set component to enabled.
    * @returns {object} The api
    */
    enable: function enable() {
      this.trigger.prop('disabled', false);
      return this;
    },


    /**
    * Set component to disabled.
    * @returns {object} The api
    */
    disable: function disable() {
      this.trigger.prop('disabled', true);
      return this;
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.field.off(['click.' + COMPONENT_NAME$F, 'mouseover.' + COMPONENT_NAME$F, 'mouseout.' + COMPONENT_NAME$F].join(' '));

      this.element.off(['beforeopen.' + COMPONENT_NAME$F, 'change.' + COMPONENT_NAME$F, 'focusin.' + COMPONENT_NAME$F, 'focusout.' + COMPONENT_NAME$F, 'listclosed.' + COMPONENT_NAME$F, 'listopened.' + COMPONENT_NAME$F].join(' '));

      this.trigger.off(['beforeopen.' + COMPONENT_NAME$F, 'click.' + COMPONENT_NAME$F, 'focusin.' + COMPONENT_NAME$F, 'focusout.' + COMPONENT_NAME$F, 'selected.' + COMPONENT_NAME$F, 'close.' + COMPONENT_NAME$F].join(' '));

      this.targetElem.off(['click.' + COMPONENT_NAME$F, 'keydown.' + COMPONENT_NAME$F].join(' '));

      $('body').off(['resize.' + COMPONENT_NAME$F].join(' '));

      $(document).off(['click.' + COMPONENT_NAME$F].join(' '));

      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, FIELDOPTIONS_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
    * Teardown process for this plugin
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$F);
    }
  };

  /**
   * jQuery Component Wrapper for FieldOptions
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.fieldoptions = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$F);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$F, new FieldOptions(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$G = 'fileupload';

  /**
  * A list of items with add/remove/delete and sort functionality.
  * @class FileUpload
  * @constructor
  *
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  */

  var FILEUPLOAD_DEFAULTS = {};

  function FileUpload(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, FILEUPLOAD_DEFAULTS);
    this.init();
  }

  // FileUpload Methods
  FileUpload.prototype = {
    init: function init() {
      this.build();
    },


    // Example Method
    build: function build() {
      var _this = this;

      var self = this;
      var elem = this.element;
      var hasInlineLabel = !elem.is('input.fileupload');

      this.fileInput = hasInlineLabel ? elem.find('input') : elem;

      elem.closest('.field').addClass('field-fileupload');

      // append markup
      var id = elem.find('input').attr('name');
      if (!hasInlineLabel) {
        id = elem.attr('id') || elem.attr('name');
      }

      var elemClass = !hasInlineLabel ? elem.attr('class') : elem.find('input').attr('class');
      elemClass = elemClass ? ' ' + elemClass : '';

      var instructions = Locale.translate('FileUpload');
      var label = $('<label for="' + id + '-filename">' + elem.text() + ' <span class="audible">' + instructions + '</span></label>');
      var shadowField = $('<input readonly id="' + id + '-filename" class="fileupload-background-transparent' + elemClass + '" type="text">');
      var svg = '<span class="trigger" tabindex="-1">' + $.createIcon('folder') + '</span>';
      var svgClose = '<span class="trigger-close" tabindex="-1">' + $.createIcon('close') + '</span>';

      if (!hasInlineLabel) {
        var orgLabel = elem.prev('label');

        // Could be wrapped (angular)
        if (orgLabel.length === 0) {
          orgLabel = elem.parent().prev('label');
        }

        label = $('<label for="' + (elem.attr('id') || elem.attr('name')) + '-filename">' + orgLabel.text() + '</label>');
        elem.before(label, shadowField);
        this.fileInput.after(svgClose);
        this.fileInput.after(svg);
        orgLabel.addClass('audible').append('<span class="audible">' + instructions + '</span>');
      } else {
        elem.before(label, shadowField);
        this.fileInput.after(svgClose);
        this.fileInput.after(svg);
      }

      // if there is a value attribute, then this will be used as the current value since unable to set files[0].name
      // move it to the text input and remove it off the file input
      var fileInputValue = this.fileInput.attr('value');
      if (fileInputValue && fileInputValue.length > 0) {
        shadowField.val(fileInputValue);
        this.fileInput.attr('value', '');
      }

      this.textInput = shadowField;
      this.svg = elem.parent().find('.trigger');
      this.svgClose = elem.parent().find('.trigger-close');

      /*
      * Added Keydown for Keyboard Backspace and remove Keypress because it doesn't detect Backspace
      */
      this.textInput.on('keydown.fileupload', function (e) {
        var handle = false;
        if (e.which === 13 || e.which === 32) {
          elem.parent().find('[type="file"]').trigger('click');
          handle = true;
        } else if (e.which === 8) {
          _this.clearUploadFile();
          handle = true;
        }
        if (handle) {
          e.stopPropagation();
        }
      });

      this.svg.on('click.fileupload', function (e) {
        _this.fileInput.trigger('click');
        if (hasInlineLabel) {
          _this.fileInput.data('handleEvent' + [e.type || ''], e.handleObj);
        }
      });

      this.svgClose.on('click.fileupload', function (e) {
        _this.clearUploadFile();
        if (hasInlineLabel) {
          _this.fileInput.data('handleEvent +' + [e.type || ''], e.handleObj);
        }
      });

      if (this.fileInput.is(':disabled')) {
        this.textInput.prop('disabled', true);
      }

      if (elem.hasClass('required')) {
        label.addClass('required');
        elem.removeClass('required');
      }

      if (this.fileInput.attr('data-validate')) {
        this.textInput.attr('data-validate', this.fileInput.attr('data-validate'));
        this.textInput.validate();
      }

      if (this.fileInput.attr('readonly')) {
        this.textInput.prop('disabled', false);
        this.textInput[0].classList.remove('fileupload-background-transparent');
        this.fileInput.attr('disabled', 'disabled');
      }

      /*
      * New Event for File Upload Change
      */
      this.fileInput.on('change.fileupload', function () {
        if (this.files.length > 0) {
          self.textInput.val(this.files[0].name).trigger('change');
          self.svgClose.show().addClass('is-visible');
        } else {
          self.clearUploadFile();
        }
      });

      // Fix - Not to buble events when clicked on trigger/close icons
      this.fileInput.on('click.fileupload', function (e) {
        var handleEventData = _this.fileInput.data('handleEvent' + [e.type || '']);
        if (handleEventData && handleEventData.type === e.type && e.handleObj.namespace === 'fileupload') {
          _this.fileInput.data('handleEvent' + [e.type || ''], null);
          e.preventDefault();
        }
      });

      // Fix: not sure why, but some browser(ie. safari) need to rerender,
      // some rules were not applying from css file
      self.fileInput.css({ position: 'static', left: 0 });
      setTimeout(function () {
        self.fileInput.css({ position: 'fixed', left: '-10000px' });
      }, 0);
    },


    /*
    * Clear the Input Upload File
    */
    clearUploadFile: function clearUploadFile() {
      var val = this.fileInput.val();
      this.fileInput.add(this.textInput).val('');
      this.svgClose.hide().removeClass('is-visible');
      if (val !== '') {
        this.fileInput.triggerHandler('change');
      }
    },


    // Unbind all events
    unbind: function unbind() {
      this.svg.add(this.svgClose).off('click.fileupload');
      this.fileInput.off('change.fileupload');
      this.textInput.off('keydown.fileupload');

      this.element.closest('.field-fileupload').removeClass('field-fileupload').find('>label:first, >[type="text"]:first, .trigger, .trigger-close, .icon-dirty, .msg-dirty').remove();

      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, FILEUPLOAD_DEFAULTS);
      }
      // Nothing to do here as there are no settings.
      return this;
    },


    /**
    * Teardown process for this plugin
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$G);
    },


    /**
    * Disable the input and button.
    * @returns {void}
    */
    disable: function disable() {
      this.textInput.prop('disabled', true);
      this.fileInput.prop('disabled', true);
    },


    /**
    * Enable the input and button.
    * @returns {void}
    */
    enable: function enable() {
      this.textInput.prop('disabled', false).prop('readonly', false);
      this.fileInput.removeAttr('disabled');
    },


    /**
    * Make the input readonly and disable the button.
    * @returns {void}
    */
    readonly: function readonly() {
      this.textInput.prop('readonly', true);
      this.fileInput.prop('disabled', true);

      this.textInput.prop('disabled', false);
      this.textInput.removeClass('fileupload-background-transparent');
    }
  };

  /**
   * jQuery Component Wrapper for FileUpload
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.fileupload = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$G);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$G, new FileUpload(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$H = 'fileuploadadvanced';

  /**
  * A trigger field for uploading a single file.
  * @class FileUploadAdvanced
  * @constructor
  *
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.isStandalone=true] On page(true)|on modal(false), used for some visual style only.
  * @param {string} [settings.standaloneClass='standalone'] Css class if on page.
  * @param {string} [settings.allowedTypes='*'] Restrict file types(ie. 'jpg|png|gif') ['*' all types]
  * @param {number} [settings.maxFilesInProcess=99999] Max number of files can be uploaded
  * @param {number} [settings.maxFileSize=-1] Max file size in bytes, -1 for unlimited
  * @param {string} [settings.fileName='myfile'] Variable name to read from server
  * @param {boolean} [settings.isDisabled=false] Make control disabled
  * @param {boolean} [settings.showBrowseButton=true] Add way to browse files to upload
  * @param {Function} [settings.send] Method for send file to upload
  * @param {string} [settings.textDropArea] Text to show in drop area
  * @param {string} [settings.textDropAreaWithBrowse] Text to show in drop area when browse option true
  * @param {string} [settings.textBtnCancel] Hidden text for cancel button
  * @param {string} [settings.textBtnCloseError] Hidden text for error close button
  * @param {string} [settings.textBtnRemove] Hidden text for remove button
  * @param {string} [settings.errorAllowedTypes] Error text for allowed types
  * @param {string} [settings.errorMaxFileSize] Error text for max file size
  * @param {string} [settings.errorMaxFilesInProcess] Error text for max files in process
  */

  var FILEUPLOADADVANCED_DEFAULTS = {
    isStandalone: true, //
    standaloneClass: 'standalone', // css class if on page
    allowedTypes: '*', // restrict file types(ie. 'jpg|png|gif') ['*' all types]
    maxFilesInProcess: 99999, // max files can be upload
    maxFileSize: -1, // max file size in bytes, -1 for unlimited
    fileName: 'myfile', // variable name to read from server
    isDisabled: false, // Disabled
    showBrowseButton: true, // Browse files to upload
    send: null, // Function to send files to server

    // Text strings
    textDropArea: null,
    textDropAreaWithBrowse: null,
    textBtnCancel: null,
    textBtnCloseError: null,
    textBtnRemove: null,

    // Error strings
    errorAllowedTypes: null,
    errorMaxFileSize: null,
    errorMaxFilesInProcess: null
  };

  function FileUploadAdvanced(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, FILEUPLOADADVANCED_DEFAULTS);
    this.init();
  }

  // FileUploadAdvanced Methods
  FileUploadAdvanced.prototype = {
    init: function init() {
      this.build();
      this.handleEvents();
    },


    /**
     * Add markup
     * @private
     * @returns {void}
     */
    build: function build() {
      var s = this.settings;
      var html = void 0;
      var cssClassList = s.isStandalone ? s.standaloneClass : '';

      // Re-evaluate strings
      s.textDropArea = s.textDropArea || Locale.translate('TextDropArea');
      s.textDropAreaWithBrowse = s.textDropAreaWithBrowse || Locale.translate('TextDropAreaWithBrowse');
      s.textBtnCancel = s.textBtnCancel || Locale.translate('TextBtnCancel');
      s.textBtnCloseError = s.textBtnCloseError || Locale.translate('TextBtnCloseError');
      s.textBtnRemove = s.textBtnRemove || Locale.translate('TextBtnRemove');
      s.errorAllowedTypes = s.errorAllowedTypes || '<em>' + Locale.translate('Error') + '</em>: ' + Locale.translate('ErrorAllowedTypes');
      s.errorMaxFileSize = s.errorMaxFileSize || '<em>' + Locale.translate('Error') + '</em>: ' + Locale.translate('ErrorMaxFileSize');
      s.errorMaxFilesInProcess = s.errorMaxFilesInProcess || '<em>' + Locale.translate('Error') + '</em>: ' + Locale.translate('ErrorMaxFilesInProcess');

      // Disabled
      if (this.element.is('.is-disabled')) {
        s.isDisabled = true;
      }
      if (s.isDisabled) {
        cssClassList += ' is-disabled';
      }

      // Browse files option
      if (s.showBrowseButton) {
        var types = '';
        var id = utils.uniqueId(this.element, 'fileupload-adv-');
        var fileExtensions = s.allowedTypes.split(/[\s|]+/g);
        var isExtra = s.maxFilesInProcess > 1 ? ' multiple' : '';
        isExtra += s.isDisabled ? ' disabled' : '';

        if (fileExtensions.length === 1) {
          if (fileExtensions[0] !== '*') {
            types = '.' + fileExtensions[0];
          }
        } else {
          for (var i = 0, l = fileExtensions.length; i < l; i++) {
            types += '.' + (fileExtensions[i] + (i !== l - 1 ? ',' : ''));
          }
        }

        html = '' + ('<div class="fileupload-wrapper ' + cssClassList + '">\n          <div class="container drop-area">\n            ' + $.createIcon('upload') + '\n            <label class="fileupload-adv-browse-lbl">\n              <span>' + s.textDropAreaWithBrowse + '</span>\n              <input type="file" name="' + id + '" accept="' + types + '"' + isExtra + ' />\n            </label>\n          </div>\n        </div>');
      } else {
        // Without browse files option

        html = '' + ('<div class="fileupload-wrapper ' + cssClassList + '">\n          <div class="container drop-area">\n            ' + $.createIcon('upload') + '\n            <p>' + s.textDropArea + '</p>\n          </div>\n        </div>');
      }

      DOM.append(this.element, html, '<div><svg><use><label><span><input>');
      this.dropArea = $('.drop-area', this.element);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      var s = this.settings;

      this.dropArea
      // Drag enter
      .on('dragenter.fileuploadadvanced', function (e) {
        self.element.triggerHandler('filesdragenter');
        e.stopPropagation();
        e.preventDefault();

        if (s.isDisabled) {
          return;
        }
        $(this).addClass('hover');
      })

      // Drag over
      .on('dragover.fileuploadadvanced', function (e) {
        e.stopPropagation();
        e.preventDefault();
      })

      // Drop
      .on('drop.fileuploadadvanced', function (e) {
        var files = e.originalEvent.dataTransfer.files;
        e.preventDefault();
        if (s.isDisabled) {
          return;
        }

        /**
        * Fires when file/s drag and droped to drop area.
        *
        * @event filesdroped
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {array} files - List of files droped
        */
        self.element.triggerHandler('filesdroped', [files]);

        $(this).removeClass('hover is-focus');

        // Clear previous errors in general area
        $('span.msg', this.element).closest('.error').remove();

        // Max files can be upload
        if (files.length + $('.progress', this.element).length > s.maxFilesInProcess) {
          self.showError(s.errorMaxFilesInProcess);
          return;
        }

        self.handleFileUpload(files);
      });

      if (s.showBrowseButton && !s.isDisabled) {
        var label = this.dropArea.find('.fileupload-adv-browse-lbl');
        var input = label.find('input[type="file"]');

        // Only let open dialog if clicked on link or input
        label.click(function (e) {
          if (!$(e.target).is('.hyperlink, input[type="file"]')) {
            e.preventDefault();
          }
        });

        input.hideFocus();
        input.on('hidefocusremove.fileuploadadvanced', function (e) {
          e.stopPropagation();
          _this.dropArea.addClass('is-focus');
        }).on('hidefocusadd.fileuploadadvanced', function (e) {
          e.stopPropagation();
          _this.dropArea.removeClass('is-focus');
        }).on('change.fileuploadadvanced', function (e) {
          e.stopPropagation();
          self.handleFileUpload(this.files);
        });
      }

      // If the files are dropped outside the div, files will open in the browser window.
      // To avoid this prevent 'drop' event on document.
      $(document).on('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced', function (e) {
        e.stopPropagation();
        e.preventDefault();

        if (e.type === 'dragover') {
          self.dropArea.removeClass('hover');
        }
      });
    },


    /**
    * Read the file contents using HTML5 FormData()
    * @param {object} files File object containing uploaded files.
    * @returns {void}
    */
    handleFileUpload: function handleFileUpload(files) {
      var s = this.settings;
      var fileName = s.fileName.replace('[]', '');

      /* eslint-disable no-continue */
      for (var i = 0, l = files.length; i < l; i++) {
        // Check if file type allowed
        if (!this.isFileTypeAllowed(files[i].name)) {
          this.showError(s.errorAllowedTypes, files[i]);
          continue;
        }

        // Check for max file size
        if (s.maxFileSize !== -1 && files[i].size > s.maxFileSize) {
          this.showError(s.errorMaxFileSize, files[i]);
          continue;
        }

        /**
        * Fires before create the progress status object.
        *
        * @event beforecreatestatus
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {object} file - file to set the status
        */
        this.element.triggerHandler('beforecreatestatus', [files[i]]);
        /* global FormData */
        var fd = new FormData();
        fd.append(fileName + '[]', files[i]);

        var status = this.createStatus(files[i]);
        status.container.find('.status-icon .action').focus();

        /**
        * Fires after create the progress status object.
        *
        * @event aftercreatestatus
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {object} file - file to set the status
        */
        this.element.triggerHandler('aftercreatestatus', [files[i]]);

        if (typeof s.send === 'function') {
          s.send(fd, status);
        } else {
          this.sendFileToServer(fd, status);
        }
      }
      /* eslint-enable no-continue */

      if (s.showBrowseButton) {
        // Clear browse file input
        this.dropArea.find('.fileupload-adv-browse-lbl input[type="file"]').val('');
      }
    },


    /**
    * Create status object
    * @param {object} file to create progress status.
    * @returns {object} contains file and status methods to access.
    */
    createStatus: function createStatus(file) {
      var _this2 = this;

      var self = this;
      var s = this.settings;
      var container = $('' + ('<div class="container">\n        <div class="file-row">\n          <span class="status-icon">\n            <button type="button" class="btn-icon action">\n              ' + $.createIcon({ icon: 'close', classes: ['icon-close'] }) + '\n              <span>' + s.textBtnCancel + '</span>\n            </button>\n          </span>\n          <span class="description">' + file.name + '</span>\n          <div class="l-pull-right">\n            <span class="size">' + this.formatFileSize(file.size) + '</span>\n          </div>\n        </div>\n        <div class="progress-row">\n          <span class="progress">\n            <span class="progress-bar" data-value="0"></span>\n          </span>\n        </div>\n      </div>'));

      var btnCancel = $('.action', container).button();
      var rightSide = $('.l-pull-right', container);
      var progressBar = $('.progress-bar', container).progress({ animationLength: 10 });

      // Add this container
      this.dropArea.after(container);

      // Update progress-bar
      var setProgress = function setProgress(progress) {
        /**
        * Fires when file progress status changes.
        *
        * @event fileprogress
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {object} status - `{ file, progress }`
        */
        _this2.element.triggerHandler('fileprogress', [{ file: file, progress: progress }]);
        progressBar.attr('data-value', progress).triggerHandler('updated');
      };

      // Set abort action
      var setAbort = function setAbort(jqxhr) {
        btnCancel.on('click.fileuploadadvanced', function () {
          /**
          * Fires when file aborted.
          *
          * @event fileaborted
          * @memberof FileUploadAdvanced
          * @property {object} event - The jquery event object
          * @property {object} file - aborted
          */
          _this2.element.triggerHandler('fileaborted', [file]);
          jqxhr.abort();
          btnCancel.off('click.fileuploadadvanced');
          container.remove();
        });
      };

      // Set completed state
      var setCompleted = function setCompleted(data) {
        container.addClass('completed');

        // Add "Completed" icon
        btnCancel.after($.createIcon('check'));

        // Add "Remove from server" button
        rightSide.append('' + ('<button type="button" class="btn-icon action">\n          ' + $.createIcon({ classes: ['icon-close'], icon: 'close' }) + '\n          <span>' + s.textBtnRemove + '</span>\n        </button>'));

        // Set "Remove from server" button action
        $('.action', rightSide).button().on('click.fileuploadadvanced', function () {
          $(this).off('click.fileuploadadvanced');
          container.remove();

          // TODO: server call for removing data
          data.remove();
        });

        // Remove Cancel button and progress-bar area
        btnCancel.off('click.fileuploadadvanced');
        btnCancel.add(progressBar.closest('.progress-row')).remove();
        /**
        * Fires when file complete uploading.
        *
        * @event filecompleteuploading
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {object} file uploaded
        */
        self.element.triggerHandler('filecompleteuploading', [file]);
      };

      return { file: file, container: container, setProgress: setProgress, setAbort: setAbort, setCompleted: setCompleted };
    },


    /**
    * Function you can implement to send data to the server.
    * @param {object} formData - Contains the form data / file data.
    * @param {object} status - Status of the upload operation
    * @returns {void}
    */
    sendFileToServer: function sendFileToServer(formData, status) {
      var jqXHR = { abort: function abort() {} };
      var tempData = { remove: function remove() {} };
      var percent = 0;
      var total = parseFloat(status.file.size);
      /* eslint-disable new-cap */
      var timer = new $.fn.timer(function () {
        status.setCompleted(tempData);
      }, total);
      /* eslint-enable new-cap */

      $(timer.event).on('update', function (e, data) {
        percent = Math.ceil(data.counter / total * 100);
        status.setProgress(percent);
      });

      status.setAbort(jqXHR);
    },


    /**
     * Show error on ui
     * @private
     * @param {string} error to display
     * @param {object} file contains the error.
     * @returns {void}
     */
    showError: function showError(error, file) {
      var container = void 0;
      var s = this.settings;

      if (error === s.errorMaxFilesInProcess) {
        // This error show without file name or size in general area
        container = $('' + ('<div class="container error">\n          <div class="file-row">\n            <span class="status-icon">\n              <button type="button" class="btn-icon action">\n                ' + $.createIcon({ classes: ['icon-close'], icon: 'close' }) + '\n                <span>' + s.textBtnCloseError + '</span>\n              </button>\n            </span>\n            <span class="msg">' + error + '</span>\n          </div>\n        </div>'));
      } else {
        container = $('' + ('<div class="container error">\n          <div class="file-row">\n            <span class="status-icon">\n              <button type="button" class="btn-icon action">\n                ' + $.createIcon({ classes: ['icon-close'], icon: 'close' }) + '\n                <span>' + s.textBtnCloseError + '</span>\n              </button>\n            </span>\n            <span class="description">' + file.name + '</span>\n            <div class="l-pull-right">\n              <span class="size">' + this.formatFileSize(file.size) + '</span>\n            </div>\n          </div>\n          <div class="msg">\n            <p>' + error + '</p>\n          </div>\n        </div>'));
      }

      $('.action', container).button().on('click.fileuploadadvanced', function () {
        container.remove();
      });

      // Add this container
      this.dropArea.after(container);
    },


    /**
     * Check if file type allowed
     * @private
     * @param {string} fileName to check types
     * @returns {boolean} true if allowed to uploaded
     */
    isFileTypeAllowed: function isFileTypeAllowed(fileName) {
      var fileExtensions = this.settings.allowedTypes.toLowerCase().split(/[\s|]+/g);
      var ext = fileName.split('.').pop().toLowerCase();
      if (this.settings.allowedTypes !== '*' && $.inArray(ext, fileExtensions) < 0) {
        return false;
      }
      return true;
    },


    /**
     * Helper function that formats the file sizes
     * @private
     * @param {number} bytes to be formated
     * @returns {string} formated to use in ui
     */
    formatFileSize: function formatFileSize(bytes) {
      var scale = {
        GB: 1000000000,
        MB: 1000000,
        KB: 1000
      };
      if (typeof bytes !== 'number') {
        return '';
      }
      if (bytes >= scale.GB) {
        return (bytes / scale.GB).toFixed(2) + ' GB';
      }
      if (bytes >= scale.MB) {
        return (bytes / scale.MB).toFixed(2) + ' MB';
      }
      return (bytes / scale.KB).toFixed(2) + ' KB';
    },


    /**
    * Set component to enabled.
    * @returns {void}
    */
    enable: function enable() {
      this.settings.isDisabled = false;
      this.unbind();
      this.element.find('.fileupload-wrapper').removeClass('is-disabled').find('.fileupload-adv-browse-lbl input[type="file"]').removeAttr('disabled');
      this.handleEvents();
    },


    /**
    * Set component to disabled.
    * @returns {void}
    */
    disable: function disable() {
      this.settings.isDisabled = true;
      this.unbind();
      this.element.find('.fileupload-wrapper').addClass('is-disabled').find('.fileupload-adv-browse-lbl input[type="file"]').attr('disabled', 'disabled');
      this.handleEvents();
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {void}
     */
    unbind: function unbind() {
      this.dropArea.find('.fileupload-adv-browse-lbl input[type="file"]').off('hidefocusremove.fileuploadadvanced hidefocusadd.fileuploadadvanced change.fileuploadadvanced');

      this.dropArea.off('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced');
      $(document).off('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced');
      $('.action', this.element).off('click.fileuploadadvanced');
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, FILEUPLOADADVANCED_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
    * Destroy and remove added markup, all events
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $('.fileupload-wrapper', this.element).remove();
      $.removeData(this.element[0], COMPONENT_NAME$H);
    }
  };

  /*
  ERROR
  --------
  https://social.technet.microsoft.com/Forums/ie/en-US/ec3c0be0-0834-4873-8e94-700e9df9c822/edge-browser-drag-and-drop-files-not-working?forum=ieitprocurrentver

  */

  /**
   * jQuery Component Wrapper for FileUpload Advanced
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.fileuploadadvanced = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$H);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$H, new FileUploadAdvanced(this, settings));
      }
    });
  };

  // Default Settings
  var COMPONENT_NAME$I = 'homepage';

  /**
  * The Homepage handles card layout at multiple breakpoints.
  *
  * @class Homepage
  * @constructor
  * @param {HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.animate] Disable animation during resize
  * @param {number} [settings.columns] Display in 3 (default) or 4 column layout
  * @param {string} [settings.easing]
  * @param {number} [settings.gutterSize]
  * @param {number} [settings.widgetWidth]
  * @param {number} [settings.widgetHeight]
  * @param {number} [settings.timeout]
  */
  var HOMEPAGE_DEFAULTS = {
    animate: true,
    columns: 3,
    easing: 'blockslide', // Private
    gutterSize: 20, // Private
    widgetWidth: 360, // Private
    widgetHeight: 370, // Private
    timeout: 100 // Private
  };

  function Homepage(element, settings) {
    this.settings = utils.mergeSettings(element, settings, HOMEPAGE_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Homepage Methods
  Homepage.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.isTransitionsSupports = this.supportsTransitions();
      this.initHeroWidget();
      this.handleEvents();

      // Initial Sizing
      this.resize(this, false);
    },


    /**
     * Initialize columns.
     * @private
     * @param {number} row to be initialize.
     * @returns {void}
     */
    initColumns: function initColumns(row) {
      row = row || 0;
      this.rowsAndCols[row] = [];

      for (var i = 0, l = this.settings.columns; i < l; i++) {
        this.rowsAndCols[row][i] = true; // Make all columns available in first row[true]
      }
    },


    /**
     * Initialize hero widget.
     * @private
     * @returns {void}
     */
    initHeroWidget: function initHeroWidget() {
      var heroWidget = $('.hero-widget');
      if (heroWidget.length > 1) {
        heroWidget = heroWidget.not(':first').remove();
      }
      this.heroWidget = heroWidget;
    },


    /**
     * Initialize rows and cols.
     * @private
     * @returns {void}
     */
    initRowsAndCols: function initRowsAndCols() {
      this.rowsAndCols = []; // Keeping all blocks as rows and columns
      this.initColumns();
    },


    /**
     * Get availability where we can fit this given block.
     * @private
     * @param {object} block to get availability.
     * @returns {object} [x and y] where we can fit this block
     */
    getAvailability: function getAvailability(block) {
      var abort = false;
      var smallest = {};
      var rows = this.rowsAndCols.length;

      // Loop thru each row and column soon it found first available spot
      // Then check for if block's width can fit in(yes), asign to [smallest] and break both loops
      for (var i = 0, l = rows; i < l && !abort; i++) {
        for (var j = 0, innerCheck = true, cols = this.rowsAndCols[i].length; j < cols && !abort; j++) {
          if (this.rowsAndCols[i][j] && block.w + j <= cols) {
            if (block.w > 1 && cols > j + 1) {
              for (var n = 0; n < block.w; n++) {
                if (!this.rowsAndCols[i][j + n]) {
                  innerCheck = false;
                  break;
                }
              }
            }
            if (block.h > 1 && rows > i + 1) {
              for (var _n = 0; _n < block.h; _n++) {
                if (!this.rowsAndCols[i + _n][j]) {
                  innerCheck = false;
                  break;
                }
              }
            }
            if (innerCheck) {
              smallest.row = i;
              smallest.col = j;
              abort = true;
            }
          }
        }
      }

      // If did not found any available spot from previous loops
      // Add new row and asign to [smallest] first column in this new row
      if (!Object.getOwnPropertyNames(smallest).length) {
        this.initColumns(rows);
        smallest.row = rows;
        smallest.col = 0;
      }

      return smallest; // {x:0, y:0}
    },


    /**
     * Make all spots as unavailable, depends on block's width and height
     * Soon we used this block
     * @private
     * @param {number} r as row.
     * @param {number} c as col.
     * @param {number} block to fit.
     * @returns {void}
     */
    fitBlock: function fitBlock(r, c, block) {
      var addRow = true;

      block.x = c;
      block.y = r;

      if (block.w === 1 && block.h === 1) {
        // Single block can fit anywhere
        this.rowsAndCols[r][c] = false;
      } else if (block.w !== 1) {
        // If more then one row or column then loop thru to block's width and height
        // If height is more then current rows then add new row
        // Mark those spots as unavailable[false]

        // Left to right
        for (var i = r, l = block.h + r; i < l; i++) {
          for (var j = c, l2 = block.w + c; j < l2; j++) {
            if (!this.rowsAndCols[i]) {
              this.initColumns(i);
            }
            this.rowsAndCols[i][j] = false;
          }
        }
      } else {
        // Top to bottom
        for (var _i = r, _l = block.h + r; _i < _l; _i++) {
          for (var _j = c, _l2 = block.h + c; _j < _l2; _j++) {
            if (!this.rowsAndCols[_i]) {
              this.initColumns(_i);
            }
            this.rowsAndCols[_i][c] = false;
          }
        }
      }

      // Check if reach to end of columns then assign flag[addRow]
      for (var _i2 = 0, _l3 = this.rowsAndCols[r].length; _i2 < _l3; _i2++) {
        if (this.rowsAndCols[r][_i2]) {
          addRow = false;
        }
      }

      // If reach to end of columns and next row is not avaiable then add new row
      // Make all columns available, if not assigned earlier as unavailable
      if (addRow) {
        if (!this.rowsAndCols[r + 1]) {
          this.initColumns(r + 1);
        }
      }
    },


    /**
     * Setup each block sizes, based on classes provided from markup
     * @private
     * @returns {void}
     */
    setBlocks: function setBlocks() {
      var cards = this.element.find('.card, .widget');
      this.blocks = [];

      for (var i = 0, l = cards.length; i < l; i++) {
        var card = $(cards[i]);
        var h = card.hasClass('double-height') ? 2 : 1;
        var w = void 0;

        if (card.hasClass('quad-width')) {
          w = 4;
        } else if (card.hasClass('triple-width')) {
          w = 3;
        } else if (card.hasClass('double-width')) {
          w = 2;
        } else {
          w = 1;
        }

        this.blocks.push({ w: w, h: h, elem: card, text: card.text() });
      }

      // Max sized columns brings to top
      if (this.settings.columns > 1) {
        for (var _i3 = 0, j = 0, _w = 0, _l4 = this.blocks.length; _i3 < _l4; _i3++) {
          if (this.blocks[_i3].w >= this.settings.columns && _i3 && _w) {
            this.arrayIndexMove(this.blocks, _i3, j);
          }
          _w += this.blocks[_i3].w;
          if (_w >= this.settings.columns) {
            _w = 0; // reset
            j = this.blocks[j].w >= this.settings.columns ? j + 1 : _i3; // record to move
          }
        }
      }
    },


    /**
     * Move an array element position
     * @private
     * @param {array} arr .
     * @param {number} from index.
     * @param {number} to index.
     * @returns {void}
     */
    arrayIndexMove: function arrayIndexMove(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },


    /**
     * Resize Method
     * @private
     * @param {object} self .
     * @param {boolean} animate .
     * @returns {void}
     */
    resize: function resize(self, animate) {
      // Sizes of "breakpoints" is  320, 660, 1000 , 1340 (for 320)
      // or 360, 740, 1120, 1500 or (for 360)
      var bpXL = self.settings.widgetWidth * 4 + self.settings.gutterSize * 3;
      var bpDesktop = self.settings.widgetWidth * 3 + self.settings.gutterSize * 2;
      var bpTablet = self.settings.widgetWidth * 2 + self.settings.gutterSize;
      var bpPhone = self.settings.widgetWidth;

      var bp = bpXL; // 1340
      // Math min against window.screen.width for single line mobile support
      var elemWidth = self.element.outerWidth();

      // elemWidth -= 30; //extra break space

      // Find the Breakpoints
      var xl = elemWidth >= bpXL;
      var desktop = elemWidth >= bpDesktop && elemWidth <= bpXL;
      var tablet = elemWidth >= bpTablet && elemWidth <= bpDesktop;
      var phone = elemWidth <= bpTablet;

      var maxAttr = this.element.attr('data-columns');
      var content = self.element.find('> .content');
      this.settings.columns = parseInt(maxAttr || this.settings.columns, 10);

      // Assign columns as breakpoint sizes
      if (xl && self.settings.columns === 4) {
        self.settings.columns = 4;
        bp = bpXL;
      }
      if (desktop || xl && self.settings.columns === 3) {
        self.settings.columns = 3;
        bp = bpDesktop;
      }
      if (tablet) {
        self.settings.columns = 2;
        bp = bpTablet;
      }
      if (phone) {
        self.settings.columns = 1;
        bp = bpPhone;
      }

      if (content.length) {
        content[0].style.marginLeft = '-' + bp / 2 + 'px';
      }

      this.setBlocks(); // setup blocks
      this.initRowsAndCols(); // setup colums

      // Loop thru each block, make fit where available and
      // If block more wider than available size, make as  available size
      // Assign new left and top css positions
      for (var i = 0, l = self.blocks.length; i < l; i++) {
        // let left, top, pos, available,
        var block = self.blocks[i];

        // Remove extra classes if assigned earlier
        block.elem.removeClass('to-single to-double to-triple');

        // If block more wider than available size, make as available size
        if (block.w > self.settings.columns) {
          block.w = self.settings.columns;

          if (self.settings.columns === 1) {
            block.elem.addClass('to-single');
          } else if (self.settings.columns === 2) {
            block.elem.addClass('to-double');
          } else if (self.settings.columns === 3) {
            block.elem.addClass('to-triple');
          }
        }

        // Get Availability
        var available = self.getAvailability(block);

        // Set positions
        var box = self.settings.widgetWidth + self.settings.gutterSize;
        var totalWidth = box * self.settings.columns;

        var left = Locale.isRTL() ? totalWidth - (box * block.w + box * available.col) : box * available.col; // eslint-disable-line
        var top = (self.settings.widgetHeight + self.settings.gutterSize) * available.row;
        var pos = { left: left, top: top };

        if (animate) {
          var easing = self.settings.easing;
          var blockslide = [0.09, 0.11, 0.24, 0.91];

          if (easing === 'blockslide') {
            if (self.isTransitionsSupports) {
              self.applyCubicBezier(block.elem, blockslide);
              block.elem[0].style.left = pos.left + 'px';
              block.elem[0].style.top = pos.top + 'px';
            } else {
              // IE-9
              block.elem.animate(pos, self.settings.timeout);
            }
          } else {
            // Other easing effects ie (linear, swing)
            block.elem.animate(pos, self.settings.timeout, easing);
          }
        } else {
          block.elem[0].style.left = pos.left + 'px';
          block.elem[0].style.top = pos.top + 'px';
        }

        // Mark all spots as unavailable for this block, as we just used this one
        self.fitBlock(available.row, available.col, block);
      }

      /**
      * Fires after the page is resized and layout is set.
      * Can be used for any special adjustments.
      * @event resize
      * @memberof Homepage
      * @type {object}
      * @param {object} event - The jquery event object
      */
      self.element.triggerHandler('resize', self.settings.columns);
    },


    /**
     * Apply cubic-bezier effects
     * @private
     * @param {object} el as element.
     * @param {string} cubicBezier effect to apply.
     * @returns {void}
     */
    applyCubicBezier: function applyCubicBezier(el, cubicBezier) {
      var value = 'all .3s cubic-bezier(' + cubicBezier + ')';
      el[0].style['-webkit-transition'] = value;
      el[0].style['-moz-transition'] = value;
      el[0].style['-ms-transition'] = value;
      el[0].style['-o-transition'] = value;
      el[0].style.transition = value;
    },


    /**
     * Check if browser supports transitions
     * @private
     * @returns {boolean} true if supports transitions
     */
    supportsTransitions: function supportsTransitions() {
      var s = document.createElement('p').style;
      var p = 'transition';

      if (typeof s[p] === 'string') {
        return true;
      }

      // Tests for vendor specific prop
      var v = ['Moz', 'webkit', 'Webkit', 'Khtml', 'O', 'ms'];
      p = p.charAt(0).toUpperCase() + p.substr(1);

      for (var i = 0, l = v.length; i < l; i++) {
        if (typeof s[v[i] + p] === 'string') {
          return true;
        }
      }
      return false;
    },


    /**
     * Detach events
     * @private
     * @returns {void}
     */
    detachEvents: function detachEvents() {
      $('body').off('resize.homepage');
      $('.application-menu').off('applicationmenuopen.homepage applicationmenuclose.homepage');
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, HOMEPAGE_DEFAULTS);
      }
      return this.detachEvents().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.detachEvents();
      $.removeData(this.element[0], COMPONENT_NAME$I);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      $('body').on('resize.homepage', function () {
        _this.resize(_this, _this.settings.animate);
      });

      $('.application-menu').on('applicationmenuopen.homepage applicationmenuclose.homepage', function () {
        _this.resize(_this, _this.settings.animate);
      });
    }
  };

  /**
   * jQuery Component Wrapper for Homepage
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.homepage = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$I);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$I, new Homepage(this, settings));
      }
    });
  };

  /* eslint-disable no-underscore-dangle */

  // The name of this component.
  var COMPONENT_NAME$J = 'pager';

  // Selector for Pager elements that should have a tabIndex
  var FOCUSABLE_SELECTOR = ['.pager-first > a', '.pager-prev > a', '.pager-next > a', '.pager-last > a', '.pager-no > a', '.pager-count input', '.pager-pagesize button'].join(', ');

  /**
  * The Pager Component supports paging on lists.
  * @class Pager
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  *
  * @param {string} [settings.componentAPI]  If defined, becomes the definitive way to call methods on
  * parent component.
  * @param {string} [settings.type = 'list']  Different types of pagers option sets.
  * list - just shows next and previous and a listing of page numbers you can click
  * pageof - for datagrid also shows next and previous and first and last with a page number input and page size selector used optionally for
  * firstlast - for lists shows next and previous and first and last with option to set showPageSizeSelector
  * standalone - lets you control all the options with settings, events and methods. In the future i will refactor the others out.
  * @param {string} [settings.position = 'bottom']  Can be on 'bottom' or 'top'.
  * @param {number} [settings.activePage = 1]  Start on this page
  * @param {boolean} [settings.hideOnOnePage = false]  If true, hides the pager if there is only one page worth of results.
  * @param {Function} [settings.source] Call back function for pager data source
  * @param {number} [settings.pagesize = 15]  Can be calculated or a specific number
  * @param {array} [settings.pagesizes = [15, 25, 50, 75]] Array of numbers of the page size selector
  * @param {boolean} [settings.showPageSizeSelector = true] If false will not show page size selector
  * @param {boolean} [settings.smallPageSizeSelector = false] If true, shows a condensed view of the page size selector
  * @param {boolean} [settings.onPageSizeChange] Call back function for page change
  * @param {boolean} [settings.showFirstButton = true] If false the first button will be hidden (standalone mode)
  * @param {boolean} [settings.enableFirstButton = true] If false the first button will be disabled (standalone mode)
  * @param {boolean} [settings.onFirstPage] Call back function for first page button click
  * @param {boolean} [settings.showPreviousButton = true] If false the previous button will be hidden (standalone mode)
  * @param {boolean} [settings.enablePreviousButton = true] If false the previous button will be disabled (standalone mode)
  * @param {boolean} [settings.onPreviousPage] Call back function for previous page button click
  * @param {boolean} [settings.showNextButton = true] If false the next button will be hidden (standalone mode)
  * @param {boolean} [settings.enableNextButton = true] If false the next button will be disabled (standalone mode)
  * @param {boolean} [settings.onNextPage] Call back function for next page button click
  * @param {boolean} [settings.showLastButton = true] If false the last button will be hidden (standalone mode)
  * @param {boolean} [settings.enableLastButton = true] If false the last button will be disabled (standalone mode)
  * @param {boolean} [settings.onLastPage] Call back function for next page button click
  * @param {boolean} [settings.indeterminate = false] If true will not show anything that lets you go to a specific page (deprecated for standalone)
  * @param {boolean} [settings.firstPageTooltip = 'First Page'] Tooltip for the first page, defaults to an internally translated tooltip.
  * @param {boolean} [settings.previousPageTooltip = 'Previous Page'] Tooltip for the first page, defaults to an internally translated tooltip.
  * @param {boolean} [settings.nextPageTooltip = 'Next Page'] Tooltip for the first page, defaults to an internally translated tooltip.
  * @param {boolean} [settings.lastPageTooltip = 'Last Page'] Tooltip for the first page, defaults to an internally translated tooltip.
  */
  var PAGER_DEFAULTS = {
    componentAPI: undefined,
    type: 'list',
    position: 'bottom',
    activePage: 1,
    hideOnOnePage: false,
    source: null,
    pagesize: 15,
    pagesizes: [15, 25, 50, 75],
    showPageSizeSelector: true,
    smallPageSizeSelector: false,
    onPageSizeChange: null,
    showFirstButton: true,
    enableFirstButton: true,
    showPreviousButton: true,
    enablePreviousButton: true,
    showNextButton: true,
    enableNextButton: true,
    showLastButton: true,
    enableLastButton: true,
    indeterminate: false,
    onFirstPage: null,
    onPreviousPage: null,
    onNextPage: null,
    onLastPage: null,
    firstPageTooltip: 'FirstPage',
    previousPageTooltip: 'PreviousPage',
    nextPageTooltip: 'NextPage',
    lastPageTooltip: 'LastPage'
  };

  function Pager(element, settings) {
    this.settings = utils.mergeSettings(element, settings, PAGER_DEFAULTS);
    this.settings.dataset = settings.dataset; // by pass deep copy
    this.element = $(element);
    this.init();
  }

  Pager.prototype = {

    /**
     * Displays the current state of the pager. Replaces `pagingInfo` object.
     * @returns {object} containing various state properties.
     */
    get state() {
      var total = 0;
      var pages = 1;
      var filteredPages = void 0;
      var filteredTotal = void 0;
      var grandTotal = void 0;
      var indeterminate = this.settings.indeterminate;
      var indeterminatePageCount = 999999999;
      var pagesize = this.settings.pagesize;
      var type = this.previousOperation;
      var trigger = this.previousTrigger;
      var ds = this.settings.dataset;

      // pass in total number of records
      if (!isNaN(this.serverDatasetTotal)) {
        total = this.serverDatasetTotal;
      } else if (ds && ds.length) {
        total = ds.length;
        if (this.isFilteredClientside) {
          var filteredDs = ds.filter(function (i) {
            return !i.isFiltered;
          });
          total = filteredDs.length;
        }
      }

      if (this.grandTotal) {
        grandTotal = this.grandTotal;
      }

      // calculate number of pages
      if (indeterminate) {
        pages = indeterminatePageCount;
      } else if (total < 1) {
        pages = 1;
      } else {
        pages = Math.ceil(total / pagesize);
      }

      // calculate number of filtered pages, if applicable
      if (!isNaN(this.filteredTotal)) {
        filteredTotal = this.filteredTotal;
        if (indeterminate) {
          pages = indeterminatePageCount;
        } else if (filteredTotal < 1) {
          filteredPages = 1;
        } else {
          filteredPages = Math.ceil(filteredTotal / pagesize);
        }
      }

      return {
        activePage: this.activePage,
        indeterminate: this.settings.indeterminate,
        grandTotal: grandTotal,
        pagesize: pagesize,
        pages: pages,
        trigger: trigger,
        total: total,
        type: type,
        filteredActivePage: this.filteredActivePage,
        filteredTotal: filteredTotal,
        filteredPages: filteredPages
      };
    },

    /**
     * This method is slated to be removed in a future v4.21.0 or v5.0.0.
     * (See https://github.com/infor-design/enterprise/issues/922)
     * @deprecated as of v4.15.0.  Please use the `state` property instead.
     * @returns {object} containing various state properties
     */
    get pagingInfo() {
      warnAboutDeprecation('state', 'pagingInfo');
      return this.state;
    },

    /**
     * @returns {Array} of HTMLElements representing focusable elements in the pager
     */
    get focusableElements() {
      return utils.getArrayFromList(this.pagerBar[0].querySelectorAll(FOCUSABLE_SELECTOR));
    },

    /**
     * @returns {Array|undefined} containing references to numeric paging buttons, if enabled
     */
    get numberButtons() {
      if (this.isTable) {
        return undefined;
      }
      var numberButtonSelector = 'li:not(.pager-prev):not(.pager-next):not(.pager-first):not(.pager-last):not(.pager-pagesize)';
      var buttons = this.pagerBar[0].querySelectorAll(numberButtonSelector);
      return utils.getArrayFromList(buttons);
    },

    /**
     * @returns {HTMLElement|undefined} the input field used for selecting pages, if enabled
     */
    get pageSelectorInput() {
      if (this.isListView) {
        return undefined;
      }
      return this.pagerBar[0].querySelector('.pager-count input');
    },

    /**
     * @returns {HTMLElement|undefined} the button used to select from a list of page sizes, if enabled
     */
    get pageSizeSelectorButton() {
      if (!this.settings.showPageSizeSelector) {
        return undefined;
      }
      return this.pagerBar[0].querySelector('.pager-pagesize button');
    },

    /**
     * @returns {boolean} if true, shows the condensed version of the Page Size
     * Selector Button for smaller viewing areas.
     */
    get showSmallPageSizeSelector() {
      if (!this.settings.showPageSizeSelector) {
        return false;
      }
      if (this.settings.smallPageSizeSelector === true) {
        return true;
      }
      return this.isListView && this.element.parents('.list-detail').length;
    },

    /**
     * Init the pager.
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup();
      this.createPagerBar();
      this.setActivePage(this.settings.activePage, true); // Get First Page
      this.handleEvents();
    },


    /**
     * Setting the internals of the pager.
     * @private
     * @returns {void}
     */
    setup: function setup() {
      // Check for legacy data attributes
      if (this.element.attr('data-pagesize')) {
        var pagesize = Number(this.element.attr('data-pagesize'));
        if (!isNaN(pagesize)) {
          this.settings.pagesize = pagesize;
        }
        this.element.removeAttr('data-pagesize');
      }

      // Add [pagesize] if not found in [pagesizes]
      if (this.settings.pagesizes.indexOf(this.settings.pagesize) === -1) {
        var sortNumber = function sortNumber(a, b) {
          return a - b;
        };
        this.settings.pagesizes.push(this.settings.pagesize);
        this.settings.pagesizes = this.settings.pagesizes.sort(sortNumber);
      }

      var widgetContainer = this.element.parents('.card, .widget');

      // Adjust for the possibility of the pager being attached to a Table instead
      // of normal grid markup
      if (this.element.is('tbody')) {
        this.isTable = true;
        this.settings.type = 'table';
        this.mainContainer = this.element.closest('.datagrid-container');

        if (!this.settings.componentAPI) {
          this.settings.componentAPI = this.mainContainer.data('datagrid');
        }

        if (widgetContainer.length) {
          widgetContainer[0].classList.add('has-datagrid');
        }
      }

      // If contained by a widget/card container, build some settings for that
      var listviewContainer = this.element.is('.listview');
      if (listviewContainer) {
        this.isTable = false;
        this.isListView = true;
        this.mainContainer = this.element;

        if (!this.settings.componentAPI) {
          this.settings.componentAPI = this.element.data('listview');
        }
      }

      return this;
    },


    /**
     * Add the pager dom elements.
     * @private
     */

    createPagerBar: function createPagerBar() {
      if (this.pagerBar) {
        return;
      }
      this.pagerBar = this.element.prev('.pager-toolbar');

      if (this.pagerBar.length === 0) {
        this.pagerBar = $('<ul class="pager-toolbar"></ul>');
      }

      if (this.settings.type === 'standalone') {
        if (this.isListView) {
          this.mainContainer.after(this.pagerBar);
        } else {
          this.element.append(this.pagerBar);
        }
      } else if (this.isTable) {
        this.mainContainer.after(this.pagerBar);
      } else if (this.settings.position === 'bottom') {
        this.element.after(this.pagerBar);
      } else {
        this.element.before(this.pagerBar);
      }

      if (this.isListView) {
        this.pagerBar.addClass('is-listview');
      }

      // Inside of Listviews, place the pager bar inside of the card/widget footer
      var widgetContainer = this.element.closest('.card, .widget');
      if (widgetContainer.length) {
        var self = this;
        var widgetTypes = ['widget', 'card'];

        widgetTypes.forEach(function (type) {
          var widgetContent = self.element.closest('.' + type + '-content');
          if (!widgetContent.length) {
            return;
          }

          var widgetFooter = widgetContent.next('.' + type + '-footer');
          if (!widgetFooter.length) {
            widgetFooter = $('<div class="' + type + '-footer"></div>').insertAfter(widgetContent);
          }

          self.pagerBar.appendTo(widgetFooter);
        });
      }
    },


    /**
     * Attach All relevant events
     * @private
     */
    handleEvents: function handleEvents() {
      var self = this;

      // Attach button click and touch
      this.pagerBar.on('click.pager', 'a', function (e) {
        var a = e.currentTarget;
        var li = a.parentNode;

        e.preventDefault();

        if ($(this).attr('disabled')) {
          return false;
        }

        // If this is a filtered dataset, use the `filteredTotal` instead
        var state = self.state;
        var currentPage = state.activePage;
        if (state.filteredTotal) {
          currentPage = state.filteredActivePage;
        }

        if (DOM.hasClass(li, 'pager-prev')) {
          self.setActivePage(currentPage - 1, false, 'prev');
          self.triggerPagingEvents(currentPage);
          return false;
        }

        if (DOM.hasClass(li, 'pager-next')) {
          self.setActivePage((currentPage === -1 ? 1 : currentPage) + 1, false, 'next');
          self.triggerPagingEvents(currentPage);
          return false;
        }

        if (DOM.hasClass(li, 'pager-first')) {
          self.setActivePage(1, false, 'first');
          self.triggerPagingEvents(currentPage);
          return false;
        }

        if (DOM.hasClass(li, 'pager-last')) {
          self.setActivePage(self.pageCount(), false, 'last'); // TODO Calculate Last Page?
          self.triggerPagingEvents(currentPage);
          return false;
        }

        // Go to the page via the applied `data-page` attribute of the button
        var activePageIdx = Number(a.getAttribute('data-page'));
        if (isNaN(activePageIdx) || activePageIdx < 1) {
          activePageIdx = 1;
        }
        self.setActivePage(activePageIdx, false, 'page');
        self.triggerPagingEvents(currentPage);
        return false;
      });

      self.pagerBar.on('keydown.pager', $(self.focusableElements), function (event) {
        event = event || window.event;
        var key = event.which || event.keyCode || event.charCode || false;
        var isLeft = key === 37 || key === 40;
        var isRight = key === 39 || key === 38;

        var elem = event.target;
        if (elem.nodeName === 'INPUT') {
          // work on up down key
          isLeft = key === 40;
          isRight = key === 38;
        }

        if (!isLeft && !isRight) {
          return true;
        }

        var parent = elem.nodeName === 'INPUT' ? elem.parentNode.parentNode : elem.parentNode;
        var next = parent.nextSibling;
        var prev = parent.previousSibling;
        var isFirst = prev === null;
        var isLast = next === null;

        event.preventDefault();

        if (isLeft && !isFirst) {
          var link = prev.querySelector('a, button, input');
          link.removeAttribute('tabindex');
          elem.setAttribute('tabindex', '-1');
          link.focus();
          return false;
        }

        if (isLeft && isFirst) {
          var _link = parent.parentNode.lastChild.querySelector('a, button, input');
          _link.removeAttribute('tabindex');
          elem.setAttribute('tabindex', '-1');
          _link.focus();
          return false;
        }

        if (isRight && !isLast) {
          var _link2 = next.querySelector('a, button, input');
          _link2.removeAttribute('tabindex');
          elem.setAttribute('tabindex', '-1');
          _link2.focus();
          return false;
        }

        if (isRight && isLast) {
          var _link3 = parent.parentNode.firstChild.querySelector('a, button, input');
          _link3.removeAttribute('tabindex');
          elem.setAttribute('tabindex', '-1');
          _link3.focus();
        }

        return false;
      });
    },


    /**
     * Resets the pager to its original settings
     * @param {string} [operation=undefined] optional informational string that describes the purpose of a filtering operation
     * @param {string} [trigger=undefined] optional information string that describes the reason for the reset
     * @returns {void}
     */
    reset: function reset(operation, trigger) {
      this.activePage = this.settings.activePage;
      this.previousOperation = operation;
      this.previousTrigger = trigger;

      this.teardown();
      this.init();
    },


    /**
     * Show page size selector
     * @param  {boolean} toggleOption Toggle vs show
     */
    showPageSizeSelector: function showPageSizeSelector(toggleOption) {
      toggleOption = ('' + toggleOption).toLowerCase() === 'true';
      this.settings.showPageSizeSelector = toggleOption;

      if (toggleOption) {
        this.isShowPageSizeSelectorCall = toggleOption;
      }
    },


    /**
     * Shows or hides a specified special control button on the Pager.
     * @param {string} [type] the type of button to target.
     * @param {boolean} toggleOption Show vs. Hide
     */
    showButton: function showButton(type, toggleOption) {
      // Determine the correct button
      var types = ['first', 'last', 'next', 'previous'];
      if (types.indexOf(type) === -1) {
        return;
      }
      var selector = '.pager-' + type + ' a';
      if (type === 'previous') {
        selector = '.pager-prev a';
      }

      // Get anchor/option
      var a = this.pagerBar[0].querySelector(selector);
      toggleOption = ('' + toggleOption).toLowerCase() === 'true';

      // Set the value in the settings
      this.settings['show' + stringUtils.capitalize(type) + 'Button'] = toggleOption;

      // If the button hasn't been rendered, don't alter the DOM.
      if (!a) {
        return;
      }

      // Change the DOM
      if (toggleOption) {
        a.parentNode.classList.remove('hidden');
      } else {
        a.parentNode.classList.add('hidden');
      }
    },


    /**
     * Enables or disables a specified special control button on the Pager.
     * @param {string} [type] the type of button to target.
     * @param {boolean} toggleOption Enable vs. Disable
     */
    enableButton: function enableButton(type, toggleOption) {
      // Determine the correct button
      var types = ['first', 'last', 'next', 'previous'];
      if (types.indexOf(type) === -1) {
        return;
      }
      var selector = '.pager-' + type + ' a';
      if (type === 'previous') {
        selector = '.pager-prev a';
      }

      // Get anchor/option
      var a = this.pagerBar[0].querySelector(selector);
      toggleOption = ('' + toggleOption).toLowerCase() === 'true';

      // Set the value in the settings
      this.settings['enable' + stringUtils.capitalize(type) + 'Button'] = toggleOption;

      // If the button hasn't been rendered, don't alter the DOM.
      if (!a) {
        return;
      }

      // Change the DOM
      if (toggleOption) {
        a.disabled = false;
        a.parentNode.classList.remove('is-disabled');
        $(a).removeAttr('disabled');
      } else {
        a.disabled = true;
        a.parentNode.classList.add('is-disabled');
        $(a).attr('disabled', 'disabled');
      }
    },


    /**
     * Set or Get Current Page.
     * @param {number|object} pagingInfo a number representing a page, or a state object with an `activePage` property
     * @param {boolean} force Force the update
     * @param {string} op The paging operation type.
     * @returns {void}
     */
    setActivePage: function setActivePage(pagingInfo, force, op) {
      var useFiltering = typeof pagingInfo.searchActivePage === 'number' || typeof pagingInfo.filteredActivePage === 'number' || typeof this.filteredActivePage === 'number';

      var pageNum = this.filteredActivePage || this.activePage || this.settings.activePage;
      if ((typeof pagingInfo === 'undefined' ? 'undefined' : _typeof(pagingInfo)) === 'object') {
        if (useFiltering) {
          pageNum = pagingInfo.filteredActivePage || pagingInfo.searchActivePage;
        } else if (pagingInfo.activePage) {
          pageNum = pagingInfo.activePage;
        } else {
          pageNum = 1;
        }
      } else if (!isNaN(pagingInfo)) {
        pageNum = pagingInfo;
      }

      // Set the active page interally and render the new state.
      // If working against a filtered dataset, use the filtered active page instead of
      // the standard one.
      if (useFiltering) {
        this.filteredActivePage = pageNum;
      } else {
        this.activePage = pageNum;
      }

      this.previousOperation = op;
      this.render();

      // If any of the following conditions are met, don't rerender the pages.
      // Only rerender the pager bar.
      if (pageNum === undefined || pageNum === 0 || isNaN(pageNum) || pageNum === this.activePage && !force) {
        return this.activePage;
      }

      // TODO: This is datagrid specific, need to move this specifically back there
      if (this.settings.componentAPI && this.settings.componentAPI.saveUserSettings) {
        this.settings.componentAPI.saveUserSettings();
      }

      return pageNum;
    },


    /**
     * Adjust an integer representing a Page Number to fit within the boundaries of the page count limits
     * @param {number} [pageNum=1] the incoming number to be analyzed
     * @returns {number} the adjusted value
     */
    adjustPageCount: function adjustPageCount(pageNum) {
      var state = this.state;
      var useFiltering = typeof state.filteredActivePage === 'number' || typeof this.filteredActivePage === 'number';

      // Never go above the total number of pages (determined internally by the state,
      // or externally by the incoming `pagingInfo` object)
      var totalPages = state.pages;
      if (useFiltering && state.filteredPages) {
        totalPages = state.filteredPages;
      }

      // If the page number provided is out of bounds, reset it to the one previously set.
      if (pageNum < 1 || pageNum > totalPages) {
        pageNum = this.filteredActivePage || this.activePage;
      }

      return pageNum;
    },


    /**
    * Fires when the page size changer is used.
    * @event pagesizechange
    * @memberof Pager
    * @property {object} event - The jquery event object
    * @property {function} request - Various paging info
    */
    /**
     * Get the Total Number of pages
     * @private
     * @param  {object} pages The pages to set.
     * @returns {void}
     */
    pageCount: function pageCount(pages) {
      var isShowPageSizeSelectorCall = this.isShowPageSizeSelectorCall;

      // Remove call, after cached
      delete this.isShowPageSizeSelectorCall;

      if (pages === undefined && this.settings.indeterminate) {
        this._pageCount = this.settings.pagesize; //eslint-disable-line
      }

      if (pages === undefined && !this.settings.source && !isShowPageSizeSelectorCall) {
        return this._pageCount; //eslint-disable-line
      }

      if (pages !== undefined) {
        this._pageCount = pages; //eslint-disable-line
      }

      this._pageCount = this._pageCount || 1;
      if (this.settings.indeterminate) {
        return 999999999;
      }
      return this._pageCount;
    },


    /**
     * Renders a row of numbers that can be used to select pages (Blockgrid/Listview)
     * @returns {void}
     */
    renderButtons: function renderButtons() {
      // Only certain types of Pages get to have the `last` and `first` buttons
      // const types = ['table', 'pageof', 'firstlast', 'standalone'];
      // const canHaveFirstLastButtons = types.indexOf(this.settings.type) > -1 || !this.isListView;
      var activePage = this.activePage;
      var totalPages = this.state.pages;
      var buttonHTML = '';
      var doRenderFirstButton = false;
      var doRenderPreviousButton = false;
      var doRenderNextButton = false;
      var doRenderLastButton = false;
      var disableFirstButton = !this.settings.enableFirstButton;
      var disablePreviousButton = !this.settings.enablePreviousButton;
      var disableNextButton = !this.settings.enableNextButton;
      var disableLastButton = !this.settings.enableLastButton;

      var disableFirstIndeterminate = this.settings.indeterminate && this.firstPage === true;
      var disableLastIndeterminate = this.settings.indeterminate && this.lastPage === true;
      var hasDataset = this.settings.dataset && this.settings.dataset.length;

      // If this is a filtered dataset, use the `filteredTotal` instead
      if (this.state.filteredPages) {
        activePage = this.state.filteredActivePage;
        totalPages = this.state.filteredPages;
      }

      // Determine whether or not special navigation buttons should eventually be rendered
      // First Button
      if (this.settings.showFirstButton) {
        if (disableFirstIndeterminate || !this.settings.indeterminate && this.settings.type !== 'standalone' && activePage === 1) {
          disableFirstButton = true;
        }
        doRenderFirstButton = true;
      }
      // Previous Button
      if (this.settings.showPreviousButton) {
        if (disableFirstIndeterminate || !this.settings.indeterminate && this.settings.type !== 'standalone' && activePage === 1) {
          disablePreviousButton = true;
        }
        doRenderPreviousButton = true;
      }
      // Next Button
      if (this.settings.showNextButton) {
        if (disableLastIndeterminate || !this.settings.indeterminate && this.settings.type !== 'standalone' && activePage === totalPages) {
          disableNextButton = true;
        }
        doRenderNextButton = true;
      }
      // Last Button
      if (this.settings.showLastButton) {
        if (disableLastIndeterminate || !this.settings.indeterminate && this.settings.type !== 'standalone' && activePage === totalPages) {
          disableLastButton = true;
        }
        doRenderLastButton = true;
      }

      var AVG_BUTTON_WIDTH = 40;
      var AVG_PAGESIZESELECTOR_WIDTH = 190;
      var buttonsToRender = [];

      var pageSizeButtonSize = this.settings.showPageSizeSelector ? AVG_PAGESIZESELECTOR_WIDTH : 0;
      var availableButtonWidth = (this.pagerBar.width() - pageSizeButtonSize) / AVG_BUTTON_WIDTH;

      // `maxAllowedButtons` does not include the Page Size Selector.
      // Subtract an allowed number button for each set of special controls.
      var maxAllowedButtons = Math.floor(availableButtonWidth);
      var maxNumberButtons = maxAllowedButtons;
      if (doRenderPreviousButton || doRenderNextButton) {
        maxNumberButtons -= 1;
      }
      if (doRenderLastButton || doRenderFirstButton) {
        maxNumberButtons -= 1;
      }

      // Disable first/last if we can display all available page numbers
      if (!this.isTable && this.settings.type !== 'standalone' && hasDataset && maxNumberButtons >= totalPages) {
        disableFirstButton = true;
        disableLastButton = true;
      }

      // Figure out the distance on either side of the median value of the number button array.
      // If either index goes out of page boundaries, shift the array to fit the same
      // number of pages by adding to the opposite side.
      if (!this.settings.indeterminate) {
        var maxDistanceFromCenter = Math.floor(maxNumberButtons / 2);
        var startIndex = activePage - maxDistanceFromCenter;
        var endIndex = activePage + maxDistanceFromCenter;
        while (startIndex < 1) {
          ++startIndex;
          if (endIndex < totalPages) {
            ++endIndex;
          }
        }
        while (endIndex > totalPages) {
          if (startIndex > 1) {
            --startIndex;
          }
          --endIndex;
        }
        for (var i = startIndex; i < endIndex + 1; i++) {
          buttonsToRender.push(i);
        }
      }

      function renderButton() {
        var visibleContent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var audibleContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var tooltipContent = arguments[2];
        var targetPageNum = arguments[3];
        var classAttr = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
        var selected = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
        var disabled = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
        var hidden = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;

        var isAriaSelected = '';
        var isAriaDisabled = '';
        var isControlDisabled = '';
        var titleAttr = '';
        var pageAttr = '';

        if (targetPageNum) {
          pageAttr = ' data-page="' + targetPageNum + '"';
        }
        if (hidden) {
          classAttr += ' hidden';
        }
        if (selected) {
          classAttr += ' selected';
          isAriaSelected = ' aria-selected="true"';
          isAriaDisabled = ' aria-disabled="true"';
        }
        if (disabled) {
          isControlDisabled = ' disabled';
          isAriaDisabled = ' aria-disabled="true"';
        }
        if (tooltipContent) {
          titleAttr = ' title="' + tooltipContent + '"';
        }

        var html = '<li class="' + classAttr + '"' + isAriaSelected + '>\n        <a' + titleAttr + pageAttr + ' href="#"' + isAriaDisabled + isControlDisabled + '>\n          <span class="audible">' + audibleContent + ' </span>' + visibleContent + '\n        </a>\n      </li>';

        return html;
      }

      // Remove all existing buttons
      $(this.numberButtons).remove();

      // First Button
      if (doRenderFirstButton) {
        buttonHTML += renderButton($.createIcon({ icon: 'first-page' }), Locale.translate('FirstPage'), this.settings.firstPageTooltip, null, 'pager-first', false, disableFirstButton, false);
      }

      // Previous Button
      if (doRenderPreviousButton) {
        buttonHTML += renderButton($.createIcon({ icon: 'previous-page' }), Locale.translate('PreviousPage'), this.settings.previousPageTooltip, null, 'pager-prev', false, disablePreviousButton, false);
      }

      // Draw all relevant page numbers, if applicable
      // Page Number Buttons are only rendered if there is visible space available to fit them.
      if (!this.isTable && hasDataset) {
        var numberButtonHTML = '';
        buttonsToRender.forEach(function (i) {
          if (i === (activePage || 1)) {
            numberButtonHTML += renderButton(i, Locale.translate('PageOn'), null, i, 'pager-no', true, false, false);
          } else {
            numberButtonHTML += renderButton(i, Locale.translate('Page'), null, i, 'pager-no', false, false, false);
          }
        });
        buttonHTML += numberButtonHTML;
      }

      // Next Button
      if (doRenderNextButton) {
        buttonHTML += renderButton($.createIcon({ icon: 'next-page' }), Locale.translate('NextPage'), this.settings.nextPageTooltip, null, 'pager-next', false, disableNextButton, false);
      }

      // Last Button
      if (doRenderLastButton) {
        buttonHTML += renderButton($.createIcon({ icon: 'last-page' }), Locale.translate('LastPage'), this.settings.lastPageTooltip, null, 'pager-last', false, disableLastButton, false);
      }

      // Render all elements into the pager container element
      this.pagerBar[0].innerHTML = buttonHTML;

      if (!doRenderLastButton && !doRenderFirstButton && !this.settings.showPageSizeSelector) {
        this.pagerBar[0].classList.add('two-button');
      } else {
        this.pagerBar[0].classList.remove('two-button');
      }

      // Invoke all sub-components
      this.pagerBar.children('li').children('a').button().tooltip();
    },


    /**
     * Renders an input-field based page selector (Datagrid only)
     * @returns {void}
     */
    renderPageSelectorInput: function renderPageSelectorInput() {
      if (!this.isTable || this.settings.indeterminate) {
        return;
      }

      var activePage = this.activePage;
      var totalPages = this.state.pages || 1;

      // If this is a filtered dataset, use the `filteredTotal` instead
      if (this.state.filteredPages) {
        activePage = this.state.filteredActivePage;
        totalPages = this.state.filteredPages;
      }

      if (!this.pageSelectorInput) {
        var text = Locale.translate('PageOf');
        text = text.replace('{0}', '<input class="new-mask" name="pager-pageno" value="' + activePage + '" autocomplete="off">');
        text = text.replace('{1}', '<span class="pager-total-pages">' + totalPages + '</span>');
        $('<li class="pager-count"><label>' + text + ' </label>').insertAfter(this.pagerBar.find('.pager-prev'));
      } else {
        // Update the total number of pages
        if (totalPages > 1) {
          this.pagerBar.find('.pager-total-pages').text(totalPages);
        }
        // Update the input field's number
        this.pagerBar.find('.pager-count input').val(activePage);
      }

      var lastValue = null;
      var pattern = ('' + totalPages).replace(/\d/g, '#');
      var self = this;
      var maskSettings = {
        pattern: pattern,
        mode: 'number',
        processOnInitialize: false
      };

      function update(elem) {
        var newValue = self.adjustPageCount(parseInt(elem.val(), 10));
        if (lastValue === newValue) {
          elem.val(lastValue);
          return;
        }

        var currentPage = self.activePage;
        if (self.state.filteredPages) {
          currentPage = self.state.filteredActivePage;
        }
        elem.val(self.setActivePage(newValue, false, 'page'));
        self.triggerPagingEvents(currentPage);
      }

      $(this.pageSelectorInput).mask(maskSettings).on('focus', function () {
        lastValue = parseInt($(this).val(), 10);
      }).on('blur', function () {
        update($(this));
        lastValue = null;
      }).on('keydown', function (e) {
        if (e.which === 13) {
          update($(this));
          e.stopPropagation();
          e.preventDefault();
          return false;
        }
        return true;
      });
    },


    /**
     * Displays a Page Size Selector button as part of the pager bar
     * @returns {void}
     */
    renderPageSizeSelectorButton: function renderPageSizeSelectorButton() {
      var _this = this;

      if (!this.settings.showPageSizeSelector || this.settings.pagesizes.length < 2) {
        return;
      }

      if (!this.pageSizeSelectorButton) {
        var pageSizeLi = $('<li class="pager-pagesize"></li>');
        var dropdownIcon = $.createIcon({ icon: 'dropdown' });
        var translatedText = Locale.translate('RecordsPerPage').replace('{0}', this.settings.pagesize);
        var isAudible = '';
        var recordHtml = '<span>' + translatedText + '</span>';

        // Change to the condensed layout, if applicable
        if (this.showSmallPageSizeSelector) {
          isAudible = ' class="audible"';
          translatedText = Locale.translate('RecordsPerPage').replace('{0}', '');
          recordHtml = '<span class="record-count">' + this.settings.pagesize + '</span>\n        <span' + isAudible + '>' + translatedText + '</span>';
        }

        // Render the button
        var pageSizeButton = $('<button type="button" class="btn-menu">\n        ' + recordHtml + '\n        ' + dropdownIcon + '\n      </button>').appendTo(pageSizeLi);
        pageSizeLi.appendTo(this.pagerBar);

        // Render menu items that render available records per page
        var menuItems = '';
        if (this.showSmallPageSizeSelector) {
          menuItems = '<li class="heading">' + translatedText + '</li>';
        }
        for (var k = 0; k < this.settings.pagesizes.length; k++) {
          var size = this.settings.pagesizes[k];
          menuItems += '<li class="' + (size === this.settings.pagesize ? ' is-checked' : '') + '"><a href="#">' + size + '</a></li>';
        }
        var menu = $('<ul class="popupmenu is-selectable">' + menuItems + '</ul>');
        pageSizeButton.after(menu);

        var popupOpts = {
          placementOpts: {
            parent: pageSizeButton,
            parentXAlignment: Locale.isRTL() ? 'left' : 'right',
            strategies: ['flip']
          }
        };

        pageSizeButton.popupmenu(popupOpts);
      }

      $(this.pageSizeSelectorButton).on('selected.pager', function (e, args) {
        _this.changePageSize(args);
      });
    },


    /**
     * Renders the contents of the pager bar
     * @returns {void}
     */
    render: function render() {
      // Adjust Page count numbers
      var state = this.state;
      var totalPages = state.pages;
      if (state.filteredPages) {
        totalPages = state.filteredPages;
      }
      this.pageCount(totalPages);

      this.renderButtons();
      this.renderPageSelectorInput();
      this.renderPageSizeSelectorButton();
      this.renderBar();
    },


    /**
     * Renders the pager bar based on derived or forced settings.
     * @private
     * @param {SohoPagingInfo} pagingInfo - an object containing information on how to render the pager.
     * @returns {undefined}
     */
    renderBar: function renderBar(pagingInfo) {
      if (!pagingInfo) {
        pagingInfo = this.state;
      } else {
        pagingInfo = utils.extend({}, this.state, pagingInfo);
      }

      var activePage = pagingInfo.activePage;
      if (pagingInfo.filteredActivePage) {
        activePage = pagingInfo.filteredActivePage;
      }

      // hide buttons feature
      if (!this.settings.showFirstButton) {
        this.showButton('first', false);
      }

      if (!this.settings.enableFirstButton) {
        this.enableButton('first', false);
      }

      if (!this.settings.showPreviousButton) {
        this.showButton('previous', false);
      }

      if (!this.settings.enablePreviousButton) {
        this.enableButton('previous', false);
      }

      if (!this.settings.showNextButton) {
        this.showButton('next', false);
      }

      if (!this.settings.enableNextButton) {
        this.enableButton('next', false);
      }

      if (!this.settings.showLastButton) {
        this.showButton('last', false);
      }

      if (!this.settings.enableLastButton) {
        this.enableButton('last', false);
      }

      if (this.settings.showPageSizeSelector) {
        this.showPageSizeSelector(true);
      }

      // Explicit true/false when using `firstPage` or `lastPage` will force the state
      // on the specified set of buttons to change.
      if (pagingInfo.firstPage !== undefined) {
        // First/Prev page
        if (pagingInfo.firstPage === false) {
          this.enableButton('first', true);
          this.enableButton('previous', true);
        }
        if (pagingInfo.firstPage === true || activePage === 1) {
          this.enableButton('first', false);
          this.enableButton('previous', false);
        }
      }

      if (pagingInfo.lastPage !== undefined) {
        // Next/Last Page
        if (pagingInfo.lastPage === false) {
          this.enableButton('next', true);
          this.enableButton('last', true);
        }
        if (pagingInfo.lastPage === true || activePage === this.pageCount()) {
          this.enableButton('next', false);
          this.enableButton('last', false);
        }
      }

      if (this.hidePagerBar(pagingInfo)) {
        this.pagerBar[0].classList.add('hidden');
      }

      this.initTabIndexes();
    },


    /**
     * Sync the tabindexes
     * @private
     */
    initTabIndexes: function initTabIndexes() {
      var tabbables = $(this.focusableElements);
      tabbables.attr('tabindex', '-1');
      tabbables.filter(':not([disabled])').first().removeAttr('tabindex');
    },


    /**
    * Fires when the first page button is clicked.
    * @event firstpage
    * @memberof Pager
    * @property {object} event - The jquery event object
    * @property {function} request - Various paging info
    */
    /**
    * Fires when the previous page button is clicked.
    * @event previouspage
    * @memberof Pager
    * @property {object} event - The jquery event object
    * @property {function} request - Various paging info
    */
    /**
    * Fires when the next page button is clicked.
    * @event nextpage
    * @memberof Pager
    * @property {object} event - The jquery event object
    * @property {function} request - Various paging info
    */
    /**
     *Fires when the last page button is clicked.
     * @event lastpage
     * @memberof Pager
     * @property {object} event - The jquery event object
     * @property {function} request - Various paging info
     */
    /**
     * @private
     * Triggers the `page` event, along with other special events.  Also runs associated callbacks.
     * @param {number} [previousActivePage=undefined] if defined, sets a previous page value for determining some event triggers
     * @returns {void}
     */
    triggerPagingEvents: function triggerPagingEvents(previousActivePage) {
      var state = this.state;
      if (!previousActivePage) {
        previousActivePage = this.state.activePage;
      }

      // Trigger events for specific special pages, and always trigger the `page` event
      // containing the new pager state.
      if (state.type === 'first') {
        // First Page
        if (this.settings.onFirstPage) {
          this.settings.onFirstPage(this, state);
        }
        this.element.trigger('firstpage', state);
      }
      if (state.type === 'prev') {
        // Previous Page
        if (this.settings.onPreviousPage) {
          this.settings.onPreviousPage(this, state);
        }
        this.element.trigger('previouspage', state);
      }
      if (state.type === 'next') {
        // Next Page
        if (this.settings.onNextPage) {
          this.settings.onNextPage(this, state);
        }
        this.element.trigger('nextpage', state);
      }
      if (state.type === 'last') {
        // Last Page
        if (this.settings.onLastPage) {
          this.settings.onLastPage(this, state);
        }
        this.element.trigger('lastpage', state);
      }

      if (state.type === 'pageinfo') {
        return;
      }

      this.element.trigger('page', state);
    },


    /**
     * Update the component and optionally apply new settings.
     * @param  {object} settings the settings to update to.
     * @returns {object} The plugin api for chaining.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }
      if (Array.isArray(settings.pagesizes) && settings.pagesizes.length) {
        this.settings.pagesizes = settings.pagesizes;
      }

      // Limit updated paging info to a specific subset
      var pagingInfo = {
        activePage: this.settings.activePage,
        indeterminate: this.settings.indeterminate,
        pagesize: this.settings.pagesize
      };

      this.updatePagingInfo(pagingInfo);
      return this;
    },


    /**
     * Changes the size of the visible page
     * @param {jQuery} anchor containing a reference to the jQuery-wrapped popupmenu menu item element that was chosen.
     * @returns {void}
     */
    changePageSize: function changePageSize(anchor) {
      var tag = anchor;
      tag.closest('.popupmenu').find('.is-checked').removeClass('is-checked');
      tag.parent('li').addClass('is-checked');
      this.settings.pagesize = parseInt(tag.text(), 10);

      if (this.settings.componentAPI) {
        this.settings.componentAPI.settings.pagesize = this.settings.pagesize;
      }
      this.setActivePage(1, true, 'first');

      if (this.settings.onPageSizeChange) {
        this.settings.onPageSizeChange(this, {
          tag: anchor,
          pagesize: this.settings.pagesize,
          settings: this.settings
        });
      }

      this.element.trigger('pagesizechange', {
        tag: anchor,
        pagesize: this.settings.pagesize,
        settings: this.settings
      });
    },


    /**
     * Updates this instance of pager with externally-provided settings.
     * @param {object} pagingInfo - contains settings that will change buttons on the pager.
     * @param {number} pagingInfo.pagesize - the number of items visible per page
     * @param {number} pagingInfo.total - the total number of pages
     * @param {number} pagingInfo.activePage - the currently visible page
     * @param {boolean} [pagingInfo.firstPage=false] - passed if the currently visible page is the
     * first one
     * @param {boolean} [pagingInfo.lastPage=false] - passed if the currently visible page is the
     * last one
     * @param {boolean} [pagingInfo.hideDisabledPagers=false] - causes the pager to become completely
     * hidden if all buttons are disabled
     * @param {boolean} [isResponse=false] if true, causes events not to be triggered (avoids infinite loops)
     * @returns {void}
     */
    updatePagingInfo: function updatePagingInfo(pagingInfo, isResponse) {
      if (!pagingInfo) {
        return;
      }

      // Grab and retain the pagesize
      if (pagingInfo.pagesize) {
        this.settings.pagesize = pagingInfo.pagesize;
        if (this.isTable && this.settings.componentAPI) {
          this.settings.componentAPI.settings.pagesize = pagingInfo.pagesize;
        }
      }

      // Detect client-side filtering in the other component's API
      if (pagingInfo.isFilteredClientside) {
        this.isFilteredClientside = true;
        delete this.serverDatasetTotal;
      } else if (this.isFilteredClientside) {
        delete this.isFilteredClientside;
      }

      // Explicitly setting `firstPage` or `lastPage` to true/false will cause pager buttons
      // to be forced enabled/disabled
      delete this.firstPage;
      delete this.lastPage;
      if (pagingInfo.firstPage !== undefined) {
        this.firstPage = pagingInfo.firstPage;
        this.settings.enableFirstButton = !pagingInfo.firstPage;
        this.settings.enablePreviousButton = !pagingInfo.firstPage;
      }
      if (pagingInfo.lastPage !== undefined) {
        this.lastPage = pagingInfo.lastPage;
        this.settings.enableNextButton = !pagingInfo.lastPage;
        this.settings.enableLastButton = !pagingInfo.lastPage;
      }

      // Track "grandTotal" for all records, including filtered-out, if applicable
      if (!isNaN(pagingInfo.grandTotal)) {
        this.grandTotal = pagingInfo.grandTotal;
      }

      // For server-side paging, retain a separate "total" for the server dataset.
      if (!this.isFilteredClientside) {
        this.serverDatasetTotal = pagingInfo.total;
      }

      // If the dataset is filtered, store some extra meta-data for the state.
      if (!isNaN(pagingInfo.filteredTotal)) {
        this.filteredTotal = pagingInfo.filteredTotal;
        this.filteredActivePage = pagingInfo.searchActivePage || pagingInfo.filteredActivePage || 1;
      } else if (this.filteredTotal || this.filteredActivePage) {
        delete this.filteredTotal;
        delete this.filteredActivePage;
      }

      if (!pagingInfo.type) {
        pagingInfo.type = 'pageinfo';
      }

      if (this.settings.source || this.settings.dataset) {
        // Set first and last page if passed
        // If we get a page number as a result, rendering has already happened and
        // we should not attempt to re-render.
        this.setActivePage(pagingInfo, false, pagingInfo.type);
        if (pagingInfo.type !== 'initial' && !isResponse) {
          this.triggerPagingEvents();
        }
        return;
      }

      this.teardown();
      this.render();
      this.handleEvents();
    },


    /**
     * Reclaim the pager height so that datagrid can use it's full container, if only one page.
     * @private
     * @param  {object} pagingInfo The pager states.
     * @returns {void}
     */
    hidePagerBar: function hidePagerBar(pagingInfo) {
      if (this.settings.hideOnOnePage && pagingInfo.total <= pagingInfo.pagesize) {
        return true;
      }

      if (pagingInfo.firstPage === true && pagingInfo.lastPage === true && pagingInfo.hideDisabledPagers) {
        return true;
      }

      return false;
    },


    /**
     * Removes all event listeners and generated HTML markup from the pager instance
     * @returns {void}
     */
    teardown: function teardown() {
      if (this.numberButtons) {
        this.numberButtons.forEach(function (li) {
          var a = li.querySelector('a');
          var buttonAPI = $(a).data('button');
          var tooltipAPI = $(a).data('tooltip');

          if (buttonAPI) {
            buttonAPI.destroy();
          }
          if (tooltipAPI) {
            tooltipAPI.destroy();
          }
        });
      }

      this.pagerBar.off(['click.' + COMPONENT_NAME$J, 'keydown.' + COMPONENT_NAME$J].join(' '));

      if (this.pageSelectorInput) {
        $(this.pageSelectorInput).off(['focus.' + COMPONENT_NAME$J, 'blur.' + COMPONENT_NAME$J, 'keydown.' + COMPONENT_NAME$J].join(' '));
        $(this.pageSelectorInput).data('mask').destroy();
      }

      if (this.pageSizeSelectorButton) {
        $(this.pageSizeSelectorButton).off('selected.' + COMPONENT_NAME$J);
        $(this.pageSizeSelectorButton).data('popupmenu').destroy();
      }

      this.pagerBar[0].innerHTML = '';

      delete this.firstPage;
      delete this.lastPage;
    },


    /**
     * Tear down and detatch all events
     */
    destroy: function destroy() {
      this.teardown();
      if (this.pagerBar) {
        this.pagerBar.remove();
      }
      $.removeData(this.element[0], COMPONENT_NAME$J);
    }
  };

  /**
   * jQuery Component Wrapper for pager
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.pager = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$J);
      if (!instance) {
        instance = $.data(this, COMPONENT_NAME$J, new Pager(this, settings));
      } else {
        instance.updated(settings);
      }
    });
  };

  var COMPONENT_NAME$K = 'listview';

  /**
   * Creates lists of small pieces of relevant, actionable information.
   * @class ListView
   * @constructor
   *
   * @param {jquery[]|htmlelement} element the base element
   * @param {object} [settings] incoming settings
   * @param {array} [settings.dataset] Array of data to feed the template
   * @param {string} [settings.template] Html Template String
   * @param {string} [settings.description] Audible Label (or use parent title)
   * @param {boolean} [settings.paging=false] If true, activates paging
   * @param {number} [settings.pagesize=10] If paging is activated, sets the number of listview items available per page
   * @param {boolean} [settings.searchable=false] If true, associates itself with a Searchfield/Autocomplete and allows itself to be filtered
   * @param {boolean} [settings.highlight=true] If false the highlighting of text when using searchable is disabled. You may want to disable this on larger lists.
   * @param {string|boolean} [settings.selectable='single'] selection mode, can be false, 'single', 'multiple' or 'mixed'
   * @param {boolean} [settings.selectOnFocus=true] If true the first item in the list will be selected as it is focused.
   * @param {boolean} [settings.showCheckboxes=true] If false will not show checkboxes used with multiple selection mode only
   * @param {boolean} [settings.hoverable=true] If true the list element will show a hover action to indicate its actionable.
   * @param {string} [settings.emptyMessage] Text to go in emptyMessage.
   * @param {function|string} [settings.source] If source is a string then it serves as
    the url for an ajax call that returns the dataset. If its a function it is a call back for getting the data asyncronously.
   * @param {boolean} [settings.forceToRenderOnEmptyDs=false] If true list will render as an empty list with ul tag, but not any li tags in it.
   * @param {boolean} [settings.disableItemDeactivation=false] If true when an item is
    activated the user should not be able to deactivate it by clicking on the activated item. They can only select another row.
   * @param {boolean} [settings.showPageSizeSelector=false] If true the page size select will be shown when paging.
   * @param {object} [settings.listFilterSettings=null] If defined as an object, passes settings into the internal ListFilter component
   * @param {object} [settings.pagerSettings=null] If defined as an object, passes settings into the internal Pager component
   */
  var LISTVIEW_DEFAULTS = {
    dataset: [],
    template: null,
    description: null,
    paging: false,
    pagesize: 10,
    searchable: false,
    highlight: true,
    selectable: 'single',
    selectOnFocus: true,
    showCheckboxes: true,
    hoverable: true,
    emptyMessage: null,
    source: null,
    forceToRenderOnEmptyDs: false,
    disableItemDeactivation: false,
    showPageSizeSelector: false,
    listFilterSettings: null,
    pagerSettings: {
      showFirstButton: false,
      showLastButton: false
    }
  };

  function ListView(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, LISTVIEW_DEFAULTS);
    this.init();

    return this;
  }

  ListView.prototype = {

    /**
     * @returns {Pager|undefined} Pager component instance, if one exists
     */
    get pagerAPI() {
      return this.element.data('pager');
    },

    /**
     * @returns {object} containing valid Pager Component settings
     */
    get pagerSettings() {
      var pagerSettings = {};
      if (this.settings.pagerSettings) {
        pagerSettings = this.settings.pagerSettings;
      }
      pagerSettings.dataset = this.settings.dataset;
      pagerSettings.source = this.settings.source;
      pagerSettings.type = 'list';

      // Backwards compatibility for direct pager settings
      var oldSettingTypes = ['pagesize', 'showPageSizeSelector'];
      for (var i = 0; i < oldSettingTypes.length; i++) {
        if (this.settings[oldSettingTypes[i]] !== undefined && !pagerSettings[oldSettingTypes[i]]) {
          pagerSettings[oldSettingTypes[i]] = this.settings[oldSettingTypes[i]];
        }
      }

      return pagerSettings;
    },

    /**
     * Initialize this component.
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup();
      this.handleEvents();
      this.refresh();
      this.selectedItems = [];
      this.lastSelectedItem = 0; // Rember index to use shift key
      this.isSelectedAll = false; // Rember if all selected or not
      this.sortInit('listview', 'click.listview', 'data-sortlist');
      this.handleResize();
    },


    /**
     * Do initial dom and settings setup.
     * @private
     * @returns {void}
     */
    setup: function setup() {
      var _this = this;

      var self = this;
      var card = this.element.closest('.card, .widget');
      var selectable = this.element.attr('data-selectable');
      var selectOnFocus = this.element.attr('data-select-onfocus');

      // Check for legacy data attributes
      if (this.element.attr('data-pagesize')) {
        var pagesize = Number(this.element.attr('data-pagesize'));
        if (!isNaN(pagesize)) {
          this.settings.pagesize = pagesize;
        }
        this.element.removeAttr('data-pagesize');
      }

      // Convert a DOM-based list into a stored dataset (legacy)
      if (!this.settings.dataset.length) {
        if (this.element.is('ul') && this.element.children('li').length) {
          var items = this.element.children('li');
          if (!this.settings.template) {
            this.settings.template = '{{#dataset}}<li>{{text}}</li>{{/dataset}}';
          }
          items.each(function (i, item) {
            _this.settings.dataset.push({ text: $(item).text() });
          });
          items.remove();
        }
      }

      // Search the global variable space for a dataset variable name, if provided.
      if (this.settings.dataset && typeof this.settings.dataset === 'string') {
        var globalDataset = window[this.settings.dataset];
        if (globalDataset && globalDataset.length) {
          this.settings.dataset = globalDataset;
        }
      }

      if (selectable && selectable.length) {
        this.settings.selectable = selectable;
      }

      if (selectOnFocus && selectOnFocus.length) {
        this.settings.selectOnFocus = JSON.parse(selectOnFocus);
      }

      self.actionButton = card.find('.btn-actions');

      if (self.actionButton.length > 0) {
        // Action Buttons may already be invoked via initialize.js.
        if (!self.actionButton.data('popupmenu')) {
          self.actionButton.popupmenu();
        }
      }

      this.element.attr({ tabindex: '-1', 'x-ms-format-detection': 'none' });

      // Configure Paging
      if (this.element.is('.paginated') || this.settings.paging === true) {
        this.element.pager(this.pagerSettings);
      }

      var cardWidgetContent = this.element.parent('.card-content, .widget-content');
      if (cardWidgetContent[0]) {
        cardWidgetContent[0].style.overflow = 'hidden';
      }

      // Add Aria Roles
      this.element.attr({
        role: 'listbox',
        'aria-label': this.settings.description || card.find('.card-title, .widget-title').text()
      });

      // Associate with an existing searchfield, if applicable
      if (this.settings.searchable) {
        this.searchfield = this.element.parent().find('.searchfield, .autocomplete');

        if (!this.searchfield.length) ;
        // TODO: Create Searchfield somehow


        // Setup the ListFilter with externally-defined settings, if applicable
        var listFilterSettings = {
          filterMode: 'contains'
        };
        if (_typeof(this.settings.listFilterSettings) === 'object') {
          listFilterSettings = utils.extend({}, listFilterSettings, this.settings.listFilterSettings);
        }

        this.listfilter = new ListFilter(listFilterSettings);
      }

      if (this.settings.emptyMessage) {
        // Object { title: "No Data Available", info: "", icon: "icon-empty-no-data" }
        self.emptyMessageContainer = $('<div>').emptymessage(this.settings.emptyMessage);
      }
    },


    /**
     * Calculate the totals for totalling examples.
     * This is displayed in the template by referencing {{totals}}.
     * @private
     * @param {array} dataset the incoming dataset
     * @returns {number} the total number of listview items.
     */
    getTotals: function getTotals(dataset) {
      var totals = { count: dataset.length };
      var property = void 0;

      if (!dataset[0]) {
        return undefined;
      }

      for (property in dataset[0]) {
        //eslint-disable-line
        totals[property] = 0;
      }

      for (var i = 0; i < dataset.length; i++) {
        for (property in dataset[i]) {
          //eslint-disable-line
          totals[property] += parseFloat(dataset[i][property]);
        }
      }
      return totals;
    },


    /**
     * Render the template against the dataset.
     * @private
     * @param {array} dataset  The dataset to use
     * @param {object} pagerInfo  Pager instructions
     */
    render: function render(dataset, pagerInfo) {
      var self = this;
      var isServerSide = typeof this.settings.source === 'function';
      var totals = {};
      var displayedDataset = dataset;
      var firstRecordIdx = 0;
      var lastRecordIdx = displayedDataset ? displayedDataset.length : 0;
      var pagesize = this.settings.pagesize;
      var setSize = dataset.length;

      if (pagerInfo) {
        pagesize = pagerInfo.pagesize || pagesize;
        setSize = pagerInfo.filteredTotal || setSize;
      }

      if (!isServerSide && this.pagerAPI) {
        this.renderPager(pagerInfo, true);
        pagerInfo = this.pagerAPI.state;
      }

      // If the paging information sets limits on the dataset, customize the
      // displayed dataset to fit the conditions.
      if (setSize > pagesize) {
        var pages = this.filteredDataset ? pagerInfo.filteredPages : pagerInfo.pages;
        if (pages > 1) {
          var trueActivePage = pagerInfo.activePage > 0 ? pagerInfo.activePage - 1 : 0;
          if (this.filteredDataset) {
            trueActivePage = pagerInfo.filteredActivePage - 1;
          }
          firstRecordIdx = pagerInfo.pagesize * trueActivePage;
          lastRecordIdx = pagerInfo.pagesize * (trueActivePage + 1);
          displayedDataset = dataset.slice(firstRecordIdx, lastRecordIdx);
        }
      }

      // Render "mustache" Template
      if ((typeof Tmpl === 'undefined' ? 'undefined' : _typeof(Tmpl)) === 'object' && displayedDataset && this.settings.template) {
        // create a copy of an inlined template
        if (this.settings.template instanceof $) {
          this.settings.template = '' + this.settings.template.html();
        } else if (typeof this.settings.template === 'string') {
          // If a string doesn't contain HTML elments,
          // assume it's an element ID string and attempt to select with jQuery
          if (!stringUtils.containsHTML(this.settings.template)) {
            this.settings.template = $('#' + this.settings.template).html();
          }
        }

        if (this.settings.template.indexOf('{{#totals}}') > -1) {
          totals = this.getTotals(dataset);
        }

        var renderedTmpl = Tmpl.compile(this.settings.template, {
          dataset: displayedDataset,
          totals: totals
        });

        if (displayedDataset.length > 0 || this.settings.forceToRenderOnEmptyDs) {
          this.element.html(renderedTmpl);
        } else if (self.emptyMessageContainer) {
          this.element.empty();
          DOM.append(this.element, this.emptyMessageContainer[0].outerHTML, '<div><svg><use><span><b>');
        } else if (displayedDataset.length === 0) {
          this.element.html(renderedTmpl || '<ul></ul>');
        }
      }

      // Add Aria
      $('ul', this.element).attr({ role: 'presentation' });

      // Add Checkboxes
      var first = this.element.find('li, tbody > tr').first();
      var items = this.element.find('li, tr');
      var isMultiselect = this.settings.selectable === 'multiple' || this.settings.selectable === 'mixed';

      // Set Initial Tab Index
      this.focusItem = first.attr('tabindex', 0);

      // Let the link be focus'd
      if (!this.settings.selectable && first.find('a').length === 1) {
        first.removeAttr('tabindex');
      }

      items.each(function (i) {
        var item = $(this);

        item.attr('role', 'option');

        if (isMultiselect) {
          // Add Selection Checkboxes
          self.element.addClass('is-multiselect');

          // Create a Toolbar for the "Selected Items" area
          var selectedToolbar = self.element.prevAll('.toolbar');
          if (selectedToolbar.length && selectedToolbar.data('toolbar')) {
            selectedToolbar.data('toolbar').toggleMoreMenu();
          }

          if (self.settings.showCheckboxes) {
            // For mixed selection mode primarily append a checkbox object
            item.prepend('<label class="listview-selection-checkbox l-vertical-center inline inline-checkbox"><input tabindex="-1" type="checkbox" class="checkbox"><span class="label-text">&nbsp;</span></label>');
          }
        }

        // Add Aria
        item.attr({ 'aria-posinset': firstRecordIdx + i + 1, 'aria-setsize': setSize });

        // Add Aria disabled
        if (item.hasClass('is-disabled')) {
          item.attr('aria-disabled', 'true');
        }

        // If this dataset is filtered, hightlight the relevant search term inside the element.
        if (self.settings.highlight && self.searchTerm) {
          item.highlight(self.searchTerm);
        }
      });

      // TODO: Invoke the "element" here after we write an updated method.
      this.element.children().initialize();

      /**
       * Fires after the listbox is fully rendered.
       *
       * @event rendered
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {array} dataset .
       */
      this.element.trigger('rendered', [displayedDataset]);

      // Handle refresh
      this.element.off('updated.listview').on('updated.listview', function (e, settings) {
        self.updated(settings);
      });
    },


    /**
     * Add and update the pager (if used)
     * @private
     * @param {object} updatedPagerInfo contains updated paging settings
     * @param {boolean} isResponse represents whether or not this render call was caused by an AJAX response
     * @returns {void}
     */
    renderPager: function renderPager(updatedPagerInfo, isResponse) {
      if (!this.pagerAPI) {
        return;
      }

      this.pagerAPI.updatePagingInfo(updatedPagerInfo, isResponse);
    },


    /**
     * Reliably gets all the pre-rendered elements in the container and returns them for use.
     * @private
     * @returns {array} TThe pagable items
     */
    getPageableElements: function getPageableElements() {
      var elements = this.element.children();

      // Adjust for cases where the root is a <ul>
      if (elements.is('ul')) {
        elements = elements.children();
      }

      return elements;
    },


    /**
     * Get the Data Source. Can be an array, Object or Url and render the list.
     * @private
     * @param {array} dataset contains a potential new dataset to display inside the listview.
     * @param {object} [pagingInfo=undefined] information about desired pager state
     */
    refresh: function refresh(dataset, pagingInfo) {
      this.loadData(dataset, pagingInfo);

      if (this.list) {
        this.render(this.list.data);
      }
    },


    /**
     * Load Data from an external API
     * @param {object} ds  The dataset to use or will use settings.dataset.
     * @param {object} pagerInfo  The pager settings to use (see pager api)
     * @param {boolean} isResponse Flag used to avoid dup source calls.
     * @returns {void}
     */
    loadData: function loadData(ds, pagerInfo, isResponse) {
      var ajaxDs = false;
      var self = this;

      ds = ds || this.settings.dataset;
      if (this.filteredDataset) {
        ds = this.filteredDataset;
      }

      if (!pagerInfo) {
        if (this.pagerAPI) {
          if (ds.length !== this.pagerAPI.settings.dataset.length) {
            this.pagerAPI.updated({
              dataset: ds
            });
          }
          pagerInfo = this.pagerAPI.state;
        } else {
          pagerInfo = {
            activePage: 1
          };
        }
      }

      if (this.filteredDataset) {
        pagerInfo.filteredTotal = ds.length;
      } else {
        pagerInfo.total = ds.length;
      }

      if (!Array.isArray(ds)) {
        return;
      }

      function done(response, pagingInfo) {
        self.settings.dataset = response;
        ds = response;
        var activePage = self.pagerAPI ? self.pagerAPI.activePage : 1;

        if (typeof pagingInfo === 'string') {
          pagingInfo = {
            activePage: activePage,
            pagesize: self.settings.pagesize,
            total: ds.length,
            type: pagingInfo
          };
        }

        if (self.pagerAPI) {
          self.renderPager(pagingInfo, true);
          pagingInfo = self.pagerAPI.state;
        }
        self.render(ds, pagingInfo);
      }

      var s = this.settings.source;

      if (typeof ds === 'string' && (ds.indexOf('http') === 0 || ds.indexOf('/') === 0)) {
        s = ds;
        ajaxDs = true;
      }

      // If paging is not active, and a source is present, attempt to retrieve
      // information from the datasource.
      // TODO: Potentially abstract this datasource concept out for use elsewhere
      if ((s || ajaxDs) && !this.filteredDataset && !isResponse) {
        switch (typeof s === 'undefined' ? 'undefined' : _typeof(s)) {
          case 'function':
            s(pagerInfo, done);
            break;
          case 'string':
            if (s.indexOf('http') === 0 || s.indexOf('/') === 0) {
              $.getJSON(s, done);
            }
            return;
          default:
            this.settings.dataset = s;
            ds = s;
            this.render(s, pagerInfo);
            break;
        }
        return;
      }

      // Otherwise, simply render with the existing dataset
      this.render(ds, pagerInfo);
    },


    /**
     * Toggle all items from selected to deselected, useful for multi/mixed selection
     * @returns {void}
     */
    toggleAll: function toggleAll() {
      this[this.isSelectedAll ? 'deselectItemsBetweenIndexes' : 'selectItemsBetweenIndexes']([0, $('li, tbody tr', this.element).length - 1]);
      this.isSelectedAll = !this.isSelectedAll;
    },


    /**
     * Select Items between a set of indexes. Used for shift selection.
     * @private
     * @param {array} indexes an array containing two numeric indicies that will
     *  be used to make a selection.
     * @returns {void}
     */
    selectItemsBetweenIndexes: function selectItemsBetweenIndexes(indexes) {
      this.clearSelection();
      indexes.sort(function (a, b) {
        return a - b;
      });
      for (var i = indexes[0]; i <= indexes[1]; i++) {
        var item = $('li, tbody tr', this.element).eq(i);

        if (!item.is('.is-disabled, .is-selected')) {
          this.select(item);
        }
      }
    },


    /**
    * De-Select Items between a set of indexes. Used for shift selection.
    * @private
    * @param {array} indexes an array containing two numeric indicies that will
    *  be used to deselect.
    * @returns {void}
    */
    deselectItemsBetweenIndexes: function deselectItemsBetweenIndexes(indexes) {
      indexes.sort(function (a, b) {
        return a - b;
      });
      for (var i = indexes[0]; i <= indexes[1]; i++) {
        var item = $('li, tbody tr', this.element).eq(i);
        if (!item.is('.is-disabled') && item.is('.is-selected')) {
          this.select(item);
        }
      }
    },


    /**
    * Clear all currently selected list items.
    * @private
    * @returns {void}
    */
    clearSelection: function clearSelection() {
      if (window.getSelection) {
        window.getSelection().removeAllRanges();
      } else if (document.selection) {
        document.selection.empty();
      }
    },


    /**
    * Handle page/form resize
    * @private
    * @returns {void}
    */
    handleResize: function handleResize() {
      var items = $('li .listview-heading, tr .listview-heading', this.element);
      var item1 = items.eq(1);
      var item1W = item1.width();

      if (item1.length && item1W) {
        items[0].style.width = item1W + 'px';
      }

      if (this.pagerAPI) {
        this.pagerAPI.render();
      }
    },


    /**
     * @private
     * @param {jquery.event} e custom jQuery `contents-checked` event.
     * @param {jquery[]} searchfield the element representing a searchfield.
     * @returns {void}
     */
    handleSearch: function handleSearch(e, searchfield) {
      this.filter(searchfield);
    },


    /**
     * Filters the contents of Listviews that are paired with a Searchfield.
     * @param {jquery[]} searchfield the element representing a searchfield.
     * @returns {void}
     */
    filter: function filter(searchfield) {
      if (!searchfield) {
        return;
      }

      searchfield = $(searchfield);

      // Get the search string and trim whitespace
      var searchFieldVal = searchfield.val().trim();
      var pagingInfo = {
        searchActivePage: 1
      };

      // Clear
      if (!searchFieldVal) {
        if (!this.searchTerm) {
          return;
        }
        this.resetSearch();
        return;
      }

      // Make sure there is a search term...and its not the
      // same as the previous term
      if (searchFieldVal.length < 2 || this.searchTerm === searchFieldVal) {
        return;
      }

      // Set a global "searchTerm" and get the list of elements
      this.searchTerm = searchFieldVal;

      // Filter the results and highlight things
      var results = this.listfilter.filter(this.settings.dataset, this.searchTerm);
      if (!results.length) {
        results = [];
      }
      pagingInfo.filteredTotal = results.length;
      pagingInfo.searchActivePage = 1;
      results.forEach(function (result) {
        result.isFiltered = true;
      });

      this.filteredDataset = results;
      this.loadData(null, pagingInfo);

      /**
       * Fires after filtering the list.
       * @event filtered
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} args.elem The list element
       * @property {array} args.filteredResults The filter list items
       * @property {term} args.term The search term used.
       */
      this.element.trigger('filtered', { elem: this.element, filteredResults: results, term: this.searchTerm });
    },


    /**
     * Reset the current search parameters and highlight.
     * @private
     * @returns {void}
     */
    resetSearch: function resetSearch() {
      if (this.filteredDataset) {
        delete this.filteredDataset;
      }
      if (this.searchTerm) {
        delete this.searchTerm;
      }

      var pagingInfo = {
        activePage: 1,
        filteredTotal: undefined,
        searchActivePage: undefined
      };

      this.refresh(null, pagingInfo);
    },


    /**
     * Focus the provided list item with the keyboard
     * @private
     * @param {jquery} item  The list item (as jQuery) to focus
     * @returns {void}
     */
    focus: function focus(item) {
      if (item.is(':hidden') || item.is('.is-disabled')) {
        return;
      }

      if (this.focusItem) {
        this.focusItem.removeAttr('tabindex');
      }
      this.focusItem = item.attr('tabindex', 0).focus();

      if (!this.settings.selectable && item.find('a').length === 1) {
        item.find('a').focus();
        item.removeAttr('tabindex');
      }

      if (this.settings.selectOnFocus && this.settings.selectable !== 'multiple' && this.settings.selectable !== 'mixed') {
        this.select(item);
      }
    },


    /**
     * Remove the given list item.
     * @param {jquery|number} li Either the actually jQuery list element or a zero based index
     * @returns {void}
     */
    remove: function remove(li) {
      if (typeof li === 'number') {
        li = $(this.element.children()[0]).children().eq(li);
      }
      // Un-select selected item
      // and donot trigger selected event, sinnce we removeing
      if (li.is('.is-selected')) {
        this.select(li, true);
      }
      li.remove();
    },


    /**
     * Remove all list items.
     * @returns {void}
     */
    clear: function clear() {
      var root = $(this.element.children()[0]);
      root.empty();
    },


    /**
     * Remove all selected items entirely from the list.
     * @returns {void}
     */
    removeAllSelected: function removeAllSelected() {
      var self = this;
      $.each(this.selectedItems, function (index, selected) {
        self.remove(selected);
      });
    },


    /**
     * Deselect all selected items.
     * @returns {void}
     */
    clearAllSelected: function clearAllSelected() {
      var self = this;
      $.each(this.selectedItems, function (index, selected) {
        // Un-select selected item
        self.select(selected);
      });
    },


    /**
     * Initialize the sorted list
     * @private
     * @param {string} control component name
     * @param {string} onEvent the name of the event to sort on
     * @param {string} attr the name of the HTML attribute to retrieve options from.
     * @returns {void}
     */
    sortInit: function sortInit(control, onEvent, attr) {
      if (!attr || $.trim(attr) === '') {
        return;
      }
      $('[' + attr + ']').each(function () {
        var element = $(this);
        var options = $.fn.parseOptions(element, attr);

        element.on(onEvent, function (e) {
          $(options.list).data(control).setSortColumn(options);
          e.preventDefault();
        });
      });
    },


    /**
    * Sort the list with the given options.
    * @private
    * @param {object} [options] incoming sort options
    * @returns {void}
    */
    setSortColumn: function setSortColumn(options) {
      var field = options.orderBy || this.list.sort.field;
      var reverse = options.order;

      if (!this.list.data && !field) {
        return;
      }

      reverse = reverse ? reverse === 'desc' : !(this.list.sort && this.list.sort[field] && this.list.sort[field].reverse);

      // reload data
      if (options.reloadApi || options.reloadApiNoSort) {
        this.loadData();
      }

      // reload data but no sort change
      if (options.reloadApiNoSort) {
        field = this.list.sort.field;
        reverse = this.list.sort[field].reverse;
      }

      var sort = this.sortFunction(field, reverse);
      this.list.data.sort(sort);
      this.render(this.list.data);

      this.list.sort = { field: field };
      this.list.sort[field] = { reverse: reverse };
      /**
       * Fires after sorting the list.
       *
       * @event sorted
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} this.element
       * @property {string} this.list.sort
       */
      this.element.trigger('sorted', [this.element, this.list.sort]);
    },


    /**
    * Overridable function to conduct sorting
    * @private
    * @param {string} field  The field in the dataset to sort on.
    * @param {string} reverse  If true sort descending.
    * @param {function} primer  A sorting primer function.
    * @returns {function} a customized sorting algorithm
    */
    sortFunction: function sortFunction(field, reverse, primer) {
      if (!primer) {
        primer = function primer(a) {
          a = a === undefined || a === null ? '' : a;
          if (typeof a === 'string') {
            a = a.toUpperCase();

            if (!isNaN(parseFloat(a))) {
              a = parseFloat(a);
            }
          }
          return a;
        };
      }

      var key = primer ? function (x) {
        return primer(x[field]);
      } : function (x) {
        return x[field];
      };

      reverse = !reverse ? 1 : -1;

      return function (a, b) {
        return a = key(a), b = key(b), reverse * ((a > b) - (b > a)); //eslint-disable-line
      };
    },


    /**
    * Deselect the given list item.
    * @param {jquery[]|number} li  Either the actually jQuery list element or a zero based index
    */
    deselect: function deselect(li) {
      if (typeof li === 'number') {
        li = $(this.element.children()[0]).children().eq(li);
      }
      if (li.is('.is-selected')) {
        this.select(li);
      }
    },


    /**
     * Deselect the given list item.
     * This method is slated to be removed in a future v4.9.0 or v5.0.0.
     * @deprecated as of v4.3.0. Please use `deselect()` instead.
     * @param {jquery[]|number} li a list item
     * @returns {void}
     */
    unselect: function unselect(li) {
      return deprecateMethod(this.deselect, this.unselect).apply(this, [li]);
    },


    /**
     * Select the given list item.
     * @param {jquery|number} li Either the actually jQuery list element or a zero based index
     * @param {boolean} noTrigger Do not trigger the selected event.
     */
    select: function select(li, noTrigger) {
      var self = this;
      var isChecked = false;
      var isMixed = self.settings.selectable === 'mixed';

      self.selectedItems = [];
      if (typeof li === 'number') {
        li = $(this.element.children()[0]).children().eq(li);
      }

      isChecked = li.hasClass('is-selected');

      // focus
      if (!li.is('[tabindex="0"]')) {
        if (this.focusItem) {
          this.focusItem.removeAttr('tabindex');
        }
        li.attr('tabindex', 0);
      }

      if (this.settings.selectable === false || this.settings.selectable === 'false') {
        return;
      }

      // Select
      if (this.settings.selectable !== 'multiple' && this.settings.selectable !== 'mixed') {
        li.parent().children().removeAttr('aria-selected');
        li.parent().find('.is-selected').removeClass('is-selected');
        self.selectedItems[0] = $(this);
      }

      if (isChecked) {
        self.selectedItems = [];
        li.removeClass('is-selected hide-selected-color');
      } else if (this.settings.selectable) {
        li.addClass('is-selected' + (isMixed ? ' hide-selected-color' : ''));
        self.lastSelectedItem = li.index(); // Rember index to use shift key
      }

      li.parent().find('.is-selected').each(function (i) {
        self.selectedItems[i] = $(this);
      });

      li.attr('aria-selected', !isChecked);
      li.find('.listview-selection-checkbox input').prop('checked', !isChecked);

      if (!noTrigger) {
        var triggerStr = isChecked ? 'unselected' : 'selected';
        var selectedData = [];

        for (var i = 0; i < this.selectedItems.length; i++) {
          var posinset = this.selectedItems[i][0].getAttribute('aria-posinset');
          selectedData.push(this.settings.dataset[posinset - 1]);
        }

        /**
         * Fires when a item is selected.
         * @event selected
         * @memberof ListView
         * @property {object} event - The jquery event object
         * @property {object} selected items and item info and item data
         */
        this.element.triggerHandler(triggerStr, {
          selectedItems: this.selectedItems,
          elem: li,
          selectedData: selectedData
        });

        if (triggerStr === 'unselected') {
          /**
           * Fires when a item is deselected.
           *
           * @event deselected
           * @memberof ListView
           * @property {object} event - The jquery event object
           * @property {object} selected items and item info
           */
          this.element.triggerHandler('deselected', { selectedItems: this.selectedItems, elem: li, selectedData: selectedData });
        }
      }

      var parent = this.element.closest('.card, .widget');
      if (!parent.length) {
        parent = this.element.parent();
      }

      var toolbar = parent.find('.listview-toolbar, .contextual-toolbar');
      var toolbarControl = toolbar.data('toolbar');

      if (self.selectedItems.length > 0) {
        if (toolbarControl) {
          toolbarControl.toggleMoreMenu();
        }
        // Order of operations: set up event, change display prop, animate, toggle menu.
        // Menu toggle takes place after the animation starts
        toolbar.one('animateopencomplete', function () {
          self.element.addClass('is-toolbar-open');
          toolbar.trigger('recalculate-buttons').removeClass('is-hidden');
        });
        if (toolbar[0]) {
          toolbar[0].style.display = 'block';
        }
        // toolbar.animateOpen({distance: 52});
        toolbar.animateOpen({ distance: 40 });

        var title = toolbar.find('.title, .selection-count');
        if (!title || !title.length) {
          title = $('<div class="title selection-count"></div>');
          toolbar.prepend(title);
        }
        title.text(self.selectedItems.length + ' ' + (Locale ? Locale.translate('Selected') : 'Selected'));
      } else {
        toolbar.addClass('is-hidden').one('animateclosedcomplete', function (e) {
          e.stopPropagation();
          this.style.display = 'none';
          self.element.removeClass('is-toolbar-open');
        }).animateClosed();
      }
    },


    /**
     * Toggle acivation state on the list item
     * @private
     * @param {jquery} li The jQuery list element.
     * @returns {void}
     */
    toggleItemActivation: function toggleItemActivation(li) {
      var isActivated = li.hasClass('is-activated');

      if (isActivated) {
        if (!this.settings.disableItemDeactivation) {
          this.deactivateItem(li);
        }
        return;
      }

      this.activateItem(li);
    },


    /**
     * Set item to activated, unactivate others and fire an event.
     * @private
     * @param {jquery|number} li The jQuery list element or the index.
     * @returns {void}
     */
    activateItem: function activateItem(li) {
      var idx = typeof li === 'number' ? li : li.index();
      var active = this.element.find('li.is-activated');
      var elemCanActivate = true;

      if (typeof li === 'number') {
        li = this.element.find('ul').children().eq(li);
      }
      this.deactivateItem(active);
      /**
       * Fires before activate item.
       *
       * @event beforeactivate
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} args index, elem, data
       */
      elemCanActivate = this.element.triggerHandler('beforeactivate', [{ index: idx, elem: li, data: this.settings.dataset[idx] }]);

      if (elemCanActivate === false) {
        return;
      }
      li.addClass('is-activated');

      /**
       * Fires after activate item.
       *
       * @event itemactivated
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} args index, elem, data
       */
      this.element.triggerHandler('itemactivated', [{ index: idx, elem: li, data: this.settings.dataset[idx] }]);
    },


    /**
    * Return an object containing info about the currently activated item.
    * @returns {object} An object containing the active row's index, dom element and data.
    */
    activatedItem: function activatedItem() {
      var active = this.element.find('li.is-activated');
      var idx = active.index();

      return {
        index: idx,
        elem: active,
        data: this.settings.dataset[idx]
      };
    },


    /**
     * Set item to deactivated, and fire an event.
     * @param {jquery|number} li The jQuery list element. The li element or the index.
     *  If null the currently activated one will be deactivated.
     * @returns {void}
     */
    deactivateItem: function deactivateItem(li) {
      if (typeof li === 'number') {
        li = this.element.find('ul').children().eq(li);
      }

      if (li === undefined) {
        li = this.element.find('li.is-activated');
      }

      li.removeClass('is-activated');
      var idx = li.index();

      if (idx < 0) {
        return;
      }

      /**
       * Fires after deactivated item.
       *
       * @event itemdeactivated
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} args index, elem, data
       */
      this.element.triggerHandler('itemdeactivated', [{ index: idx, elem: li, data: this.settings.dataset[idx] }]);
    },


    /**
     * @returns {jquery[]} the currently selected ListView item, or an empty jQuery selector
     *  if there are currently no items selected.
     */
    getSelected: function getSelected() {
      return this.element.find('.is-selected');
    },


    /**
     * Handle to update the search data
     * @private
     * @returns {void}
     */
    updateSearch: function updateSearch() {
      if (this.settings.searchable && this.filteredDataset) {
        delete this.filteredDataset;
        if (this.searchTerm) {
          delete this.searchTerm;
        }
        var searchfieldApi = this.searchfield.data('searchfield');
        if (searchfieldApi && searchfieldApi.xButton) {
          searchfieldApi.xButton.trigger('click');
        }
      }
    },


    /**
     * Refresh the list with any optioned options that might have been set.
     * @param {object} [settings] incoming settings
     * @returns {object} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
        if (settings && settings.dataset) {
          this.settings.dataset = settings.dataset;
        }
      }

      this.updateSearch();
      this.refresh(settings && settings.dataset ? settings.dataset : null);
      return this;
    },


    /**
     * Disables the functionality of a ListView.
     * @returns {void}
     */
    disable: function disable() {
      this.element.addClass('is-disabled');
    },


    /**
    * Enables the functionality of a ListView.
    * @returns {void}
    */
    enable: function enable() {
      this.element.removeClass('is-disabled');
    },


    /**
     * Detatch all bound events.
     * @private
     * @returns {object} component instance
     */
    teardown: function teardown() {
      $('body').off('resize.listview');
      this.element.prev('.listview-header').off('click.listview');
      if (this.searchfield) {
        this.searchfield.off(['contents-checked.searchable-listview', 'cleared.searchable-listview'].join(' '));
      }
      this.element.off('change.selectable-listview', '.listview-checkbox input');
      this.element.off('contextmenu.listview dblclick.listview', 'li, tr');
      this.element.off('click.listview', 'li, tr, input[checkbox]');
      this.element.off('keydown.listview', 'li, tr, a');
      this.element.off('focus.listview', 'li, tbody tr');
      this.element.off('focus.listview click.listview touchend.listview keydown.listview change.selectable-listview afterpaging.listview updated.listview').empty();

      if (this.filteredDataset) {
        delete this.filteredDataset;
      }
      if (this.searchTerm) {
        delete this.searchTerm;
      }

      return this;
    },


    /**
     * Detatch all events and tear down data object
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      this.element.removeData(COMPONENT_NAME$K);
    },


    /**
      * Attach Events used by the Control
      * @private
      * @returns {void}
      */
    handleEvents: function handleEvents() {
      var self = this;
      var isSelect = false;
      var isFocused = false;
      var isMultiple = self.settings.selectable === 'multiple' || self.settings.selectable === 'mixed';

      this.element.off('focus.listview', 'li, tbody tr').on('focus.listview', 'li, tbody tr', function (evt) {
        var item = $(this);

        // Ignore favorite clicks
        if (evt.originalEvent && evt.originalEvent.target && $(evt.originalEvent.target).is('.icon-favorite')) {
          return;
        }

        // First element if disabled
        if (item.is(':first-child') && item.hasClass('is-disabled')) {
          var e = $.Event('keydown.listview');

          e.keyCode = 40; // move down
          isSelect = true;
          item.trigger(e);
        }

        if (!isSelect && !item.hasClass('is-disabled') && self.settings.selectOnFocus && self.settings.selectable !== 'multiple' && self.settings.selectable !== 'mixed') {
          self.select(item);
          isSelect = true;
          isFocused = true;
        }
      });

      // Keyboard
      this.element.off('keydown.listview', 'li, tr, a').on('keydown.listview', 'li, tr, a', function (e) {
        var elem = $(this);
        var item = elem.is('a') ? elem.closest('li') : $(this);
        var list = item.is('a') ? item.closest('ul') : item.parent();
        var key = e.keyCode || e.charCode || 0;
        var metaKey = e.metaKey;

        if (item.index() === 0 && e.keyCode === 38) {
          return false;
        }

        if ((key === 40 || key === 38) && !metaKey) {
          // move down or up
          var newItem = e.keyCode === 40 ? item.nextAll(':not(.is-disabled):visible:first') : item.prevAll(':not(.is-disabled):visible:first');

          if (newItem.length && ($(e.target).is(item) || e.shiftKey || elem.is('a'))) {
            self.focus(newItem);
          }
          e.preventDefault();
          e.stopPropagation(); // prevent container from scrolling
        }

        if (key === 35 || key === 40 && metaKey) {
          // end
          var last = list.children().last();
          self.focus(last);
          e.stopPropagation();
          return false;
        }

        if (key === 36 || key === 38 && metaKey) {
          // home
          var first = list.children().first();
          self.focus(first);
          e.stopPropagation();
          return false;
        }

        if (key === 32) {
          // Space to toggle selection
          if ($(e.target).is(item)) {
            if (isMultiple && e.shiftKey) {
              self.selectItemsBetweenIndexes([self.lastSelectedItem, item.index()]);
            } else {
              self.select(item);
            }
            e.preventDefault();
          }
        }

        // If multiSelect is enabled, press Control+A to toggle select all items
        if (isMultiple && (e.ctrlKey || e.metaKey) && key === 65) {
          self.toggleAll();
          self.focus(item);
          e.preventDefault();
        }

        return true;
      });

      // Selection View Click/Touch
      if (this.settings.selectable) {
        this.element.addClass('is-selectable');

        var pattern = $(this.element).closest('.list-detail, .builder');

        this.element.off('click.listview', 'li, tr, input[checkbox]').on('click.listview', 'li, tr, input[checkbox]', function (e) {
          var item = $(this);
          var isCheckbox = $(e.target).closest('.listview-selection-checkbox').length > 0;
          var isMixed = self.settings.selectable === 'mixed';
          var target = $(e.target);

          // ignore clicking favorites element or a hyperlink
          if (target.hasClass('icon-favorite') || target.hasClass('hyperlink')) {
            return;
          }

          if (!isFocused && !item.hasClass('is-disabled') && (!isMixed || isCheckbox)) {
            isSelect = true;

            if (isMultiple && e.shiftKey) {
              self.selectItemsBetweenIndexes([self.lastSelectedItem, item.index()]);
              e.preventDefault();
            } else {
              self.select(item);
            }
            item.focus();
          }

          if (!item.hasClass('is-disabled') && isMixed && !isCheckbox) {
            item.focus();
            self.toggleItemActivation(item);
          }

          if (pattern.length > 0 && $(window).outerWidth() < 767 && !item.hasClass('is-disabled') && !isCheckbox) {
            self.element.trigger('drilldown', [item]);
          }

          isFocused = false;

          e.preventDefault();
          e.stopPropagation();

          self.element.trigger('click', [{
            elem: item,
            data: self.settings.dataset[item.attr('aria-posinset') - 1],
            index: item.index(),
            originalEvent: e
          }]);
        });

        this.element.off('dblclick.listview', 'li, tr').on('dblclick.listview', 'li, tr', function (e) {
          var item = $(this);

          e.preventDefault();
          e.stopPropagation();
          self.element.trigger('dblclick', [{
            elem: $(this),
            data: self.settings.dataset[item.attr('aria-posinset') - 1],
            index: item.index(),
            originalEvent: e
          }]);
          return false;
        });

        this.element.off('contextmenu.listview', 'li, tr').on('contextmenu.listview', 'li, tr', function (e) {
          var item = $(this);

          e.preventDefault();
          e.stopPropagation();
          self.element.trigger('contextmenu', [{
            elem: $(this),
            data: self.settings.dataset[item.attr('aria-posinset') - 1],
            index: item.index(),
            originalEvent: e
          }]);
          return false;
        });
      }

      if (!this.settings.hoverable || this.settings.hoverable === 'false') {
        this.element.removeClass('is-selectable');
        this.element.addClass('disable-hover');
      }

      if (!this.settings.selectable || this.settings.selectable === 'false') {
        this.element.removeClass('is-selectable');
        this.element.addClass('disable-hover');
      }

      if (this.settings.selectable === 'multiple' || this.settings.selectable === 'mixed') {
        this.element.off('change.selectable-listview', '.listview-checkbox input').on('change.selectable-listview', '.listview-checkbox input', function (e) {
          $(this).parent().trigger('click');
          e.stopPropagation();
        });
      }

      // For use with Searchfield
      if (this.settings.searchable) {
        this.searchfield.off('contents-checked.searchable-listview').on('contents-checked.searchable-listview', function (e) {
          self.handleSearch(e, $(this));
        }).off('cleared.searchable-listview').on('cleared.searchable-listview', function () {
          self.resetSearch();
          self.element.trigger('filtered', { elem: self.element, filteredResults: [], term: '' });
        });
      }

      // If used with a Pager Control, listen for the end of the page and scroll
      // the Listview to the top
      if (this.pagerAPI) {
        this.element.off('page.listview').on('page.listview', function (e, pagingInfo) {
          self.handlePageChange(pagingInfo);
        }).off('pagesizechange.listview').on('pagesizechange.listview', function (e, pagingInfo) {
          self.handlePageSizeChange(pagingInfo);
        });
      }

      $('body').off('resize.listview').on('resize.listview', function (e) {
        self.handleResize(e);
      });

      // Animate open and Closed from the header
      self.element.prev('.listview-header').off('click.listview').on('click.listview', function () {
        var icon = $(this).find('.plus-minus');
        if (icon.hasClass('active')) {
          icon.removeClass('active');
          self.element.animateClosed();
        } else {
          icon.addClass('active');
          self.element.animateOpen();
        }
      });
    },


    /**
     * Listens for a `pagesizechange` event from the dropdown that recalculates page size
     * @param {object} pagingOpts state information from the pager
     */
    handlePageSizeChange: function handlePageSizeChange(pagingOpts) {
      pagingOpts.activePage = 1;
      this.loadData(undefined, pagingOpts);
    },


    /**
     * Listens for `page` events from the Pager.
     * @param {object} pagingOpts state information from the pager
     */
    handlePageChange: function handlePageChange(pagingOpts) {
      this.loadData(undefined, pagingOpts);
    }
  };

  /**
   * jQuery Component Wrapper for ListView
   * @param {object} settings The settings to apply.
   * @returns {jQuery[]} The jquery object for chaining.
   */
  $.fn.listview = function (settings) {
    /**
     * NOTE: Much of this is here for backwards-compatibility reasons.  In the future we need to
     * make sure these enhancements make it to the components.
     */
    var cs = $(this);
    var attr = cs.attr('data-dataset');
    var tmpl = cs.attr('data-tmpl');
    var inlineOpts = utils.parseOptions(this) || {};

    inlineOpts.dataset = inlineOpts.dataset || attr;
    inlineOpts.template = inlineOpts.template || tmpl;

    if (window[inlineOpts.dataset]) {
      inlineOpts.dataset = window[inlineOpts.dataset];
    }

    if (inlineOpts.template && inlineOpts.template.length) {
      inlineOpts.template = $('#' + inlineOpts.template).html();
    }

    var combinedSettings = utils.extend({}, settings, inlineOpts);

    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$K);
      if (instance) {
        instance.updated(combinedSettings);
      } else {
        instance = $.data(this, COMPONENT_NAME$K, new ListView(this, combinedSettings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$L = 'listbuilder';

  /**
   * A list of items with add/remove/delete and sort functionality.
   * @class ListBuilder
   * @constructor
   * @param {jQuery[]|HTMLElement} element The base element.
   * @param {object} [settings] incoming settings.
   *
   * @param {array} [settings.dataset]  Array of data
   * @param {string} [settings.handle]  The CSS Class of the handle element
   * @param {string|jQuery[]} [settings.btnAdd]  "Add" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string|jQuery[]} [settings.btnEdit]  "Edit" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string|jQuery[]} [settings.btnDelete]  "Delete" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string|jQuery[]} [settings.btnGoUp]  "GoUp" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string|jQuery[]} [settings.btnGoDown]  "GoDown" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string} [settings.template]  representing HTML content that builds a list
   * @param {string} [settings.templateNewItem]  representing HTML content that builds a single list item
   * @param {string} [settings.templateItemContent]  representing HTML content that replaces the inner content
   *  section of each item.
   */

  var LISTBUILDER_DEFAULTS = {
    dataset: [],
    handle: '.handle',
    btnAdd: 'add',
    btnEdit: 'edit',
    btnDelete: 'delete',
    btnGoUp: 'goup',
    btnGoDown: 'godown',
    template: '' + '<ul data-handle=".handle">' + '{{#dataset}}' + '{{#text}}' + '<li' + '{{#value}} data-value="{{value}}"{{/value}}' + '{{#selected}} selected="selected"{{/selected}}' + '{{#disabled}} class="is-disabled"{{/disabled}}' + '>' + '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>' + '<div class="item-content"><p>{{text}}</p></div>' + '</li>' + '{{/text}}' + '{{/dataset}}' + '</ul>',
    templateNewItem: '' + '<li data-value="{{text}}" role="option">' + '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>' + '<div class="item-content"><p>{{text}}</p></div>' + '</li>',
    templateItemContent: '<p>{{text}}</p>'
  };

  function ListBuilder(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, LISTBUILDER_DEFAULTS);
    if (settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.init();
  }

  // ListBuilder Methods
  ListBuilder.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      var _this = this;

      this.loadListview().initDataset().setElements().handleEvents();

      setTimeout(function () {
        _this.setSelected();
      }, 0);
    },


    /**
     * Load listview
     * @private
     * @returns {this} component instance
     */
    loadListview: function loadListview() {
      var s = this.settings;
      var lv = $('.listview', this.element);

      if (!s.dataset.length && lv.length && $('li', lv).length) {
        this.listApi = lv.listview({ selectable: 'single' }).data('listview');
      } else if (lv.length) {
        this.listApi = lv.listview({ dataset: s.dataset, template: s.template, selectable: 'single' }).data('listview');
      }
      return this;
    },


    /**
     * Initialize dataset
     * @private
     * @returns {this} component instance
     */
    initDataset: function initDataset() {
      var s = this.settings;
      var nodes = $('.listview li', this.element);

      this.dataset = [];
      for (var i = 0, l = nodes.length; i < l; i++) {
        var data = void 0;
        var li = $(nodes[i]);
        if (s.dataset) {
          // Make sure it's not reference pointer to data object, make copy of data
          data = JSON.parse(JSON.stringify(s.dataset[i]));
          data.node = li;
        } else {
          data = this.extractNodeData(li);
        }
        this.dataset.push(data);
      }
      return this;
    },


    /**
     * Extract node data
     * @private
     * @param {jQuery[]} node element to be checked for data
     * @returns {object} data from the node.
     */
    extractNodeData: function extractNodeData(node) {
      var data = { node: node, text: $.trim($('.item-content', node).text()) };
      var value = node.attr('data-value');
      if (typeof value !== 'undefined') {
        data.value = value;
      }
      return data;
    },


    /**
     * Set elements
     * @private
     * @returns {this} component instance
     */
    setElements: function setElements() {
      var _this2 = this;

      var s = this.settings;

      // Action buttons
      var setAction = function setAction(selector) {
        if (_this2.isjQuery(selector)) {
          return selector;
        } else if (typeof selector === 'string') {
          return $('[data-action="' + selector + '"]', _this2.element);
        }
        return null;
      };
      s.btnAdd = setAction(s.btnAdd);
      s.btnGoUp = setAction(s.btnGoUp);
      s.btnGoDown = setAction(s.btnGoDown);
      s.btnEdit = setAction(s.btnEdit);
      s.btnDelete = setAction(s.btnDelete);

      // Init tooltips
      this.topButtons = s.btnAdd.add(s.btnGoUp).add(s.btnGoDown).add(s.btnEdit).add(s.btnDelete);
      this.topButtons.tooltip();

      // Make Draggable
      this.ul = $('.listview ul', this.element);
      this.arrangeApi = this.ul.arrange({
        handle: s.handle,
        placeholder: s.templateNewItem
      }).data('arrange');

      return this;
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this3 = this;

      var data = void 0;
      var self = this;
      var s = self.settings;

      // TOP BUTTONS =============================================================
      var topButtonsClick = function topButtonsClick(btn, method) {
        btn.off('click.listbuilder').on('click.listbuilder', function () {
          self[method]();
        });
      };
      topButtonsClick(s.btnAdd, 'addItem');
      topButtonsClick(s.btnGoUp, 'moveItemUp');
      topButtonsClick(s.btnGoDown, 'moveItemDown');
      topButtonsClick(s.btnEdit, 'editItem');
      topButtonsClick(s.btnDelete, 'deleteItem');

      // DRAGGABLE ===============================================================
      this.arrangeApi.element.on('beforearrange.listbuilder', function (e, status) {
        var d = _this3.getDataByNode(status.start);
        var str = s.templateItemContent.replace(/{{text}}/g, d.data.text);

        _this3.arrangeApi.placeholders.attr('data-value', d.data.text).find('.item-content').html(str);
      }).on('arrangeupdate.listbuilder', function (e, status) {
        _this3.updateAttributes();
        _this3.arrayIndexMove(_this3.dataset, status.startIndex, status.endIndex);
        data = _this3.getDataByNode(status.end);
        data.indexBeforeMove = status.startIndex;
        _this3.element.triggerHandler('arrangeupdate', [data]);
      });

      $('li:not(.is-disabled) ' + this.arrangeApi.handle, this.ul).on('mousedown.listbuilder touchstart.listbuilder', function () {
        var li = $(this);
        if (!li.is('.is-selected')) {
          li.trigger('click');
        }
      });

      $('.listview', this.element).off('selected.listbuilder').on('selected.listbuilder', function (e, args) {
        data = _this3.getDataByNode(args.elem[0]);

        /**
         * Fires when a item is selected.
         * @event selected
         * @memberof ListBuilder
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} data - Data for this selected item
         */
        _this3.element.triggerHandler('selected', [data]);
      });

      this.updatedEventsStr = 'arrangeupdate.listbuilder aftergoup.listbuilder aftergodown.listbuilder exiteditmode.listbuilder';
      this.element.off(this.updatedEventsStr).on(this.updatedEventsStr, function (e, updatedData) {
        /**
         * Fires when a item is updated.
         * @event updated
         * @memberof ListBuilder
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} data - Data for this item
         */
        _this3.element.triggerHandler('updated', [updatedData]);
      });

      return this;
    },
    // END: Handle Events -----------------------------------------------------

    /**
     * Add an item into edit mode.
     * @private
     * @returns {void}
     */
    addItem: function addItem() {
      var self = this;
      var s = this.settings;

      /**
       * Fires before add new item.
       *
       * @event beforeadd
       * @memberof ListBuilder
       * @type {object}
       * @property {object} event - The jquery event object
       */
      $.when(this.element.triggerHandler('beforeadd')).done(function () {
        var li = void 0;
        var data = void 0;
        var index = 0;

        var node = self.listApi.selectedItems[0];
        var str = s.templateNewItem.replace(/{{text}}/g, Locale.translate('NewItem'));

        if (node && node.length > 0) {
          data = self.getDataByNode(node);
          index = data.index + 1;
          $(str).insertAfter(node);
          li = $('li', self.ul).eq(index);
        } else {
          self.ul.prepend(str);
          li = $('li:first-child', self.ul);
        }

        self.dataset.push(self.extractNodeData(li));
        self.arrayIndexMove(self.dataset, self.dataset.length - 1, index);
        self.updateAttributes();
        li.trigger('click');
        self.arrangeApi.updated();
        self.editItem(true);

        data = { index: index, data: self.dataset[index] };

        /**
         * Fires after add new item.
         * @event afteradd
         * @memberof ListBuilder
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} data - Data for this new item
         */
        self.element.triggerHandler('afteradd', [data]);
      });
    },


    /**
     * Move the currently selected item up.
     * @private
     * @returns {void}
     */
    moveItemUp: function moveItemUp() {
      var self = this;
      var node = self.listApi.selectedItems[0];

      if (node && node.length > 0) {
        var data = self.getDataByNode(node);
        if (typeof data.index !== 'undefined' && data.index > 0) {
          /**
           * Fires before move up item.
           * @event beforegoup
           * @memberof ListBuilder
           * @type {object}
           * @property {object} event - The jquery event object
           * @property {object} data - Data for this item
           */
          $.when(self.element.triggerHandler('beforegoup', [data])).done(function () {
            var prev = node.prev();
            node.insertBefore(prev);
            self.updateAttributes();
            self.arrayIndexMove(self.dataset, data.index, data.index - 1);
            data.indexBeforeMove = data.index;
            data.index--;

            /**
             * Fires after move up item.
             * @event aftergoup
             * @memberof ListBuilder
             * @type {object}
             * @property {object} event - The jquery event object
             * @property {object} data - Data for this item
             */
            self.element.triggerHandler('aftergoup', [data]);
          });
        }
      }
    },


    /**
     * Move the currently selected item down.
     * @private
     * @returns {void}
     */
    moveItemDown: function moveItemDown() {
      var self = this;
      var node = self.listApi.selectedItems[0];
      if (node && node.length > 0) {
        var data = self.getDataByNode(node);
        if (typeof data.index !== 'undefined' && data.index < self.dataset.length - 1) {
          /**
           * Fires before move down item.
           * @event beforegodown
           * @memberof ListBuilder
           * @type {object}
           * @property {object} event - The jquery event object
           * @property {object} data - Data for this item
           */
          $.when(self.element.triggerHandler('beforegodown', [data])).done(function () {
            var next = node.next();
            node.insertAfter(next);
            self.updateAttributes();
            self.arrayIndexMove(self.dataset, data.index, data.index + 1);
            data.indexBeforeMove = data.index;
            data.index++;

            /**
             * Fires after move down item.
             * @event aftergodown
             * @memberof ListBuilder
             * @type {object}
             * @property {object} event - The jquery event object
             * @property {object} data - Data for this item
             */
            self.element.triggerHandler('aftergodown', [data]);
          });
        }
      }
    },


    /**
     * Edit the selected item
     * @private
     * @param {boolean} isNewItem  Is it a newly added item?
     * @returns {void}
     */
    editItem: function editItem(isNewItem) {
      var node = this.listApi.selectedItems[0];
      if (node && node.length > 0) {
        if (node.is('.is-editing')) {
          this.commitEdit(node, isNewItem);
        } else {
          this.makeEditable(node, isNewItem);
        }
      }
    },


    /**
     * Make the node editable
     * @private
     * @param {object} node  The HTML element to edit
     * @param {boolean} isNewItem  Is it a newly added item?
     * @returns {void}
     */
    makeEditable: function makeEditable(node, isNewItem) {
      var self = this;
      var data = self.getDataByNode(node);
      var container = $('.item-content', node);

      if (typeof data.index !== 'undefined' && data.index < self.dataset.length) {
        /**
         * Fires before edit item.
         * @event beforeedit
         * @memberof ListBuilder
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} data - Data for this item
         */
        $.when(self.element.triggerHandler('beforeedit', [data])).done(function () {
          var origValue = container.text().trim();
          var editInput = $('<input name="edit-input" class="edit-input" type="text" value="' + origValue + '" />');

          node.addClass('is-editing');
          container.html(editInput);
          editInput.focus().select();

          editInput.on('click.listbuilder', function () {
            return false;
          }).on('blur.listbuilder', function () {
            return self.commitEdit(node, isNewItem);
          }).on('keypress.listbuilder', function (e) {
            var key = e.keyCode || e.charCode || 0;
            if (key === 13) {
              self.commitEdit(node, isNewItem);
              node.focus();
            }
          });

          /**
           * Fires when enter to edit mode.
           * @event entereditmode
           * @memberof ListBuilder
           * @type {object}
           * @property {object} event - The jquery event object
           * @property {object} data - Data for this item
           */
          self.element.triggerHandler('entereditmode', [data]);
        });
      }
    },


    /**
     * Commit the changes to item.
     * @private
     * @param {object} node  The HTML element to commit changes
     * @param {boolean} isNewItem  Is it a newly added item?
     * @returns {void}
     */
    commitEdit: function commitEdit(node, isNewItem) {
      var s = this.settings;
      var data = this.getDataByNode(node);
      var container = $('.item-content', node);
      var editInput = $('.edit-input', container);

      if (isNewItem) {
        data.data.value = editInput.val();
      }
      data.data.text = editInput.val();
      editInput.off('click.listbuilder blur.listbuilder keypress.listbuilder');
      container.html(s.templateItemContent.replace(/{{text}}/g, editInput.val()));
      node.removeClass('is-editing');

      /**
       * Fires when exited to edit mode.
       * @event exiteditmode
       * @memberof ListBuilder
       * @type {object}
       * @property {object} event - The jquery event object
       * @property {object} data - Data for this item
       */
      this.element.triggerHandler('exiteditmode', [data]);
    },


    /**
     * Delete the selected item.
     * @private
     * @returns {void}
     */
    deleteItem: function deleteItem() {
      var self = this;
      var node = self.listApi.selectedItems[0];
      if (node && node.length > 0) {
        var data = self.getDataByNode(node);
        if (typeof data.index !== 'undefined') {
          /**
           * Fires before delete item.
           * @event beforedelete
           * @memberof ListBuilder
           * @type {object}
           * @property {object} event - The jquery event object
           * @property {object} data - Data for this item
           */
          $.when(self.element.triggerHandler('beforedelete', [data])).done(function () {
            self.listApi.removeAllSelected();
            self.updateAttributes();
            self.dataset.splice(data.index, 1);

            /**
             * Fires after delete item.
             * @event afterdelete
             * @memberof ListBuilder
             * @type {object}
             * @property {object} event - The jquery event object
             * @property {object} data - Data for this item
             */
            self.element.triggerHandler('afterdelete', [data]);
          });
        }
      }
    },


    /**
     * Get data from dataset by node
     * @param {jQuery[]} node  The HTML element to get data
     * @returns {object} node data
     */
    getDataByNode: function getDataByNode(node) {
      var data = {};
      for (var i = 0, l = this.dataset.length; i < l; i++) {
        var d = this.dataset[i];
        if ($(d.node).is(node)) {
          data = { index: i, data: d };
          break;
        }
      }
      return data;
    },


    /**
     * Move an array element position
     * @private
     * @param {array} arr .
     * @param {number} from .
     * @param {number} to .
     * @returns {void}
     */
    arrayIndexMove: function arrayIndexMove(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },


    /**
     * Check if given object is a jQuery object
     * @private
     * @param {object} obj .
     * @returns {boolean} true if jQuery
     */
    isjQuery: function isjQuery(obj) {
      return obj && (obj instanceof jQuery || obj.constructor.prototype.jquery);
    },


    /**
     * Move cursor to end
     * http://stackoverflow.com/a/26900921
     * @private
     * @param {object} el as element.
     * @returns {void}
     */
    moveCursorToEnd: function moveCursorToEnd(el) {
      setTimeout(function () {
        if (typeof el.selectionStart === 'number') {
          el.selectionEnd = el.value.length;
          el.selectionStart = el.value.length;
        } else if (typeof el.createTextRange !== 'undefined') {
          var range = el.createTextRange();
          range.collapse(false);
          range.select();
        }
      }, 100);
    },


    /**
     * Update attributes
     * @private
     * @returns {void}
     */
    updateAttributes: function updateAttributes() {
      var nodes = $('li', this.ul);

      for (var i = 0, l = nodes.length; i < l; i++) {
        $(nodes[i]).attr({ 'aria-posinset': i + 1, 'aria-setsize': l });
      }
    },


    /**
     * Update dataset
     * @private
     * @param {object} ds as dataset.
     * @returns {void}
     */
    updateDataset: function updateDataset(ds) {
      var _this4 = this;

      var nodes = $('li', this.ul);
      var lv = $('.listview', this.element).data('listview');

      lv.deselectItemsBetweenIndexes([0, nodes.length - 1]);
      this.settings.dataset = ds;
      lv.loadData(this.settings.dataset);

      this.initDataset().setElements().handleEvents();

      setTimeout(function () {
        _this4.setSelected();
      }, 0);
    },


    /**
     * Set pre selected items
     * @private
     * @returns {object} this api
     */
    setSelected: function setSelected() {
      var nodes = $('li[selected]', this.ul);
      for (var i = 0, l = nodes.length; i < l; i++) {
        var li = $(nodes[i]);
        li.removeAttr('selected');
        if (!li.is('.is-selected')) {
          li.trigger('click');
        }
      }
      return this;
    },


    /**
     * Make selected
     * @private
     * @param {object} selector .
     * @returns {void}
     */
    select: function select(selector) {
      var li = this.getListItem(selector);

      if (li && !li.is('.is-selected')) {
        li.trigger('click');
      }
    },


    /**
     * Make unselected
     * @private
     * @param {object} selector .
     * @returns {void}
     */
    unselect: function unselect(selector) {
      var li = this.getListItem(selector);

      if (li && li.is('.is-selected')) {
        li.trigger('click');
      }
    },


    /**
     * Get an item from list, selector: can be
     * jQuery, DOM element, zero based index or 'first'|'last' as string
     * @private
     * @param {object} selector .
     * @returns {object} item node
     */
    getListItem: function getListItem(selector) {
      var li = $();
      if (this.isElement(selector) && $.contains(this.ul, selector)) {
        li = this.isjQuery(selector) ? selector : $(selector);
      } else {
        var idx = parseInt(selector, 10);
        var items = $('li', this.ul);
        if (!isNaN(idx) && idx > -1 && idx < items.length) {
          li = items.eq(idx); // zero based index
        } else if (('' + selector).toLowerCase() === 'first') {
          li = items.first(); // first
        } else if (('' + selector).toLowerCase() === 'last') {
          li = items.last(); // last
        }
      }
      // Make sure to return only one item -or- null
      if (li.length < 1) {
        return null;
      } else if (li.length > 1) {
        return li.eq(0);
      }
      return li;
    },


    /**
     * Check if given object is a DOM object
     * @private
     * @param {object} obj .
     * @returns {object} item node
     */
    isElement: function isElement(obj) {
      /* global Element */
      return this.isjQuery(obj) && obj.get(0) instanceof Element || obj instanceof Element;
    },


    /**
     * Make enable.
     * @returns {void}
     */
    enable: function enable() {
      this.element.removeClass('is-disabled').find('.toolbar .buttonset button').removeAttr('disabled').end().find('.toolbar .buttonset button[data-original-disabled]').attr('disabled', 'disabled').removeAttr('data-original-disabled');

      this.ul.find('li').removeClass('is-disabled').end().find('li[data-original-disabled]').addClass('is-disabled').removeAttr('data-original-disabled');
    },


    /**
     * Make disable.
     * @returns {void}
     */
    disable: function disable() {
      this.element.addClass('is-disabled').find('.toolbar .buttonset button[disabled]').attr('data-original-disabled', 'disabled').end().find('.toolbar .buttonset button').attr('disabled', 'disabled');

      this.ul.find('li.is-disabled').attr('data-original-disabled', 'is-disabled').end().find('li').addClass('is-disabled');
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {this} component instance
     */
    unbind: function unbind() {
      this.element.off(this.updatedEventsStr);
      $('.listview', this.element).off('selected.listbuilder');

      $('li ' + this.arrangeApi.handle, this.ul).off('mousedown.listbuilder touchstart.listbuilder');

      this.arrangeApi.element.off('beforearrange.listbuilder arrangeupdate.listbuilder').destroy();

      this.topButtons.off('click.listbuilder');
      if (this.topButtons) {
        for (var i = 0, l = this.topButtons.length; i < l; i++) {
          var tooltipApi = $(this.topButtons[i]).data('tooltip');
          if (tooltipApi && typeof tooltipApi.destroy === 'function') {
            tooltipApi.destroy();
          }
        }
      }

      if (this.listApi && typeof this.listApi.destroy === 'function') {
        this.listApi.destroy();
      }

      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} [settings] incoming settings.
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, LISTBUILDER_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Teardown process for this plugin
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$L);
    }
  };

  /**
   * jQuery Component Wrapper for ListBuilder
   * @param {object} settings The settings to apply.
   * @returns {jQuery[]} The jquery object for chaining.
   */
  $.fn.listbuilder = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$L);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$L, new ListBuilder(this, settings));
      }
    });
  };

  // The name of this component.
  var COMPONENT_NAME$M = 'modal';

  /**
  * Responsive and Accessible Modal Control
  * @class Modal
  * @param {string} element The component element.
  * @param {string} settings The component settings.
  *
  * @param {string} [settings.trigger='click'] The method of opening the dialog. Supports click, immediate.
  * @param {array} [settings.buttons=null]  A list of buttons that will sit in the toolbar's Buttonset area.
  * @param {isAlert} [settings.isAlert=false] Adds alertdialog role for message dialogs.
  * @param {content} [settings.content=null] Ability to pass in dialog html content.
  * @param {string} [settings.cssClass=null] Append a css class to top level.
  * @param {boolean} [settings.autoFocus=true] If true the first input will be focused.
  * @param {string} [settings.id=null] Optionally tag a dialog with an id.
  * @param {number} [settings.frameHeight=180] Optional extra height to add.
  * @param {number} [settings.frameWidth=46] Optional extra width to add.
  * @param {function} [settings.beforeShow=null] A call back function that can be used to return data for the modal.
  * @param {boolean} [settings.useFlexToolbar] If true the new flex toolbar will be used (For CAP)
  * @param {boolean} [settings.showCloseBtn] If true, show a close icon button on the top right of the modal.
  * @param {number} [settings.maxWidth=null] Optional max width to add in pixels.
  * return the markup in the response and this will be shown in the modal. The busy indicator will be shown while waiting for a response.
  */
  var MODAL_DEFAULTS = {
    trigger: 'click',
    buttons: null,
    isAlert: false,
    content: null,
    cssClass: null,
    autoFocus: true,
    id: null,
    frameHeight: 180,
    frameWidth: 46,
    beforeShow: null,
    useFlexToolbar: false,
    showCloseBtn: false,
    maxWidth: null
  };

  function Modal(element, settings) {
    this.settings = utils.mergeSettings(element, settings, MODAL_DEFAULTS);
    this.element = $(element);
    this.init();
    this.reStructure();
  }

  // Actual Plugin Code
  Modal.prototype = {

    /**
     * @private
     * @returns {boolean} whether or not the Modal is a Contextual Action Panel (CAP)
     */
    get isCAP() {
      return this.element.is('.contextual-action-panel');
    },

    /**
     * @private
     * @returns {ContextualActionPanel|undefined} a reference to a Contextual Action Panel
     * API associated with this modal, if one exists.
     */
    get capAPI() {
      var api = void 0;
      if (this.trigger && this.trigger.length) {
        api = this.trigger.data('contextualactionpanel');
      } else if (this.mainContent.is('body')) {
        api = this.mainContent.data('contextualactionpanel');
      }
      return api;
    },

    /**
     * @returns {boolean} whether or not the body tag is this Modal's trigger element
     */
    get isAttachedToBody() {
      return this.trigger.length && this.trigger.is('body');
    },

    /**
     * @returns {boolean} whether or not this Modal is currently being displayed
     */
    get visible() {
      return this.element.is('.is-visible');
    },

    /**
     * @returns {boolean} whether or not this Modal instance is the top-level one
     */
    get isOnTop() {
      var max = 0;
      var dialog = this.element;

      $('.modal.is-visible').each(function () {
        if (max < this.style.zIndex) {
          max = this.style.zIndex;
        }
      });

      return max === dialog[0].style.zIndex;
    },

    /**
     * @private
     */
    init: function init() {
      var self = this;

      // Used for tracking events tied to the Window object
      this.id = this.element.attr('id') || parseInt($('.modal').length, 10) + 1;

      // Find the button or anchor with same dialog ID
      this.trigger = $('[data-modal="' + this.element.attr('id') + '"]');
      if (this.element.is('body')) {
        this.trigger = this.element;
      }

      this.overlay = $('<div class="overlay"></div>');
      this.oldActive = this.trigger;

      if (this.settings.trigger === 'click' && !this.isAttachedToBody) {
        this.trigger.on('click.modal', function (e) {
          if (!$(e.currentTarget).is(self.trigger)) {
            return;
          }
          self.open();
        });
      }

      if (this.settings.trigger === 'immediate') {
        setTimeout(function () {
          self.open();
        }, 1);
      }

      self.isCancelled = false;

      // ensure is appended to body for new dom tree
      if (this.settings.content) {
        this.settings.trigger = this.settings.content instanceof jQuery ? this.settings.trigger : 'immediate';
        this.appendContent();
        setTimeout(function () {
          self.open();
        }, 1);
        return;
      }

      if (this.settings.beforeShow) {
        this.settings.trigger = this.settings.content instanceof jQuery ? this.settings.trigger : 'immediate';
        this.appendContent();
        this.callSource();
        return;
      }

      self.addButtons(this.settings.buttons);
      this.element.appendTo('body');
      this.element[0].style.display = 'none';
    },
    appendContent: function appendContent() {
      var _this = this;

      var isAppended = false;

      this.element = $('' + ('<div class="modal">' + '<div class="modal-content" style="max-width: ') + (this.settings.maxWidth ? this.settings.maxWidth : '') + 'px' + ('">' + '<div class="modal-header"><h1 class="modal-title">') + this.settings.title + '</h1></div>' + '<div class="modal-body-wrapper">' + '<div class="modal-body"></div>' + '</div>' + '</div>' + '</div>');

      if (this.settings.showCloseBtn) {
        var closeBtn = $('\n        <button type="button" class="btn-icon btn-close" title="' + Locale.translate('Close') + '" aria-hidden="true">\n          ' + $.createIcon('close') + '\n          <span class="audible">' + Locale.translate('Close') + '</span>\n        </button>\n      ');
        this.element.find('.modal-content').append(closeBtn);
        closeBtn.on('click.modal', function () {
          return _this.close();
        }).tooltip();
      }

      if (this.settings.id) {
        this.element.attr('id', this.settings.id);
      }

      if ($(this.settings.content).is('.modal')) {
        this.element = $(this.settings.content);
        isAppended = this.element.parent().hasClass('modal-wrapper');
      } else if (this.settings.content && this.settings.content.length > 0) {
        if (this.settings.content instanceof jQuery && this.settings.content.parent().is('.modal-body')) {
          isAppended = true;
          this.element = this.settings.content.closest('.modal');
        } else {
          this.element.find('.modal-body').append(this.settings.content);
        }

        if (this.settings.content instanceof jQuery && !this.settings.beforeShow) {
          this.settings.content.removeClass('hidden is-hidden');
          this.settings.content.show();
        }
      }

      if (this.settings.beforeShow) {
        this.busyIndicator = $('<div class="overlay busy"></div>' + '<div class="busy-indicator-container blocked-ui" aria-live="polite" role="status">' + '<div class="busy-indicator active">' + '<div class="bar one"></div>' + '<div class="bar two"></div>' + '<div class="bar three"></div>' + '<div class="bar four"></div>' + '<div class="bar five"></div>' + '</div>' + '<span>Loading...</span>' + '</div>');
        $('body').append(this.busyIndicator);
      }

      if (!isAppended) {
        this.element.appendTo('body');
      }

      if (this.settings.cssClass) {
        this.element.addClass(this.settings.cssClass);
      }

      if (this.settings.title) {
        this.element.find('.modal-title').text(this.settings.title);
      }

      if (!isAppended) {
        this.addButtons(this.settings.buttons);
      }

      utils.fixSVGIcons(this.element);
    },
    reStructure: function reStructure() {
      var body = $('.modal-body', this.element);
      var hr = $('hr:first-child', body);
      var buttonset = $('.modal-buttonset', this.element);

      if (body && body.length && !body.parent().hasClass('modal-body-wrapper')) {
        body.wrap('<div class="modal-body-wrapper"></div>');
      }
      if (hr && hr.length && !hr.parent().hasClass('modal-content')) {
        hr.insertAfter(this.element.find('.modal-header'));
      }
      if (buttonset && buttonset.length && !buttonset.parent().hasClass('modal-content')) {
        buttonset.insertAfter(this.element.find('.modal-body-wrapper'));
      }
    },


    /**
     * Check if the submit button should be disabled based on validation status.
     * @private
     * @returns {void}
     */
    disableSubmit: function disableSubmit() {
      var body = this.element;
      var inlineBtns = body.find('.modal-buttonset button');
      var primaryButton = inlineBtns.filter('.btn-modal-primary').not('.no-validation');
      var dropdowns = body.find('select.dropdown[data-validate]');
      var fields = body.find('[data-validate]:visible');

      dropdowns.each(function () {
        var dropdown = $(this);
        if (dropdown.next('.dropdown-wrapper').is(':visible')) {
          fields = fields.add(this);
        }
      });

      if (fields.length > 0) {
        primaryButton.removeAttr('disabled');

        var allValid = true;
        fields.each(function () {
          var field = $(this);
          if (field.closest('.datagrid-filter-wrapper').length > 0) {
            return;
          }

          var isVisible = field.is('.dropdown') && field.next('.dropdown-wrapper').is(':visible') || field[0].offsetParent !== null;

          if (field.is('.required')) {
            if (isVisible && !field.val()) {
              allValid = false;
            }
          } else {
            field.validateField();
            if (isVisible && !field.isValid()) {
              allValid = false;
            }
          }

          if (isVisible && field.is('.error')) {
            allValid = false;
          }

          if (allValid) {
            primaryButton.removeAttr('disabled');
          }
        });

        if (!allValid && !primaryButton.is(':disabled')) {
          primaryButton.attr('disabled', 'true');
        }
      }
    },
    addButtons: function addButtons(buttons) {
      var self = this;
      var body = this.element.find('.modal-body');
      var bodywrapper = body.parent();
      var flexToolbar = this.element.find('.flex-toolbar');
      var btnWidth = 100;
      var isPanel = false;
      var buttonset = void 0;

      this.modalButtons = buttons;

      if (!buttons) {
        var inlineBtns = this.element.find('.modal-buttonset button');

        // Buttons in markup
        btnWidth = 100 / inlineBtns.length;
        for (var i = 0, l = inlineBtns.length; i < l; i++) {
          inlineBtns[i].style.width = btnWidth + '%';
        }
        inlineBtns.button();
        inlineBtns.not('[data-ng-click], [ng-click], [onclick], :submit').on('click.modal', function (e) {
          if ($(e.target).is('.btn-cancel')) {
            self.isCancelled = true;
          }
          self.close();
        });
        return;
      }

      if (this.isCAP) {
        // CAP is responsible for rendering this part, and will have done so by the
        // time this code runs
        isPanel = true;
        buttonset = this.element.find('.buttonset');
      } else {
        buttonset = this.element.find('.modal-buttonset');
        if (!buttonset.length) {
          buttonset = $('<div class="modal-buttonset"></div>').insertAfter(bodywrapper);
        }
      }

      btnWidth = 100 / buttons.length;

      if (buttons) {
        buttonset.empty();
      }

      var decorateButtons = function decorateButtons(props, cnt) {
        var btn = $('<button type="button">\n        <span></span>\n      </button>');
        var span = btn.find('span');

        span.text(props.text);
        btn.attr('type', props.type || 'button');

        if (props.cssClass === 'separator') {
          btn = $('<div class="separator"></div>');
        }

        if (props.cssClass) {
          btn.attr('class', props.cssClass);
        } else if (props.isDefault) {
          btn.addClass('btn-modal-primary');
        } else {
          btn.addClass('btn-modal');
        }

        if (props.audible) {
          span.addClass('audible');
        }

        if (props.validate !== undefined && !props.validate) {
          btn.addClass('no-validation');
        }

        var attrs = {};
        var attrTypes = ['id', 'name', 'text'];

        for (var k = 0; k < attrTypes.length; k++) {
          if (props[attrTypes[k]]) {
            attrs[attrTypes[k]] = props[attrTypes[k]];
          }
        }

        if (props.type === 'input') {
          var label = $('<label class="audible" for="filter">' + props.text + '</label>');
          var input = $('<input class="searchfield">').attr(attrs);

          if (flexToolbar.length) {
            flexToolbar.find('.toolbar-section.search').append(label, input);
          } else {
            buttonset.append(label, input);
          }
          input.searchfield(props.searchfieldSettings);
          return;
        }

        if (props.icon && props.icon.charAt(0) === '#') {
          $.createIconElement({
            classes: [props.icon === '#icon-close' ? 'icon-close' : ''],
            icon: props.icon.substr('#icon-'.length)
          }).prependTo(btn);
        }

        btn[0].setAttribute('id', props.id || utils.uniqueId(self.element, 'button', 'modal'));

        var func = buttons[cnt].click;

        btn.on('click.modal', function (e) {
          if (func) {
            func.apply(self.element[0], [e, self]);
            return;
          }
          self.close();
        });

        if (!isPanel) {
          btn[0].style.width = btnWidth + '%';
        }

        btn.button();

        if ((self.settings.useFlexToolbar || self.settings.centerTitle) && props.align) {
          if (props.align === 'left') {
            flexToolbar.find('.toolbar-section').eq(0).append(btn);
          }

          if (props.align === 'center') {
            flexToolbar.find('.toolbar-section').eq(1).find('h2').append(btn);
          }

          if (props.align === 'right') {
            flexToolbar.find('.toolbar-section').eq(2).append(btn);
          }
        } else {
          buttonset.append(btn);
        }
      };

      for (var cnt = 0; cnt < buttons.length; cnt++) {
        decorateButtons(buttons[cnt], cnt);
      }
    },


    /**
    * Size the inner content on resize.
    * @private
    * @returns {void}
    */
    sizeInner: function sizeInner() {
      var messageArea = this.element.find('.detailed-message');
      // Set a max width
      var h = $(window).height() - messageArea.offset().top - 150;
      messageArea[0].style.maxHeight = h + 'px';
      messageArea[0].style.overflow = 'auto';
      messageArea[0].style.width = messageArea.width() + 'px';
    },
    callSource: function callSource() {
      if (typeof this.settings.beforeShow !== 'function') {
        return;
      }

      var self = this;
      var response = function response(content) {
        if (content === false) {
          return false;
        }

        $('#modal-busyindicator').trigger('complete.busyindicator');

        // Returning `true` from the response will cause a modal area to render to the page,
        // but remain hidden.  In this scenario it will be up to the app developer to reveal
        // the modal when needed.
        if (content === true) {
          if (self.busyIndicator) {
            self.busyIndicator.remove();
            delete self.busyIndicator;
          }

          return true;
        }

        if (!(content instanceof jQuery)) {
          content = $(content);
        }

        self.open(true);

        self.element.find('.modal-body').empty();
        self.element.find('.modal-body').append(content);

        content.show();

        return true;
      };

      var callBackOpts = {};
      this.settings.beforeShow(response, callBackOpts);
    },


    /**
     * Open the modal via the api.
     * @param {boolean} ajaxReturn Flag used internally to denote its an ajax result return.
     */
    open: function open(ajaxReturn) {
      var _this2 = this;

      var messageArea = null;
      var elemCanOpen = true;

      // close any active tooltips
      $('#validation-errors, #tooltip, #validation-tooltip').addClass('is-hidden');

      if (this.busyIndicator) {
        this.busyIndicator.remove();
        delete this.busyIndicator;
      }

      if (!this.trigger || this.trigger.length === 0) {
        this.oldActive = $(':focus'); // Save and restore focus for A11Y
      }

      this.element.after(this.overlay);
      if (this.element && !this.element.parent().hasClass('modal-wrapper')) {
        this.element.wrap('<div class="modal-page-container"><div class="modal-wrapper"></div>');
      }
      this.root = this.element.closest('.modal-page-container');

      messageArea = this.element.find('.detailed-message');
      if (messageArea.length === 1) {
        $('body').on('resize.modal-' + this.id, function () {
          _this2.sizeInner();
        });
        this.sizeInner();
      }

      /**
      * Fires when the modal is about to open. You can return false to abort opening.
      * @event beforeopen
      * @memberof Modal
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      elemCanOpen = this.element.triggerHandler('beforeopen', [this]);
      $('body').triggerHandler('beforeopen', [this]);
      this.isCancelled = false;

      if (elemCanOpen === false) {
        this.overlay.remove();
        this.root[0].style.display = 'none';
        return;
      }

      if (!ajaxReturn) {
        this.callSource();

        if (this.settings.beforeShow) {
          return;
        }
      }

      // Look for other nested dialogs and adjust the zindex.
      $('.modal').each(function (i) {
        var modal = $(this);
        this.style.zIndex = (1020 + (i + 1)).toString();

        if (modal.data('modal') && modal.data('modal').overlay) {
          modal.data('modal').overlay[0].style.zIndex = (1020 + i).toString();
        }

        if (!modal.data('modal')) {
          var overlay = modal.closest('.modal-page-container').next('.overlay');
          if (overlay && overlay[0]) {
            overlay[0].style.zIndex = (1020 + i).toString();
          }
        }
      });

      $('body > *').not(this.element).not('.modal, .overlay, .modal-page-container').attr('aria-hidden', 'true');

      // Ensure aria-labelled by points to the id
      if (this.settings.isAlert) {
        this.element.attr('aria-labelledby', 'message-title');
        this.element.attr('aria-describedby', 'message-text');
      } else {
        var h1 = this.element.find('h1:first');
        var id = h1.attr('id');

        if (!id) {
          id = (this.element.attr('id') ? this.element.attr('id') : 'h1') + '-title';
          h1.attr('id', id);
        }

        var body = this.element.find('.modal-body');
        var descById = (this.element.attr('id') ? this.element.attr('id') : 'message') + '-text';

        this.element.attr('aria-labelledby', id);

        // Contextual Action Panel Case - Has a toolbar
        if (this.element.find('.toolbar .title').length) {
          this.element.find('.toolbar .title').attr('id', descById);
          this.element.attr('aria-describedby', descById);
        } else {
          body.attr('id', descById);
          this.element.attr('aria-describedby', descById);
        }
      }

      this.mainContent = $('body').children('.scrollable-container');
      if (!this.mainContent.length) {
        this.mainContent = $('body');
      }

      this.removeNoScroll = !this.mainContent.hasClass('no-scroll');
      this.mainContent.addClass('no-scroll');

      $('body').on('resize.modal-' + this.id, function () {
        _this2.resize();
      });

      // Center
      this.root[0].style.display = '';
      this.element[0].style.display = '';

      setTimeout(function () {
        _this2.resize();
        _this2.element.addClass('is-visible').attr('role', _this2.settings.isAlert ? 'alertdialog' : 'dialog');
        _this2.root.removeAttr('aria-hidden');
        _this2.overlay.attr('aria-hidden', 'true');
        _this2.element.attr('aria-modal', 'true'); // This is a forward thinking approach, since aria-modal isn't actually supported by browsers or ATs yet
      }, 1);

      // Add the 'modal-engaged' class after all the HTML markup and CSS classes have a
      // chance to be established
      // (Fixes an issue in non-V8 browsers (FF, IE) where animation doesn't work correctly).
      // http://stackoverflow.com/questions/12088819/css-transitions-on-new-elements
      $('body').addClass('modal-engaged');

      // Handle Default button.
      $(this.element).on('keypress.modal', function (e) {
        var target = $(e.target);

        if (target.is('.editor, .searchfield, textarea, :button') || target.closest('.tab-list').length || $('#dropdown-list').length) {
          return;
        }

        if (e.which === 13 && _this2.isOnTop && !target.closest('form').find(':submit').length && _this2.element.find('.btn-modal-primary:enabled').length) {
          e.stopPropagation();
          e.preventDefault();

          if (!target.hasClass('fileupload') && !$(target).is(':input') || target.hasClass('colorpicker')) {
            _this2.element.find('.btn-modal-primary:enabled').trigger('click');
          }
        }
      });

      // Override this page's skip-link default functionality to instead focus the top
      // of this element if it's clicked.
      $('.skip-link').on('focus.modal', function (e) {
        e.preventDefault();
        _this2.getTabbableElements().first.focus();
      });

      function focusElement(self) {
        var focusElem = self.element.find(':focusable').not('.modal-header .searchfield').first();
        self.keepFocus();

        /**
        * Fires when the modal opens.
        * @event open
        * @memberof Modal
        * @property {object} event - The jquery event object
        * @property {object} ui - The dialog object
        */
        self.element.trigger('open', [self]);

        if (focusElem.length === 0) {
          focusElem = self.element.find('.btn-modal-primary');
        }

        if (focusElem.length === 1 && focusElem.is('.btn-modal')) {
          focusElem = self.element.find('.btn-modal-primary');
        }

        if (focusElem.length === 1 && focusElem.is('button') && !focusElem.is(':disabled')) {
          focusElem.addClass('hide-focus');
        }

        if (!self.settings.autoFocus) {
          return;
        }

        // If the selected element is a tab, actually make sure it's the "selected" tab.
        var selected = void 0;
        var tabParent = void 0;

        if (focusElem.is('.tab:not(.is-selected) a')) {
          tabParent = focusElem.closest('.tab-container');
          selected = tabParent.find('.is-selected');
          if (selected.length) {
            focusElem = selected;
            tabParent.data('tabs').select(selected.children('a').attr('href'));
            return;
          }
        }

        // Otherwise, just focus
        focusElem.focus();
      }

      var pagerElem = this.element.find('.paginated');
      pagerElem.on('afterpaging', function () {
        _this2.resize();
      });

      setTimeout(function () {
        _this2.disableSubmit();
      }, 10);

      var fields = this.element.find('[data-validate]');
      fields.removeClass('disable-validation');

      setTimeout(function () {
        focusElement(_this2);
      }, 200);

      /**
      * Fires after the modal has opened.
      * @event afteropen
      * @memberof Modal
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */
      setTimeout(function () {
        _this2.element.trigger('afteropen');
      }, 300);
    },
    resize: function resize() {
      // 90% -(180 :extra elements-height)
      var calcHeight = $(window).height() * 0.9 - this.settings.frameHeight;
      var calcWidth = $(window).width() * 1 - this.settings.frameWidth;

      var wrapper = this.element.find('.modal-body-wrapper');

      if (wrapper.length) {
        wrapper[0].style.maxHeight = calcHeight + 'px';
        wrapper[0].style.maxWidth = calcWidth + 'px';
      }

      if (this.element.hasClass('lookup-modal')) {
        var table = this.element.find('.datagrid-body');
        var hasPager = this.element.find('.pager-toolbar');
        var container = table.closest('.datagrid-container');

        calcHeight = calcHeight - (container.prev().is('.toolbar') ? 130 : 60) - (container.next().is('.pager-toolbar') ? 35 : 0);
        table[0].style.maxHeight = calcHeight + (hasPager.length ? -15 : 0) + 'px';
        table[0].style.maxWidth = calcWidth + 'px';
      }

      var toolbars = this.element.find('.toolbar');
      if (toolbars.length) {
        toolbars.triggerHandler('recalculate-buttons');
      }
    },


    /**
     * This method is slated to be removed in a future v4.20.0 or v5.0.0.
     * @deprecated as of v4.14.0. Please use the `visible` property instead.
     * @returns {boolean} The current state open (true) or closed (false).
     */
    isOpen: function isOpen() {
      warnAboutDeprecation('visible', 'isOpen');
      return this.visible;
    },
    getTabbableElements: function getTabbableElements() {
      var allTabbableElements = $(this.element).find('a[href], area[href], input:not([disabled]),' + 'select:not([disabled]), textarea:not([disabled]),' + 'button:not([disabled]), iframe, object, embed, *[tabindex],' + '*[contenteditable]').filter(':visible');
      return {
        first: allTabbableElements[0],
        last: allTabbableElements[allTabbableElements.length - 1]
      };
    },
    keepFocus: function keepFocus() {
      var self = this;
      var tabbableElements = void 0;

      // Escape key
      $(document).off('keydown.modal-' + this.id).on('keydown.modal-' + this.id, function (e) {
        var keyCode = e.which || e.keyCode;
        if (keyCode === 27) {
          var modals = $('.modal.is-visible');

          self.isCancelled = true;

          if (modals.length > 1) {
            modals.not(':last').on('beforeclose.modal', function () {
              return false;
            });
            modals.on('afterclose.modal', function () {
              modals.off('beforeclose.modal');
            });
            var apiModal = modals.last().data('modal');
            if (apiModal && apiModal.close) {
              apiModal.close();
            }
          } else {
            self.close();
          }
        }
      });

      $(self.element).off('keypress.modal keydown.modal').on('keypress.modal keydown.modal', function (e) {
        var keyCode = e.which || e.keyCode;

        if (keyCode === 9) {
          tabbableElements = self.getTabbableElements();

          // Move focus to first element that can be tabbed if Shift isn't used
          if (e.target === tabbableElements.last && !e.shiftKey) {
            e.preventDefault();
            tabbableElements.first.focus();
          } else if (e.target === tabbableElements.first && e.shiftKey) {
            e.preventDefault();
            tabbableElements.last.focus();
          }

          self.element.find('#message-title').removeAttr('tabindex');
        }
      });
    },


    /**
     * Close the modal.
     * @param  {boolean} destroy Call the destroy method.
     * @returns {boolean} If the dialog was open returns false. If the dialog was closed is true.
     */
    close: function close(destroy) {
      if (!this.visible) {
        return true;
      }

      var elemCanClose = this.element.triggerHandler('beforeclose');
      var self = this;
      var fields = this.element.find('[data-validate]');

      this.root = this.element.closest('.modal-page-container');
      fields.addClass('disable-validation');

      if (elemCanClose === false) {
        return false;
      }

      if (this.mainContent && this.removeNoScroll) {
        this.mainContent.removeClass('no-scroll');
      }
      $('body').off('resize.modal-' + this.id);

      this.element.off('keypress.modal keydown.modal');
      this.element.removeClass('is-visible');

      this.overlay.attr('aria-hidden', 'true');
      if (this.root) {
        this.root.attr('aria-hidden', 'true');
      }

      if ($('.modal-page-container').length <= 1) {
        $('body').removeClass('modal-engaged');
        $('body > *').not(this.element.closest('.modal-page-container')).removeAttr('aria-hidden');
        $('.overlay').remove();
      }

      // Fire Events
      self.element.trigger('close', self.isCancelled);

      // Restore focus
      if (this.oldActive && $(this.oldActive).is('a:visible, button:visible, input:visible, textarea:visible')) {
        this.oldActive.focus();
        this.oldActive = null;
      } else if (this.trigger.parents('.toolbar, .formatter-toolbar').length < 1) {
        this.trigger.focus();
      }

      // close tooltips
      $('#validation-errors, #tooltip, #validation-tooltip').addClass('is-hidden');

      // remove the event that changed this page's skip-link functionality in the open event.
      $('.skip-link').off('focus.modal');

      setTimeout(function () {
        self.overlay.remove();
        self.root[0].style.display = 'none';
        self.element.trigger('afterclose');

        if (self.settings.trigger === 'immediate' || destroy) {
          self.destroy();
        }
      }, 300); // should match the length of time needed for the overlay to fade out

      return false;
    },


    /**
     * Update the modal
     * @param {settings} settings The settings to update on the modal
     * @returns {object} The modal object for chaining.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      if (this.settings.trigger === 'immediate') {
        this.open();
      }

      return this;
    },


    /**
     * Destroy the modal.
     */
    destroy: function destroy() {
      var self = this;
      var canDestroy = this.element.trigger('beforedestroy');

      if (!canDestroy) {
        return;
      }

      function destroyCallback() {
        if (self.modalButtons) {
          self.element.find('button').off('click.modal');
        }

        if (self.element.find('.detailed-message').length === 1) {
          $('body').off('resize.modal-' + this.id);
        }

        // Properly teardown contexual action panels
        if (self.isCAP && self.capAPI) {
          self.capAPI.teardown();
        }

        self.trigger.off('click.modal');

        if (self.root && self.root.length) {
          self.root.remove();
        } else {
          self.element.closest('.modal-page-container').remove();
        }
        self.element[0].removeAttribute('data-modal');

        $.removeData(self.element[0], 'modal');
        if (self.isCAP && self.capAPI) {
          self.capAPI.destroy();
        }
      }

      if (!this.visible) {
        destroyCallback();
        return;
      }

      this.element.one('afterclose.modal', function () {
        destroyCallback();
      });

      this.close(true);
    }
  };

  /**
   * The Message Component is used to show warning / error messages.
   * @class Message
   * @param {object} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.title='Message Title']  Title text or content shown in the message
   * @param {string} [settings.status='']  Pass a status to style icon and title color ('error', 'alert', 'success')
   * @param {string} [settings.message='Message Summary']  The message content or text
   * @param {number} [settings.width='auto']  Pass a specific with or defaults to auto
   * @param {object} [settings.buttons=null]  Array of buttons to add to the message (see modal examples as well)
   * @param {string} [settings.cssClass=null]  Extra Class to add to the dialog for customization.
   * @param {string} [settings.returnFocus=null]  JQuery Element selector to focus on return.
   * @param {string} [allowedTags='<a><b><br><br/><del><em><i><ins><mark><small><strong><sub><sup>']  String of allowed HTML tags.
   */
  var MESSAGE_DEFAULTS = {
    title: 'Message Title',
    status: '',
    message: 'Message Summary',
    width: 'auto',
    buttons: null,
    cssClass: null,
    returnFocus: null,
    allowedTags: '<a><b><br><br/><del><em><i><ins><mark><small><strong><sub><sup>'
  };

  function Message(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings, MESSAGE_DEFAULTS);
    this.init();
  }

  Message.prototype = {
    init: function init() {
      var self = this;
      var content = void 0;
      var tags = this.settings.allowedTags;
      var allowTags = true;

      // Check for any allowed tags in settings string
      if (!(this.settings.allowedTags.length > 0)) {
        allowTags = false;
      }

      // Create the Markup
      this.message = $('<div class="modal message"></div>');
      this.messageContent = $('<div class="modal-content"></div>');
      this.title = $('<h1 class="modal-title" id="message-title">' + (allowTags ? xssUtils.stripTags(this.settings.title, tags) : xssUtils.stripHTML(this.settings.title)) + '</h1>').appendTo(this.messageContent).wrap('<div class="modal-header"></div>');
      this.content = $('<div class="modal-body"><p class="message" id="message-text">' + (allowTags ? xssUtils.stripTags(this.settings.message, tags) : xssUtils.stripHTML(this.settings.message)) + '</p></div>').appendTo(this.messageContent);

      // Append The Content if Passed in
      if (!this.element.is('body')) {
        content = this.element;
        this.content.empty().append(content.show());
      }

      this.message.append(this.messageContent).appendTo('body');
      this.message.modal({
        trigger: 'immediate',
        buttons: this.settings.buttons,
        resizable: this.settings.resizable,
        close: this.settings.close,
        isAlert: true
      });

      // Adjust Width if Set as a Setting
      if (this.settings.width !== 'auto') {
        this.content.closest('.modal')[0].style.maxWidth = 'none';
        this.content.closest('.modal')[0].style.width = this.settings.width + (/(px|%)/i.test('' + this.settings.width) ? '' : 'px');
      }

      if (this.settings.cssClass) {
        this.message.addClass(this.settings.cssClass);
      }

      // Setup the destroy event to fire on close.
      // Needs to fire after the "close" event on the modal.
      this.message.on('beforeclose.message', function () {
        var ok = self.element.triggerHandler('beforeclose');
        return ok;
      }).on('beforeopen.message', function () {
        var ok = self.element.triggerHandler('beforeopen');
        return ok;
      }).on('open.message', function () {
        self.element.trigger('open');
      }).on('afterclose.message', function () {
        self.destroy();
        if (self.settings.returnFocus) {
          self.settings.returnFocus.focus();
        }

        $(document).off('keypress.message keydown.message');
      });

      $(document).on('keypress.message keydown.message', function (e) {
        var keyCode = e.which || e.keyCode;

        if (keyCode === 27) {
          setTimeout(function () {
            var modalData = self.message.data('modal');
            if (modalData !== undefined) {
              modalData.close();
            }
          }, 0);
        }
      });

      if (this.settings.status === 'error') {
        this.title.addClass('has-status is-error').prepend($.createIconElement('error'));
      } else if (this.settings.status === 'alert') {
        this.title.addClass('has-status is-alert').prepend($.createIconElement('alert'));
      } else if (this.settings.status === 'success') {
        this.title.addClass('has-status is-success').prepend($.createIconElement('success'));
      } else {
        this.title.removeClass('has-status is-error is-alert is-success').find('svg').remove();
      }
    },
    destroy: function destroy() {
      var modalData = this.message.data('modal');
      if (modalData !== undefined) {
        modalData.destroy();
      }

      this.message.off('beforeclose.message beforeopen.message open.message afterclose.message').remove();
    }
  };

  /**
   * jQuery Component Wrapper for Messages
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.message = function (settings) {
    // Support Chaining and Init the Control or Set Settings
    return this.each(function () {
      return new Message(this, settings);
    });
  };

  /**
  * jQuery Component Wrapper for Modal
  * @param {object} settings The settings to apply.
  * @returns {jQuery[]} The jquery object for chaining.
  */
  $.fn.modal = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$M);
      var elem = $(this);

      if (!elem.is('.modal')) {
        instance = elem.closest('.modal').data(COMPONENT_NAME$M);
      }

      if (instance && settings) {
        instance.updated(settings);
        // This was added for backwards compatability when using:
        // `$(this).modal('close');`
        // Examples have been updated to not show this.
        if (typeof instance[settings] === 'function') {
          instance[settings]();
        }
        return;
      }

      if (instance && !settings) {
        return;
      }

      instance = $.data(this, COMPONENT_NAME$M, new Modal(this, settings));
    });
  };

  /**
   * jQuery Component Wrapper for MonthView
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.monthview = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$p);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$p, new MonthView(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$N = 'multiselect';

  // Component Defaults
  var MULTISELECT_DEFAULTS = {
    closeOnSelect: false,
    empty: true,
    filterMode: 'contains',
    maxSelected: undefined,
    moveSelected: 'all',
    multiple: true,
    showEmptyGroupHeaders: false,
    showSelectAll: false,
    source: undefined
  };

  /**
   * The MultiSelect Component allows selecting multiple items from a list
   * @class MultiSelect
   * @constructor
   * @param {jQuery[]|HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   * @param {string} [settings.filterMode = 'contains']  The search mode to use, can be 'contains' or 'startsWith'
   * @param {number} [settings.maxSelected = null]  The max number of items which can be selected
   * @param {string} [settings.moveSelected = 'all']   Move selected options in each group to just underneath their corresponding group headers.
   * @param {boolean} [settings.showEmptyGroupHeaders = false]  If true groups with no items will still show the empty group header.
   * @param {boolean} [settings.showSelectAll = false]  Show the select all button and text .
   * @param {function} [settings.source]  The calback for ajax.
   */
  function MultiSelect(element, settings) {
    this.settings = utils.mergeSettings(element, settings, MULTISELECT_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  MultiSelect.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.build();
    },


    /**
     * @private
     * @returns {void}
     */
    build: function build() {
      this.element.dropdown(this.settings);
      this.dropdown = this.element.data('dropdown');

      return this;
    },


    /**
     * Enable the multiselect input
     * @returns {void}
     */
    enable: function enable() {
      this.dropdown.enable();
    },


    /**
    * Disable the multiselect input
    * @returns {void}
    */
    disable: function disable() {
      this.dropdown.disable();
    },


    /**
    * Trigger a rebuild due to settings change
    * @param {object} [settings] incoming settings
    * @returns {void}
    */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.build();
    },


    /**
     * Remove added markup and events
     * @returns {void}
     */
    destroy: function destroy() {
      this.dropdown.destroy();
      this.element.off();
      $.removeData(this.element[0], COMPONENT_NAME$N);
    }
  };

  /**
   * jQuery Component wrapper for Multiselect
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.multiselect = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$N);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$N, new MultiSelect(this, settings));
      }
    });
  };

  // Settings and Options
  var COMPONENT_NAME$O = 'notification';

  var NOTIFICATION_DEFAULTS = {
    message: 'Hi! Im a notification message.',
    type: 'alert',
    parent: '.header',
    link: '#',
    linkText: 'Click here to view.'
  };

  /**
   * Notification - Shows a slide in notifcation banner on the top of the page.
   * @class Notification
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {string} [settings.message] The text message to show in the notification.
   * @param {string} [settings.type] The message type, this influences the icon and color, possible types are 'error', 'alert', 'info' and 'success'
   * @param {string} [settings.parent] The jQuery selector to find where to insert the message into (prepended). By default this will appear under the .header on the page.
   * @param {string} [settings.link] The url to use for the hyperlink
   * @param {string} [settings.linkText] The text to show in the hyperlink. Leave empty for no link.
   */
  function Notification(element, settings) {
    this.settings = utils.mergeSettings(element, settings, NOTIFICATION_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Notification.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The Notification prototype, useful for chaining.
     */
    init: function init() {
      return this.build().handleEvents();
    },


    /**
     * Add any needed markup to the component.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    build: function build() {
      this.notificationEl = document.createElement('div');
      this.notificationEl.classList.add('notification', this.settings.type);
      this.notificationEl.innerHTML = '<svg class="icon icon-' + this.settings.type + '" focusable="false" aria-hidden="true" role="presentation">\n       <use xlink:href="#icon-' + this.settings.type + '"></use>\n    </svg>\n    <span class="notification-text">' + this.settings.message + '</span>\n    ' + (this.settings.linkText ? '<a class="notification-link" href="' + this.settings.link + '">' + this.settings.linkText + '</a>' : '') + '\n    <button type="text" class="notification-close"><svg class="icon" focusable="false" aria-hidden="true" role="presentation">\n       <use xlink:href="#icon-close"></use>\n    </svg><span class="audible">' + Locale.translate('Close') + '</span></button>';

      var parentEl = document.querySelector(this.settings.parent);

      parentEl.parentNode.insertBefore(this.notificationEl, parentEl.nextSibling);
      $(this.notificationEl).animateOpen({ distance: 40 });
      return this;
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.off('updated.' + COMPONENT_NAME$O).on('updated.' + COMPONENT_NAME$O, function () {
        self.updated();
      });

      $(this.notificationEl).off('click.' + COMPONENT_NAME$O).on('click.' + COMPONENT_NAME$O, '.notification-close', function () {
        self.destroy();
      });

      return this;
    },


    /**
     * Handle updated settings and values.
     * @param {object} [settings] incoming settings
     * @returns {object} [description]
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, NOTIFICATION_DEFAULTS);
      }

      return this.teardown().init();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$O);
      this.element.off('click.' + COMPONENT_NAME$O, '.notification-close');
      return this;
    },


    /**
     * Destroy and remove added markup and detatch events.
     */
    destroy: function destroy() {
      if (this.notificationEl && this.notificationEl.parentNode) {
        this.notificationEl.parentNode.removeChild(this.notificationEl);
      }

      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$O);
    }
  };

  /**
   * jQuery Component Wrapper for notification
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.notification = function (settings) {
    return this.each(function () {
      $.data(this, COMPONENT_NAME$O, new Notification(this, settings));
    });
  };

  // Component Name
  var COMPONENT_NAME$P = 'progress';

  // Default Progress Options
  var PROGRESS_DEFAULTS = {};

  /**
  * A list of items with add/remove/delete and sort functionality.
  * @class Progress
  * @constructor
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  */
  function Progress(element, settings) {
    this.settings = utils.mergeSettings(element, settings, PROGRESS_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Actual Progress Code
  Progress.prototype = {

    /**
     * Init this component.
     * @private
     */
    init: function init() {
      var _this = this;

      this.update();

      this.element.off('updated.progress').on('updated.progress', function (e) {
        e.stopPropagation();
        _this.update();
      });
    },


    /**
     * Update the aria on this component
     * @private
     * @param  {string} value The progress value.
     */
    updateAria: function updateAria(value) {
      this.element.attr({ role: 'progressbar', 'aria-valuenow': value, 'aria-valuemax': '100' });

      var container = this.element.parent();
      if (container.data('tooltip')) {
        container.data('tooltip').content = value + '%';
      } else {
        container[0].setAttribute('title', value + '%');
        container.tooltip();
      }
    },


    /**
     * Unbind all events.
     * @private
     */
    unbind: function unbind() {
      this.element.off('updated.progress');
    },


    /**
    * Update the progress bar.
    * @param {string} value  The percent value to use to fill. 0-100
    * @returns {void}
    */
    update: function update(value) {
      var perc = this.element.attr('data-value');

      if (value) {
        perc = value;
        this.element.attr('data-value', value);
      }

      this.element[0].style.width = perc + '%';
      this.updateAria(perc);
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, PROGRESS_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
    * Teardown and remove any added markup and events.
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$P);
    }
  };

  /**
   * jQuery Component Wrapper for Progress
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.progress = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$P);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$P, new Progress(this, settings));
      }
    });
  };

  // jQuery Components

  // Component Name
  var COMPONENT_NAME$Q = 'popdown';

  /**
   * The Popdown Component can be used to open an animated popdown from a button. This may in the future
   * be deprecated to one thing. Popup vs Popdown vs Tooltip.
   * @class Popdown
   * @deprecated
   * @param {object} element The component element.
   * @param {object} [settings] The component settings.
   * @property {boolean} [settings.keepOpen = false] If true, will keep the Popdown open after clicking out until the Trigger
   * element is clicked, or until another pop-open element is opened.
   * @property {jQuery[]} [settings.trigger] If defined, provides a way to place the popdown against an alternate element.
  */
  var POPDOWN_DEFAULTS = {
    keepOpen: false,
    trigger: undefined
  };

  function Popdown(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, POPDOWN_DEFAULTS);
    this.init();
  }

  Popdown.prototype = {
    init: function init() {
      return this.setup().build().handleEvents();
    },
    setup: function setup() {
      var self = this;
      this.popdown = $();

      // Setup the proper trigger element to use
      this.trigger = this.element;
      if (this.settings.trigger instanceof $ || DOM.isElement(this.settings.trigger)) {
        this.trigger = $(this.settings.trigger);
      }
      // Force-change the trigger element in some specific scenarios
      if (this.trigger.is('.dropdown, .multiselect')) {
        this.trigger = $('#' + this.element.attr('id') + '-shdo');
      }

      // Find the correct element to use as the popdown's view.
      function tryPopdownElement(elem) {
        if (!elem) {
          return false;
        }

        if (typeof elem === 'string') {
          if (!elem.match('#') || elem.indexOf('#') !== 0) {
            elem = '#' + elem;
          }
          elem = $(elem);
        }

        if (elem.length) {
          self.popdown = elem;
          return true;
        }

        return false;
      }

      var popdownElem = tryPopdownElement(this.trigger.attr('data-popdown'));
      if (!popdownElem) {
        tryPopdownElement(this.trigger.next('.popdown'));
      }

      // Setup an ID for this popdown if it doesn't already have one
      this.id = this.popdown.attr('id');
      if (!this.id) {
        this.id = 'popdown-' + $('body').find('.popdown').index(this.popdown);
        this.popdown.attr('id', this.id);
      }

      return this;
    },
    build: function build() {
      // Ensure the popdown window is a popdown, and remove any hidden classes from it.
      this.popdown.addClass('popdown').removeClass('hidden');

      // Wrap the contents inside for spacing purposes
      var contents = this.popdown.children('.popdown-contents');
      if (!contents.length) {
        this.popdown.children().wrap('<div class="popdown-contents"></div>');
      }

      // Add the arrow markup if it doesn't already exist
      this.arrow = $('<div class="arrow"></div>').prependTo(this.popdown);

      this.place();

      // Expand if necessary
      var ariaExpanded = this.trigger.attr('aria-expanded');
      if (!ariaExpanded || ariaExpanded === undefined) {
        this.trigger.attr('aria-expanded', '');
      }
      if (ariaExpanded === 'true') {
        this.open();
      }

      // aria-controls for the trigger element
      if (this.trigger) {
        this.trigger[0].setAttribute('aria-controls', this.id);
      }
      return this;
    },
    handleEvents: function handleEvents() {
      var self = this;

      this.trigger.on('click.popdown', function () {
        self.toggle();
      }).on('updated.popdown', function () {
        self.updated();
      });

      return this;
    },
    hasValidTriggerSetting: function hasValidTriggerSetting() {
      return this.settings.trigger instanceof $ || DOM.isElement(this.settings.trigger);
    },


    /**
     * Detects whether or not the Popdown has focus.
     * @private
     * @returns {boolean} whether or not the element is currently focused.
     */
    hasFocus: function hasFocus() {
      var active = document.activeElement;
      if (this.trigger.is(active)) {
        return true;
      }
      if ($.contains(this.popdown[0], active)) {
        return true;
      }

      return false;
    },


    /**
     * Determines whether or not the popdown is open.
     * @returns {boolean} returns current state.
     */
    isOpen: function isOpen() {
      return this.trigger.attr('aria-expanded') === 'true';
    },


    /**
     * Open the popdown.
     */
    open: function open() {
      if (this.isAnimating) {
        return;
      }

      var self = this;
      var setFocusinEvent = false;

      this.isAnimating = true;
      this.trigger.attr('aria-expanded', 'true');
      this.position();
      this.popdown.addClass('visible');

      // Setup events that happen on open
      // Needs to be on a timer to prevent automatic closing of popdown.
      setTimeout(function () {
        $('body').on('resize.popdown', function () {
          if (!self.hasFocus()) {
            self.close();
          }
        });

        // Only allow $(document).click() to close the Popdown if `keepOpen` isn't set.
        if (!self.settings.keepOpen) {
          $(document).on('click.popdown', function () {
            if (!self.hasFocus()) {
              self.close();
            }
          });

          // When focusing in on other important page elements, this Popdown instance will check to
          // see if it contains those elements, and will close if it doesn't.
          if (!setFocusinEvent) {
            setFocusinEvent = true;
            $(document).on('focusin.popdown', function () {
              if (!self.hasFocus()) {
                self.close();
              }
            });
          }
        }

        self.isAnimating = false;
      }, 400);
    },


    /**
     * Close the popdown.
     */
    close: function close() {
      if (this.isAnimating) {
        return;
      }

      var self = this;
      this.isAnimating = true;
      this.trigger.attr('aria-expanded', 'false');
      this.popdown.removeClass('visible');

      // Turn off events
      this.popdown.off('focusin.popdown');
      $('body').off('resize.popdown');
      $(document).off('click.popdown focusin.popdown');

      // Sets the element to "display: none" to prevent interactions while hidden.
      setTimeout(function () {
        self.popdown[0].style.display = 'none';
        self.isAnimating = false;
      }, 400);
    },


    /**
     * Toggle the popdown.
     */
    toggle: function toggle() {
      if (this.isOpen()) {
        this.close();
        return;
      }
      this.open();
    },


    /**
     * Detaches Popdown Element and places at the body tag root, or at the root of the nearest scrollable parent.
     * @private
     */
    place: function place() {
      this.scrollparent = $('body');
      this.popdown.detach().appendTo(this.scrollparent);
    },


    /**
     * Set the right popdown position.
     * @private
     */
    position: function position() {
      var parent = {
        offset: {
          left: 0,
          top: 0
        },
        scrollDistance: {
          left: 0,
          top: 0
        }
      };
      var winH = window.innerHeight + $(document).scrollTop();
      // subtract 2 from the window width to account for the tooltips
      // resizing themselves to fit within the CSS overflow boundary.
      var winW = window.innerWidth - 2 + $(document).scrollLeft();

      // Reset adjustments to panel and arrow
      this.popdown.removeAttr('style');
      this.arrow.removeAttr('style');

      // Add/subtract offsets if a scrollable parent element is involved
      if (this.scrollparent.length) {
        parent.offset = this.scrollparent.offset();
        parent.scrollDistance.top = this.scrollparent.scrollTop();
        parent.scrollDistance.left = this.scrollparent.scrollLeft();
        winH -= parent.offset.top + parent.scrollDistance.top;
        winW -= parent.offset.left + parent.scrollDistance.left;
      }

      var adjustX = false;
      var adjustY = false;
      var t = this.trigger;
      var to = t.offset(); // Trigger offset
      var arrowHeight = 11;
      var XoffsetFromTrigger = 0;
      var YoffsetFromTrigger = 0;
      var po = void 0; // Popover offset

      // Place the popdown below to start
      this.popdown.addClass('bottom');

      this.popdown[0].style.left = to.left + 'px';
      this.popdown[0].style.top = to.top + t.outerHeight(true) + arrowHeight + 'px';

      this.arrow[0].style.left = t.outerWidth(true) / 2 + 'px';
      this.arrow[0].style.top = 0 - arrowHeight + 'px';

      // Get the newly-set values for the popdown's offset
      po = this.popdown.offset();

      // Get deltas for popdown position if the button is off either X edge
      if (po.left < 0) {
        // Checking the left edge
        adjustX = true;
        XoffsetFromTrigger = 0 - po.left;
      }
      var rightEdgePos = po.left + this.popdown.outerWidth(true);
      if (rightEdgePos > winW) {
        // Checking the right edge
        adjustX = true;
        XoffsetFromTrigger = rightEdgePos - winW + (Locale.isRTL() ? 20 : 0);
      }

      if (adjustX) {
        // Adjust the X position based on the deltas
        this.popdown[0].style.left = po.left + XoffsetFromTrigger * -1 + 'px';

        var popdownRect = this.popdown[0].getBoundingClientRect();
        var triggerRect = t[0].getBoundingClientRect();
        var deltaRightEdge = popdownRect.right - triggerRect.right + 10;

        this.arrow[0].style.left = 'auto';
        this.arrow[0].style.right = deltaRightEdge + 'px';

        // Get the newly set values
        po = this.popdown.offset();
      }

      // Get the deltas for popdown position if the button is off either Y edge
      if (po.top < 0) {
        // Checking top edge
        adjustY = true;
        YoffsetFromTrigger = 0 - po.top;
      }
      var bottomEdgePos = po.top + this.popdown.outerHeight(true);
      if (bottomEdgePos > winH) {
        // Checking the bottom edge
        adjustY = true;
        YoffsetFromTrigger = bottomEdgePos - winH;
      }

      // Remove the arrow if we need to adjust this, since it won't line up anymore
      if (adjustY) {
        this.arrow[0].style.display = 'none';

        // Adjust the Y position based on the deltas
        this.popdown[0].style.top = po.top + YoffsetFromTrigger * -1 + 'px';
        this.arrow[0].style.top = parseInt(this.arrow[0].style.top, 10) - YoffsetFromTrigger * -1 + 'px';

        // Get the values again
        po = this.popdown.offset();
      }

      // One last check of the Y edges.  At this point, if either edge is out of bounds, we need to
      // shrink the height of the popdown, as it's too tall for the viewport.
      if (po.top < 0 || po.top + this.popdown.outerHeight(true) > winH) {
        this.popdown[0].style.top = 0;
        po = this.popdown.offset();

        bottomEdgePos = po.top + this.popdown.outerHeight(true);
        this.popdown[0].style.height = parseInt(this.popdown[0].style.height, 10) - (bottomEdgePos - winH) + 'px';
      }
    },


    /**
     * Update the popdown and refresh with new settings
     * @param  {object} settings The new settings
     * @returns {object} The component api.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      if (this.hasValidTriggerSetting()) {
        this.trigger = $(this.settings.trigger);
      }

      return this;
    },


    /**
     * Release Events
     * @private
     * @returns {object} The component api.
     */
    teardown: function teardown() {
      if (this.isOpen()) {
        this.close();
      }

      this.trigger.off('updated.popdown click.popdown').removeAttr('aria-controls').removeAttr('aria-expanded');

      if (this.originalParent && this.originalParent.length) {
        this.popdown.detach().appendTo(this.originalParent);
      }

      this.arrow.remove();

      return this;
    },


    /**
     * Teardown - Remove added markup and events
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$Q);
    }
  };

  /**
   * jQuery component wrapper for Popdown
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery selector containing all elements
   */
  $.fn.popdown = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$Q);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$Q, new Popdown(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$R = 'rating';

  // Default Rating Options
  var RATING_DEFAULTS = {};

  /**
   * @class Rating
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   */
  function Rating(element, settings) {
    this.settings = utils.mergeSettings(element, settings, RATING_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Actual Rating Code
  Rating.prototype = {
    init: function init() {
      this.handleEvents();
      this.allInputs = this.element.find('input');
      this.readonly();
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var inputs = $('input', this.element);

      var _loop = function _loop(i, l) {
        $(inputs[i]).on('change.' + COMPONENT_NAME$R, function () {
          if (!_this.element.hasClass('is-readonly')) {
            _this.val(i + 1);
          }
        });
      };

      for (var i = 0, l = inputs.length; i < l; i++) {
        _loop(i, l);
      }
    },


    /**
     * Icon filled star
     * @param {jQuery|HTMLElement} inpt - Input element
     * @param {jQuery|HTMLElement} svg - SVG element
     */
    fillStar: function fillStar(inpt, svg) {
      $(inpt).addClass('is-filled').removeClass('is-half').next(svg).find('svg').changeIcon('star-filled');
    },


    /**
     * Icon empty star
     * @param {jQuery|HTMLElement} inpt - Input element
     * @param {jQuery|HTMLElement} svg - SVG element
     */
    emptyStar: function emptyStar(inpt, svg) {
      $(inpt).removeClass('is-filled').removeClass('is-half').next(svg).find('svg').changeIcon('star-outlined');
    },


    /**
     * Icon half star
     * @param {jQuery|HTMLElement} inpt - Input element
     * @param {jQuery|HTMLElement} svg - SVG element
     */
    halfStar: function halfStar(inpt, svg) {
      $(inpt).addClass('is-half').removeClass('is-filled').next(svg).find('svg').changeIcon('star-half');
    },


    /**
     * Optionally set the value and return the current value
     * @param {number} [value] - A new value
     * @returns {number}- The current value
     */
    val: function val(value) {
      if (arguments.length === 0 || value === '' || isNaN(value) || math.sign(value) === -1) {
        return this.currentValue;
      }

      this.currentValue = parseFloat(value, 10);
      var chkIdx = Math.floor(this.currentValue);

      for (var i = 0, l = this.allInputs.length; i < l; i++) {
        var input = $(this.allInputs[i]);
        var svgSelector = input.parent().is('.inline') ? 'svg' : 'label';
        var valNotAWholeNumber = value % 1 !== 0 && chkIdx === i;

        if (valNotAWholeNumber) {
          this.halfStar(input, svgSelector);
        } else if (i < value) {
          this.fillStar(input, svgSelector);
        } else {
          this.emptyStar(input, svgSelector);
        }

        if (i + 1 === chkIdx) {
          input.prop('checked', true);
        }
      }

      if (chkIdx <= 0 && value > 0) {
        $(this.allInputs[0]).prop('checked', true);
      }

      return this.currentValue;
    },


    /**
    * Set component to readonly.
    * @returns {void}
    */
    readonly: function readonly() {
      var elem = $(this.element);
      if (elem.hasClass('is-readonly')) {
        elem.find('input').attr('disabled', '');
      }
    },


    /**
    * Set component to enable.
    * @returns {void}
    */
    enable: function enable() {
      var elem = $(this.element);
      elem.removeClass('is-readonly').find('input').removeAttr('disabled');
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.element.find('input').off('change.' + COMPONENT_NAME$R);
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, RATING_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
    * Destroy and remove added markup, all events
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$R);
    }
  };

  /**
   * jQuery Component Wrapper for Rating
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.rating = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$R);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$R, new Rating(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$S = 'signin';

  // Default SignIn Options
  var SIGNIN_DEFAULTS = {};

  /**
  * The sign in page component.
  * @class SignIn
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  */
  function SignIn(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SIGNIN_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  SignIn.prototype = {
    init: function init() {
      this.handleKeys();
    },


    /**
     * Checks a keyboard event for a CAPS LOCK modifier.
     * @private
     * @param {object} e jQuery.Event
     * @returns {boolean} true if caps lock
     */
    isCapslock: function isCapslock(e) {
      e = e || window.event;
      var charCode = false;
      var shifton = false;

      if (e.which) {
        charCode = e.which;
      } else if (e.keyCode) {
        charCode = e.keyCode;
      }

      if (e.shiftKey) {
        shifton = e.shiftKey;
      } else if (e.modifiers) {
        shifton = !!(e.modifiers & 4); // eslint-disable-line
      }

      if (charCode >= 97 && charCode <= 122 && shifton) {
        return true;
      }
      if (charCode >= 65 && charCode <= 90 && !shifton) {
        return true;
      }
      return false;
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      $('body').off('keypress.signin blur.signin change.signin');
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, SIGNIN_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$S);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleKeys: function handleKeys() {
      var self = this;
      var cssIcon = $.createIconElement({ classes: 'icon-capslock', icon: 'capslock' });

      // Disable default [caps lock on] popup in IE
      document.msCapsLockWarningOff = true;

      this.element.on('keypress.signin', '[type="password"]', function (e) {
        var field = $(this);
        var fieldParent = field.parent('.field');
        var iconCapslock = $('.icon-capslock', fieldParent);

        if (self.isCapslock(e) && !field.hasClass('error')) {
          if (!iconCapslock.length) {
            fieldParent.append(cssIcon);
            $('body').toast({ audibleOnly: true, message: Locale.translate('CapsLockOn') });
          }
        } else {
          iconCapslock.remove();
        }
      }).on('blur.signin change.signin', '[type="password"]', function () {
        var field = $(this);
        var fieldParent = field.closest('.field');
        var iconCapslock = $('.icon-capslock', fieldParent);

        setTimeout(function () {
          if (iconCapslock && iconCapslock.length) {
            if (field.hasClass('error')) {
              iconCapslock.remove();
            } else {
              fieldParent.append(cssIcon);
            }
          }
        }, 150);
      });
    }
  };

  /**
   * jQuery Component Wrapper for SignIn
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.signin = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$S);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$S, new SignIn(this, settings));
      }
    });
  };

  /* eslint-disable no-underscore-dangle */

  // Component Name
  var COMPONENT_NAME$T = 'slider';

  // The Component Defaults
  var SLIDER_DEFAULTS = {
    value: [50],
    min: 0,
    max: 100,
    range: false,
    step: undefined,
    ticks: [],
    tooltipContent: undefined,
    persistTooltip: false
  };

  /**
   * Touch Enabled/Responsive and Accessible Slider Control
   * @class Slider
   * @param {jQuery[]|HTMLElement} element The DOM element
   * @param {object} [settings] incoming settings
   * @param {array} [settings.value = [50]] An array with the slider values. Or one if a single value slider.
   * @param {number} [settings.min = 0] The minimum slider value.
   * @param {number} [settings.max = 100] The maximum slider value.
   * @param {boolean} [settings.range = false] If true a range slider with two selectors is formed.
   * @param {undefined|Number} [settings.step] If added will be the number of slider steps to use.
   * @param {array} [settings.ticks = []] An array of the ticks to use for the steps
   * @param {undefined|Array} [settings.tooltipContent] Special customizable tooltip content.
   * @param {boolean} [settings.persistTooltip = false] If true the tooltip will stay visible.
   */
  function Slider(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, SLIDER_DEFAULTS);
    this.init();
  }

  // Check if is an integer
  function isInt(n) {
    return n % 1 === 0;
  }

  // Round a non-integer to an integer closest to the nearest increment/decrement.
  // If no increment is provided or the increment is 0, only round to the nearest whole number.
  function roundToIncrement(number, increment) {
    if (!increment || isNaN(increment) || increment === 0) {
      increment = 1;
    }
    return Math.round(number / increment) * increment;
  }

  // Get the distance between two points.
  // PointA & PointB are both arrays containing X and Y coordinates of two points.
  // Distance Formula:  http://www.purplemath.com/modules/distform.htm
  function getDistance(pointA, pointB) {
    var aX = pointA[0];
    var aY = pointA[1];
    var bX = pointB[0];
    var bY = pointB[1];

    return Math.sqrt(Math.pow(bX - aX, 2) + Math.pow(bY - aY, 2));
  }

  // Actual Plugin Code
  Slider.prototype = {

    /**
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      return this.buildSettings().addMarkup().bindEvents();
    },


    /**
     * Handles Data Attribute settings, some markup settings
     * @private
     * @returns {this} component instance
     */
    buildSettings: function buildSettings() {
      var self = this;

      // Add "is-disabled" css class to closest ".field" if element is disabled
      if (this.element.is(':disabled')) {
        this.element.closest('.field').addClass('is-disabled');
      }

      if (!this.settings) {
        this.settings = {};
      }
      this.settings.value = this.element.attr('value') !== undefined ? this.element.attr('value') : this.settings.value;
      this.settings.min = this.element.attr('min') !== undefined ? parseInt(this.element.attr('min'), 10) : this.settings.min;
      this.settings.max = this.element.attr('max') !== undefined ? parseInt(this.element.attr('max'), 10) : this.settings.max;
      this.settings.range = this.element.attr('data-range') !== undefined ? this.element.attr('data-range') === 'true' : this.settings.range;
      this.settings.step = !isNaN(this.element.attr('step')) ? Number(this.element.attr('step')) : this.settings.step;

      if (this.settings.value === '') {
        this.settings.value = this.settings.min;
      }

      // build tick list
      var parsedTicks = void 0;
      if (this.element.attr('data-ticks') !== undefined) {
        try {
          parsedTicks = JSON.parse(self.element.attr('data-ticks'));
        } catch (e) {
          parsedTicks = [];
        }

        if ($.isArray(parsedTicks)) {
          this.settings.ticks = parsedTicks;
        }
      }

      // build tooltip content
      var isTooltipPersist = this.element.attr('data-tooltip-persist') === 'true' || this.element.attr('data-tooltip-persist') === true;
      this.settings.persistTooltip = this.element.attr('data-tooltip-persist') !== undefined ? isTooltipPersist : this.settings.persistTooltip;
      this.settings.tooltip = this.settings.tooltipContent;
      if (this.element.attr('data-tooltip-content') !== undefined) {
        try {
          self.settings.tooltip = JSON.parse(self.element.attr('data-tooltip-content'));
        } catch (e) {
          self.settings.tooltip = ['', ''];
        }
      }
      if (typeof this.settings.tooltip === 'string') {
        if (this.settings.tooltip.indexOf(',') === -1) {
          this.settings.tooltip = [this.settings.tooltip, ''];
        } else {
          var strings = this.settings.tooltip.split(',');
          this.settings.tooltip = [strings[0]];
          this.settings.tooltip.push(strings[1] ? strings[1] : '');
        }
      }
      if (this.settings.tooltip && this.settings.tooltip.length === 1) {
        this.settings.tooltip.push('');
      }

      // Build ticks.  All sliders have a tick for minimum and maximum by default.
      // Some will be provided as extra.
      this.ticks = [];
      var minTick = {
        value: this.settings.min,
        description: self.getModifiedTextValue(this.settings.min)
      };
      var maxTick = {
        value: this.settings.max,
        description: self.getModifiedTextValue(this.settings.max)
      };

      if (!this.settings.ticks) {
        this.ticks.push(minTick, maxTick);
      } else {
        // Check the type of the data-ticks.  If it's not a complete array
        // and doesn't have at least one option, ignore it.
        var ticks = self.settings.ticks || [];

        if ($.isArray(ticks) && ticks.length > 0) {
          // Filter through the incoming ticks to figure out if any have been defined
          // That match the values of min and max.
          var equalsMin = ticks.filter(function (obj) {
            return obj.value === self.settings.min;
          });
          var equalsMax = ticks.filter(function (obj) {
            return obj.value === self.settings.max;
          });

          // Overwrite description and color for min/max if they've been found.
          if (equalsMin.length > 0) {
            minTick.description = equalsMin[0].description;
            minTick.color = equalsMin[0].color;
            ticks = $.grep(ticks, function (val) {
              return val !== equalsMin[0];
            });
          }
          if (equalsMax.length > 0) {
            maxTick.description = equalsMax[0].description;
            maxTick.color = equalsMax[0].color;
            ticks = $.grep(ticks, function (val) {
              return val !== equalsMax[0];
            });
          }
        }

        // Push the values of all ticks out to the ticks array
        self.ticks.push(minTick);
        for (var i = 0; i < ticks.length; i++) {
          var tick = {};
          if (ticks[i].value !== undefined) {
            tick.value = ticks[i].value;
            tick.description = ticks[i].description !== undefined ? ticks[i].description : '';
            tick.color = ticks[i].color;
            self.ticks.push(tick);
          }
        }
        self.ticks.push(maxTick);
      }

      // configure the slider to deal with an array of values, and normalize the
      // values to make sure they are numbers.
      if ($.isArray(this.settings.value)) {
        this.settings.value[0] = isNaN(this.settings.value[0]) ? (this.settings.min + this.settings.max) / 2 : parseInt(this.settings.value[0], 10);
      } else if (typeof this.settings.value === 'number') {
        this.settings.value = [this.settings.value];
      } else if (this.settings.value.indexOf(',') === -1) {
        // String
        this.settings.value = [isNaN(this.settings.value) ? (this.settings.min + this.settings.max) / 2 : parseInt(this.settings.value, 10)];
      } else {
        var vals = this.settings.value.split(',');
        vals[0] = isNaN(vals[0]) ? this.settings.min : parseInt(vals[0], 10);
        vals[1] = isNaN(vals[1]) ? this.settings.max : parseInt(vals[1], 10);
        this.settings.value = vals;
      }

      // Add a second value to the array if we're dealing with a range.
      if (this.settings.range && !this.settings.value[1]) {
        this.settings.value.push(this.settings.max);
      }

      return this;
    },


    /**
     * Adds pseudo-markup that helps build the component
     * @private
     * @returns {this} component instance
     */
    addMarkup: function addMarkup() {
      var self = this;
      var isVertical = false;

      if (self.element[0].tagName !== 'INPUT') {
        throw new Error('Element with ID "' + self.element.id + '" cannot invoke a slider;  it\'s not an Input element.');
      }

      // store values and attributes on the original element
      self.originalElement = {
        type: self.element.attr('type')
      };

      // Hide the input element
      self.element.attr('type', 'hidden');

      // Build the slider controls
      self.wrapper = $('<div class="slider-wrapper"></div>').attr('id', self.element.attr('id') + '-slider').insertAfter(self.element);
      self.hitarea = $('<div class="slider-hit-area"></div>').appendTo(self.wrapper);
      self.range = $('<div class="slider-range"></div>').appendTo(self.wrapper);

      // Set to a vertical slider if the class exists on the input
      if (this.element.hasClass('vertical')) {
        this.wrapper.addClass('vertical');
        isVertical = true;
      }

      // Set RTL
      this.isRtlHorizontal = Locale.isRTL() && !isVertical;
      this.isRtlVertical = Locale.isRTL() && isVertical;

      // Retain any width or height size properties from the original range
      // element onto the Pseudo-markup
      var style = this.element.attr('style');
      if (style) {
        if (style.match(/min-height/)) {
          this.wrapper[0].style.minHeight = this.element[0].style.minHeight;
          style = style.replace('min-height', '');
        }
        if (style.match(/height/)) {
          this.wrapper[0].style.height = this.element[0].style.height;
        }
        if (style.match(/min-width/)) {
          this.wrapper[0].style.minWidth = this.element[0].style.minWidth;
          style = style.replace('min-width', '');
        }
        if (style.match(/width/)) {
          this.wrapper[0].style.width = this.element[0].style.width;
        }
      }

      // Handles
      self.handles = [];
      var labelText = self.element.prev('label').text();
      var handleLower = $('<div class="slider-handle' + (self.settings.range ? ' lower' : '') + '" tabindex="0"></div>').attr('aria-label', (self.settings.range ? Locale.translate('SliderMinimumHandle') : Locale.translate('SliderHandle')) + ' ' + labelText);
      self.handles.push(handleLower);
      if (self.settings.range) {
        var handleHigher = $('<div class="slider-handle higher" tabindex="0"></div>').attr('aria-label', Locale.translate('SliderMaximumHandle') + ' ' + labelText);
        self.handles.push(handleHigher);
      }
      $.each(self.handles, function (i, handle) {
        // Add WAI-ARIA to the handles
        handle.attr({
          role: 'slider',
          'aria-orientation': isVertical ? 'vertical' : 'horizontal',
          'aria-valuemin': self.settings.min,
          'aria-valuemax': self.settings.max
        }).hideFocus();
        handle.appendTo(self.wrapper);
      });

      function positionTick(tick) {
        var convertValueToPercentage = self.isRtlHorizontal ? 100 - self.convertValueToPercentage(tick.value) : self.convertValueToPercentage(tick.value);
        var pos = 'calc(' + convertValueToPercentage + '% - 4px)';

        tick.element = $('<div class="tick" data-value="' + tick.value + '"></div>');
        tick.label = $('<span class="label">' + tick.description + '</span>');
        tick.element[0].style[isVertical ? 'bottom' : 'left'] = pos;
        tick.element.append(tick.label);
        self.wrapper.append(tick.element);

        if (isVertical) {
          return;
        }
        tick.label[0].style.left = -(tick.label.outerWidth() / 2 - tick.element.width() / 2) + 'px';
      }

      // Ticks
      self.ticks.forEach(function (tick) {
        positionTick(tick);
      });

      self.value(self.settings.value);
      self.updateRange();

      // Tooltip on handle needs to update later
      $.each(self.handles, function (i, handle) {
        if (self.settings.tooltip) {
          handle.tooltip({
            content: function content() {
              return '' + self.getModifiedTextValue(Math.floor(self.value()[i]));
            },

            placement: isVertical ? 'right' : 'bottom',
            trigger: 'focus',
            keepOpen: self.settings.persistTooltip
          });
          handle.removeAttr('aria-describedby');
        }
      });

      if (this.element.prop('readonly') === true) {
        this.readonly();
      } else if (this.element.prop('disabled') === true) {
        this.disable();
      }

      return self;
    },


    /**
     * User is interacting with the Slider Range (not the handle or ticks)
     * @private
     * @param {jQuery.Event} e jQuery `click` event
     * @returns {void}
     */
    handleRangeClick: function handleRangeClick(e) {
      e.preventDefault();
      if (this.isDisabled()) {
        return;
      }

      var self = this;
      var isVertical = this.wrapper.hasClass('vertical');
      var pageX = e.originalEvent.type !== 'click' ? e.originalEvent.changedTouches[0].pageX : e.pageX;
      var pageY = e.originalEvent.type !== 'click' ? e.originalEvent.changedTouches[0].pageY : e.pageY;
      var mouseX = pageX - self.wrapper.offset().left - $(document).scrollLeft();
      var mouseY = pageY - self.wrapper.offset().top - $(document).scrollTop();
      var clickCoords = [mouseX, mouseY];
      var fhX = self.handles[0].offset().left + self.handles[0].width() / 2 - self.wrapper.offset().left - $(document).scrollLeft();
      var fhY = self.handles[0].offset().top + self.handles[0].height() / 2 - self.wrapper.offset().top - $(document).scrollTop();
      var firstHandleCoords = [fhX, fhY];
      var shX = void 0;
      var shY = void 0;
      var secondHandleCoords = void 0;
      var oldVals = self.value();
      var dLower = getDistance(clickCoords, firstHandleCoords);
      var dHigher = void 0;
      var targetOldVal = oldVals[0];
      var targetHandle = self.handles[0];

      targetHandle.addClass('hide-focus');

      function conversion() {
        if (isVertical) {
          var wh = self.wrapper.height();
          return (wh - mouseY) / wh * 100;
        }
        return mouseX / self.wrapper.width() * 100;
      }

      // Convert the coordinates of the mouse click to a value
      var val = conversion();
      var rangeVal = self.convertPercentageToValue(val);

      // If the slider is a range, we may use the second handle instead of the first
      if (self.handles[1]) {
        shX = self.handles[1].offset().left + self.handles[1].width() / 2 - self.wrapper.offset().left - $(document).scrollLeft();
        shY = self.handles[1].offset().top + self.handles[1].height() / 2 - self.wrapper.offset().top - $(document).scrollTop();
        secondHandleCoords = [shX, shY];
        dHigher = getDistance(clickCoords, secondHandleCoords);

        if (dLower > dHigher) {
          self.value([undefined, rangeVal]);
          targetHandle = self.handles[1];
          targetOldVal = oldVals[1];
        } else {
          self.value([rangeVal]);
        }
      } else {
        self.value([rangeVal]);
      }

      self.checkHandleDifference(targetHandle, targetOldVal, rangeVal);

      var moveBy = self.settings.step ? self.settings.step : 0;
      if (rangeVal < targetOldVal) {
        self.decreaseValue(e, targetHandle, rangeVal, moveBy);
      } else {
        self.increaseValue(e, targetHandle, rangeVal, moveBy);
      }

      // Tooltip repositioner will focus the handle after positioning occurs, but if
      // we are clicking a tick on a slider with no tooltip, we need to focus it manually.
      if (!self.settings.tooltip) {
        targetHandle.focus();
      }
    },


    /**
     * Activates one of the slider handles
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     */
    activateHandle: function activateHandle(handle) {
      handle.addClass('is-active');
    },


    /**
     * Deactivates one of the slider handles
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     */
    deactivateHandle: function deactivateHandle(handle) {
      handle.removeClass('is-active');
    },


    /**
     * Enables the ability to drag one of the slider handles.
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     */
    enableHandleDrag: function enableHandleDrag(handle) {
      if (this.isDisabled()) {
        return;
      }

      var self = this;
      var draggableOptions = {
        containment: 'parent',
        axis: this.isVertical() ? 'y' : 'x',
        clone: false
      };

      function updateHandleFromDraggable(e, thisHandle, args) {
        if (self.isDisabled()) {
          return;
        }

        function conversion() {
          if (self.isVertical()) {
            var wh = self.wrapper.height();
            // Vertical Slider accounts for limits set on the height by IDS Enterprise Drag.js
            var adjustedHeight = wh - thisHandle.outerHeight();

            return (adjustedHeight - args.top) / adjustedHeight * 100;
          }
          return args.left / (self.wrapper.width() - thisHandle.outerWidth()) * 100;
        }

        var val = conversion();
        var rangeVal = self.convertPercentageToValue(val);

        // Ranged values need to check to make sure that the higher-value handle
        // doesn't drawindowg past the lower-value handle, and vice-versa.
        if (self.settings.range) {
          var originalVal = self.value();
          if (thisHandle.hasClass('higher') && rangeVal <= originalVal[0]) {
            rangeVal = originalVal[0];
          }
          if (thisHandle.hasClass('lower') && rangeVal >= originalVal[1]) {
            rangeVal = originalVal[1];
          }
        }

        // Round the value to the nearest step, if the step is defined
        if (self.settings.step) {
          rangeVal = Math.round(rangeVal / self.settings.step) * self.settings.step;
        }

        /**
        * Fires while the slider is being slid.
        * @event sliding
        * @memberof Slider
        * @property {object} event The jquery event object
        * @property {object} args Extra event information.
        * @property {HTMLElement} args.handle The slider handle DOM element.
        * @property {number} args.value The current range value.
        */
        if (!e.defaultPrevented) {
          self.value(thisHandle.hasClass('higher') ? [undefined, rangeVal] : [rangeVal]);
          self.updateRange();
          self.updateTooltip(thisHandle);
          self.element.trigger('sliding', thisHandle, rangeVal);
        }
      }

      // Add/Remove Classes for canceling animation of handles on the draggable's events.
      /**
      * Fires while the slider is being slid.
      * @event slidestart
      * @memberof Slider
      * @property {object} event The jquery event object
      * @property {object} args Extra event information.
      * @property {HTMLElement} args.handle The slider handle DOM element.
      */
      /**
       * Fires while the slider is being slid.
       * @event slidestop
       * @memberof Slider
       * @property {object} event The jquery event object
       * @property {object} args Extra event information.
       * @property {HTMLElement} args.handle The slider handle DOM element.
       */
      handle.drag(draggableOptions).on('drag.slider', function (e, args) {
        updateHandleFromDraggable(e, $(e.currentTarget), args);
      }).on('dragstart', function () {
        $(this).addClass('is-dragging');
        self.range.addClass('is-dragging');
        self.element.trigger('slidestart', handle);
      }).on('dragend', function () {
        $(this).removeClass('is-dragging');
        self.range.removeClass('is-dragging');
        self.element.trigger('slidestop', handle);
      });
    },


    /**
     * Disables the dragging of a handle.
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     */
    disableHandleDrag: function disableHandleDrag(handle) {
      handle.off('drag.slider dragstart dragend');

      this.range.removeClass('is-dragging');
      handle.removeClass('is-dragging');

      var dragAPI = handle.data('drag');
      if (dragAPI) {
        dragAPI.destroy();
      }
    },


    /**
     * @private
     * @param {number} value pixel value
     * @returns {number} representing a percentage
     */
    convertValueToPercentage: function convertValueToPercentage(value) {
      return (value - this.settings.min) / (this.settings.max - this.settings.min) * 100;
    },


    /**
     * @private
     * @param {number} percentage percentage value
     * @returns {number} representing a pixel value
     */
    convertPercentageToValue: function convertPercentageToValue(percentage) {
      var val = percentage / 100 * (this.settings.max - this.settings.min) + this.settings.min;
      return this.isRtlHorizontal ? this.settings.max - val + this.settings.min : val;
    },


    /**
     * Gets a 10% increment/decrement as a value within the range of minimum and maximum values.
     * @returns {number} nearest 10% increment
     */
    getIncrement: function getIncrement() {
      var increment = 0.1 * (this.settings.max - this.settings.min);
      if (this.settings.step !== undefined && increment <= this.settings.step) {
        increment = this.settings.step;
      }
      return increment;
    },


    /**
     * Handles Slider Component's keystrokes
     * @private
     * @param {jQuery.Event} e jQuery `keydown` event
     * @param {this} self reference to this component instance
     */
    handleKeys: function handleKeys(e, self) {
      if (self.isDisabled()) {
        return;
      }

      var key = e.which;
      var handle = $(e.currentTarget);

      handle.removeClass('hide-focus');

      // If the keycode got this far, it's an arrow key, Page Up, Page Down, HOME, or END.
      switch (key) {
        case 33:
          // Page Up increases the value by 10%
          self.increaseValue(e, handle, undefined, this.getIncrement());
          break;
        case 34:
          // Page Down decreases the value by 10%
          self.decreaseValue(e, handle, undefined, this.getIncrement());
          break;
        case 35:
          // End key sets the handle to its maximum possible value
          self.increaseValue(e, handle, this.settings.max);
          break;
        case 36:
          // Home key sets the handle to its lowest
          // (either minimum value or as low as the "lower" handle)
          self.decreaseValue(e, handle, this.settings.min);
          break;
        case 38:case 39:
          // Right and Up increase the spinbox value
          if (self.isRtlHorizontal && key === 39) {
            self.decreaseValue(e, handle);
          } else {
            self.increaseValue(e, handle);
          }
          break;
        case 37:case 40:
          // Left and Down decrease the spinbox value
          if (self.isRtlHorizontal && key === 37) {
            self.increaseValue(e, handle);
          } else {
            self.decreaseValue(e, handle);
          }
          break;
        default:
          break;
      }
    },


    /**
     * Increases the value of one of the slider handles, accounting for step value, percentage, etc.
     * Also visually updates the handle on the visual part of the slider.
     * @param {jQuery.Event} e jQuery `click` or `keydown` event.
     * @param {jQuery[]} handle represents a slider handle element.
     * @param {number} [value] - target value - will be automatically determined if not passed.
     * @param {number} [increment] - an integer that will be used as the amount to increment.
     */
    increaseValue: function increaseValue(e, handle, value, increment) {
      e.preventDefault();
      clearTimeout(handle.data('animationTimeout'));

      var val = this.value().slice(0);
      var incrementBy = increment !== undefined ? increment : this.settings.step !== undefined ? this.settings.step : 1; //eslint-disable-line
      var testVal = void 0;
      var updatedVal = void 0;
      var finalVal = void 0;

      if (handle.hasClass('higher')) {
        testVal = value !== undefined ? value : val[1];
        incrementBy = isInt(testVal) ? incrementBy : isNaN(testVal % incrementBy) ? 0 : testVal % incrementBy; //eslint-disable-line
        updatedVal = testVal + incrementBy < this.settings.max ? testVal + incrementBy : this.settings.max;
        finalVal = updatedVal % incrementBy ? updatedVal : roundToIncrement(updatedVal, incrementBy);
        this.value([undefined, finalVal]);
      } else {
        testVal = value !== undefined ? value : val[0];
        var maxValue = val[1] === undefined ? this.settings.max : val[1];
        incrementBy = isInt(testVal) ? incrementBy : isNaN(testVal % incrementBy) ? 0 : incrementBy - testVal % incrementBy; //eslint-disable-line
        updatedVal = testVal + incrementBy < maxValue ? testVal + incrementBy : maxValue;
        finalVal = updatedVal % incrementBy ? updatedVal : roundToIncrement(updatedVal, incrementBy);
        this.value([finalVal]);
      }
      this.checkHandleDifference(handle, testVal, finalVal);
      this.updateRange();
      this.updateTooltip(handle);
    },


    /**
     * Decreases the value of one of the slider handles, accounting for step value, percentage, etc.
     * Also visually updates the handle on the visual part of the slider.
     * @param {jQuery.Event} e jQuery `click` or `keydown` event.
     * @param {jQuery[]} handle element representing a slider handle.
     * @param {number} [value] - target value - will be automatically determined if not passed.
     * @param {number} [decrement] - an integer that will be used as the amount to decrement.
     */
    decreaseValue: function decreaseValue(e, handle, value, decrement) {
      e.preventDefault();
      clearTimeout(handle.data('animationTimeout'));

      var val = this.value();
      var decrementBy = decrement !== undefined ? decrement : this.settings.step !== undefined ? this.settings.step : 1; //eslint-disable-line
      var testVal = void 0;
      var updatedVal = void 0;
      var finalVal = void 0;

      if (handle.hasClass('higher')) {
        testVal = value !== undefined ? value : val[1];
        var minValue = val[0] === undefined ? this.settings.min : val[0];
        decrementBy = isInt(testVal) ? decrementBy : isNaN(testVal % decrementBy) ? 0 : decrementBy - testVal % decrementBy; //eslint-disable-line
        updatedVal = testVal - decrementBy > minValue ? testVal - decrementBy : minValue;
        finalVal = updatedVal % decrementBy ? updatedVal : roundToIncrement(updatedVal, decrementBy);
        this.value([undefined, finalVal]);
      } else {
        testVal = value !== undefined ? value : val[0];
        decrementBy = isInt(testVal) ? decrementBy : isNaN(testVal % decrementBy) ? 0 : testVal % decrementBy; //eslint-disable-line
        updatedVal = testVal - decrementBy > this.settings.min ? testVal - decrementBy : this.settings.min;
        finalVal = updatedVal % decrementBy ? updatedVal : roundToIncrement(updatedVal, decrementBy);
        this.value([finalVal]);
      }
      this.checkHandleDifference(handle, testVal, finalVal);
      this.updateRange();
      this.updateTooltip(handle);
    },


    /**
     * Changes the position of the bar and handles based on their values.
     * @private
     */
    updateRange: function updateRange() {
      var self = this;
      var newVal = this.value();
      var percentages = [];
      var color = this.getColorClosestToValue();
      var isVertical = self.wrapper.hasClass('vertical');

      for (var i = 0; i < this.ticks.length; i++) {
        var condition = !this.settings.range ? this.ticks[i].value <= newVal[0] : newVal[0] < this.ticks[i].value && this.ticks[i].value <= newVal[1];

        if (condition) {
          this.ticks[i].element.addClass('complete');
          if (color) {
            this.ticks[i].element[0].style.backgroundColor = color;
            this.ticks[i].element.addClass('inherit');
          }
        } else {
          this.ticks[i].element.removeClass('complete');
          if (color) {
            this.ticks[i].element[0].style.backgroundColor = '';
            this.ticks[i].element.removeClass('inherit');
          }
        }
      }

      if (color) {
        this.range[0].style.backgroundColor = color;
        $.each(this.handles, function (i, handle) {
          handle[0].style.backgroundColor = color;
          handle[0].style.borderColor = color;
        });
      }

      // Remove any text colors that already existed.
      $.each(self.ticks, function (i) {
        self.ticks[i].label[0].style.color = '';
      });

      // Convert the stored values from ranged to percentage
      percentages[0] = this.convertValueToPercentage(newVal[0]);
      if (newVal[1] !== undefined) {
        percentages[1] = this.convertValueToPercentage(newVal[1]);
      }

      function getPosAttrs() {
        if (isVertical) {
          return ['bottom', 'top'];
        }
        if (self.isRtlHorizontal) {
          return ['right', 'left'];
        }
        return ['left', 'right'];
      }

      var posAttrs = getPosAttrs();
      var cssProps = {};

      // If no arguments are provided, update both handles with the latest stored values.
      if (!this.handles[1]) {
        cssProps[posAttrs[0]] = '0%';
        cssProps[posAttrs[1]] = 100 - percentages[0] + '%';
      } else {
        cssProps[posAttrs[0]] = percentages[0] + '%';
        cssProps[posAttrs[1]] = 100 - percentages[1] + '%';
      }
      this.range.css(cssProps);

      function positionHandle(handle, percentage) {
        var basePosition = isVertical ? posAttrs[1] : posAttrs[0];
        var realPercentage = isVertical ? 100 - percentage : percentage;

        handle.css(basePosition, 'calc(' + realPercentage + '% - ' + handle.outerWidth() / 2 + 'px)');
      }

      if (this.handles[0].hasClass('is-animated')) {
        this.handles[0].data('animationTimeout', setTimeout(function () {
          self.handles[0].removeClass('is-animated').trigger('slide-animation-end');
          self.range.removeClass('is-animated');
        }, 201));
      }
      positionHandle(this.handles[0], percentages[0]);

      if (this.handles[1]) {
        if (this.handles[1].hasClass('is-animated')) {
          this.handles[1].data('animationTimeout', setTimeout(function () {
            self.handles[1].removeClass('is-animated').trigger('slide-animation-end');
            self.range.removeClass('is-animated');
          }, 201));
        }
        positionHandle(this.handles[1], percentages[1]);

        // update the 'aria-valuemin' attribute on the Max handle, and the 'aria-valuemax'
        // attribute on the Min handle for better screen reading compatability
        this.handles[0].attr('aria-valuemax', newVal[1]);
        this.handles[1].attr('aria-valuemin', newVal[0]);
      }
    },


    /**
     * Allows a handle to animate to a new position if the difference in value is greater
     *  than 3% of the size of the range.
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     * @param {number} originalVal the value before it was modified
     * @param {number} updatedVal the target value
     */
    checkHandleDifference: function checkHandleDifference(handle, originalVal, updatedVal) {
      // IE9 doesn't support animation so return immediately.
      if ($('html').hasClass('ie9')) {
        return;
      }
      var origPercent = this.convertValueToPercentage(originalVal);
      var updatedPercent = this.convertValueToPercentage(updatedVal);

      if (Math.abs(origPercent - updatedPercent) > 3) {
        handle.addClass('is-animated');
        this.range.addClass('is-animated');
      }
    },


    /**
     * If tooltips are active, updates the current placement and content of the Tooltip.
     * If no handle argument is passed, this method simply hides both handles' tooltips.
     * @param {jQuery[]} [handle] element representing a slider handle.
     */
    updateTooltip: function updateTooltip(handle) {
      if (!this.settings.tooltip) {
        return;
      }

      if (!handle) {
        var tooltipLow = this.handles[0].data('tooltip');
        var tooltipHigh = void 0;

        if (this.handles[1]) {
          tooltipHigh = this.handles[1].data('tooltip');
        }

        tooltipLow.hide();
        if (tooltipHigh) {
          tooltipHigh.hide();
        }

        return;
      }

      var tooltip = handle.data('tooltip');

      function update() {
        tooltip.position();
        handle.focus();
      }

      // NOTE: This is a bit hacky because it depends on the setTimeout() method for
      // animation that is triggered inside the self.updateRange() method to have not
      // fired yet.  If you put a breakpoint anywhere in there you may see strange
      // results with animation.
      if (handle.hasClass('is-animated')) {
        tooltip.hide();
        handle.one('slide-animation-end', function () {
          update();
        });
      } else {
        update();
      }
    },


    /**
     * Gets a string-based hex value for the closest tick's defined color.
     * @private
     * @returns {string} hex value representing a color
     */
    getColorClosestToValue: function getColorClosestToValue() {
      var currentTheme = exports.theme;
      var preColors = {
        light: {
          default: '#000000',
          'very-poor': '#a13030',
          poor: '#d66221',
          adequate: '#f2bc41',
          good: '#9cce7c',
          'very-good': '#76b051',
          superior: '#488421'
        },
        dark: {
          default: '#ffffff',
          'very-poor': '#a13030',
          poor: '#d66221',
          adequate: '#f2bc41',
          good: '#9cce7c',
          'very-good': '#76b051',
          superior: '#488421'
        },
        'high-contrast': {
          default: '#000000',
          'very-poor': '#a13030',
          poor: '#d66221',
          adequate: '#e4882b',
          good: '#76b051',
          'very-good': '#56932e',
          superior: '#397514'
        }
      };

      var themeColors = preColors[currentTheme];
      var val = this.value()[0];
      var highestTickColor = void 0;
      var c = void 0;

      for (var i = 0; i < this.ticks.length; i++) {
        c = this.ticks[i].color;
        if (c && val >= this.ticks[i].value) {
          highestTickColor = c;
          highestTickColor = c.indexOf('#') > -1 ? c : themeColors[c] || themeColors.default;
        }
      }

      return highestTickColor;
    },


    /**
     * External Facing Function to set the value. Works as percent for now but need it on ticks.
     * NOTE:  Does not visually update the range.  Use _setValue()_ to do both in one swoop.
     * @param {number} minVal the smaller handle's value
     * @param {number} [maxVal] the larger handle's value, if applicable
     * @returns {array} both currently set handle values
     */
    value: function value(minVal, maxVal) {
      var self = this;

      // if both options are absent, act as a getter and return the current value
      if (minVal === undefined && maxVal === undefined) {
        return self._value;
      }

      // if an array is passed as the first argument, break it apart
      if (minVal && $.isArray(minVal)) {
        if (minVal[1] !== undefined) {
          maxVal = minVal[1];
        }
        minVal = minVal[0];
      }

      // set the values back to the existing one if they aren't passed.
      if (minVal === undefined && $.isArray(self._value) && self._value[0] !== undefined) {
        minVal = self._value[0];
      }
      if (maxVal === undefined && $.isArray(self._value) && self._value[1] !== undefined) {
        maxVal = self._value[1];
      }

      // set the internal value and the element's retrievable value.
      self._value = [minVal, maxVal];
      self.element.val(maxVal !== undefined ? self._value : self._value[0]);
      $.each(self.handles, function (i, handle) {
        var value = self._value[i];
        var valueText = self.getModifiedTextValue(value);

        $.each(self.ticks, function (a, tick) {
          if (tick.value === value) {
            valueText = tick.description;
          }
        });

        handle.attr({
          'aria-valuenow': self._value[i],
          'aria-valuetext': valueText
        });
      });

      self.element.trigger('change');
      return self._value;
    },


    /**
     * Returns a value with prefixed/suffixed text content.
     * Used by the tooltip and default ticks to get potential identifiers like $ and %.
     * @private
     * @param {string} content the original tooltip content
     * @returns {string} prepended/appended text that will be displayed inside the tooltip
     */
    getModifiedTextValue: function getModifiedTextValue(content) {
      if (!this.settings.tooltip) {
        return content;
      }
      return this.settings.tooltip[0] + content + this.settings.tooltip[1];
    },


    /**
     * Enables the slider instance.
     * @returns {this} component instance
     */
    enable: function enable() {
      this.element.prop('disabled', false);
      this.element.prop('readonly', false);
      this.wrapper.removeClass('is-readonly');
      this.wrapper.removeClass('is-disabled');

      var self = this;
      $.each(this.handles, function (i, handle) {
        self.enableHandleDrag(handle);
      });

      return this;
    },


    /**
     * Disables the slider instance.
     * @returns {this} component instance
     */
    disable: function disable() {
      this.element.prop('disabled', true);
      this.element.prop('readonly', false);
      this.wrapper.removeClass('is-readonly');
      this.wrapper.addClass('is-disabled');

      var self = this;
      $.each(this.handles, function (i, handle) {
        self.disableHandleDrag(handle);
      });

      return this;
    },


    /**
     * Sets the slider in a readonly state
     * @returns {this} component instance
     */
    readonly: function readonly() {
      var _this = this;

      this.element.prop('disabled', true);
      this.element.prop('readonly', true);
      this.wrapper.removeClass('is-disabled');
      this.wrapper.addClass('is-readonly');

      $.each(this.handles, function (i, handle) {
        _this.disableHandleDrag(handle);
      });

      return this;
    },


    /**
     * Detects whether or not this slider is disabled
     * @returns {boolean} whether or not this slider is disabled
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Detects whether or not this slider is vertical
     * @returns {boolean} whether or not this slider is vertical
     */
    isVertical: function isVertical() {
      return this.wrapper.hasClass('vertical');
    },


    /**
     * Externally-facing function that updates the current values and correctly
     * animates the range handles, if applicable.
     * @param {number} lowVal the value for the lower slider handle.
     * @param {number} [highVal] the value for the upper slider handle, if applicable.
     * @returns {array} the newly set values
     */
    setValue: function setValue(lowVal, highVal) {
      var oldVals = this.value();

      this.checkHandleDifference(this.handles[0], oldVals[0], lowVal);
      if (this.handles[1]) {
        this.checkHandleDifference(this.handles[1], oldVals[1], highVal);
      }

      var vals = this.value(lowVal, highVal);
      this.updateRange();
      this.updateTooltip();

      return vals;
    },


    /**
     * @deprecated in v4.2.0. Please use `setValue()` instead.
     * @param {number} lowVal the value for the lower slider handle.
     * @param {number} [highVal] the value for the upper slider handle, if applicable.
     * @returns {array} the newly set values
     */
    refresh: function refresh(lowVal, highVal) {
      return deprecateMethod(this.setValue, this.refresh).apply(this, [lowVal, highVal]);
    },


    /**
     * Updates the slider instance after a settings change.
     * Settings and markup are complicated in the slider so we just destroy and re-invoke it
     * with fresh settings.
     * @param {object|function} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.element.removeAttr('value');
      return this.teardown().init();
    },


    /**
     * Removes the events and pseudo-markup created by the slider
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      var self = this;
      $.each(self.handles, function (i, handle) {
        self.disableHandleDrag(handle);
        handle.off('mousedown.slider click.slider blur.slider keydown.slider keyup.slider');
      });
      this.wrapper.off('click.slider touchend.slider touchcancel.slider').remove();
      this.element.attr('type', xssUtils.ensureAlphaNumeric(this.originalElement.type));

      return this;
    },


    /**
     * Destroys the slider component instance and unlinks it from its base element.
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$T);
    },


    /**
     * Handle component events.
     * @private
     * @returns {void}
     */
    bindEvents: function bindEvents() {
      var self = this;

      $.each(self.handles, function (i, handle) {
        handle.on('mousedown.slider', function () {
          if (self.isDisabled()) {
            return;
          }
          $(this).focus();
        }).on('click.slider', function (e) {
          e.preventDefault(); // Prevent from jumping to top.
        }).on('keydown.slider', function (e) {
          self.activateHandle(handle);
          self.handleKeys(e, self);
        }).on('keyup.slider blur.slider', function () {
          self.deactivateHandle(handle);
        });

        self.enableHandleDrag(handle);
      });

      self.wrapper.on('click.slider touchend.slider touchcancel.slider', function (e) {
        self.handleRangeClick(e);
      });

      // Slider Control listens to 'updated' trigger on its base element to update values
      self.element.on('updated.slider', function () {
        self.updated();
      });

      return self;
    }
  };

  /**
   * jQuery Component Wrapper for Slider
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.slider = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$T);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$T, new Slider(this, settings));
      }
    });
  };

  // Name of this component
  var COMPONENT_NAME$U = 'zoom';

  /**
  * The Zoom Component is used to manage zoom on mobile devices.
  * @class Zoom
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  */
  function Zoom(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings);
    this.init();
  }

  Zoom.prototype = {
    init: function init() {
      return this.build().handleEvents();
    },


    /**
    * Add markup to the control
    * @private
    * @returns {object} The api prototype for chaining.
    */
    build: function build() {
      // get references to elements
      this.viewport = this.element.find('meta[name=viewport]');
      this.body = $('body');

      return this;
    },


    /**
    * Sets up event handlers for this control and its sub-elements
    * @private
    * @returns {object} The api prototype for chaining.
    */
    handleEvents: function handleEvents() {
      var self = this;

      // Allow the head to listen to events to globally deal with the zoom problem on
      // a per-control basis (for example, Dropdown/Multiselect need to handle this issue manually).
      this.element.on('updated.' + COMPONENT_NAME$U, function () {
        self.updated();
      }).on('enable-zoom', function () {
        self.enableZoom();
      }).on('disable-zoom', function () {
        self.disableZoom();
      });

      // Don't continue setting this up on each element if
      if (Environment.os.name !== 'ios') {
        return this;
      }

      // Setup conditional events for all elements that need it.
      this.body.on('touchstart.zoomdisabler', 'input, label', function () {
        if (self.noZoomTimeout) {
          return;
        }

        self.disableZoom();
      }).on('touchend.zoomdisabler', 'input, label', function () {
        if (self.noZoomTimeout) {
          clearTimeout(self.noZoomTimeout);
          self.noZoomTimeout = null;
        }
        self.noZoomTimeout = setTimeout(function () {
          self.noZoomTimeout = null;
          self.enableZoom();
        }, 600);
      });

      return this;
    },


    /**
    * Enable zoom by un-setting the meta tag.
    */
    enableZoom: function enableZoom() {
      // TODO: Test to see if prepending this meta tag conflicts with Base Tag implementation
      this.viewport[0].setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=1');
    },


    /**
    * Disable zoom by setting the meta tag.
    */
    disableZoom: function disableZoom() {
      // TODO: Test to see if prepending this meta tag conflicts with Base Tag implementation
      this.viewport[0].setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=0');
    },


    /**
    * Handle Updating Settings
    * @param {object} settings The settings to update to.
    * @returns {this} component instance
    */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
    * Simple Teardown - remove events & rebuildable markup.
    * @private
    * @returns {object} component instance
    */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$U + ' enable-zoom disable-zoom');
      this.body.off('touchstart.zoomdisabler touchend.zoomdisabler');
      return this;
    },


    /**
    * Teardown - Remove added markup and events
    */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$U);
    }
  };

  /**
   * jQuery Component Wrapper for Zoom
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.zoom = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$U);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$U, new Zoom(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$V = 'spinbox';

  // Component Defaults
  var SPINBOX_DEFAULTS = {
    autocorrectOnBlur: false,
    min: -2147483647,
    max: 2147483647,
    step: null,
    validateOnInput: true
  };

  /**
   * The Spinbox component provides easy access to modification of a numeric input field.
   * @class Spinbox
   * @constructor
   * @param {jQuery[]|HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.autocorrectOnBlur = false] If true the input will adjust to the nearest step on blur.
   * @param {Number} [settings.min = -2147483647] if defined, provides a minimum numeric limit
   * @param {Number} [settings.max = 2147483647]  if defined, provides a maximum numeric limit
   * @param {null|Number} [settings.step = null]  if defined, increases or decreases the spinbox value
   *  by a specific interval whenever the control buttons are used.
   * @param {boolean} [settings.validateOnInput = true]  If set to false, will only automatically correct
   *  the spinbox value after the spinbox has lost focus.
   */
  function Spinbox(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, SPINBOX_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Spinbox.prototype = {

    /**
     * @private
     * @returns {boolean} whether or not touch controls are available
     */
    get isTouch() {
      return Environment.features.touch;
    },

    /**
     * @private
     */
    init: function init() {
      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = this.element.parent().is('.inline');
      this.isWrapped = this.element.parent().is('.spinbox-wrapper');

      this.setInitialValue().addMarkup().bindEvents().setWidth();
    },


    /**
     * Sets the width of the spinbox input field.
     * @private
     * @returns {this} component instance
     */
    setWidth: function setWidth() {
      var style = this.element[0].style;

      if (style.width) {
        this.element.parent()[0].style.width = parseInt(style.width, 10) + this.element.parent().find('.down').outerWidth() * 2 + 'px';
      }

      return this;
    },


    /**
     * Sanitize the initial value of the input field.
     * @private
     * @returns {this} component instance
     */
    setInitialValue: function setInitialValue() {
      var self = this;
      var val = self.checkForNumeric(self.element.val());

      this.element.val(val);
      // If using Dirty Tracking, reset the "original" value of the dirty tracker to the current value
      // of the input, since it may have changed after re-invoking the input field.
      if (this.element.attr('data-trackdirty')) {
        this.element.data('original', val);
      }

      // allow numeric input on iOS
      var iOS = /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
      if (iOS) {
        this.element.attr('pattern', '\\d*');
      }

      if (this.element.attr('max')) {
        this.settings.max = this.element.attr('max');
      } else if (this.settings.max) {
        this.element.attr('max', this.settings.max);
      }

      if (this.element.attr('step')) {
        this.settings.max = this.element.attr('step');
      } else if (this.settings.step) {
        this.element.attr('step', this.settings.step);
      }

      if (this.element.attr('min')) {
        this.settings.max = this.element.attr('min');
      } else if (this.settings.min) {
        this.element.attr('min', this.settings.min);
      }

      return this;
    },


    /**
     * Appends extra control markup to a Spinbox field.
     * @private
     * @returns {this} component instance
     */
    addMarkup: function addMarkup() {
      var self = this;
      if (this.isInlineLabel) {
        this.inlineLabel.addClass('spinbox-wrapper');
      } else if (!this.isWrapped) {
        var spinboxWrapper = '<span class="spinbox-wrapper"></span>';
        if (this.element.is('.field-options')) {
          var field = this.element.closest('.field');
          var fieldOptionsTrigger = field.find('.btn-actions');

          this.element.add(fieldOptionsTrigger).add(fieldOptionsTrigger.next('.popupmenu')).wrapAll(spinboxWrapper);
        } else {
          this.element.wrap(spinboxWrapper);
        }
      }

      if (this.isWrapped) {
        this.buttons = {
          down: this.element.parent().find('.down').button(),
          up: this.element.parent().find('.up').button()
        };

        if (this.isTouch) {
          this.buttons.down.attr('aria-hidden', 'true');
          this.buttons.up.attr('aria-hidden', 'true');
        }
      }

      if (!this.buttons) {
        this.buttons = {
          down: $('<span ' + (this.isTouch ? '' : 'aria-hidden="true"') + ' class="spinbox-control down">-</span>').insertBefore(this.element).button(),
          up: $('<span ' + (this.isTouch ? '' : 'aria-hidden="true"') + ' class="spinbox-control up">+</span>').insertAfter(this.element).button()
        };
      }

      // Figure out minimum/maximum and data-masking attributes.  The user can provide the spinbox
      // plugin either the min/max or the mask, and the plugin will automatically figure out how to
      // use them.
      var min = this.element.attr('min');
      var max = this.element.attr('max');
      var mask = this.element.attr('data-mask');
      var maskValue = '';
      var attributes = {
        role: 'spinbutton'
      };
      var i = 0;

      // Define a default Max value if none of these attributes exist, to ensure the mask plugin will
      // work correctly.  Cannot define a Min value here because the plugin must be able to invoke
      // itself with a NULL value.
      if (!min && !max && !mask) {
        max = '9999999';
      }

      // If a mask doesn't exist, but min and max values do exist, create a mask that reflects
      // those min/max values
      if ((min || max) && !mask) {
        var newMask = '';
        var tempMin = min || '';
        var tempMax = max || '';
        var longerVal = tempMin.length > tempMax.length ? tempMin : tempMax;
        i = 0;

        while (i <= longerVal.length) {
          newMask += '#';
          i++;
        }

        // Add a negative symbol to the mask if it exists within the longer value.
        if (tempMin.indexOf('-') !== -1 || tempMax.indexOf('-') !== -1) {
          newMask = '-' + newMask.substring(0, newMask.length - 1);
        }

        attributes['data-mask'] = newMask;
        mask = newMask;
      }

      // If a "data-mask" attribute is already defined, use it to determine missing values
      // for min/max, if they don't already exist.
      var maskSize = mask.length;

      i = 0;
      while (i <= maskSize) {
        maskValue += '9';
        i++;
      }

      // If no negative symbol exists in the mask, the minimum value must be zero.
      if (mask.indexOf('-') === -1) {
        attributes.min = min || 0;
        attributes.max = max || maskValue;
      } else {
        attributes.min = min || maskValue;
        attributes.max = max || maskValue.substring(0, maskValue.length - 1);
      }

      if (!this.element.attr('data-mask-mode') || this.element.attr('data-mask-mode') !== 'number') {
        attributes['data-mask-mode'] = 'number';
      }

      // Destroy the Mask Plugin if it's already been invoked.  We will reinvoke it later
      // on during initialization.  Check to make sure its the actual Mask plugin object,
      // and not the "data-mask" pattern string.
      if (this.element.data('mask') && _typeof(this.element.data('mask')) === 'object') {
        this.element.data('mask').destroy();
      }

      // Add Aria Properties for valuemin/valuemax
      attributes['aria-valuemin'] = min || 0;
      attributes['aria-valuemax'] = max || 0;
      this.element.attr(attributes);

      // Set an initial "aria-valuenow" value.
      this.updateAria(self.element.val());

      // Invoke the mask plugin
      this.element.mask();

      // Disable in full if the settings have determined we need to disable on init.
      if (this.isDisabled()) {
        this.disable();
      }

      if (this.element.attr('readonly')) {
        this.readonly();
      }

      return this;
    },


    /**
     * Enables Long Pressing one of the Spinbox control buttons.
     * @private
     * @param {jQuery.Event} e jQuery `touchstart` or `mousedown` events
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    enableLongPress: function enableLongPress(e, self) {
      self.addButtonStyle(e);
      self.longPressInterval = setInterval(function () {
        if ($(e.currentTarget).is(':hover')) {
          self.handleClick(e);
        }
      }, 140);
    },


    /**
     * Disables Long Pressing one of the Spinbox control buttons.
     * @private
     * @param {jQuery.Event} e jQuery `touchend` or `mouseup` events
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    disableLongPress: function disableLongPress(e, self) {
      self.removeButtonStyle(e);
      clearInterval(self.longPressInterval);
      self.longPressInterval = null;
    },


    /**
     * Event handler for 'click' events
     * @private
     * @param {jQuery.Event} e jQuery `click` event
     * @returns {void}
     */
    handleClick: function handleClick(e) {
      e.preventDefault();

      if (this.isDisabled() || e.which !== 1 || this.isReadonly()) {
        return;
      }
      var target = $(e.currentTarget);
      if (target.hasClass('up')) {
        this.increaseValue();
      } else {
        this.decreaseValue();
      }

      this.safeFocus();
    },


    /**
     * Event handler for 'keydown' events
     * @private
     * @param {jQuery.Event} e jQuery `keydown` event
     * @param {Spinbox} self component instance
     */
    handleKeyDown: function handleKeyDown(e, self) {
      var key = e.which;
      var validKeycodes = [35, 36, 37, 38, 39, 40];

      if ($.inArray(key, validKeycodes) === -1) {
        return;
      }

      if (this.isReadonly()) {
        return;
      }

      // If the keycode got this far, it's an arrow key, HOME, or END.
      switch (key) {
        case 35:
          // End key sets the spinbox to its minimum value
          if (self.element.attr('min')) {
            self.element.val(self.element.attr('min'));
          }
          break;
        case 36:
          // Home key sets the spinbox to its maximum value
          if (self.element.attr('max')) {
            self.element.val(self.element.attr('max'));
          }
          break;
        case 38:
          // Up increases the spinbox value
          self.addButtonStyle(self.buttons.up);
          self.increaseValue();
          break;
        case 40:
          // Down decreases the spinbox value
          self.addButtonStyle(self.buttons.down);
          self.decreaseValue();
          break;
        default:
          break;
      }
    },


    /**
     * Event handler for 'keypress' events
     * TODO: Deprecate in 4.4.0
     * @private
     * @param {jQuery.Event} e jQuery `keypress` event
     * @param {Spinbox} self component instance
     * @returns {void}
     */
    handleKeyPress: function handleKeyPress(e, self) {
      var key = e.which;

      // NOTE:
      if (key < 48 || key > 57 && key < 96 || key > 105) {
        return undefined;
      }

      return this.handleInput(e, self);
    },


    /**
     * Event handler for the 'input' event
     * @private
     * @param {jQuery.Event} e jQuery `input` event
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    handleInput: function handleInput(e, self) {
      if (self.isDisabled() || this.isReadonly()) {
        return undefined;
      }

      // If we're only auto-correcting on blur, don't continue.
      if (this.settings.autocorrectOnBlur) {
        return undefined;
      }

      return this.correctValue(e);
    },


    /**
     * Event handler for 'keyup' events
     * @private
     * @param {jQuery.Event} e jQuery `input` event
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    handleKeyup: function handleKeyup(e, self) {
      if (self.isDisabled() || this.isReadonly()) {
        return;
      }
      var key = e.which;

      // Spinbox Control Button styles are added/removed on keyup.
      switch (key) {
        case 38:case 39:
          if (Locale.isRTL() && key === 39) {
            self.removeButtonStyle(self.buttons.down);
          } else {
            self.removeButtonStyle(self.buttons.up);
          }
          break;
        case 37:case 40:
          if (Locale.isRTL() && key === 39) {
            self.removeButtonStyle(self.buttons.up);
          } else {
            self.removeButtonStyle(self.buttons.down);
          }
          break;
        default:
          break;
      }

      self.updateAria(self.element.val());
    },


    /**
     * Change a newly pasted value to this element's min or max values, if the pasted
     * value goes beyond either of those limits.  Listens to an event emitted by the
     * Mask plugin after pasted content is handled.
     * @private
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    handleAfterPaste: function handleAfterPaste(self) {
      var min = Number(self.element.attr('min'));
      var max = Number(self.element.attr('max'));
      var val = Number(self.element.val());

      if (val < min) {
        val = min;
      }
      if (val > max) {
        val = max;
      }

      self.updateVal(val);
    },


    /**
     * Fixes a value that may have been entered programmatically, or by paste,
     * if it goes out of the range boundaries.
     * @private
     * @param {jQuery.Event} e jQuery `input` event
     * @returns {void}
     */
    correctValue: function correctValue(e) {
      var num = Number(this.element.val());
      var min = this.element.attr('min');
      var max = this.element.attr('max');

      if (num < min) {
        if (e) {
          e.preventDefault();
        }
        return this.updateVal(min);
      }
      if (num > max) {
        if (e) {
          e.preventDefault();
        }
        return this.updateVal(max);
      }
      return undefined;
    },


    /**
     * Increases the value of the Spinbox field, constrained by the step interval and maximum limit.
     * @returns {void}
     */
    increaseValue: function increaseValue() {
      var max = this.element.attr('max');
      var val = this.checkForNumeric(this.element.val()) + Number(this.element.attr('step') || 1);

      if (max && val > max) {
        return this.updateVal(max);
      }
      return this.updateVal(val);
    },


    /**
     * Decreases the value of the Spinbox field, constrained by the step interval and minimum limit.
     * @returns {void}
     */
    decreaseValue: function decreaseValue() {
      var min = this.element.attr('min');
      var val = this.checkForNumeric(this.element.val()) - Number(this.element.attr('step') || 1);

      if (min && val < min) {
        return this.updateVal(min);
      }
      return this.updateVal(val);
    },


    /**
     * Sets a new spinbox value and focuses the spinbox.
     * @param {Number|String} newVal the value to set on the spinbox
     * @returns {void}
     */
    updateVal: function updateVal(newVal) {
      this.element.val(newVal).trigger('change');
      this.updateAria(newVal);
    },


    /**
     * Sanitizes the value of the input field to an integer if it isn't already established.
     * @private
     * @param {Number|String} val will be converted to a number if it's a string.
     * @returns {number} a numeric version of the value provided, or a corrected value.
     */
    checkForNumeric: function checkForNumeric(val) {
      // Allow for NULL
      if (val === '') {
        return val;
      }
      if ($.isNumeric(val)) {
        return Number(val);
      }
      val = parseInt(val, 10);
      if ($.isNumeric(val)) {
        return Number(val);
      }
      // Zero out the value if a number can't be made out of it.
      return 0;
    },


    /**
     * Updates the "aria-valuenow" property on the spinbox element if the value is currently set
     * @private
     * @param {number} val the new value to be set on the spinbox
     * @returns {void}
     */
    updateAria: function updateAria(val) {
      var min = this.element.attr('min');
      var max = this.element.attr('max');

      val = this.checkForNumeric(val);
      this.element[0].setAttribute('aria-valuenow', val || '0');

      // Toggle min/max buttons
      this.setIsDisabled(this.buttons.up, val !== '' && max && val >= max ? 'disable' : 'enable');
      this.setIsDisabled(this.buttons.down, val !== '' && min && val <= min ? 'disable' : 'enable');
    },


    /**
     * Adds a "pressed-in" styling for one of the spinner buttons.
     * @private
     * @param {jQuery.Event|jQuery[]} e either an incoming event, or a button element to be acted on
     * @returns {void}
     */
    addButtonStyle: function addButtonStyle(e) {
      if (this.isDisabled() || this.isReadonly()) {
        return;
      }
      var target = e;
      if (e.currentTarget) {
        target = $(e.currentTarget);
      }
      target.addClass('is-active');
    },


    /**
     * Removes "pressed-in" styling for one of the spinner buttons
     * @private
     * @param {jQuery.Event|jQuery[]} e either an incoming event, or a button element to be acted on
     * @returns {void}
     */
    removeButtonStyle: function removeButtonStyle(e) {
      if (this.isDisabled() || this.isReadonly()) {
        return;
      }
      var target = e;
      if (e.currentTarget) {
        target = $(e.currentTarget);
      }
      target.removeClass('is-active');
    },


    /**
     * Focuses the main input field without a mobile zoom.
     * @returns {void}
     */
    safeFocus: function safeFocus() {
      var isMobile = Environment.os.name === 'ios' || Environment.os.name === 'android';
      if (isMobile) {
        $('head').triggerHandler('disable-zoom');
      }

      this.element.focus();

      if (isMobile) {
        $('head').triggerHandler('enable-zoom');
      }
    },


    /**
     * Enables the Spinbox
     * @returns {void}
     */
    enable: function enable() {
      this.element.prop('disabled', false);
      this.element.parent('.spinbox-wrapper').removeClass('is-disabled is-readonly');
    },


    /**
     * Disables the Spinbox
     * @returns {void}
     */
    disable: function disable() {
      this.element.prop('disabled', true);
      this.element.parent('.spinbox-wrapper').addClass('is-disabled');
    },


    /**
     * Makes the Spinbox readonly
     * @returns {void}
     */
    readonly: function readonly() {
      this.element.prop('readonly', true);
      this.element.parent('.spinbox-wrapper').addClass('is-readonly');
    },


    /**
     * Checks if the Spinbox is readonly
     * @returns {void}
     */
    isReadonly: function isReadonly() {
      return this.element.prop('readonly');
    },


    /**
     * Determines whether or not the spinbox is disabled.
     * @returns {boolean} whether or not the spinbox is disabled.
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Toggle whther or not the component is disabled.
     * @private
     * @param {jQuery[]} button the button element to be disabled
     * @param {booelan} [isDisabled] whether or not to force a change to the button's state.
     * @returns {void}
     */
    setIsDisabled: function setIsDisabled(button, isDisabled) {
      isDisabled = isDisabled === undefined ? true : !(!isDisabled || isDisabled === 'enable');

      button[isDisabled ? 'addClass' : 'removeClass']('is-disabled');
    },


    /**
     * Updated
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }
      return this;
    },


    /**
     * Teardown
     * @returns {void}
     */
    destroy: function destroy() {
      var mask = this.element.data('mask');
      if (mask && typeof mask.destroy === 'function') {
        mask.destroy();
      }

      for (var button in this.buttons) {
        // eslint-disable-line
        var buttonAPI = $(button).data('button');

        if (buttonAPI) {
          buttonAPI.destroy();
        }
      }

      this.buttons.up.off('click.spinbox mousedown.spinbox');
      this.buttons.up.remove();
      this.buttons.down.off('click.spinbox mousedown.spinbox');
      this.buttons.down.remove();
      this.element.off('focus.spinbox blur.spinbox keydown.spinbox keyup.spinbox');
      this.element.unwrap();
      $.removeData(this.element[0], COMPONENT_NAME$V);
    },


    /**
    *  Fires when the input gains focus.
    * @event focus
    * @memberof Spinbox
    * @property {object} event - The jquery event object
    */
    /**
     * Fires when the input looses focus.
     * @event blur
     * @memberof Spinbox
     * @property {object} event - The jquery event object
     */
    /**
      * Fires when a key is pressed down.
      * @event keydown
      * @memberof Spinbox
      * @property {object} event - The jquery event object
    */
    /**
      * Fires when a key is pressed.
      * @event keypress
      * @memberof Spinbox
      * @property {object} event - The jquery event object
    */
    /**
      * Fires when a key is pressed up.
      * @event keyup
      * @memberof Spinbox
      * @property {object} event - The jquery event object
    */
    /**
      * Fires after input is pasted in.
      * @event afterpaste
      * @memberof Spinbox
      * @property {object} event - The jquery event object
    */

    /**
     * Sets up event handlers for this control and its sub-elements
     * @private
     * @returns {void}
     */
    bindEvents: function bindEvents() {
      var self = this;
      var preventClick = false;

      // Main Spinbox Input
      this.element.on('focus.spinbox', function () {
        self.element.parent('.spinbox-wrapper').addClass('is-focused');
      }).on('blur.spinbox', function () {
        self.element.parent('.spinbox-wrapper').removeClass('is-focused');
        if (self.settings.autocorrectOnBlur) {
          self.correctValue();
        }
      }).on('keydown.spinbox', function (e) {
        self.handleKeyDown(e, self);
      }).on('input.spinbox', function (e) {
        self.handleInput(e, self);
      }).on('keyup.spinbox', function (e) {
        self.handleKeyup(e, self);
      }).on('afterpaste.mask', function () {
        self.handleAfterPaste(self);
      });

      // Up and Down Buttons
      var buttons = this.buttons.up.add(this.buttons.down[0]);
      buttons.on('touchstart.spinbox mousedown.spinbox', function (e) {
        if (e.which === 1) {
          if (!preventClick) {
            self.handleClick(e);
          }

          if (self.isTouch) {
            return;
          }

          preventClick = true;
          self.enableLongPress(e, self);

          $(document).one('mouseup', function () {
            self.disableLongPress(e, self);
            preventClick = false;
            self.safeFocus();
          });
        }
      });

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Spinbox
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.spinbox = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$V);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$V, new Spinbox(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$W = 'splitter';

  // Default Splitter Options
  var SPLITTER_DEFAULTS = {
    axis: 'x',
    side: 'left', // or right
    resize: 'immediate',
    containment: null, // document or parent
    save: true,
    maxWidth: {
      left: 'auto',
      right: 'auto'
    }
  };

  /**
  * Splitter Component
  * @class Splitter
  * @constructor
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  * @param {string} [settings.axis = 'x'] The axis on which to split x or y
  * @param {string} [settings.side = 'left'] Which side to dock to 'left' or 'right'.
  * @param {string} [settings.resize = 'immediate'] When to resize, during the drag 'immediate' or 'end'
  * @param {HTMLElement|jQuery[]} [settings.containment = null] When to stop the splitter, this can be document, or a parent element
  * @param {boolean} [settings.save = true] If true the split size will automatically be saved for next time
  * @param {object} [settings.maxWidth = {left: 'auto', right: 'auto'}] Ability to stop dragging at a max left or right size.
  */
  function Splitter(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SPLITTER_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Splitter.prototype = {

    /**
     * Do other init (change/normalize settings, load externals, etc)
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      return this.build().handleEvents();
    },


    /**
     * Build the Control and Events
     * @private
     * @returns {void}
     */
    build: function build() {
      var self = this;
      var s = this.settings;
      var splitter = this.element;
      var parent = splitter.parent();
      var direction = s.axis === 'x' ? 'left' : 'top';
      var thisSide = parent.is('.content') ? parent.parent() : parent;
      var defaultOffset = 299;
      var w = parent.width();
      var parentHeight = void 0;

      setTimeout(function () {
        parentHeight = parent.height();
      }, 0);

      this.docBody = $('body');
      this.isSplitterRightSide = splitter.is('.splitter-right') || s.axis === 'x' && s.side === 'right';
      this.isSplitterHorizontal = splitter.is('.splitter-horizontal') || s.axis === 'y';
      s.uniqueId = utils.uniqueId(this.element, 'splitter');

      if (this.isSplitterRightSide) {
        var thisPrev = thisSide.prev();
        if (thisPrev.is('.main')) {
          this.leftSide = thisPrev;
          w = thisSide.parent().outerWidth() - w;
        } else {
          this.leftSide = thisSide;
          splitter.addClass('splitter-right');
        }

        thisSide.addClass('is-right-side').next().addClass('flex-grow-shrink is-right-side').parent().addClass('splitter-container');

        if (s.collapseButton) {
          var savedOffset = 0;
          var splitterButton = $('<button type="button" class="splitter-btn" id="splitter-collapse-btn"><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-double-chevron"></use></svg></button>');
          splitterButton.appendTo(splitter);
          if (splitter[0].offsetLeft > 10) {
            $('#splitter-collapse-btn').addClass('rotate');
          }
          $('#splitter-collapse-btn').click(function () {
            if (savedOffset <= 0) {
              if (splitter[0].offsetLeft <= 10) {
                self.splitTo(defaultOffset, parentHeight);
                $(this).addClass('rotate');
              } else {
                savedOffset = splitter[0].offsetLeft;
                self.splitTo(0, parentHeight);
                $(this).removeClass('rotate');
              }
            } else if (splitter[0].offsetLeft > 10) {
              savedOffset = splitter[0].offsetLeft;
              self.splitTo(0, parentHeight);
              $(this).removeClass('rotate');
            } else {
              self.splitTo(savedOffset, parentHeight);
              $(this).addClass('rotate');
              savedOffset = 0;
            }
          });
        }
      } else if (this.isSplitterHorizontal) {
        this.topPanel = splitter.prev();
        w = this.topPanel.height();

        parent.addClass('splitter-container is-horizontal');
        splitter.next().addClass('flex-grow-shrink');
        splitter.addClass('splitter-horizontal');
      } else {
        this.rightSide = thisSide;
        this.leftSide = thisSide.prev().parent();

        thisSide.prev().addClass('flex-grow-shrink').parent().addClass('splitter-container');
      }

      // Restore from local storage
      if (localStorage && s.save && !isNaN(parseInt(localStorage[s.uniqueId], 10))) {
        w = localStorage[s.uniqueId];
      }

      w = parseInt(w, 10);

      if (this.isSplitterHorizontal) {
        splitter[0].style.top = w + 'px';
      } else {
        splitter[0].style.top = 0;
      }

      this.splitTo(w, parentHeight);

      if (w <= 10) {
        $('#splitter-collapse-btn').removeClass('rotate');
      }

      // Add the Splitter Events
      this.documentWidth = 0;

      this.element.drag({
        axis: s.axis,
        containment: s.containment || s.axis === 'x' ? 'document' : 'parent',
        containmentOffset: { left: 20, top: 0 }
      }).on('dragstart.splitter', function () {
        var iframes = $('iframe');
        self.documentWidth = $(document).width();

        if (iframes.length > 0) {
          for (var i = 0, l = iframes.length; i < l; i++) {
            var frame = $(iframes[i]);
            // eslint-disable-next-line
            var width = parseInt(getComputedStyle(frame.parent()[0]).width, 10) - 40 + 'px';
            var overlay = $('<div class="overlay splitter-overlay"></div>');
            overlay.css('width', width);
            frame.before(overlay);
          }
        }
      }).on('dragend.splitter', function (e, args) {
        $('.overlay').remove();

        if (s.collapseButton) {
          if (args[direction] <= 10) {
            $('#splitter-collapse-btn').removeClass('rotate');
          } else {
            $('#splitter-collapse-btn').addClass('rotate');
          }
        }

        if (s.resize === 'end') {
          self.splitTo(args[direction], parentHeight);
        }
      }).on('drag.splitter', function (e, args) {
        if (args.left <= 0) {
          return false;
        }
        if (s.resize === 'immediate') {
          self.splitTo(args[direction], parentHeight);
        }
        return true;
      });

      // Horizontal Splitter
      if (s.axis === 'y') {
        this.element.addClass('splitter-horizontal');
      }

      // Aria
      this.element.attr({ 'aria-dropeffect': 'move', tabindex: '0', 'aria-grabbed': 'false' });

      return this;
    },


    /**
     * Toggle selection
     * @private
     * @returns {void}
     */
    toggleSelection: function toggleSelection() {
      this.element.toggleClass('is-dragging');
    },


    /**
     * Resize the panel vertically
     * @private
     * @param {object} splitter element.
     * @param {number} top value.
     * @param {number} parentHeight value.
     * @returns {void}
     */
    resizeTop: function resizeTop(splitter, top, parentHeight) {
      if (top > parentHeight || top < 0) {
        top = parseInt(parentHeight, 10) / 2;
      }

      this.topPanel[0].style.height = top + 'px';
    },


    /**
     * Resize the panel to the Left
     * @private
     * @param {object} splitter element.
     * @param {number} leftArg value.
     * @returns {void}
     */
    resizeLeft: function resizeLeft(splitter, leftArg) {
      var left = this.leftSide.outerWidth() - leftArg;

      // Adjust Left and Right Side
      this.rightSide[0].style.width = left + 'px';

      // Reset the Width
      splitter[0].style.left = '';
    },


    /**
     * Resize the panel to the Right
     * @private
     * @param {object} splitter element.
     * @param {number} w - width value.
     * @returns {void}
     */
    resizeRight: function resizeRight(splitter, w) {
      // Adjust Left and Right Side
      this.leftSide[0].style.width = w + 'px';
      splitter[0].style.left = w - 1 + 'px';
    },


    /**
     * Split to
     * @private
     * @param {number} split value.
     * @param {number} parentHeight value.
     * @returns {void}
     */
    splitTo: function splitTo(split, parentHeight) {
      var self = this;
      var s = this.settings;
      var splitter = this.element;

      if (this.isSplitterRightSide) {
        if (split > s.maxWidth.right) {
          split = s.maxWidth.right;
        }
        this.resizeRight(splitter, split);
      } else if (this.isSplitterHorizontal) {
        this.resizeTop(splitter, split, parentHeight);
      } else {
        if (split > s.maxWidth.left) {
          split = s.maxWidth.left;
        }
        this.resizeLeft(splitter, split);
      }

      /**
      * Fires when after the split occurs. Allowing you to sync any ui.
      * @event split
      * @memberof Splitter
      * @property {object} event The jquery event object
      * @property {number} split value
      */
      this.element.trigger('split', [split]);
      this.docBody.triggerHandler('resize', [self]);

      // Save to local storage
      if (localStorage) {
        localStorage[this.settings.uniqueId] = split;
      }

      this.split = split;
      this.parentHeight = parentHeight;
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.element.off('updated.' + COMPONENT_NAME$W);
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, SPLITTER_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
    * Destroy and remove added markup, all events
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$W);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element
      /**
      * Fires when the component updates.
      *
      * @event updated
      * @memberof Splitter
      * @type {object}
      * @property {object} event - The jquery event object
      */
      .on('updated.' + COMPONENT_NAME$W, function () {
        _this.updated();
      })

      /**
      * Fires when a key is pressed while the component is focused.
      *
      * @event keydown
      * @memberof Splitter
      * @type {object}
      * @property {object} event - The jquery event object
      */
      .on('keydown.' + COMPONENT_NAME$W, function (e) {
        // Space will toggle selection
        if (e.which === 32) {
          _this.toggleSelection();
          e.preventDefault();
        }

        if (e.which === 37) {
          _this.splitTo(_this.split - 15, _this.parentHeight);
        }

        if (e.which === 39) {
          _this.splitTo(_this.split + 15, _this.parentHeight);
        }
      });

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Splitter
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.splitter = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$W);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$W, new Splitter(this, settings));
      }
    });
  };

  // The name of this component
  var COMPONENT_NAME$X = 'swaplist';

  // The Component Defaults
  var SWAPLIST_DEFAULTS = {
    // Searchable
    searchable: false,

    // Datasets
    available: null,
    selected: null,
    additional: null,

    // Main containers
    availableClass: '.available',
    selectedClass: '.selected',
    additionalClass: '.full-access',

    // Action buttons
    availableBtn: '.btn-moveto-selected',
    selectedBtnLeft: '.btn-moveto-left',
    selectedBtnRight: '.btn-moveto-right',
    additionalBtn: '.btn-moveto-selected',

    draggable: {
      available: true,
      selected: true,
      additional: true
    },

    // Template HTML
    template: '' + '<ul data-swap-handle=".handle">' + '{{#dataset}}' + '{{#text}}' + '<li data-id="{{id}}"' + '{{#value}} data-value="{{value}}"{{/value}}' + '{{#selected}} selected="selected"{{/selected}}' + '{{#disabled}} class="is-disabled"{{/disabled}}' + '>' + '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>' + '<div class="swaplist-item-content"><p>{{text}}</p></div>' + '</li>' + '{{/text}}' + '{{/dataset}}' + '</ul>'
  };

  /**
  * The SwapList Component creates a list of options that can be picked and organized.
  * @class SwapList
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.searchable = false] If true, associates itself with a Searchfield/Autocomplete
  *  and allows itself to be filtered
  * @param {array} [settings.available] An array containing items for the available bucket.
  * @param {array} [settings.selected] An array containing items for the selected bucket.
  * @param {array} [settings.additional] An array containing items for the additional bucket.
  * @param {string} [settings.availableClass = '.available'] A class name linking the available root element.
  * @param {string} [settings.selectedClass = '.selected'] A class name linking the selected root element.
  * @param {string} [settings.additionalClass = '.full-access'] A class name linking the additional root element.
  * @param {string} [settings.availableBtn = '.btn-moveto-selected'] A class name linking the available button element.
  * @param {string} [settings.selectedBtnLeft = '.btn-moveto-left'] A class name linking the move left button element.
  * @param {string} [settings.selectedBtnRight = '.btn-moveto-right'] A class name linking the move right button element.
  * @param {string} [settings.additionalBtn = '.btn-moveto-selected'] A class name linking the additional button element.
  * @param {string} [settings.template] An Html String with the mustache template for the view.
  * @param {object} [settings.draggable] An object containing boolean key/value to make container/s
  *  disable for dragging and moving items. Supported keys with draggable are "available",
  *  "selected", "additional".
  */
  function SwapList(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SWAPLIST_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // SwapList Methods
  SwapList.prototype = {
    init: function init() {
      var _this = this;

      var s = this.settings;
      s.draggable = $.extend(true, SWAPLIST_DEFAULTS.draggable, s.draggable);
      this.isTouch = Environment.features.touch;
      this.isAdditional = $(s.additionalClass + ' .listview', this.element).length > 0;

      if (this.isTouch) {
        this.element.addClass('is-touch');
      }
      this.loadListview();
      this.initDataset();
      this.setElements();
      this.isMultiSelectClass();

      setTimeout(function () {
        // Wait for Listview availability
        _this.makeDraggable();
        _this.handleEvents();
        _this.initSelected(s.availableClass);
        _this.initSelected(s.additionalClass);
      }, 0);
    },


    /**
     * Load listview
     * @private
     */
    loadListview: function loadListview() {
      var s = this.settings;
      var containers = [{ dataset: s.available, class: s.availableClass, draggable: s.draggable.available }, { dataset: s.selected, class: s.selectedClass, draggable: s.draggable.selected }, { dataset: s.additional, class: s.additionalClass, draggable: s.draggable.additional }];

      for (var i = 0, l = containers.length; i < l; i++) {
        var c = containers[i];
        var lv = $(c.class + ' .listview', this.element);
        var list = lv.data('listview');
        var options = { dataset: c.dataset || [], selectable: 'multiple', showCheckboxes: false };
        var isSearchable = (s.searchable === true || s.searchable === 'true') && $(c.class + ' .searchfield', this.element).length > 0;

        if (isSearchable) {
          options.searchable = true;
        }

        // Initialize listview
        if (!c.dataset && lv.length && $('li', lv).length) {
          lv.listview(options);
        } else if (lv.length) {
          // Remove any previous listview instance
          if (list) {
            list.destroy();
          }

          // Force to have id attribute
          if (s.template.indexOf('data-id="{{id}}"') === -1) {
            s.template = s.template.replace('<li', '<li data-id="{{id}}"');
          }

          options.template = s.template;
          options.dataset = c.dataset || [];

          // Generate unique id
          options.dataset.forEach(function (node) {
            if (!/string|number/.test(_typeof(node.id)) || node.id === '') {
              node.id = 'sw' + (Date.now().toString(36) + Math.round(Math.random() * Math.pow(36, 12)).toString(36).substr(2, 5)).toLowerCase();
            }
          });

          if (options.dataset.length === 0) {
            options.forceToRenderOnEmptyDs = true;
          }
          lv.listview(options);
        }

        // Add css class('is-not-droppable') to ul in this container
        if (!c.draggable) {
          $('ul', lv).addClass('is-not-droppable');
        }
      }
    },


    /**
     * Set elements
     * @private
     */
    setElements: function setElements() {
      var s = this.settings;
      var disabledBtnStr = '';

      this.offset = null;

      this.containers = $(s.availableClass + ',' + s.selectedClass + ',' + s.additionalClass, this.element);

      this.actionButtons = $(s.availableBtn + ',' + s.additionalBtn + ',' + s.selectedBtnLeft + ',' + s.selectedBtnRight, this.element);

      this.selectedButtons = $(s.selectedBtnLeft + ',' + s.selectedBtnRight, this.element);

      this.tabButtonsStr = s.availableBtn + ', ' + s.additionalBtn + ', ' + (this.selectedButtons.length > 1 ? s.selectedBtnRight : s.selectedBtnLeft);

      this.dragElements = 'ul:not(.is-not-droppable), ul:not(.is-not-droppable) li:not(.is-disabled)';
      this.dragStart = 'dragstart.swaplist touchstart.swaplist gesturestart.swaplist';
      this.dragEnterWhileDragging = 'dragenter.swaplist';
      this.dragOverWhileDragging = 'dragover.swaplist touchmove.swaplist gesturechange.swaplist';
      this.dragEnd = 'dragend.swaplist touchend.swaplist touchcancel.swaplist gestureend.swaplist';

      this.selections = {
        items: [],
        owner: null,
        related: null,
        droptarget: null,
        isInSelection: null,
        isHandle: null,
        placeholder: null,
        placeholderTouch: null,
        dragged: null,
        draggedIndex: null
      };

      // Dragging time placeholder
      s.numOfSelectionsClass = 'num-of-selections';
      s.itemContentClass = 'swaplist-item-content';
      s.itemContentTempl = $('<div><p><span class="' + s.numOfSelectionsClass + '">###</span> ' + (Locale ? Locale.translate('ItemsSelected') : ' Items Selected ') + '</p><div/>');

      // Make top buttons disable if not draggable
      if (!s.draggable.available) {
        disabledBtnStr = s.availableClass + ' ' + s.availableBtn + ',' + s.selectedBtnLeft;
        $(disabledBtnStr, this.element).prop('disabled', true);
      }
      if (!s.draggable.selected) {
        disabledBtnStr = s.selectedBtnLeft + ',' + s.selectedBtnRight;
        if (!s.draggable.available) {
          disabledBtnStr += ',' + s.additionalClass + ' ' + s.additionalBtn;
        }
        if (!this.isAdditional || !s.draggable.additional) {
          disabledBtnStr += ',' + s.availableClass + ' ' + s.availableBtn;
        }
        $(disabledBtnStr, this.element).prop('disabled', true);
        $(s.additionalClass + ' ' + s.additionalBtn, this.element).addClass('is-rotate');
      }
      if (!s.draggable.additional) {
        $(s.additionalClass + ' ' + s.additionalBtn + ',' + s.selectedBtnRight, this.element).prop('disabled', true);
      }
    },


    /**
     * When list is Empty force to add css class "is-multiselect"
     * @private
     */
    isMultiSelectClass: function isMultiSelectClass() {
      var s = this.settings;
      var containers = [s.availableClass, s.selectedClass, s.additionalClass];

      for (var i = 0, l = containers.length; i < l; i++) {
        var lv = $(containers[i] + ' .listview', this.element);
        if (!$('li', lv).length) {
          lv.addClass('is-multiselect');
        }
      }
    },


    /**
     * Initialize pre selected items
     * @private
     * @param {jQuery|HTMLElement} container container element
     * @returns {void}
     */
    initSelected: function initSelected(container) {
      container = this.isjQuery(container) ? container : $(container, this.element);
      if (container.length) {
        var list = $('.listview', container).data('listview');
        var selected = $('li[selected]', container);

        for (var i = 0, l = selected.length; i < l; i++) {
          var li = $(selected[i]);
          li.removeAttr('selected');
          list.select(li); // Select this item
        }
        this.moveElements(container, this.settings.selectedClass);
      }
    },


    /**
     * Move Elements
     * @private
     * @param {jQuery[]|HTMLElement} from beginning container
     * @param {jQuery[]|HTMLElement} to ending contaner
     * @returns {void}
     */
    moveElements: function moveElements(from, to) {
      if (to === null) {
        return;
      }

      from = typeof from !== 'string' ? from : $(from, this.element);
      to = typeof to !== 'string' ? to : $(to, this.element);
      var list = $('.listview', from).data('listview');

      this.clearSelections();
      this.selections.owner = from;
      this.selections.droptarget = to;

      if (this.isTouch) {
        if (list.selectedItems) {
          for (var i = 0, l = list.selectedItems.length; i < l; i++) {
            this.selections.items[i] = list.selectedItems[i].closest('li');
          }
        }
      } else {
        this.selections.items = list.selectedItems;
      }

      this.setSelectionsItems(this.selections.owner);
      this.unselectElements(list);

      if (this.selections.items.length) {
        this.selections.move = {
          items: this.selections.itemsData,
          from: this.getContainer(this.selections.itemsData)
        };
        var result = this.element.triggerHandler('beforeswap', [this.selections.move]);
        if (typeof result === 'boolean' && !result || typeof result === 'string' && result.toLowerCase() === 'false') {
          return;
        }

        var ul = $('ul', to);
        var currentSize = $('li', ul).length;
        var size = this.selections.items.length + currentSize;

        if (this.selections.items) {
          for (var _i = 0, _l = this.selections.items.length; _i < _l; _i++) {
            var val = $(this.selections.items[_i]);
            val.attr({ 'aria-posinset': currentSize + _i + 1, 'aria-setsize': size }).find('mark.highlight').contents().unwrap();
            ul.append(val);
          }
        }

        this.afterUpdate($('.listview', to).data('listview'));
      }
    },


    /**
     * Get container info from given list items
     * @private
     * @param {Array} items to get container info.
     * @returns {Object} container info (jQuery container element, css-class)
     */
    getContainer: function getContainer(items) {
      var s = this.settings;

      if (_typeof(items[0]) === 'object' && items[0].node) {
        var container = items[0].node.closest('.card');
        var cssClass = '';

        if (container.is(s.availableClass)) {
          cssClass = s.availableClass;
        } else if (container.is(s.selectedClass)) {
          cssClass = s.selectedClass;
        } else if (container.is(s.additionalClass)) {
          cssClass = s.additionalClass;
        }
        return { container: container, class: cssClass };
      }
      return null;
    },


    /**
     * Un-select Elements
     * @private
     * @param {jQuery|HTMLElement} list the list
     */
    unselectElements: function unselectElements(list) {
      if (list.selectedItems) {
        for (var i = 0, l = list.selectedItems.length; i < l; i++) {
          list.select($(list.selectedItems[i]));
        }
      }
      if (list && list.element) {
        list.element.find('li').attr('aria-selected', false).removeClass('is-selected');
      }
    },


    /**
     * Detect browser support for drag-n-drop
     * @private
     * @returns {boolean} whether or not drag-n-drop is supported
     */
    isDragAndDropSupports: function isDragAndDropSupports() {
      var div = document.createElement('div');
      return 'draggable' in div || 'ondragstart' in div && 'ondrop' in div;
    },


    /**
     * Detect browser support for match-media
     * @private
     * @returns {boolean} whether or not matchMedia is supported in this browser
     */
    isMatchMediaSupports: function isMatchMediaSupports() {
      return typeof window.matchMedia !== 'undefined' || typeof window.msMatchMedia !== 'undefined';
    },


    /**
     * Detect browser viewport
     * @private
     * @returns {object} contains width and height
     */
    viewport: function viewport() {
      var e = window;
      var a = 'inner';
      if (!('innerWidth' in window)) {
        a = 'client';
        e = document.documentElement || document.body;
      }
      return { width: e[a + 'Width'], height: e[a + 'Height'] };
    },


    /**
     * Check given [max-width] is true/false
     * @private
     * @param {number} w the current page width
     * @returns {boolean} whether or not the max-width has been matched
     */
    isMaxWidth: function isMaxWidth(w) {
      return this.isMatchMediaSupports() && window.matchMedia('(max-width: ' + w + 'px)').matches || this.viewport().width <= w;
    },


    /**
     * Make Draggable
     * @private
     */
    makeDraggable: function makeDraggable() {
      var _this2 = this;

      var self = this;
      var ul = $('ul', this.element);

      if (this.isDragAndDropSupports) {
        // Use Handle if available
        this.handle = ul.first().attr('data-swap-handle');
        this.handle = $(this.handle, ul).length > 0 ? this.handle : null;
        // this.handle = (!this.isTouch && $(this.handle, ul).length > 0) ? this.handle : null;
        $(this.handle, ul).addClass('draggable').off('mousedown.swaplist touchstart.swaplist').on('mousedown.swaplist touchstart.swaplist', function () {
          _this2.selections.isHandle = true;
        }).off('mouseup.swaplist touchend.swaplist').on('mouseup.swaplist touchend.swaplist', function () {
          _this2.selections.isHandle = false;
        });

        this.targets = ul.attr({ 'aria-dropeffect': 'none' });

        this.items = $('li:not(.is-disabled)', this.element).not('a[href], img').off('selectstart.swaplist').on('selectstart.swaplist', function () {
          if (this.dragDrop) {
            this.dragDrop();
          } // ie9
          return false;
        }).end().attr({ draggable: true }).addClass(self.handle ? '' : 'draggable');
      }
    },


    /**
     * Get Element By Touch In List
     * @private
     * @param {jQuery|HTMLElement} list the list element
     * @param {number} x touch event's x coordinate
     * @param {number} y touch event's y coordinate
     * @returns {jQuery[]} component that was tapped
     */
    getElementByTouchInList: function getElementByTouchInList(list, x, y) {
      var returns = false;
      var listJq = $(list);

      for (var i = 0, l = listJq.length; i < l; i++) {
        var item = $(listJq[i]);
        var offset = item.offset();

        if (!(x <= offset.left || x >= offset.left + item.outerWidth() || y <= offset.top || y >= offset.top + item.outerHeight())) {
          returns = item;
        }
      }
      return returns;
    },


    /**
     * Drag touch element
     * @private
     * @param {jQuery.Event} e jquery-wrapped `touch` event
     * @param {jQuery[]} elm the element being dragged
     */
    draggTouchElement: function draggTouchElement(e, elm) {
      var orig = e.originalEvent.changedTouches[0];
      elm[0].style.top = orig.pageY - this.offset.y + 'px';
      elm[0].style.left = orig.pageX - this.offset.x + 'px';
    },


    /**
     * Shorctut for testing whether a modifier key is pressed
     * @private
     * @param {jQuery.Event} e the keypress event
     * @returns {boolean} whether or not a modifier key is pressed
     */
    hasModifier: function hasModifier(e) {
      return e.ctrlKey || e.metaKey || e.shiftKey;
    },


    /**
     * Applying dropeffect to the target containers
     * @private
     */
    addDropeffects: function addDropeffects() {
      if (this.targets) {
        for (var i = 0, l = this.targets.length; i < l; i++) {
          $(this.targets[i]).attr({ 'aria-dropeffect': 'move', tabindex: 0 });
        }
      }
      if (this.selections && this.selections.items) {
        for (var _i2 = 0, _l2 = this.selections.items.length; _i2 < _l2; _i2++) {
          $(this.selections.items[_i2]).attr({ 'aria-grabbed': true, tabindex: 0 });
        }
      }
    },


    /**
     * Removing dropeffect from the target containers
     * @private
     */
    clearDropeffects: function clearDropeffects() {
      this.targets.attr({ 'aria-dropeffect': 'none' }).removeAttr('tabindex');
      if (this.selections && this.selections.items) {
        for (var i = 0, l = this.selections.items.length; i < l; i++) {
          var val = $(this.selections.items[i]);
          val.removeAttr('aria-grabbed' + (!val.is(':focus') ? ' tabindex' : ''));
        }
      }
    },


    /**
     * Clear selections
     * @private
     */
    clearSelections: function clearSelections() {
      this.selections.items = [];
      this.selections.itemsData = [];
      this.selections.owner = null;
      this.selections.related = null;
      this.selections.droptarget = null;
      this.selections.isInSelection = null;
      this.selections.dragged = null;
      this.selections.placeholder = null;
      this.selections.placeholderTouch = null;
      $('ul, li', this.element).removeClass('over');
      $('#sl-placeholder-container, #sl-placeholder-touch, #sl-placeholder-touch2, #sl-placeholder').remove();
    },


    /**
     * Set selections items
     * @private
     * @param {jQuery[]|HTMLElement} container the container element
     */
    setSelectionsItems: function setSelectionsItems(container) {
      container = this.isjQuery(container) ? container : $(container, this.element);
      var nodes = $('.listview li', container);
      var dataList = this.getDataList(container);

      for (var i = 0, l = nodes.length; i < l; i++) {
        if ($(nodes[i]).is('.is-selected')) {
          this.selections.itemsData.push(dataList[i]);
        }
      }
    },


    /**
     * Init dataset
     * @private
     */
    initDataset: function initDataset() {
      var s = this.settings;
      var containers = [{ type: 'available', dataset: s.available, class: s.availableClass }, { type: 'selected', dataset: s.selected, class: s.selectedClass }, { type: 'additional', dataset: s.additional, class: s.additionalClass }];

      this.dataset = { available: [], selected: [] };
      if (this.isAdditional) {
        this.dataset.additional = [];
      }

      for (var i = 0, l = containers.length; i < l; i++) {
        var c = containers[i];
        var nodes = $(c.class + ' .listview li', this.element);

        for (var nodeIndex = 0, l2 = nodes.length; nodeIndex < l2; nodeIndex++) {
          var data = void 0;
          var value = void 0;
          var li = $(nodes[nodeIndex]);
          if (c.dataset) {
            // Make sure it's not reference pointer to data object, make copy of data
            data = JSON.parse(JSON.stringify(c.dataset[nodeIndex]));
            delete data.selected;
          } else {
            data = { text: $.trim($('.swaplist-item-content', li).text()) };
            value = li.attr('data-value');
            if (value) {
              data.value = value;
            }
          }
          if (this.dataset[c.type]) {
            data.node = li;
            this.dataset[c.type].push(data);
          }
        }
      }
    },


    /**
     * Get data list
     * @private
     * @param {jQuery[]|HTMLElement} container the container element
     * @returns {object|array} the subset of the dataset desired
     */
    getDataList: function getDataList(container) {
      var s = this.settings;
      var d = this.dataset;
      container = this.isjQuery(container) ? container : $(container, this.element);

      if (container.is(s.additionalClass)) {
        return d.additional;
      }
      if (container.is(s.selectedClass)) {
        return d.selected;
      }
      if (container.is(s.availableClass)) {
        return d.available;
      }
      return [];
    },


    /**
     * Move an array element position
     * @private
     * @param {array} arr target array to manipulate
     * @param {number} from index to pull from
     * @param {number} to index to move to
     */
    arrayIndexMove: function arrayIndexMove(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },


    /**
     * Sync dataset
     * @private
     * @param {jQuery[]} owner element that currently contains the dataset
     * @param {jQuery[]} droptarget element that will receive the dataset
     */
    syncDataset: function syncDataset(owner, droptarget) {
      var droptargetNodes = $('.listview li', droptarget);
      var ownerAPI = owner.find('.listview').data('listview');
      var dropTargetAPI = droptarget.find('.listview').data('listview');
      var ownerDataList = this.getDataList(owner);
      var dtDataList = this.getDataList(droptarget);
      var isMoved = function isMoved(mOwner, mItem) {
        if (mOwner && mItem) {
          var id = { owner: mOwner.getAttribute('data-id'), item: mItem.getAttribute('data-id') };
          return typeof id.owner !== 'undefined' && typeof id.item !== 'undefined' && id.owner === id.item;
        }
        return false;
      };

      for (var i = 0, l = this.selections.items.length; i < l; i++) {
        var item = this.selections.items[i];
        for (var dtIndex = 0, l2 = droptargetNodes.length; dtIndex < l2; dtIndex++) {
          if ($(droptargetNodes[dtIndex]).is(item)) {
            for (var ownerIndex = 0, l3 = ownerDataList.length; ownerIndex < l3; ownerIndex++) {
              var ownerItem = ownerDataList[ownerIndex];
              if (isMoved(ownerItem.node[0], item[0])) {
                dtDataList.push(ownerItem);
                ownerDataList.splice(ownerIndex, 1);
                this.arrayIndexMove(dtDataList, dtDataList.length - 1, dtIndex);
                break;
              }
            }
          }
        }
      }

      ownerAPI.updated({ dataset: ownerDataList });
      dropTargetAPI.updated({ dataset: dtDataList });
      this.makeDraggable();
    },


    /**
     * Check if a object is jQuery object
     * @private
     * @param {object} obj the object being checked
     * @returns {boolean} whether or not the object is a jQuery selector
     */
    isjQuery: function isjQuery(obj) {
      return obj && (obj instanceof jQuery || obj.constructor.prototype.jquery);
    },


    /**
     * Update attributes
     * @private
     * @param {jQuery[]} list the target element to update
     */
    updateAttributes: function updateAttributes(list) {
      var items = $('li', list);

      for (var i = 0, l = items.length; i < l; i++) {
        $(items[i]).attr({ 'aria-posinset': i + 1, 'aria-setsize': l });
      }
    },


    /**
     * After update
     * @private
     * @param {jQuery[]} list the target element to change after an update
     */
    afterUpdate: function afterUpdate(list) {
      var focusIdx = this.selections.droptarget.find('li:focus').index();
      var focusClass = '.card.' + this.selections.droptarget[0].classList[1] + ' li';

      if (list) {
        if (this.selections.placeholder) {
          list.select(this.selections.placeholder);
          this.selections.placeholder.focus();
        }
        this.unselectElements(list);
        this.syncDataset(this.selections.owner, this.selections.droptarget);
        this.updateAttributes($('.listview', this.selections.owner));
        this.updateAttributes($('.listview', this.selections.droptarget));
        if (this.selections.items.length) {
          this.selections.move = $.extend(true, this.selections.move, {
            to: this.getContainer(this.selections.itemsData)
          });
          /**
          * Fires when any bucket has its content changed.
          * @event swapupdate
          * @memberof SwapList
          * @type {object}
          * @property {object} event - The jquery event object
          * @property {array} items - List of items data
          */
          this.element.triggerHandler('swapupdate', [this.selections.move]);
        }
      }

      this.selections.items.forEach(function (elem) {
        elem.show();
      });

      this.clearDropeffects();
      this.clearSelections();
      this.items.removeClass('is-dragging is-dragging-touch');

      if (focusIdx >= 0) {
        this.element.find(focusClass).eq(focusIdx).focus();
      }
    },


    /**
     * Get items from provided container
     * @private
     * @param {jQuery[]|HTMLElement} container the container being checked
     * @returns {object|array} dataset
     */
    getItems: function getItems(container) {
      container = this.isjQuery(container) ? container : $(container, this.element);
      return this.getDataList(container);
    },


    /**
     * Get the current representative dataset with only the available elements in it.
     * @returns {object|array} dataset
     */
    getAvailable: function getAvailable() {
      return this.getDataList(this.settings.availableClass);
    },


    /**
     * Get the current representative dataset with only the selected elements in it.
     * @returns {object|array} dataset
     */
    getSelected: function getSelected() {
      return this.getDataList(this.settings.selectedClass);
    },


    /**
     * Get the current representative dataset with only the additional elements in it.
     * @returns {object|array} dataset
     */
    getAdditional: function getAdditional() {
      return this.getDataList(this.settings.additionalClass);
    },


    /**
     * Make selected if dragged element was not selected
     * @private
     * @param {object} list the list to manipulate
     * @param {jQuery[]} target the target to give a "selected" state
     * @returns {boolean} whether or not an item was made selected
     */
    draggedMakeSelected: function draggedMakeSelected(list, target) {
      var isInSelection = false;
      if (!this.selections.isInSelection) {
        // Check if dragged element was selected or not
        if (list.selectedItems) {
          for (var i = 0, l = list.selectedItems.length; i < l; i++) {
            if (target.is(list.selectedItems[i])) {
              isInSelection = true;
              return false;
            }
          }
        }
        if (!isInSelection) {
          list.select(target); // Make selected
          this.selections.isInSelection = true;
        }
      }
      return true;
    },


    /**
     * Updates the internal datasets and refresh the ui.
     * @param {object} ds The updated dataset(s) of the form.
     *  `{available: [], selected: [], additional: []}`
     * @returns {void}
     */
    updateDataset: function updateDataset(ds) {
      var s = this.settings;
      var containers = [{ type: 'available', dataset: ds.available, class: s.availableClass }, { type: 'selected', dataset: ds.selected, class: s.selectedClass }, { type: 'additional', dataset: ds.additional, class: s.additionalClass }];

      for (var i = 0, l = containers.length; i < l; i++) {
        var c = containers[i];
        var lv = $(c.class + ' .listview', this.element);
        var api = lv.data('listview');

        if (api) {
          api.deselectItemsBetweenIndexes([0, $('li', lv).length - 1]);
          s[c.type] = c.dataset || [];
          api.loadData(s[c.type]);
        }
      }

      this.initDataset();
      this.makeDraggable();
      this.initSelected(s.availableClass);
      this.initSelected(s.additionalClass);
    },


    /**
     * Removes event bindings from the swaplist instance.
     * @private
     * @returns {this} component instance
     */
    unbind: function unbind() {
      this.actionButtons.off('click.swaplist');
      this.containers.off('keydown.swaplist', '.listview');
      this.selectedButtons.off('keydown.swaplist');
      this.element.off('keydown.swaplist', this.tabButtonsStr);
      this.element.off(this.dragStart + ' ' + this.dragEnterWhileDragging + ' ' + this.dragOverWhileDragging + ' ' + this.dragEnd, this.dragElements);

      $('#sl-placeholder-container, #sl-placeholder-touch, #sl-placeholder-touch2, #sl-placeholder').remove();
      return this;
    },


    /**
     * Updates this instance of the swaplist component with new settings.
     * @private
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, SWAPLIST_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroys this instance of the swaplist component and removes its link to its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$X);
    },


    // Handle Events
    handleEvents: function handleEvents() {
      var self = this;
      var settings = self.settings;
      var selections = self.selections;

      // TOP BUTTONS =============================================================================
      self.actionButtons.off('click.swaplist').on('click.swaplist', function () {
        var actionButton = $(this);
        var container = actionButton.closest('.card'); // Current list clicked from

        var moveTo = null;

        if (container.is(settings.availableClass)) {
          // Move from Available to Selected or Additional
          if (settings.draggable.selected) {
            moveTo = settings.selectedClass;
          } else {
            moveTo = self.isAdditional && settings.draggable.additional ? settings.additionalClass : null;
          }
          self.moveElements(settings.availableClass, moveTo);
        } else if (container.is(settings.additionalClass)) {
          // Move from Additional to Selected or Available
          if (settings.draggable.selected) {
            moveTo = settings.selectedClass;
          } else {
            moveTo = settings.draggable.available ? settings.availableClass : null;
          }
          self.moveElements(settings.additionalClass, moveTo);
        } else if (container.is(settings.selectedClass)) {
          // Move from Selected
          if (actionButton.is(settings.selectedBtnLeft)) {
            // to Available
            self.moveElements(settings.selectedClass, settings.availableClass);
          } else if (actionButton.is(settings.selectedBtnRight)) {
            // to Additional
            self.moveElements(settings.selectedClass, settings.additionalClass);
          }
        }
      });

      // KEYSTROKE ===============================================================================
      // Keydown event to implement selections
      self.containers.on('keydown.swaplist', '.listview', function (e) {
        var container = $(this).closest(self.containers);
        e = e || window.event;
        if (e.keyCode === 77 && self.hasModifier(e)) {
          // Modifier + M
          if (!container.is(settings.selectedClass) || container.is(settings.selectedClass) && self.selectedButtons.length === 1) {
            container.find(self.actionButtons).trigger('click.swaplist');
          } else {
            self.selectedButtons.first().focus();
          }
          e.preventDefault();
        }
      });

      // Keydown event to handle selected container
      self.selectedButtons.on('keydown.swaplist', function (e) {
        var btn = $(this);
        var index = void 0;
        var move = void 0;
        e = e || window.event;
        if (e.keyCode === 13 || e.keyCode === 32) {
          // Enter or Space
          btn.trigger('click.swaplist');
          e.preventDefault();
        }
        // Left or Right arrow
        if ((e.keyCode === 37 || e.keyCode === 39) && self.selectedButtons.length > 1) {
          index = self.selectedButtons.index(this);
          if (e.keyCode === 37) {
            move = index > 0 ? index - 1 : self.selectedButtons.length - 1;
          } else {
            move = index < self.selectedButtons.length - 1 ? index + 1 : 0;
          }
          self.selectedButtons[move].focus();
        }
      });

      self.element.on('keydown.swaplist', self.tabButtonsStr, function (e) {
        var btn = $(this);
        var keyCode = e.keyCode || e.which;

        if (keyCode === 9 && !e.shiftKey) {
          // Tab key
          var card = btn.closest('.card')[0];
          var items = [].slice.call(card.querySelectorAll('li[tabindex]'));
          var itemsLen = items.length;
          var found = false;
          if (itemsLen) {
            items.forEach(function (item) {
              var tabindex = parseInt(item.getAttribute('tabindex'), 10);
              if (tabindex !== -1) {
                found = true;
              }
            });
          }
          if (!found) {
            var item = card.querySelector('li');
            if (item) {
              item.setAttribute('tabindex', 0);
            }
          }
        }
      });

      // SEARCHFIELD =============================================================================
      self.containers.on('filtered.swaplist', '.listview', function () {
        self.makeDraggable();
      });

      // DRAGGABLE ===============================================================================
      self.element.on('mousedown.swaplist', self.dragElements, function (e) {
        if (self.handle) {
          var target = $(e.target).closest('li');
          target.attr({ draggable: $(e.target).is('.draggable') });
        }
        e.stopPropagation();
      })
      // Dragstart - initiate dragging
      .on(self.dragStart, self.dragElements, function (e) {
        e.stopImmediatePropagation();
        if (self.handle && !selections.isHandle) {
          e.stopPropagation();
          return;
        }
        var rect = void 0;
        var touch = void 0;
        var placeholderContainer = void 0;
        var target = $(e.target).closest('li');
        var list = $('.listview', target.closest('.card')).data('listview');

        // Not in draging area
        if (!list) {
          return;
        }

        if (!self.isTouch) {
          self.draggedMakeSelected(list, target);
        }

        self.clearSelections(); // Clear selection before fill

        selections.owner = target.closest('.card');
        selections.dragged = target;
        selections.draggedIndex = target.index();
        selections.placeholder = target.clone(true);
        selections.placeholder.attr('id', 'sl-placeholder');

        self.setSelectionsItems(selections.owner);

        selections.items = list.selectedItems;

        self.selections.move = {
          items: self.selections.itemsData,
          from: self.getContainer(self.selections.itemsData)
        };

        /**
          * Fires before moving an element allowing you to access the draggable item.
          * @event beforeswap
          * @memberof SwapList
          * @type {object}
          * @property {object} event - The jquery event object
          * @property {array} items - List of selected items data
          */
        var result = self.element.triggerHandler('beforeswap', [self.selections.move]);
        if (typeof result === 'boolean' && !result || typeof result === 'string' && result.toLowerCase() === 'false') {
          selections.dragged = null;
          return;
        }

        $('.' + settings.numOfSelectionsClass, settings.itemContentTempl).html(selections.items.length);
        self.addDropeffects();

        if (!self.isTouch) {
          selections.dragged.addClass('is-dragging');
          e.originalEvent.dataTransfer.setData('text', '');

          if (selections.items.length > 1) {
            $('.' + settings.itemContentClass, selections.dragged).html(settings.itemContentTempl.html());
          }
        } else {
          rect = target[0].getBoundingClientRect();
          touch = e.originalEvent.changedTouches[0];

          // Save offset
          self.offset = {
            x: touch.pageX - rect.left,
            y: touch.pageY - rect.top
          };

          for (var i = 0, l = self.containers.length; i < l; i++) {
            self.containers[i].style.zIndex = '1';
          }
          selections.placeholderTouch = selections.dragged.clone(true);

          if (selections.items.length > 1 && !$('#sl-placeholder-touch2').length) {
            selections.dragged.clone().addClass('is-dragging-touch').attr('id', 'sl-placeholder-touch2').insertBefore(selections.dragged).hide();
          }
          selections.placeholderTouch.attr('id', 'sl-placeholder-touch').removeClass('is-selected').hide();

          // Mobile view with three container(available, selected, additional) prepend to parent
          placeholderContainer = self.element.is('.one-third') && self.isMaxWidth(766) ? self.element.parent() : self.element;
          placeholderContainer.prepend('<ul id="sl-placeholder-container"></ul>');

          $('#sl-placeholder-container').append(selections.placeholderTouch);
          $('#sl-placeholder-container')[0].style.width = selections.owner.width() + 'px';
          $('#sl-placeholder-touch')[0].style.width = selections.owner.width() + 'px';

          self.draggTouchElement(e, selections.placeholderTouch);
        }
        e.stopPropagation();
      })

      // Dragenter - set that related/droptarget
      .on(self.dragEnterWhileDragging, self.dragElements, function (e) {
        if (!selections.dragged) {
          return;
        }
        self.element.triggerHandler('draggingswap', [selections.move]);
        selections.related = e.target;
        $('ul, li', self.element).removeClass('over');
        $(e.target).closest('ul, li').addClass('over');
        selections.droptarget = $(selections.related).closest('.card');
        $('[aria-grabbed="true"]', self.element).not(selections.dragged).slideUp();
        e.stopPropagation();
      })

      // Dragover - allow the drag by preventing default, for touch set related/droptarget
      .on(self.dragOverWhileDragging, self.dragElements, function (e) {
        if (!selections.dragged) {
          return;
        }
        var touch = void 0;
        var overItem = $(this);
        var list = $('.listview', selections.dragged.closest('.card')).data('listview');

        if (self.isTouch) {
          if (!!self.handle && !selections.isHandle) {
            return;
          }

          if (!selections.isInSelection) {
            self.draggedMakeSelected(list, selections.dragged);
            selections.items = list.selectedItems;
            $('.' + settings.numOfSelectionsClass, settings.itemContentTempl).html(selections.items.length);
          }

          touch = e.originalEvent.touches[0];
          overItem = self.getElementByTouchInList($('ul, li', self.element), touch.pageX, touch.pageY) || overItem;

          selections.dragged.addClass('is-dragging');
          selections.placeholderTouch.addClass('is-dragging is-dragging-touch');
          selections.placeholderTouch.show();

          $('[aria-grabbed="true"]', self.element).not(selections.dragged).not(selections.placeholderTouch).not('#sl-placeholder-touch2').slideUp();

          if (selections.items.length > 1) {
            $('.' + settings.itemContentClass, selections.placeholderTouch.add('#sl-placeholder-touch2')).html(settings.itemContentTempl.html());

            $('#sl-placeholder-touch2').show();
            selections.dragged.hide();
          }
          self.draggTouchElement(e, selections.placeholderTouch);

          self.element.triggerHandler('draggingswap', [selections.move]);
          selections.related = overItem;
          $('ul, li', this.element).removeClass('over');
          overItem.closest('ul, li').addClass('over');
          selections.droptarget = selections.related.closest('.card');
        }
        e.preventDefault();
        e.stopPropagation();
      })

      // Dragend - implement items being validly dropped into targets
      .on(self.dragEnd, self.dragElements, function (e) {
        if (!selections.dragged) {
          return;
        }
        var related = $(selections.related).closest('li');
        var ul = $('ul', selections.droptarget);
        var currentSize = $('li', ul).length;
        var size = selections.items.length + currentSize;

        self.unselectElements($('.listview', selections.owner).data('listview'));

        $.each(selections.items, function (index, val) {
          val = $(val);
          val.find('mark.highlight').contents().unwrap();
          if (currentSize && !$(selections.related).is('ul')) {
            var isLess = related.index() < selections.draggedIndex;
            var el = isLess ? val : $(selections.items[selections.items.length - 1 - index]);
            var posinset = related.index() + (isLess ? index + 1 : index + 2);

            val.attr({ 'aria-posinset': posinset, 'aria-setsize': size });
            related[isLess ? 'before' : 'after'](el);
          } else {
            val.attr({ 'aria-posinset': currentSize + index + 1, 'aria-setsize': size });
            ul.append(val);
          }
          val.focus();
        });

        if (selections.items.length > 1) {
          $('.' + settings.itemContentClass, selections.dragged).html($('.' + settings.itemContentClass, selections.placeholder).html());
          if (self.isTouch) {
            selections.dragged.show();
          }
        }

        if (self.isTouch) {
          for (var i = 0, l = self.containers.length; i < l; i++) {
            self.containers[i].style.zIndex = '';
          }
        }

        self.makeDraggable();

        selections.isHandle = null;
        $('[aria-grabbed="true"]', self.element).show();
        self.afterUpdate($('.listview', selections.droptarget).data('listview'));
        e.preventDefault();
        e.stopPropagation();
      });
    } // END: Handle Events ---------------------------------------------------------------------

  };

  /**
   * jQuery Component Wrapper for SwapList
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.swaplist = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$X);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$X, new SwapList(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$Y = 'scrollaction';

  // Default ScrollAction Options
  var SCROLLACTION_DEFAULTS = {
    scrollActionTarget: '.js-scroll-target', // The element to add a class to based on scrolling logic
    classToAdd: 'scrolled-down' // The class added to the target element
  };

  /**
  * A component that applies a class based on scroll direction
  * @class ScrollAction
  * @param {string} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [scrollActionTarget='.js-scroll-target'] The selector of the element to add the class to.
  * @param {string} [classToAdd ='scrolled-down'] The class name to use when toggling.
  */
  function ScrollAction(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SCROLLACTION_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // ScrollAction Methods
  ScrollAction.prototype = {
    init: function init() {
      this.handleEvents();
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      var s = this.settings;
      this.element.off('scroll.scrollaction');
      if (s) {
        $(s.scrollActionTarget).removeClass(s.classToAdd);
      }
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, SCROLLACTION_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$Y);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var s = this.settings;
      this.lastScrollTop = 0;

      this.element.on('scroll.scrollaction', function () {
        var scrollTop = _this.element.scrollTop();

        if (scrollTop > _this.lastScrollTop) {
          $(s.scrollActionTarget).addClass(s.classToAdd);
        } else {
          $(s.scrollActionTarget).removeClass(s.classToAdd);
        }

        _this.lastScrollTop = scrollTop;
      });
    }
  };

  /**
   * jQuery Component Wrapper for ScrollAction
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.scrollaction = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$Y);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$Y, new ScrollAction(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$Z = 'stepchart';

  // Default component options
  var DEFAULT_STEPCHART_OPTIONS = {
    steps: null,
    completed: null,
    inProgress: null,
    iconType: null,
    completedText: null,
    extraText: '',
    completedColor: null,
    allCompletedColor: null,
    inProgressColor: null
  };

  /**
   * The Step Chart Component is displays visual info on step completion.
   * @class StepChart
   * @constructor
   * @param {jQuery[]|HTMLElement} element The base element
   * @param {object} [settings] incoming settings
   * @param {number} [settings.steps = null] The number of steps to show.
   * @param {number} [settings.completed = null] The number of steps complete (linear).
   * @param {number} [settings.inProgress = null] The number of the in progress step (linear).
   * @param {boolean} [settings.iconType = null] The icon to display fx. 'icon-error', 'icon-success'
   * @param {string} [settings.completedText = null] The completed text or uses a localized 'N of N Steps complete'.
   *  You can use {0} and {1} to replace n of n in the string.
   * @param {boolean} [settings.extraText = ''] The additional text to show on the right. Defaults to none. You
   *  can use {0} to replace with the steps remaining count and {1} to replace the number of steps.
   * @param {string} [settings.completedColor = null] The color to show completed steps. Defaults to primary color.
   * @param {string} [settings.allCompletedColor = null] The color to steps when all are completed. Defaults to primary color.
   * @param {string} i[settings.nProgressColor The color to show in-progress steps. Defaults to ruby02.
   */
  function StepChart(element, settings) {
    return this.init(element, settings);
  }

  StepChart.prototype = {

    /**
     * Initialize and render the chart
     * @private
     * @param {jQuery[]|HTMLElement} element The base element
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    init: function init(element, settings) {
      if (!this.element && element instanceof HTMLElement) {
        this.element = $(element);
      }

      if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object' || this.settings === undefined) {
        var previousSettings = this.settings || DEFAULT_STEPCHART_OPTIONS;
        this.settings = utils.mergeSettings(this.element[0], settings, previousSettings);
      }

      return this.render();
    },


    /**
     * Initialize and render the from the options
     * @private
     * @returns {this} component instance
     */
    render: function render() {
      var container = $('<div class="step-chart-steps"></div>');
      var icon = '\n      <svg class="icon {icon-name}" focusable="false" aria-hidden="true" role="presentation">\n        <use xlink:href="#icon-success"></use>\n      </svg>\n    ';

      var isEmpty = this.settings.completed === null && this.settings.steps === null;
      if (isEmpty) {
        this.settings.completed = 0;
        this.settings.steps = 1;
      }

      if (this.element.attr('data-options')) {
        this.settings = utils.parseSettings(this.element);
      }

      if (this.element.children().length > 0) {
        return this;
      }

      for (var i = 0; i < this.settings.steps; i++) {
        var step = $('<div class="step-chart-step"></div>');

        // Set up ticks
        if (i < this.settings.completed) {
          step.addClass('is-complete');

          if (this.settings.completedColor) {
            step.css('background-color', this.settings.completedColor);
          }
        }

        if (i === this.settings.inProgress - 1) {
          step.addClass('is-inprogress');

          if (this.settings.inProgressColor) {
            step.css('background-color', this.settings.inProgressColor);
          }
        }

        container.append(step);
      }

      // Set up labels and alerts
      var completedText = this.settings.completedText || Locale.translate('StepsCompleted');
      completedText = completedText.replace('{0}', this.settings.completed);
      completedText = completedText.replace('{1}', this.settings.steps);

      if (isEmpty) {
        completedText = Locale ? Locale.translate('NoData') : 'No Data Available';
      }
      var label = $('<span class="step-chart-label">' + completedText + '</span>');

      if (this.settings.steps === this.settings.completed) {
        container.addClass('is-complete');
        label.append(icon.replace('{icon-name}', 'icon-success'));
      }

      if (this.settings.iconType) {
        label.append(icon.replace('{icon-name}', this.settings.iconType));
      }

      if (this.settings.extraText) {
        var extraText = this.settings.extraText;
        extraText = extraText === '{0} Days Remaining' ? Locale.translate('DaysRemaining') : extraText;
        extraText = extraText === '{1} Days Overdue' ? Locale.translate('DaysOverdue') : extraText;
        extraText = extraText.replace('{0}', this.settings.steps - this.settings.completed);
        extraText = extraText.replace('{1}', this.settings.completed);
        label.append('<span class="step-chart-label-small">' + extraText + '</span>');
      }

      this.element.append(label, container);

      // Adjust completed color
      if (this.settings.steps === this.settings.completed && this.settings.allCompletedColor) {
        container.find('.step-chart-step').css('background-color', this.settings.allCompletedColor);
        label.find('.icon').attr('style', 'fill: ' + this.settings.allCompletedColor + '!important');
      }

      return this;
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      this.element.empty();

      return this.render();
    },


    /**
     * Tear down and remove.
     * @returns {this} component instance
     */
    destroy: function destroy() {
      this.element.empty();
      this.settings = null;
      $.removeData(this.element[0], COMPONENT_NAME$Z);

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for StepChart
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.stepchart = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$Z);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$Z, new StepChart(this, settings));
        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, COMPONENT_NAME$Z);
        };
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$_ = 'tabs';

  // Types of possible Tab containers
  var tabContainerTypes = ['horizontal', 'vertical', 'module-tabs', 'header-tabs'];

  /**
   * @class Tabs
   * @constructor
   * @param {HTMLElement|jQuery[]} element the base element for this component
   * @param {object} settings incoming settings
   *
   * @param {boolean} [settings.addTabButton=false] If set to true, creates a button at the end
   * of the tab list that can be used to add an empty tab and panel
   * @param {function} [settings.addTabButtonCallback=null] if defined as a function, will
   * be used in-place of the default Tab Adding method
   * @param {boolean} [settings.appMenuTrigger=false] If set to true, will force an App Menu
   * trigger to be present on Non-Vertical Tabs implementatations.
   * @param {string} [settings.appMenuTriggerText] If defined, replaces the default "Menu" text used
   * in the app menu trigger.
   * @param {object} [settings.ajaxOptions] if defined, will be used by any internal
   * Tabs AJAX calls as the desired request settings.
   * @param {function} [settings.beforeActivate] If defined as a function, fires
   * this before a tab is activated to allow a possible "veto" of the tab swap (SOHO-5250).
   * @param {string|jQuery} [settings.containerElement=null] Defines a separate element
   * to be used for containing the tab panels.  Defaults to a `.tab-panel-container`
   * element that is created if it doesn't already exist.
   * @param {boolean} [settings.changeTabOnHashChange=false] If true, will change the selected
   * tab on invocation based on the URL that exists after the hash.
   * @param {function} [settings.hashChangeCallback=null] If defined as a function,
   * provides an external method for adjusting the current page hash used by these tabs.
   * @param {boolean} [settings.lazyLoad=true] if true, when using full URLs in tab HREFs,
   * or when using Ajax calls, tabs will be loaded as needed instead of the markup
   * all being established at once.
   * @param {boolean} [settings.moduleTabsTooltips=false] if true, will display a tooltip on
   * Module Tabs with cut-off text content.
   * @param {function} [settings.source=null] If defined, will serve as a way of pulling
   * in external content to fill tabs.
   * @param {object} [settings.sourceArguments={}] If a source method is defined, this
   * flexible object can be passed into the source method, and augmented with
   * parameters specific to the implementation.
   * @param {boolean} [settings.tabCounts=false] If true, Displays a modifiable count above each tab.
   * @param {boolean} [settings.verticalResponsive=false] If Vertical Tabs & true, will automatically
   * switch to Horizontal Tabs on smaller breakpoints.
   */
  var TABS_DEFAULTS = {
    addTabButton: false,
    addTabButtonCallback: null,
    appMenuTrigger: false,
    appMenuTriggerText: undefined,
    ajaxOptions: null,
    beforeActivate: undefined,
    containerElement: null,
    changeTabOnHashChange: false,
    hashChangeCallback: null,
    lazyLoad: true,
    moduleTabsTooltips: false,
    source: null,
    sourceArguments: {},
    tabCounts: false,
    verticalResponsive: false
  };

  function Tabs(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, TABS_DEFAULTS);
    this.init();
  }

  Tabs.prototype = {

    /**
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      return this.setup().build().setupEvents();
    },


    /**
     * @private
     * @returns {this} component instance
     */
    setup: function setup() {
      // Used by the $(body).resize event to correctly identify the tabs container element
      this.tabsIndex = $('.tab-container').index(this.element);
      return this;
    },


    /**
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      var _this = this;

      var self = this;
      var tabPanelContainer = void 0;
      var moveTabPanelContainer = false;

      // Check for a tab panel container immediately after the `.tab-container`
      // element (default as of IDS Enterprise 4.3.0)
      tabPanelContainer = this.element.next('.tab-panel-container');

      // Auto-detect and move existing tab-panel containers in key areas, if applicable.
      // Check inside the container first
      if (!tabPanelContainer.length) {
        tabPanelContainer = this.element.children('.tab-panel-container');

        if (!this.isVerticalTabs()) {
          moveTabPanelContainer = true;
        }
      }

      // Special case for Header Tabs, find the page container and use that as the container
      var bodyPageContainer = $('body > .page-container, .application-menu + .page-container');
      if (this.element.closest('.header').length > 0 && bodyPageContainer.length) {
        tabPanelContainer = bodyPageContainer;
      }

      // Special case for Module Tabs, where it's possible for layout reasons for there to be
      // an application menu element adjacent between the Tab list and the Tab Panel container
      if (this.element.next('.application-menu').length) {
        tabPanelContainer = this.element.next().next('.page-container');
        moveTabPanelContainer = false;
      }

      // Defining `this.settings.containerElement` ultimately overrides any internal
      // changes to the tab panel container.
      if (this.settings.containerElement && $(this.settings.containerElement).length) {
        tabPanelContainer = $(this.settings.containerElement);
        moveTabPanelContainer = false;
      }

      // If a `.tab-panel-container` still doesn't exist, create one.
      if (!tabPanelContainer || !tabPanelContainer.length) {
        tabPanelContainer = $('<div class="tab-panel-container"></div>');
        moveTabPanelContainer = true;
      }

      if (!tabPanelContainer[0].classList.contains('tab-panel-container')) {
        tabPanelContainer[0].classList.add('tab-panel-container');
      }
      if (moveTabPanelContainer) {
        tabPanelContainer.insertAfter(this.element);
      }

      this.container = tabPanelContainer;

      // Detect the existence of a "tab-list-container" element, if applicable.
      // Tab List containers are optional for all tab container types, but mandatory for
      // Composite Form tabs.
      var tablistContainer = this.element.children('.tab-list-container');
      if (!tablistContainer.length && this.isScrollableTabs()) {
        tablistContainer = $('<div class="tab-list-container"></div>').prependTo(this.element);
      }
      if (tablistContainer.length) {
        this.tablistContainer = tablistContainer;
      }

      // Add a default tabs class of "horizontal" if it doesn't already exist
      var noClass = true;
      var closestHeader = this.element.closest('.header');
      tabContainerTypes.forEach(function (val, i) {
        if (_this.element.hasClass(tabContainerTypes[i])) {
          noClass = false;
        }
      });
      if (noClass) {
        if (closestHeader.length) {
          self.element.addClass('header-tabs');
        } else {
          self.element.addClass('horizontal');
        }
      }

      // Build Tab Counts
      if (self.settings.tabCounts) {
        self.element.addClass('has-counts');
      }

      // Attach Tablist role and class to the tab headers container
      this.tablist = this.element.children('.tab-list');
      if (!this.tablist.length) {
        // If we have a `.tab-list-container` element, check that before creating markup
        if (this.tablistContainer) {
          this.tablist = this.tablistContainer.children('.tab-list');
        }

        // Create and append the `.tab-list` if it still doesn't exist.
        if (!this.tablist.length) {
          this.tablist = $('<ul class="tab-list"></ul>');
          if (this.tablistContainer) {
            this.tablist.appendTo(this.tablistContainer);
          } else {
            this.tablist.appendTo(this.element);
          }
        }
      }

      // Double-check that the `.tab-list-container` actually contains the `.tab-list`.
      // Move it if necessary.
      if (this.tablistContainer) {
        if (!this.tablist.parent().is(this.tablistContainer)) {
          this.tablistContainer.append(this.tablist);
        }

        this.tablistContainer.on('mousewheel.tabs', function (e) {
          if (e.deltaY) {
            this.scrollLeft += e.deltaY;
          }
        });
      }

      self.tablist.attr({
        class: 'tab-list',
        role: 'tablist',
        'aria-multiselectable': 'false'
      });

      // Conditionally Change layout classes if veritcal tabs is in responsive
      // mode, and breakpoints match.
      this.checkResponsive(false);

      // Handle Focus State, Animated Bar, More Button, Add Tabs Button, and
      // App Menu Button.
      this.renderHelperMarkup();

      // for each item in the tabsList...
      self.anchors = self.tablist.children('li:not(.separator)').children('a');
      self.anchors.each(function prepareAnchor() {
        var a = $(this);
        a.attr({ role: 'tab', 'aria-expanded': 'false', 'aria-selected': 'false', tabindex: '-1' }).parent().attr('role', 'presentation').addClass('tab');

        if (a.parent().hasClass('dismissible') && !a.parent().children('.icon').length) {
          $.createIconElement({ icon: 'close', classes: 'icon close' }).insertAfter(a);
        }

        // Find and configure dropdown tabs
        var dd = a.nextAll('ul').first();
        if (dd.length > 0) {
          dd.addClass('dropdown-tab');
          var li = a.parent();

          li.addClass('has-popupmenu').popupmenu({
            menu: dd,
            trigger: 'click',
            attachToBody: true
          });

          a.removeAttr('role').removeAttr('aria-expanded').removeAttr('aria-selected');

          if (!a.parent().children('.icon.icon-more').length) {
            $.createIconElement({ classes: 'icon-more', icon: 'dropdown' }).insertAfter(a);
          }
        }

        if (self.settings.tabCounts && $(this).find('.count').length === 0) {
          $(this).prepend('<span class="count">0 </span>');
        }

        // Make it possible for Module Tabs to display a tooltip containing their contents
        // if the contents are cut off by ellipsis.
        if (self.settings.moduleTabsTooltips) {
          a.on('beforeshow.toolbar', function () {
            return a.data('cutoffTitle') === 'yes';
          }).tooltip({
            content: '' + a.text().trim()
          });
        }
      });

      // Build/manage tab panels
      function associateAnchorWithPanel() {
        var a = $(this);
        var li = a.parent();
        var popup = li.data('popupmenu');
        var panel = void 0;

        // Associated the current one
        var href = a.attr('href');

        if (href.substr(0, 1) !== '#') {
          // is an outbound Link
          return;
        }

        if (href.substr(0, 2) === '#/') {
          // uses angular LocationStrategy
          // Just to find the panel but these are handled by angular
          href = href.replace('#/', '#');
        }

        if (href !== undefined && href !== '#') {
          panel = $(href);

          if (li.is(':not(.has-popupmenu)') && !panel.length) {
            return;
          }

          a.data('panel-link', panel);
          panel.data('tab-link', a);
          self.panels = self.panels.add(panel);
        }

        // If dropdown tab, add the contents of the dropdown
        // NOTE: popupmenu items that represent dropdown tabs shouldn't have children,
        // so they aren't accounted for here.
        if (popup) {
          popup.menu.children('li').each(function () {
            var popupLi = $(this);
            var popupA = popupLi.children('a');
            var popupHref = popupA.attr('href');
            var popupPanel = $(popupHref);

            popupA.data('panel-link', popupPanel);
            popupPanel.data('tab-link', popupA);

            self.panels = self.panels.add(popupPanel);
            self.anchors = self.anchors.add(popupA);

            if (!popupLi.hasClass('dismissible')) {
              return;
            }

            var popupIcon = popupLi.children('.icon');
            if (!popupIcon.length) {
              popupIcon = $.createIconElement({ icon: 'close', classes: 'icon close' });
            }
            popupIcon.detach().appendTo(popupA);
          }).on('click.popupmenu', '.icon', function iconClickHandler(e) {
            var popupIcon = $(this);
            var popupLi = popupIcon.closest('li');

            if (popupLi.is('.dismissible') && popupIcon.is('.icon')) {
              e.preventDefault();
              e.stopPropagation();
              self.closeDismissibleTab(popupLi.children('a').attr('href'));
            }
          });
        }
      }

      self.panels = $();
      self.anchors.each(associateAnchorWithPanel);
      self.panels.addClass('tab-panel').attr({ role: 'tabpanel' }).find('h3:first').attr('tabindex', '0');

      self.panels.appendTo(self.container);

      var excludes = ':not(.separator):not(.is-disabled):not(.is-hidden)';
      var tabs = this.tablist.children('li' + excludes);
      var selected = this.tablist.children('li.is-selected' + excludes);
      var selectedAnchor = selected.children('a');
      var hash = void 0;
      var matchingTabs = void 0;

      // Setup a hash for nested tab controls
      self.nestedTabControls = self.panels.find('.tab-container');

      if (tabs.length) {
        // If the hashChange setting is on, change the selected tab to the one referenced by the hash
        if (this.settings.changeTabOnHashChange) {
          hash = window.location.hash;
          if (hash && hash.length) {
            matchingTabs = tabs.find('a[href="' + hash + '"]');
            if (matchingTabs.length) {
              selected = matchingTabs.first().parent();
              selectedAnchor = selected.children('a');
            }
          }
        }

        // If there is no selected tab, try to find the first available tab (if there are any present)
        if (!selected.length) {
          selected = tabs.not('.add-tab-button, .application-menu-trigger').first();
          selectedAnchor = selected.children('a');
        }

        // If there are tabs present, activate the first one
        if (selected.length) {
          this.activate(selectedAnchor.attr('href'), selectedAnchor);
        }
      }

      if (this.isModuleTabs() && this.element.children('.toolbar').length) {
        this.element.addClass('has-toolbar');
      }

      this.setOverflow();

      this.positionFocusState(selectedAnchor);

      if (this.hasAnimatedBar()) {
        this.animatedBar.addClass('no-transition');
        this.focusBar(undefined, function () {
          setTimeout(function () {
            _this.animatedBar.removeClass('no-transition');
          }, 0);
        });
      }

      // Setup Edge Fades
      if (this.tablistContainer) {
        this.tablistContainer.on('scroll.tabs', function () {
          _this.renderEdgeFading();
        });
        this.renderEdgeFading();
      }

      return this;
    },


    /**
     * Adds/removes helper buttons and accessibility-centric markup, based on Tabs' configuration
     * Designed to be run at any point in the Tabs lifecycle.
     * @private
     * @returns {this} component instance
     */
    renderHelperMarkup: function renderHelperMarkup() {
      var auxilaryButtonLocation = this.tablistContainer || this.tablist;
      if (this.isModuleTabs()) {
        auxilaryButtonLocation = this.tablist;
      }

      this.focusState = this.element.find('.tab-focus-indicator');
      if (!this.focusState.length) {
        this.focusState = $('<div class="tab-focus-indicator" role="presentation"></div>').insertBefore(this.tablist);
      }

      // Animated Bar
      if (this.hasAnimatedBar()) {
        this.animatedBar = this.element.find('.animated-bar');
        if (!this.animatedBar.length) {
          this.animatedBar = $('<div class="animated-bar" role="presentation"></div>');
        }
        this.animatedBar.insertBefore(this.tablist);
      } else if (this.animatedBar && this.animatedBar.length) {
        this.animatedBar.off().remove();
        this.animatedBar = undefined;
      }

      // Add the markup for the "More" button if it doesn't exist.
      if (!this.moreButton) {
        this.moreButton = $();
      }

      if (!this.isVerticalTabs()) {
        if (!this.moreButton.length) {
          this.moreButton = auxilaryButtonLocation.next('.tab-more');
        }
        // If we still don't have a More Button, create one
        if (!this.moreButton.length) {
          this.moreButton = $('<div>').attr({ class: 'tab-more' });
          this.moreButton.append($('<span class="more-text">').text(Locale.translate('More')));
          this.moreButton.append($.createIconElement({ classes: 'icon-more', icon: 'dropdown' }));
        }

        // Append in the right place based on configuration
        auxilaryButtonLocation.after(this.moreButton);
      } else if (this.moreButton.length) {
        this.moreButton.off().remove();
        this.moreButton = $();
      }

      // Add the application menu Module Tab, if applicable
      var appMenuTrigger = this.tablist.find('.application-menu-trigger');
      if (this.settings.appMenuTrigger === true) {
        // Backwards Compatibility for the original Application Menu codepath.
        if (this.isModuleTabs()) {
          if (!appMenuTrigger.length) {
            appMenuTrigger = $('\n            <li class="tab application-menu-trigger">\n              <a href="#">\n                <span class="icon app-header">\n                  <span class="one"></span>\n                  <span class="two"></span>\n                  <span class="three"></span>\n                </span>\n                <span>' + (this.settings.appMenuTriggerText || Locale.translate('AppMenuTriggerText')) + '</span>\n              </a>\n            </li>\n          ');
            this.tablist.prepend(appMenuTrigger);
          }
        } else if (this.isVerticalTabs() && appMenuTrigger.length) {
          appMenuTrigger.off().remove();
        }
      } else if (appMenuTrigger.length) {
        if (this.isVerticalTabs()) {
          appMenuTrigger.off().remove();
        } else {
          this.tablist.prepend(appMenuTrigger);
        }
      }

      // Add Tab Button
      if (this.settings.addTabButton) {
        if (!this.addTabButton || !this.addTabButton.length) {
          this.addTabButton = $('\n          <div class="add-tab-button" tabindex="0" role="button">\n            <span aria-hidden="true" role="presentation">+</span>\n            <span class="audible">' + Locale.translate('AddNewTab') + '</span>\n          </div>\n        ');
          this.addTabButton.insertAfter(this.moreButton);
          this.element.addClass('has-add-button');
        }
      } else if (this.addTabButton && this.addTabButton.length) {
        this.addTabButton.remove();
        this.addTabButton = undefined;
        this.element.removeClass('has-add-button');
      }

      return this;
    },


    /**
     * Establishes the bound event listeners on all tabs elements
     * @private
     * @returns {this} component instance
     */
    setupEvents: function setupEvents() {
      var _this2 = this;

      var self = this;

      // Set animation bar if tabs under modal
      var modal = self.element.closest('.modal');
      if (modal.length) {
        modal.on('afteropen', function () {
          if (self.hasAnimatedBar()) {
            self.focusBar();
          }
        });
      }

      // Clicking the 'a' triggers the click on the 'li'
      function routeAnchorClick(e) {
        var a = $(e.currentTarget);

        if (this.wasTapped === true) {
          this.wasTapped = false;
          return;
        }

        if (e.type === 'touchend') {
          this.wasTapped = true;
        }

        if (a.attr('href').substr(0, 1) !== '#') {
          // is an outbound Link
          return;
        }
        e.preventDefault();
      }

      // Some tabs have icons that can be clicked and manipulated
      function handleIconClick(e) {
        var elem = $(this);
        if (elem.is('[disabled]') || elem.parent().hasClass('is-disabled')) {
          return;
        }

        var li = $(elem).parent();

        if (li.hasClass('dismissible')) {
          e.preventDefault();
          e.stopPropagation();
          self.closeDismissibleTab(li.children('a').attr('href'));
        }
      }

      function handleTabBlur() {
        $(this).parent().removeClass('is-focused');
      }

      // Any events bound to individual tabs (li) and their anchors (a) are bound
      // to the tablist element so that tabs can be added/removed/hidden/shown without
      // needing to change event bindings.
      this.tablist.on('mousedown.tabs', '> li', function (e) {
        self.handleAddFocusData(e, $(this));

        if ($(e.target).hasClass('close') && $(e.target).parent().hasClass('has-popupmenu')) {
          var menu = $(this).data('popupmenu').menu;
          var hrefs = [];
          $.each(menu[0].children, function (i, li) {
            hrefs.push(li.children[0].href);
          });
          self.closeDismissibleTabs(hrefs);
        }

        // let right click pass through
        if (e.which !== 3) {
          return self.handleTabClick(e, $(this));
        }
        return false;
      }).on('click.tabs', 'a', routeAnchorClick).on('click.tabs', '.icon', handleIconClick).on('focus.tabs', 'a', function (e) {
        return self.handleTabFocus(e, $(this));
      }).on('blur.tabs', 'a', handleTabBlur).on('keydown.tabs', 'a', function (e) {
        return _this2.handleTabKeyDown(e);
      });

      // Setup events on Dropdown Tabs
      function dropdownTabEvents(i, tab) {
        var li = $(tab);
        var a = li.children('a');
        var menu = li.data('popupmenu').menu;

        // Alt+Del or Alt+Backspace closes a dropdown tab item
        function closeDropdownMenuItem(e) {
          if (!e.altKey || !li.is('.dismissible')) {
            return;
          }

          self.closeDismissibleTab(a.attr('href'));
        }

        menu.on('keydown.popupmenu', 'a', function (e) {
          switch (e.which) {
            case 27:
              // escape
              li.addClass('is-selected');
              a.focus();
              break;
            case 8:
              // backspace (delete on Mac)
              closeDropdownMenuItem(e);
              break;
            case 46:
              // The actual delete key
              closeDropdownMenuItem(e);
              break;
            default:
              break;
          }
        });

        li.on('selected.tabs', function (e, anchor) {
          var popupLi = $(this);
          var href = $(anchor).attr('href');

          if (!self.activate(href, $(anchor))) {
            return false;
          }

          self.positionFocusState(a);

          if (self.hasAnimatedBar()) {
            self.focusBar(popupLi);
          }

          a.focus();
          self.scrollTabList(popupLi);

          popupLi.addClass('is-selected');
          return false;
        });
      }

      var ddTabs = self.tablist.find('li').filter('.has-popupmenu');
      ddTabs.each(dropdownTabEvents);

      function dismissibleTabEvents(i, tab) {
        var li = $(tab);
        var a = li.children('a');

        a.on('keydown.tabs', function (e) {
          self.handleDismissibleTabKeydown(e);
        });
      }

      var dismissible = self.tablist.find('li').filter('.dismissible');
      dismissible.each(dismissibleTabEvents);

      this.setupHelperMarkupEvents();

      this.panels.on('keydown.tabs', function (e) {
        self.handlePanelKeydown(e);
      });

      // Check whether or not all of the tabs + more button are de-focused.
      // If true, the focus-state and animated bar need to revert positions
      // back to the currently selected tab.
      this.element.on('focusout.tabs', function () {
        var noFocusedTabs = !$.contains(self.element[0], document.activeElement);
        var noPopupMenusOpen = self.tablist.children('.has-popupmenu.is-open').length === 0;

        if (noFocusedTabs && noPopupMenusOpen && !self.moreButton.is('.is-selected, .popup-is-open')) {
          self.hideFocusState();
        }
      }).on('updated.tabs', function (e, settings) {
        self.updated(settings);
      }).on('activated.tabs', function (e) {
        // Stop propagation of the activate event from going higher up into the DOM tree
        e.stopPropagation();
      }).on('add.tabs', function (e, newTabId, newTabOptions, newTabIndex) {
        self.add(newTabId, newTabOptions, newTabIndex);
      }).on('remove.tabs', function (e, tabId) {
        self.remove(tabId);
      });

      // Check to see if we need to add/remove the more button on resize
      $('body').on('resize.tabs' + this.tabsIndex, function () {
        self.handleResize();
      });
      self.handleResize(true);

      // Resize the tab to show the error
      $('.tab-panel input').on('error.tabs, valid.tabs', function () {
        var currentLi = $('.tab.is-selected');
        self.focusBar(currentLi);
      });

      return this;
    },


    /**
     * Adds events associated with elements that are re-renderable during the Tabs lifecycle
     * @private
     */
    setupHelperMarkupEvents: function setupHelperMarkupEvents() {
      var self = this;

      // Setup the "more" function
      this.moreButton.on('click.tabs', function (e) {
        self.handleMoreButtonClick(e);
      }).on('keydown.tabs', function (e) {
        self.handleMoreButtonKeydown(e);
      }).on('focus.tabs', function (e) {
        self.handleMoreButtonFocus(e);
      }).on('mousedown.tabs', function (e) {
        self.handleAddFocusData(e, $(this));
      });

      if (this.settings.addTabButton) {
        this.addTabButton.on('click.tabs', function () {
          self.handleAddButton();
        }).on('keydown.tabs', function (e) {
          self.handleAddButtonKeydown(e);
        }).on('focus.tabs', function (e) {
          self.handleAddButtonFocus(e);
        });
      }
    },


    /**
     * Removes events associated with elements that are re-renderable during the Tabs lifecycle
     * @private
     * @returns {this} component instance
     */
    removeHelperMarkupEvents: function removeHelperMarkupEvents() {
      if (this.moreButton && this.moreButton.length) {
        this.moreButton.off('click.tabs keydown.tabs focus.tabs mousedown.tabs');
      }

      if (this.addTabButton && this.addTabButton.length) {
        this.addTabButton.off('click.tabs keydown.tabs focus.tabs');
      }

      return this;
    },


    /**
     * Setup a mousedown event on tabs to determine in the focus handler whether
     * or a not a keystroked cause a change in focus, or a click.  Keystroke focus
     * changes cause different visual situations
     * @private
     * @param {$.Event} e incoming focus event
     * @param {jQuery[]} elem element
     * @returns {undefined}
     */
    handleAddFocusData: function handleAddFocusData(e, elem) {
      var tab = elem;
      if (tab.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      if (!tab.is(this.moreButton)) {
        tab = tab.children('a');
      }

      this.hideFocusState();
      tab.data('focused-by-click', true);
      return true;
    },


    /**
     * Handler for Tab Click
     * @private
     * @param {jQuery.Event} e incoming click event
     * @param {jQuery[]} li list item representing the clicked tab
     * @returns {boolean|undefined} ? // TODO: why?
     */
    handleTabClick: function handleTabClick(e, li) {
      if (this.element.is('.is-disabled') || li && (li.is('.is-disabled') || li.is('.separator'))) {
        e.stopPropagation();
        e.preventDefault();
        return false;
      }

      var appMenuResult = this.handleAppMenuTabKeydown(e);
      if (!appMenuResult) {
        return true;
      }

      var a = li.children('a');
      a.data('focused-by-click', true);

      if (this.popupmenu && this.popupmenu.element.hasClass('is-open')) {
        this.popupmenu.close();
      }

      // Don't activate a dropdown tab.  Clicking triggers the Popupmenu Control attached.
      if (li.is('.has-popupmenu')) {
        this.positionFocusState(a);
        return true;
      }

      var href = a.attr('href');

      if (li.is('.add-tab-button')) {
        a = this.handleAddButton();
        li = a.parent();
        href = a.attr('href');
        this.element.trigger('tab-added', [a]);
      }

      // close tab on middle click
      if (e.which === 2) {
        if (li.is('.dismissible') && $(e.target).is('.close')) {
          this.closeDismissibleTab(href);
        }
        e.preventDefault();
        return true;
      }

      if (!this.activate(href, a)) {
        return true;
      }
      this.changeHash(href);

      this.focusState.removeClass('is-visible');

      a.focus();

      if (this.isScrollableTabs()) {
        this.scrollTabList(li);
      }

      // Hide these states
      this.focusBar(li);
      this.positionFocusState(a);

      if (this.settings.lazyLoad === true && this.isURL(href)) {
        return false;
      }

      return true;
    },


    /**
     * Handler for click events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e Event
     * @returns {boolean|undefined} ?
     */
    handleMoreButtonClick: function handleMoreButtonClick(e) {
      if (this.element.is('.is-disabled') || this.moreButton.is('.is-disabled')) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }

      this.moreButton.data('focused-by-click', true);

      if (!this.hasMoreButton()) {
        e.stopPropagation();
      }
      if (this.moreButton.hasClass('popup-is-open')) {
        this.popupmenu.close();
        this.moreButton.removeClass('popup-is-open');
      } else {
        this.buildPopupMenu();
      }

      this.hideFocusState();
      return true;
    },


    /**
     * Handler for click events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e Event
     * @param {jQuery[]} a represents an anchor tag
     * @returns {boolean|undefined} ?
     */
    handleTabFocus: function handleTabFocus(e, a) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      var li = a.parent();
      var dataFocusedClick = a.data('focused-by-click');
      var focusedByKeyboard = dataFocusedClick === undefined || dataFocusedClick && dataFocusedClick === false;

      $.removeData(a[0], 'focused-by-click');

      if (this.isTabOverflowed(li)) {
        this.buildPopupMenu(a.attr('href'));
        this.moreButton.addClass('is-focused');
        this.positionFocusState(this.moreButton);
      } else {
        li.addClass('is-focused');
        this.positionFocusState(a, focusedByKeyboard);
      }

      return true;
    },


    /**
     * Handler for focus events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e incoming focus event
     * @returns {void}
     */
    handleMoreButtonFocus: function handleMoreButtonFocus(e) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return;
      }

      var dataFocusedClick = this.moreButton.data('focused-by-click');
      var focusedByKeyboard = dataFocusedClick && dataFocusedClick === false;

      $.removeData(this.moreButton[0], 'focused-by-click');

      this.focusState.removeClass('is-visible');
      this.positionFocusState(this.moreButton, focusedByKeyboard);
    },


    /**
     * Handler for keydown events on Tabs in the list
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {boolean|undefined} ?
     */
    handleTabKeyDown: function handleTabKeyDown(e) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      if (e.shiftKey || e.ctrlKey || e.metaKey || e.altKey && e.which !== 8) {
        return true;
      }

      var self = this;
      var passableKeys = [8, 13, 32];

      function isPassableKey() {
        return $.inArray(e.which, passableKeys) > -1;
      }

      if (e.which < 32 && !isPassableKey() || e.which > 46) {
        return true;
      }

      if (isPassableKey()) {
        var appMenuResult = this.handleAppMenuTabKeydown(e);
        if (!appMenuResult) {
          return true;
        }
      }

      function openMenu(oldHref) {
        e.preventDefault();
        // setTimeout is used to bypass triggering of the keyboard when
        // self.buildPopupMenu() is invoked.
        setTimeout(function () {
          self.buildPopupMenu(oldHref);
        }, 0);
      }

      var allExcludes = ':not(.separator):not(.is-disabled):not(:hidden)';
      var currentLi = $(e.currentTarget).parent();
      var currentA = currentLi.children('a');
      var targetLi = void 0;
      var tabs = self.tablist.children('li' + allExcludes);
      var isRTL = Locale.isRTL();

      function previousTab() {
        var i = tabs.index(currentLi) - 1;
        while (i > -1 && !targetLi) {
          if (tabs.eq(i).is(allExcludes)) {
            return tabs.eq(i);
          }
          i -= 1;
        }

        if (self.settings.addTabButton) {
          return self.addTabButton;
        }

        var last = self.tablist.children('li' + allExcludes).last();

        if (self.hasMoreButton() && self.isScrollableTabs()) {
          openMenu(last.find('a').attr('href'));
        }

        return last;
      }

      function nextTab() {
        var i = tabs.index(currentLi) + 1;
        while (i < tabs.length && !targetLi) {
          if (tabs.eq(i).is(allExcludes)) {
            return tabs.eq(i);
          }
          i++;
        }

        var first = self.tablist.children('li' + allExcludes).first();

        if (self.hasMoreButton() && self.isScrollableTabs()) {
          openMenu(first.find('a').attr('href'));
          return first;
        }

        if (self.settings.addTabButton) {
          return self.addTabButton;
        }
        return first;
      }

      function checkAngularClick() {
        if (currentA.attr('ng-click') || currentA.attr('data-ng-click')) {
          // Needed to fire the "Click" event in Angular situations
          currentA.click();
        }
      }

      function activate() {
        if (currentLi.hasClass('has-popupmenu')) {
          currentLi.data('popupmenu').open();
          return;
        }

        var href = currentA.attr('href');

        if (currentLi.is('.add-tab-button')) {
          currentA = self.handleAddButton();
          currentLi = currentA.parent();
          href = currentA.attr('href');
          self.element.trigger('tab-added', [currentA]);
        }

        if (!self.activate(href)) {
          return;
        }

        self.changeHash(href);
        self.focusBar(currentLi);
        checkAngularClick();
        currentA[0].focus();
        self.hideFocusState();

        // In the event that the activated tab is a full link that should be followed,
        // the keystroke events need to manually activate the link change.  Clicks are handled
        // automatically by the browser.
        self.handleOutboundLink(href);
      }

      switch (e.which) {
        case 8:
          if (e.altKey && currentLi.is('.dismissible')) {
            e.preventDefault();
            self.closeDismissibleTab(currentA.attr('href'));
          }
          return true;
        case 13:
          // Enter
          activate();
          return false;
        case 32:
          // Spacebar
          activate();
          return false;
        case 38:
          targetLi = previousTab();
          e.preventDefault();
          break;
        case 37:
          targetLi = isRTL ? nextTab() : previousTab();
          e.preventDefault();
          break;
        case 40:
          targetLi = nextTab();
          e.preventDefault();
          break;
        case 39:
          targetLi = isRTL ? previousTab() : nextTab();
          e.preventDefault();
          break;
        default:
          break;
      }

      if (targetLi) {
        var isAddTabButton = targetLi.is('.add-tab-button');
        var focusStateTarget = isAddTabButton ? targetLi : targetLi.children('a');

        // Use the matching option in the popup menu if the target is hidden by overflow.
        if (this.isTabOverflowed(targetLi)) {
          return openMenu(targetLi.children('a').attr('href'));
        }

        if (!isAddTabButton) {
          focusStateTarget.focus();
        } else {
          self.addTabButton.focus();
        }

        if (this.isScrollableTabs()) {
          this.scrollTabList(focusStateTarget);
        }

        self.positionFocusState(focusStateTarget, true);
      }

      return true;
    },


    /**
     * Handler for keydown events on Dismissible tabs
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {void}
     */
    handleDismissibleTabKeydown: function handleDismissibleTabKeydown(e) {
      var key = e.which;
      var tab = $(e.target);

      if (tab.is('a')) {
        tab = tab.parent();
      }

      if (e.altKey && key === 46) {
        // Alt + Del
        if (tab.children('a').is('[disabled]') || tab.hasClass('is-disabled')) {
          return;
        }

        e.preventDefault();
        this.closeDismissibleTab(tab.children('a').attr('href'));
      }
    },


    /**
     * Handler for keydown events on the "App Menu" tab (trigger button for the App Menu)
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {boolean} ?
     */
    handleAppMenuTabKeydown: function handleAppMenuTabKeydown(e) {
      var target = $(e.target);
      var li = target.parent();

      if (!(li.is('.application-menu-trigger') || target.is('.application-menu-trigger'))) {
        return true;
      }

      // If the tab is an application-menu trigger, open the app menu
      // Used by Module Tabs
      var menu = $('#application-menu');
      if (!menu.length) {
        return false;
      }

      e.preventDefault();

      this.hideFocusState();

      if (menu.hasClass('is-open')) {
        menu.trigger('close-applicationmenu');
        return false;
      }

      menu.trigger('open-applicationmenu');
      return false;
    },


    /**
     * Handler for keydown events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {boolean|undefined} ?
     */
    handleMoreButtonKeydown: function handleMoreButtonKeydown(e) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      var self = this;
      var isRTL = Locale.isRTL();

      function openMenu() {
        e.preventDefault();
        self.buildPopupMenu(self.tablist.find('.is-selected').children('a').attr('href'));
        self.positionFocusState(self.moreButton, true);
      }

      function lastTab() {
        e.preventDefault();
        self.findLastVisibleTab();
      }

      switch (e.which) {
        case 37:
          // left
          if (isRTL) {
            openMenu();
            break;
          }
          lastTab();
          break;
        case 38:
          // up
          lastTab();
          break;
        case 13: // enter
        case 32:
          // spacebar
          e.preventDefault();
          break;
        case 39:
          // right
          if (isRTL) {
            lastTab();
            break;
          }
          openMenu();
          break;
        case 40:
          // down
          openMenu();
          break;
        default:
          break;
      }

      return true;
    },


    /**
     * Handler for keydown events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {void}
     */
    handlePanelKeydown: function handlePanelKeydown(e) {
      var key = e.which;
      var panel = $(e.target);
      var a = this.anchors.filter('#' + panel.attr('id'));
      var tab = this.anchors.filter('#' + panel.attr('id')).parent();

      if (tab.is('.dismissible')) {
        // Close a Dismissible Tab
        if (e.altKey && key === 46) {
          // Alt + Delete
          e.preventDefault();
          return this.closeDismissibleTab(a.attr('href'));
        }
      }

      // Takes focus away from elements inside a Tab Panel and brings focus to its corresponding Tab
      if (e.ctrlKey && key === 38 && $.contains(document.activeElement, panel[0])) {
        // Ctrl + Up Arrow
        e.preventDefault();
        return this.activate(a.attr('href'), a);
      }

      return undefined;
    },


    /**
     * Handles the Add Tab button being clicked
     * @private
     * @returns {boolean|undefined} ?
     */
    handleAddButton: function handleAddButton() {
      var cb = this.settings.addTabButtonCallback;
      if (cb && typeof cb === 'function') {
        var newTabId = cb();
        return this.anchors.filter('[href="#' + newTabId + '"]');
      }

      function makeId() {
        var stringName = 'new-tab';
        var existing = $('[id^="' + stringName + '"]');

        if (!existing.length) {
          return stringName + '-0';
        }
        return stringName + '-' + existing.length;
      }

      function makeName(id) {
        var nameParts = id.toString().split('-');
        nameParts.forEach(function (val, i) {
          nameParts[i] = val.charAt(0).toUpperCase() + val.slice(1);
        });

        return nameParts.join(' ');
      }

      var newIndex = this.tablist.children().index(this.addTabButton);
      var newId = makeId();
      var newName = makeName(newId);
      var settings = {
        name: newName,
        content: '&nbsp;',
        isDismissible: true
      };

      if (newIndex < 0) {
        newIndex = this.tablist.find('li:not(.separator)').length;
      }

      // Allow the opportunity to pass in external settings for the new tab control
      var externalSettings = this.element.triggerHandler('before-tab-added', [newId, settings, newIndex]);
      if (!externalSettings) {
        this.add(newId, settings, newIndex);
        return this.anchors.filter('[href="#' + newId + '"]');
      }

      if (externalSettings.newId && externalSettings.newId.length && typeof externalSettings.newId === 'string') {
        newId = externalSettings.newId;
      }
      if (externalSettings.settings && _typeof(externalSettings.settings) === 'object') {
        settings = externalSettings.settings;
      }
      if (!isNaN(externalSettings.newIndex)) {
        newIndex = externalSettings.newIndex;
      }

      this.add(newId, settings, newIndex);
      return this.anchors.filter('[href="#' + newId + '"]');
    },


    /**
     * @private
     * @param {jQuery.Event} e incoming keydown event
     * @returns {undefined|boolean} ?
     */
    handleAddButtonKeydown: function handleAddButtonKeydown(e) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      var validKeys = [13, 32, 37, 38, 39, 40];
      var key = e.which;

      if (validKeys.indexOf(key) < 0) {
        return false;
      }

      var self = this;
      var isRTL = Locale.isRTL();
      var targetLi = void 0;
      var filter = 'li:not(.separator):not(.is-disabled):not(:hidden)';

      function openMenu() {
        e.preventDefault();
        targetLi = self.tablist.find(filter).last();

        if (self.isTabOverflowed(targetLi)) {
          // Open the spillover
          self.buildPopupMenu(targetLi.children('a').attr('href'));
          self.positionFocusState(self.moreButton, true);
        }
      }

      function firstTab() {
        targetLi = self.tablist.find(filter).first();
      }

      switch (key) {
        case 37:
          // left
          if (isRTL) {
            firstTab();
            break;
          }
          openMenu();
          break;
        case 38:
          // up
          openMenu();
          break;
        case 13: // enter
        case 32:
          // spacebar
          e.preventDefault();
          return this.handleAddButton();
        case 39:
          // right
          if (isRTL) {
            openMenu();
            break;
          }
          firstTab();
          break;
        case 40:
          // down
          firstTab();
          break;
        default:
          break;
      }

      targetLi.children('a').focus();
      return true;
    },


    /**
     * @private
     * @returns {void}
     */
    handleAddButtonFocus: function handleAddButtonFocus() {
      var tabs = this.tablist.find('li:not(.separator)');
      tabs.add(this.moreButton).removeClass('is-focused');

      this.addTabButton.addClass('is-focused');
      this.positionFocusState(this.addTabButton, true);
    },


    /**
     * @private
     * @param {boolean} ignoreResponsiveCheck if true, doesn't run `this.checkResponsive()`
     * @returns {void}
     */
    handleResize: function handleResize(ignoreResponsiveCheck) {
      if (!ignoreResponsiveCheck) {
        this.checkResponsive(true);
      }

      this.setOverflow();

      var selected = this.tablist.find('.is-selected');
      if (!selected.length || this.moreButton.is('.is-selected') || this.isTabOverflowed(selected)) {
        selected = this.moreButton;
      }

      if (!selected.length) {
        this.defocusBar();
        this.hideFocusState();
      } else {
        this.focusBar(selected);
        this.positionFocusState(selected);
      }

      this.handleVerticalTabResize();
      this.renderVisiblePanel();
      this.renderEdgeFading();
    },


    /**
     * Checks the window size to determine if a responsive-mode switch is needed.
     * @private
     * @returns {void}
     * @param  {boolean} handleRebuild Do a rebuild after handling.
     */
    checkResponsive: function checkResponsive(handleRebuild) {
      var self = this;
      var classList = self.element[0].classList;

      function rebuild() {
        self.removeHelperMarkupEvents();
        self.renderHelperMarkup();
        self.setupHelperMarkupEvents();
      }

      function makeResponsive() {
        if (!classList.contains('is-in-responsive-mode')) {
          classList.add('is-in-responsive-mode');
          classList.add('header-tabs');
          classList.add('alternate');
          classList.remove('vertical');
          if (handleRebuild) {
            rebuild();
          }
        }
      }

      function makeVertical() {
        if (classList.contains('is-in-responsive-mode')) {
          classList.add('vertical');
          classList.remove('is-in-responsive-mode');
          classList.remove('header-tabs');
          classList.remove('alternate');
          if (handleRebuild) {
            rebuild();
          }
        }
      }

      // Check for responsive mode for Vertical tabs
      if (this.isResponsiveVerticalTabs()) {
        if (breakpoints.isBelow('phone-to-tablet')) {
          makeResponsive();
        } else {
          makeVertical();
        }
      } else {
        makeVertical();
      }
    },


    /**
     * Causes a vertical tabs container to stretch to the height of its parent container
     * @private
     * @returns {void}
     */
    handleVerticalTabResize: function handleVerticalTabResize() {
      if (!this.isVerticalTabs()) {
        return;
      }

      // When tabs are full-size (part of a layout) CSS rules should handle this better
      // due to less strange sizing constraints.  JS resizing is necessary for nesting.
      if (!this.isNested() || this.isNestedInLayoutTabs() || this.isHidden()) {
        return;
      }

      var elemStyle = window.getComputedStyle(this.element[0]);
      var elemOuterHeight = elemStyle.getPropertyValue('height') + elemStyle.getPropertyValue('margin-top') + elemStyle.getPropertyValue('margin-bottom');

      this.tablist[0].style.height = elemOuterHeight;
    },


    /**
     * Changes the location in the browser address bar to force outbound links.
     * @param {string} href incoming href link
     * @param {boolean} useRelativePath don't prepend the full domain, port,
     * protocol, etc. to the HREF.
     * @returns {void}
     */
    handleOutboundLink: function handleOutboundLink(href, useRelativePath) {
      if (href.charAt(0) === '#') {
        return;
      }

      if (href.charAt(0) === '/' && (!useRelativePath || useRelativePath === false)) {
        href = window.location.origin + href;
      }

      window.location = href;
    },


    /**
     * Determines whether or not this tabset's tab list should display an animated selected state on a tab.
     * @returns {boolean} whether or not the animated selected state should display.
     */
    hasAnimatedBar: function hasAnimatedBar() {
      return !this.isModuleTabs() && !this.isVerticalTabs();
    },


    /**
     * Determines whether or not this tabset currently has a "More Tabs" spillover button.
     * @returns {boolean} whether or not the "More Tabs" button is currently displayed.
     */
    hasMoreButton: function hasMoreButton() {
      return this.element[0].classList.contains('has-more-button');
    },


    /**
     * Determines whether or not this normally "vertical" tabset is in an optional "horizontal" responsive mode
     * @returns {boolean} whether or not the responsive mode is active.
     */
    isInResponsiveMode: function isInResponsiveMode() {
      return this.element[0].classList.contains('is-in-responsive-mode');
    },


    /**
     * Determines whether or not this tabset is currently operating as Module Tabs
     * @returns {boolean} whether or not this is a Module tabset.
     */
    isModuleTabs: function isModuleTabs() {
      return this.element.hasClass('module-tabs');
    },


    /**
     * Determines whether or not this tabset is currently operating as Vertical Tabs
     * @returns {boolean} whether or not this is a Vertical tabset.
     */
    isVerticalTabs: function isVerticalTabs() {
      return this.element.hasClass('vertical');
    },


    /**
     * Determines whether or not this tabset is Vertical Tabs with a responsive, horizontal capability
     * @returns {boolean} whether or not this is a Vertical tabset.
     */
    isResponsiveVerticalTabs: function isResponsiveVerticalTabs() {
      return this.settings.verticalResponsive === true;
    },


    /**
     * Determines whether or not this tabset is currently operating as Header Tabs
     * @returns {boolean} whether or not this is a Header tabset.
     */
    isHeaderTabs: function isHeaderTabs() {
      return this.element.hasClass('header-tabs');
    },


    /**
     * Determines whether or not this tabset is showing tabs that allow for selection via horizontal scrolling.
     * @returns {boolean} whether or not horizontal scrolling is possible.
     */
    isScrollableTabs: function isScrollableTabs() {
      return !this.isModuleTabs() && !this.isVerticalTabs();
    },


    /**
     * Determines whether or not this tabset is currently hidden
     * @returns {boolean} whether or not this tabset is hidden.
     */
    isHidden: function isHidden() {
      return this.element.is(':hidden');
    },


    /**
     * Determines whether or not this tabset is nested inside a parent Tab Panel
     * @returns {boolean} whether or not this tabset is nested.
     */
    isNested: function isNested() {
      return this.element.closest('.tab-panel').length;
    },


    /**
     * Determines whether or not a particular tab panel is currently the active (displayed) tab panel
     * @param {string} href representing the HTML "id" attribute of a corresponding tab panel
     * @returns {boolean} whether or not the tab panel is active.
     */
    isActive: function isActive(href) {
      if (!href || !href.length || href.length === 1 && href.indexOf('#') < 1) {
        return false;
      }

      var panel = this.getPanel(href);
      return panel[0].classList.contains('can-show');
    },


    /**
     * Determines whether or not this tabset is nested inside a "Layout"-style of Tab container
     * @returns {boolean} whether or not this tabset is nested.
     */
    isNestedInLayoutTabs: function isNestedInLayoutTabs() {
      var nestedInModuleTabs = this.element.closest('.module-tabs').length;
      var nestedInHeaderTabs = this.element.closest('.header-tabs').length;
      var hasTabContainerClass = this.element.closest('.tab-panel-container').length;

      return nestedInModuleTabs > 0 || nestedInHeaderTabs > 0 || hasTabContainerClass > 0;
    },


    /**
     * Determines if an object is an HTML List Item representing a tab
     * @param {object} obj incoming object
     * @returns {boolean} whether or not the item is a tab
     */
    isTab: function isTab(obj) {
      return obj instanceof jQuery && obj.length && obj.is('li.tab');
    },


    /**
     * Determines if an object is an HTML Anchor Tag representing a tab's actionable element
     * @param {object} obj incoming object
     * @returns {boolean} whether or not the item is an anchor tag
     */
    isAnchor: function isAnchor(obj) {
      return obj instanceof jQuery && obj.length && obj.is('a');
    },


    /**
     * Gets a reference to an Anchor tag.
     * @param {string|jQuery} href either a string that can be used as a Tab ID, or an actual jQuery wrapped Anchor Tag.
     * @returns {jQuery} the Anchor tag
     */
    getAnchor: function getAnchor(href) {
      if (this.isAnchor(href)) {
        return href;
      }

      if (href.indexOf('#') === -1 && href.charAt(0) !== '/') {
        href = '#' + href;
      }

      return this.anchors.filter('[href="' + href + '"]');
    },


    /**
     * Gets a reference to a Tab panel.
     * @param {string|jQuery} href either a string that can be used as a Tab ID, or an actual jQuery wrapped Anchor Tag.
     * @returns {jQuery} the Anchor tag
     */
    getPanel: function getPanel(href) {
      if (this.isTab(href)) {
        href = href.children('a');
      }

      if (this.isAnchor(href)) {
        href = href.attr('href');
      }

      if (!href || href === '' || href === '#') {
        return $();
      }

      // uses angular LocationStrategy
      if (href.substr(0, 2) === '#/') {
        href = href.replace('#/', '#');
      }
      return this.panels.filter('[id="' + href.replace(/#/g, '') + '"]');
    },
    getMenuItem: function getMenuItem(href) {
      if (this.isAnchor(href)) {
        href = href.attr('href');
      }

      if (href.indexOf('#') === -1) {
        href = '#' + href;
      }
      return this.moreMenu.children().children().filter('[data-href="' + href + '"]').parent();
    },


    /**
     * Takes a tab ID and returns a jquery object containing the previous available tab
     * @param {string} tabId the tab ID
     * @returns {jQuery[]} jQuery-wrapped element reference for the tab
     */
    getPreviousTab: function getPreviousTab(tabId) {
      var tab = this.getTab(null, tabId);
      var filter = 'li:not(.separator):not(:hidden):not(.is-disabled)';
      var tabs = this.tablist.find(filter);
      var idx = tabs.index(tab);
      var target = tabs.eq(idx === 0 ? 1 : idx - 1);

      while (target.length && !target.is(filter)) {
        target = tabs.eq(tabs.index(target) - 1);
      }

      // Top-level Dropdown Tabs don't have an actual panel associated with them.
      // Get a Dropdown Tab's first child as the target.
      if (target.is('.has-popupmenu')) {
        var menuAPI = target.data('popupmenu');
        if (menuAPI) {
          target = menuAPI.menu.children('li').first();
        }
      }

      return target;
    },


    /**
     * Takes a tab ID and activates an adjacent available tab
     * @param {object} e event object
     * @param {string} tabId the tab ID
     */
    activateAdjacentTab: function activateAdjacentTab(e, tabId) {
      var tab = this.doGetTab(e, tabId);

      if (typeof e === 'string') {
        tabId = e;
      }

      if (tab.is('.is-selected')) {
        if (tab.prevAll('li.tab').not('.hidden').not('.is-disabled').length > 0) {
          this.select($(tab.prevAll('li.tab').not('.hidden').not('.is-disabled')[0]).find('a')[0].hash);
        } else if (tab.nextAll('li.tab').not('.hidden').length > 0) {
          this.select($(tab.nextAll('li.tab').not('.hidden').not('.is-disabled')[0]).find('a')[0].hash);
        }
      } else {
        this.select($(this.element.find('li.tab.is-selected')[0]).find('a')[0].hash);
      }
    },


    /**
     * Takes a tab ID and returns a jquery object containing the previous available tab
     * If an optional target Tab (li) is provided, use this to perform activation events
     * @param {string} tabId the tab ID
     * @param {jQuery[]} [target] a reference to the previous tab in the list (before this one)
     * @returns {jQuery[]} potentially-updated target
     */
    activatePreviousTab: function activatePreviousTab(tabId, target) {
      var tab = this.getTab(null, tabId);

      if (!target || !(target instanceof jQuery)) {
        target = this.getPreviousTab(tabId);
      }

      if (!target.length) {
        this.hideFocusState();
        this.defocusBar();
        return target;
      }

      var a = target.children('a');
      if (tab.is('.is-selected')) {
        if (!this.activate(a.attr('href'), a)) {
          return target;
        }
        a.focus();
      }
      this.positionFocusState(a);
      this.focusBar(target);

      return target;
    },


    /**
     * Determines whether or not a string has an outbound URL, instead of a hash (#) that would match up to a Tab ID.
     * @param {string} href a string that may or may not contain a URL
     * @returns {boolean} whether or not the incoming string is a URL
     */
    isURL: function isURL(href) {
      if (!href || href.indexOf('#') === 0) {
        return false;
      }

      return true;
    },


    /**
     * Causes a new tab panel to become active.  Will also trigger AJAX calls on unloaded tab panels, if necessary.
     * @param {string} href a string that either matches up to a Tab ID, or an outbound link to grab AJAX content from.
     * @param {object} anchor in addition to the ref the anchor object may be passed to avoid extra querying.
     * @returns {void}
     */
    activate: function activate(href, anchor) {
      var self = this;

      if (self.isURL(href)) {
        return this.callSource(href, anchor, true);
      }

      var a = self.getAnchor(href);
      var targetTab = a.parent();
      var targetPanel = self.getPanel(href);
      var targetPanelElem = targetPanel[0];
      var oldTab = self.anchors.parents().filter('.is-selected');
      var oldPanel = void 0;
      var selectedStateTarget = void 0;
      var activeStateTarget = void 0;

      // Avoid filter(:visible)
      for (var i = 0; i < self.panels.length; i++) {
        if (self.panels[i].classList.contains('is-visible')) {
          oldPanel = $(self.panels[i]);
        }
      }

      if (!oldPanel) {
        oldPanel = self.panels;
      }

      // NOTE: Breaking Change as of 4.3.3 - `beforeactivate` to `beforeactivated`
      // See SOHO-5994 for more details
      /**
       * Fires when an attempt at activating a tab is started
       *
       * @event beforeactivated
       * @memberof Tabs
       * @param {jQuery.Event} e event object
       * @param {jQuery} a the tab anchor attempting to activate
       */
      var isCancelled = self.element.trigger('beforeactivated', [a]);
      if (!isCancelled) {
        return false;
      }

      function completeActivate(vetoResult) {
        if (targetPanel.length < 1) {
          if (self.settings.source) {
            self.callSource(href, a);
            return true;
          }
        } else {
          oldPanel[0].classList.remove('can-show');
          oldPanel[0].classList.remove('is-visible');
          oldPanel.closeChildren();

          /**
           * Fires when a new tab has been activated
           *
           * @event activated
           * @memberof Tabs
           * @param {jQuery.Event} e event object
           * @param {jQuery} a the tab anchor attempting to activate
           */
          self.element.trigger('activated', [a]);

          targetPanelElem.classList.add('can-show');
          self.renderVisiblePanel();
          // trigger reflow as display property is none for animation
          // eslint-disable-next-line
          targetPanelElem.offsetHeight;

          // Register an `afteractivated` event trigger as a renderLoop callback
          var timer = new RenderLoopItem({
            duration: math.convertDelayToFPS(150),
            timeoutCallback: function timeoutCallback() {
              /**
               * Fires when a new tab has been completely activated, and the activation process is done
               *
               * @event afteractivated
               * @memberof Tabs
               * @param {jQuery.Event} e event object
               * @param {jQuery} a the tab anchor attempting to activate
               */
              self.element.trigger('afteractivated', [a]);
            }
          });
          renderLoop.register(timer);

          // Triggers the CSS Animation
          targetPanelElem.classList.add('is-visible');
        }

        // Update the currently-selected tab
        self.updateAria(a);
        oldTab.add(self.moreButton).removeClass('is-selected');
        if (targetTab[0]) {
          if (targetTab[0].classList.contains('tab')) {
            selectedStateTarget = targetTab;
            activeStateTarget = targetTab;
          }
        }

        var ddMenu = targetTab.parents('.popupmenu');
        var ddTab = void 0;

        if (ddMenu.length) {
          ddTab = ddMenu.data('trigger');
          if (ddTab.length) {
            selectedStateTarget = ddTab;
            activeStateTarget = ddTab;
          }
        }

        if (self.isTabOverflowed(activeStateTarget)) {
          activeStateTarget = self.moreButton;
          selectedStateTarget = self.moreButton;
        }
        self.focusBar(activeStateTarget);

        if (selectedStateTarget) {
          selectedStateTarget.addClass('is-selected');
        }

        // Fires a resize on any invoked child toolbars inside the tab panel.
        // Needed to fix issues with Toolbar alignment, since we can't properly detect
        // size on hidden elements.
        var childToolbars = targetPanel.find('.toolbar');
        if (childToolbars.length) {
          childToolbars.each(function () {
            var api = $(this).data('toolbar');
            if (api && typeof api.handleResize === 'function') {
              api.handleResize();
            }
          });
        }

        // Automatically refresh all icons inside Tab panels on activation.
        // See SOHO-7313
        utils.fixSVGIcons(targetPanel[0]);

        return vetoResult || false;
      }

      // Handle an optional, veto-able "beforeActivate" callback.
      if (this.settings.beforeActivate && typeof this.settings.beforeActivate === 'function') {
        return this.settings.beforeActivate(oldTab, targetTab, completeActivate);
      }

      // Otherwise, simply continue
      return completeActivate(true);
    },


    /**
     * Shows/Hides some tabsets' faded edges based on scrolling position, if applicable.
     * @private
     * @returns {undefined}
     */
    renderEdgeFading: function renderEdgeFading() {
      if (!this.isScrollableTabs() || !this.tablistContainer) {
        return;
      }

      var isRTL = Locale.isRTL();
      var tablistContainerElem = this.tablistContainer[0];
      var scrollLeft = tablistContainerElem.scrollLeft;
      var scrollWidth = tablistContainerElem.scrollWidth;
      var containerWidth = parseInt(window.getComputedStyle(tablistContainerElem).getPropertyValue('width'), 10);

      if (isRTL) {
        this.element[0].classList[scrollLeft > 0 ? 'add' : 'remove']('scrolled-left');
        this.element[0].classList[scrollWidth - scrollLeft <= containerWidth ? 'remove' : 'add']('scrolled-right');
      } else {
        this.element[0].classList[scrollLeft > 0 ? 'add' : 'remove']('scrolled-right');
        this.element[0].classList[scrollWidth - scrollLeft <= containerWidth ? 'remove' : 'add']('scrolled-left');
      }
    },


    /**
     * Calls an options-provided source method to fetch content that will be displayed inside a tab.
     * @param {string} href - string representing the target tab to load content under.
     * @param {object} anchor - Reference to the dom object anchor tag.
     * @param {boolean} isURL detects whether or not the URL is actually an external /
     * call, or an ID for an existing tab in the page.
     * @returns {boolean|$.Deferred} true if source call was successful, false for failure/ignore,
     * or a promise object that will fire callbacks in either "success" or "failure" scenarios.
     */
    callSource: function callSource(href, anchor, isURL) {
      var _this3 = this;

      if ((isURL === undefined || isURL === null || isURL === false) && !this.settings.source) {
        return false;
      }
      if (this.settings.lazyLoad !== true) {
        return false;
      }

      var sourceType = _typeof(this.settings.source);
      var response = function response(htmlContent) {
        if (htmlContent === undefined || htmlContent === null) {
          return;
        }

        htmlContent = xssUtils.sanitizeHTML(htmlContent);

        // Get a new random tab ID for this tab if one can't be derived from the URL string
        if (isURL) {
          var containerId = _this3.element[0].id || '';
          var id = utils.uniqueId(anchor, 'tab', containerId);

          href = '#' + id;
          // Replace the original URL on this anchor now that we've loaded content.
          anchor[0].setAttribute('href', href);
        }

        _this3.createTabPanel(href, htmlContent, true);
        _this3.activate(href);

        _this3.element.triggerHandler('complete'); // For Busy Indicator
        _this3.element.trigger('requestend', [href, htmlContent]);
      };

      this.container.triggerHandler('start'); // For Busy Indicator
      this.container.trigger('requeststart');

      function handleStringSource(url, options) {
        var opts = $.extend({ dataType: 'html' }, options, {
          url: url
        });

        var request = $.ajax(opts);
        request.done(response);
        return request;
      }

      if (isURL) {
        return handleStringSource(href, this.ajaxOptions);
      }

      // return _true_ from this source function on if we're just loading straight content
      // return a promise if you'd like to setup async handling.
      if (sourceType === 'function') {
        return this.settings.source(response, href, this.settings.sourceArguments);
      }

      if (sourceType === 'string') {
        // Attempt to resolve source as a URL string.  Make an $.ajax() call with the URL
        var safeHref = href.replace(/#/g, '');
        var sourceURL = this.settings.source.toString();
        var hasHref = sourceURL.indexOf(safeHref) > -1;

        if (!hasHref) {
          var param = 'tab=' + safeHref;
          var paramIndex = sourceURL.indexOf('?');
          var hashIndex = sourceURL.indexOf('#');
          var insertIndex = sourceURL.length;

          if (paramIndex < 0) {
            param = '?' + param;
            if (hashIndex > -1) {
              insertIndex = hashIndex + 1;
            }
          } else {
            param += '&';
            insertIndex = paramIndex + 1;
          }

          sourceURL = stringUtils.splice(sourceURL, insertIndex, 0, param);
        }

        return handleStringSource(sourceURL, this.ajaxOptions);
      }

      return false;
    },


    /**
     * @private
     */
    renderVisiblePanel: function renderVisiblePanel() {
      // Recalculate all components inside of the visible tab to adjust
      // widths/heights/display if necessary
      this.resizeNestedTabs();
      // TJM: Prioritizing performance fix.
      // this.panels.filter(':visible').handleResize();
    },


    /**
     *
     * Update the hash in the link.
     * @private
     * @param  {HTMLElement} href The Dom Element.
     * @returns {void}
     */
    changeHash: function changeHash(href) {
      if (!this.settings.changeTabOnHashChange) {
        return;
      }

      if (!href) {
        href = '';
      }

      href.replace(/#/g, '');

      var cb = this.settings.hashChangeCallback;
      if (cb && typeof cb === 'function') {
        cb(href);
      } else {
        window.location.hash = href;
      }

      /**
       * @event hash-change
       * @memberof Tabs
       * @param {jQuery.Event} e the jQuery event object
       * @param {string} href the new hash fragment for the URL
       */
      this.element.triggerHandler('hash-change', [href]);
    },


    /**
     * Updates the aria-related markup on all tab elements
     * @private
     * @param {jQuery} a the 'selected' tab anchor
     */
    updateAria: function updateAria(a) {
      if (!a) {
        return;
      }
      // hide old tabs
      this.anchors.attr({
        'aria-selected': 'false',
        'aria-expanded': 'false',
        tabindex: '-1'
      });
      this.moreButton.attr({
        tabindex: '-1'
      });

      // show current tab
      if (a.length && this.element.is(':not(.is-disabled)')) {
        a.parent().removeClass('is-selected');
        if (!this.isTabOverflowed(a.parent())) {
          a.attr({
            'aria-selected': 'true',
            'aria-expanded': 'true',
            tabindex: '0'
          }).parent().addClass('is-selected');
        } else {
          this.moreButton.attr({
            tabindex: '0'
          });
        }
      }
    },


    /**
     * Causes `handleResize()` to be fired on any Tab components that are nested inside of this tab component's panels.
     * @returns {void}
     */
    resizeNestedTabs: function resizeNestedTabs() {
      this.nestedTabControls.each(function (i, container) {
        var c = $(container);
        var api = c.data('tabs');

        if (api && api.handleResize && typeof api.handleResize === 'function') {
          api.handleResize(true);
        }
      });
    },


    /**
     * Adds a new tab into the list and properly binds all of its events
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @param {object} options incoming options for the new tab.
     * @param {string} [options.name] the text title of the new tab.
     * @param {boolean} [options.doActivate=false] if true, causes the newly-added tab to become activated and focused.
     * @param {boolean} [options.isDismissible=false] if true, causes the tab to become dismissible (closable) with an "X" button.
     * @param {boolean} [options.isDropdown=false] if true, causes the tab to become a dropdown tab.
     * @param {string} [options.content] representing HTML markup that will be added inside of the new tab panel.
     * @param {number} [atIndex] if defined, inserts the tab at a particular number index in the tab list.  Defaults to the last tab in the list.
     * @returns {this} component instance
     */
    add: function add(tabId, options, atIndex) {
      if (!tabId) {
        return this;
      }

      if (!options) {
        options = {};
      }

      var startFromZero = this.tablist.find('li').not('.application-menu-trigger, .add-tab-button').length === 0;

      // Sanitize
      tabId = '' + tabId.replace(/#/g, '');
      options.name = options.name ? options.name.toString() : '&nbsp;';
      options.isDismissible = options.isDismissible ? options.isDismissible === true : false;
      options.isDropdown = options.isDropdown ? options.isDropdown === true : false;

      function getObjectFromSelector(sourceString) {
        var contentType = typeof sourceString === 'undefined' ? 'undefined' : _typeof(sourceString);
        var hasId = void 0;

        switch (contentType) {
          case 'string':
            hasId = sourceString.match(/#/g);
            // Text Content or a Selector.
            if (hasId !== null) {
              var obj = $(sourceString);
              sourceString = obj.length ? obj : sourceString;
            }
            // do nothing if it's just a string of text.
            break;
          default:
            break;
        }
        return sourceString;
      }

      if (options.content) {
        options.content = getObjectFromSelector(options.content);
      }
      if (options.dropdown) {
        options.dropdown = getObjectFromSelector(options.dropdown);
      }

      // Build
      var tabHeaderMarkup = $('<li role="presentation" class="tab"></li>');
      var anchorMarkup = $('<a href="#' + tabId + '" role="tab" aria-expanded="false" aria-selected="false" tabindex="-1">' + xssUtils.escapeHTML(options.name) + '</a>');
      var tabContentMarkup = this.createTabPanel(tabId, options.content);

      tabHeaderMarkup.html(anchorMarkup);

      if (options.isDismissible) {
        tabHeaderMarkup.addClass('dismissible');
        tabHeaderMarkup.append($.createIconElement({ icon: 'close', classes: 'close icon' }));
      }

      if (this.settings.tabCounts) {
        anchorMarkup.prepend('<span class="count">0 </span>');
      }

      if (options.dropdown) ;

      function insertIntoTabset(self, targetIndex) {
        var method = void 0;
        var tabs = self.tablist.children('li');
        var nonSpecialTabs = tabs.not('.application-menu-trigger, .add-tab-button');
        var finalIndex = tabs.length - 1;

        if (!tabs.length) {
          tabHeaderMarkup.appendTo(self.tablist);
          tabContentMarkup.appendTo(self.container);
          return;
        }

        var addTabButton = tabs.filter('.add-tab-button');
        var appMenuTrigger = tabs.filter('.application-menu-trigger');

        // NOTE: Cannot simply do !targetIndex here because zero is a valid index
        if (targetIndex === undefined || targetIndex === null || isNaN(targetIndex)) {
          targetIndex = tabs.length;
        }

        function pastEndOfTabset(index) {
          return index > tabs.length - 1;
        }

        function atBeginningOfTabset(index) {
          return index <= 0;
        }

        if (tabs.length > nonSpecialTabs.length) {
          if (pastEndOfTabset(targetIndex) && addTabButton && addTabButton.length) {
            targetIndex -= 1;
          }

          if (atBeginningOfTabset(targetIndex) && appMenuTrigger && appMenuTrigger.length) {
            targetIndex += 1;
          }
        }

        var conditionInsertTabBefore = tabs.eq(targetIndex).length > 0;

        finalIndex = conditionInsertTabBefore ? targetIndex : finalIndex;

        method = 'insertAfter';
        if (conditionInsertTabBefore) {
          method = 'insertBefore';
        }

        tabHeaderMarkup[method](tabs.eq(finalIndex));
        tabContentMarkup.appendTo(self.container);
      }

      insertIntoTabset(this, atIndex);

      // Add each new part to their respective collections.
      this.panels = this.panels.add(tabContentMarkup);
      this.anchors = this.anchors.add(anchorMarkup);

      // Link the two items via data()
      anchorMarkup.data('panel-link', tabContentMarkup);
      tabContentMarkup.data('tab-link', anchorMarkup);
      // TODO: When Dropdown Tabs can be added/removed, add that here

      // Make it possible for Module Tabs to display a tooltip containing their contents
      // if the contents are cut off by ellipsis.
      if (this.settings.moduleTabsTooltips) {
        anchorMarkup.on('beforeshow.toolbar', function () {
          return anchorMarkup.data('cutoffTitle') === 'yes';
        }).tooltip({
          content: '' + anchorMarkup.text().trim()
        });
      }

      // Recalc tab width before detection of overflow
      if (this.isModuleTabs()) {
        this.adjustModuleTabs();
      }

      // Adjust tablist height
      this.setOverflow();

      // If started from zero, position the focus state/bar and activate the tab
      if (startFromZero) {
        this.positionFocusState(anchorMarkup);
        this.focusBar(tabHeaderMarkup);
        if (!this.activate(anchorMarkup.attr('href'))) {
          return this;
        }
        anchorMarkup.focus();
      }

      if (options.doActivate) {
        this.activate(anchorMarkup.attr('href'));
      }

      return this;
    },


    /**
     * Removes a tab from the list and cleans up properly
     * NOTE: Does not take advantage of _activatePreviousTab()_ due to specific needs
     * of selecting certain Tabs/Anchors at certain times.
     * @param {string} tabId tab ID that corresponds to a `.tab-panel` element's ID attribute
     * @param {boolean} disableBeforeClose whether or not tab closing can become veteoed
     * @returns {boolean|this} component instance
     */
    remove: function remove(tabId, disableBeforeClose) {
      var self = this;
      var targetLi = this.doGetTab(null, tabId);

      if (!targetLi || !targetLi.length) {
        return false;
      }

      var targetAnchor = targetLi.children('a');
      var targetPanel = this.getPanel(tabId);
      var hasTargetPanel = targetPanel && targetPanel.length;
      var targetLiIndex = this.tablist.children('li').index(targetLi);
      var notATab = '.application-menu-trigger, .separator, .is-disabled, :hidden';
      var prevLi = targetLi.prev();

      if (!disableBeforeClose) {
        var canClose = this.element.triggerHandler('beforeclose', [targetLi]);
        if (canClose === false) {
          return false;
        }
      }

      var wasSelected = false;
      if (targetLi.hasClass('is-selected')) {
        wasSelected = true;
      } else {
        prevLi = this.tablist.children('li').not(notATab).filter('.is-selected');
      }

      // Remove these from the collections
      if (hasTargetPanel) {
        this.panels = this.panels.not(targetPanel);
      }
      this.anchors = this.anchors.not(targetAnchor);

      // Destroy Anchor tooltips, if applicable
      if (this.settings.moduleTabsTooltips) {
        targetAnchor.off('beforeshow.toolbar').data('tooltip').destroy();
      }

      // Close Dropdown Tabs in a clean fashion
      var popupAPI = targetLi.data('popupmenu');
      if (targetLi.hasClass('has-popupmenu')) {
        if (popupAPI) {
          popupAPI.menu.children('li').each(function () {
            self.remove($(this).children('a').attr('href'));
          });
          popupAPI.destroy();
        }
      }

      // If this tab is inside of a Dropdown Tab's menu, detect if it was the last one
      // remaining, and if so, close the entire Dropdown Tab.
      // The actual check on these elements needs to be done AFTER the targetLi is removed
      // from a Dropdown Tab, to accurately check the number of list items remaining.
      // See: _isLastDropdownTabItem()_
      var parentMenu = targetLi.closest('.dropdown-tab');
      var trigger = parentMenu.data('trigger');

      // Kill associated events
      targetLi.off('click.tabs');
      targetAnchor.off('click.tabs focus.tabs keydown.tabs');

      // Remove Markup
      targetLi.remove();
      if (hasTargetPanel) {
        targetPanel.remove();
      }

      var menuItem = targetAnchor.data('moremenu-link');
      if (menuItem) {
        menuItem.parent().off().remove();
        $.removeData(targetAnchor[0], 'moremenu-link');
      }

      function isLastDropdownTabItem(menu) {
        return menu.length && menu.children('li:not(.separator)').length === 0;
      }
      if (isLastDropdownTabItem(parentMenu)) {
        prevLi = this.getPreviousTab(trigger);

        setTimeout(function () {
          self.remove(trigger);
        }, 1);
      }

      // Close dropdown tab's menu
      if (trigger && trigger.length) {
        trigger.data('popupmenu').close();
      }

      // Recalc tab width before detection of overflow
      if (this.isModuleTabs()) {
        this.adjustModuleTabs();
      }

      // Adjust tablist height
      this.setOverflow();

      /**
       * Fires when a tab is removed from the tabset
       *
       * @event close
       * @memberof Tabs
       * @param {jQuery.Event} e event object
       * @param {jQuery} targetLi the tab list item being closed
       */
      this.element.trigger('close', [targetLi]);

      // If any tabs are left in the list, set the first available tab as the currently selected one.
      var count = targetLiIndex - 1;
      while (count > -1) {
        count = -1;
        if (prevLi.is(notATab)) {
          prevLi = this.tablist.children('li').not(notATab)[0];
          count -= 1;
        }
      }

      // If we find nothing, search for ANY available tab
      if (!prevLi.length) {
        prevLi = this.tablist.children('li').not(notATab).first();
      }

      // If there's really nothing, kick on out and defocus everything.
      if (!prevLi.length) {
        this.hideFocusState();
        this.defocusBar();

        this.element.trigger('afterclose', [targetLi]);
        return this;
      }

      var a = prevLi.children('a');
      var activateTargetA = a;

      this.positionFocusState(a);

      if (wasSelected) {
        if (prevLi.is('.has-popupmenu') && prevLi.data('popupmenu')) {
          activateTargetA = prevLi.data('popupmenu').menu.children().first().children('a');
        }
        if (!this.activate(activateTargetA.attr('href'))) {
          return this;
        }
      }

      this.focusBar(prevLi);
      a.focus();

      /**
       * Fires after a tab is completely removed from the tabset, and the close process has completed.
       *
       * @event afterclose
       * @memberof Tabs
       * @param {jQuery.Event} e event object
       * @param {jQuery} targetLi the tab list item being closed
       */
      this.element.trigger('afterclose', [targetLi]);

      return this;
    },


    /**
     * Adds a new tab into the list and properly binds all of its events
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @param {string} [content] representing HTML markup that will be added inside of the new tab panel.
     * @param {boolean} [doInsert=false] if true, actually appends the new content to the tab panel.
     * @returns {this} component instance
     */
    createTabPanel: function createTabPanel(tabId, content, doInsert) {
      tabId = tabId.replace(/#/g, '');

      // If a jQuery-wrapped element is provided, actually append the element.
      // If content is text/string, simply inline it.
      var markup = $('<div id="' + xssUtils.stripTags(tabId) + '" class="tab-panel" role="tabpanel"></div>');
      if (content instanceof $) {
        content = content[0];
      }
      DOM.html(markup[0], content || '', '*');

      if (doInsert === true) {
        this.container.append(markup);
      }

      this.panels = this.panels.add(markup);

      return markup;
    },


    /**
     * @param {jQuery} tab the tab to be checked for popupmenu items.
     * @returns {jQuery[]} a list of avaiable popupmenu items
     */
    checkPopupMenuItems: function checkPopupMenuItems(tab) {
      function getRemainingMenuItems(popupAPI) {
        if (!popupAPI || !popupAPI.menu) {
          return $();
        }
        var menu = popupAPI.menu;
        var items = menu.children('li');

        if (!items.length) {
          popupAPI.destroy();
          return $();
        }
        return items;
      }

      if (tab.is('.has-popupmenu')) {
        return getRemainingMenuItems(tab.data('popupmenu'));
      }

      var ddTab = tab.closest('.dropdown-tab');
      if (!ddTab.length) {
        return $();
      }
      return getRemainingMenuItems(ddTab.data('popupmenu'));
    },


    // @private
    getTab: function getTab(e, tabId) {
      var self = this;
      var tab = $();

      function getTabFromEvent(ev) {
        var t = $(ev.currentTarget);
        if (t.is('.tab')) {
          return t;
        }
        if (t.closest('.tab').length) {
          return t.closest('.tab').first();
        }
        return null;
      }

      function getTabFromId(id) {
        if (!id || id === '' || id === '#') {
          return null;
        }

        if (id.indexOf('#') === -1) {
          id = '#' + id;
        }

        var anchor = self.anchors.filter('[href="' + id + '"]');
        if (!anchor.length) {
          return null;
        }

        return anchor.parent();
      }

      // TabId can also be a jQuery object containing a tab.
      if (tabId instanceof $ && tabId.length > 0) {
        if (tabId.is('a')) {
          return tabId.parent();
        }
        return tabId;
      }

      if (e) {
        return getTabFromEvent(e);
      } else if (tabId) {
        return getTabFromId(tabId);
      }

      return tab;
    },


    // @private
    doGetTab: function doGetTab(e, tabId) {
      if (!e && !tabId) {
        return $();
      }
      if (e && !(e instanceof $.Event) && typeof e !== 'string') {
        return $();
      }

      if (e) {
        if (typeof e !== 'string') {
          // jQuery Event
          return this.getTab(e);
        }
        return this.getTab(null, e); // String containing a selector
      }

      // Straight to the TabID
      return this.getTab(null, tabId);
    },


    /**
     * Hides a tab
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @returns {this} component instance
     */
    hide: function hide(e, tabId) {
      var tab = this.doGetTab(e, tabId);

      this.activateAdjacentTab(e, tabId);

      tab.addClass('hidden');
      this.focusBar();
      this.positionFocusState();
      return this;
    },


    /**
     * Shows a tab
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @returns {this} component instance
     */
    show: function show(e, tabId) {
      var tab = this.doGetTab(e, tabId);

      tab.removeClass('hidden');

      this.select($(this.element.find('li.tab.is-selected')[0]).find('a')[0].hash);

      this.focusBar();
      this.positionFocusState();
      return this;
    },


    /**
     * Disables an individual tab
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @returns {this} component instance
     */
    disableTab: function disableTab(e, tabId) {
      var tab = this.doGetTab(e, tabId);

      this.activateAdjacentTab(e, tabId);

      tab.addClass('is-disabled');
      this.focusBar();
      this.positionFocusState();
      return this;
    },


    /**
     * Enables an individual tab
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @returns {this} component instance
     */
    enableTab: function enableTab(e, tabId) {
      var tab = this.doGetTab(e, tabId);

      tab.removeClass('is-disabled');
      this.focusBar();
      this.positionFocusState();
      return this;
    },


    /**
     * Renames a tab and resets the focusable bar/animation.
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @param {string} name the new tab name
     * @returns {void}
     */
    rename: function rename(e, tabId, name) {
      // Backwards compatibility with 4.2.0
      if (e && typeof e === 'string') {
        name = tabId;
        tabId = e;
      }

      if (!name) {
        return;
      }

      var tab = this.doGetTab(e, tabId);
      var hasCounts = this.settings.tabCounts;
      var hasTooltip = this.settings.moduleTabsTooltips;
      var anchor = tab.children('a');
      var count = void 0;

      if (hasCounts) {
        count = anchor.find('.count').clone();
      }

      anchor.text(name.toString());

      if (hasCounts) {
        anchor.prepend(count);
      }

      if (hasTooltip) {
        anchor.data('tooltip').setContent(name.trim());
      }

      var doesTabExist = this.tablist.children('li').length < 2 ? tab : undefined;

      this.positionFocusState(doesTabExist);
      this.focusBar(doesTabExist);
    },


    /**
     * For tabs with counts, updates the count and resets the focusable bar/animation
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @param {number|string} count the new tab count
     * @returns {void}
     */
    updateCount: function updateCount(e, tabId, count) {
      // Backwards compatibility with 4.2.0
      if (e && typeof e === 'string') {
        count = tabId;
        tabId = e;
      }

      if (!this.settings.tabCounts || !count) {
        return;
      }

      var tab = this.doGetTab(e, tabId);

      tab.children('a').find('.count').text(count.toString() + ' ');

      var doesTabExist = this.tablist.children('li').length < 2 ? tab : undefined;

      this.positionFocusState(doesTabExist);
      this.focusBar(doesTabExist);
    },


    /**
     * returns the currently active tab
     * @returns {jQuery} the currently active tab anchor
     */
    getActiveTab: function getActiveTab() {
      var visible = this.panels.filter(':visible');
      return this.anchors.filter('[href="#' + visible.first().attr('id') + '"]');
    },


    /**
     * returns all visible tabs
     * @returns {jQuery[]} all visible tabs
     */
    getVisibleTabs: function getVisibleTabs() {
      var self = this;
      var tabHash = $();

      this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)').each(function tabOverflowIterator() {
        var tab = $(this);

        if (!self.isTabOverflowed(tab)) {
          tabHash = tabHash.add(tab);
        }
      });

      return tabHash;
    },


    /**
     * returns a list of all tabs that are currently in the "More..." overflow menu.
     * @returns {jQuery[]} all overflowed tabs
     */
    getOverflowTabs: function getOverflowTabs() {
      var self = this;
      var tabHash = $();

      this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)').each(function tabOverflowIterator() {
        var tab = $(this);

        if (self.isTabOverflowed(tab)) {
          tabHash = tabHash.add(tab);
        }
      });

      return tabHash;
    },


    /**
     * @private
     * @returns {void}
     */
    setOverflow: function setOverflow() {
      var self = this;
      var elem = this.element[0];
      var tablist = this.tablist[0];
      var HAS_MORE = 'has-more-button';
      var hasMoreIndex = this.hasMoreButton();
      var isScrollableTabs = this.isScrollableTabs();

      function checkModuleTabs() {
        if (self.isModuleTabs()) {
          self.adjustModuleTabs();
        }
      }

      // Recalc tab width before detection of overflow
      checkModuleTabs();

      var tablistStyle = void 0;
      var tablistHeight = void 0;
      var tablistContainerScrollWidth = void 0;
      var tablistContainerWidth = void 0;
      var overflowCondition = void 0;

      if (isScrollableTabs) {
        tablistContainerScrollWidth = this.tablistContainer[0].scrollWidth;
        tablistContainerWidth = this.tablistContainer[0].offsetWidth;
        overflowCondition = tablistContainerScrollWidth > tablistContainerWidth;
      } else {
        tablistStyle = window.getComputedStyle(tablist, null);
        tablistHeight = parseInt(tablistStyle.getPropertyValue('height'), 10) + 1; // +1 to fix an IE bug
        overflowCondition = tablist.scrollHeight > tablistHeight; // Normal tabs check the height
      }

      // Add "has-more-button" class if we need it, remove it if we don't
      // Always display the more button on Scrollable Tabs
      if (overflowCondition) {
        if (!hasMoreIndex) {
          elem.classList.add(HAS_MORE);
          checkModuleTabs();
        }
      } else if (hasMoreIndex) {
        elem.classList.remove(HAS_MORE);
        checkModuleTabs();
      }

      this.adjustSpilloverNumber();
    },


    /**
     * @private
     * @returns {void}
     */
    adjustModuleTabs: function adjustModuleTabs() {
      var self = this;
      var sizeableTabs = this.tablist.find('li:not(.separator):not(.application-menu-trigger):not(:hidden)');
      var appTrigger = this.tablist.find('.application-menu-trigger');
      var hasAppTrigger = appTrigger.length > 0;
      var tabContainerW = this.tablist.outerWidth();
      var defaultTabSize = 120;
      var visibleTabSize = 120;
      var appTriggerSize = hasAppTrigger ? appTrigger.outerWidth() : 0;

      // Remove overflowed tabs
      sizeableTabs.children('a').removeAttr('style');
      sizeableTabs.removeAttr('style').each(function () {
        var t = $(this);
        if (self.isTabOverflowed(t)) {
          sizeableTabs = sizeableTabs.not(t);
        }
      });

      // Resize the more button to fit the entire space if no tabs can show
      // Math: +101 is the padding of the <ul class="tab-list"> element
      if (!sizeableTabs.length) {
        visibleTabSize = tabContainerW - appTriggerSize + 101;
        this.moreButton[0].style.width = visibleTabSize + 'px';
        return;
      }
      var anchorStyle = window.getComputedStyle(sizeableTabs.eq(0).children()[0]);
      var anchorPadding = parseInt(anchorStyle.paddingLeft, 10) + parseInt(anchorStyle.paddingRight, 10);

      if (this.moreButton[0].hasAttribute('style')) {
        this.moreButton[0].removeAttribute('style');
      }

      // Math explanation:
      // Width of tab container - possible applcation menu trigger
      // Divided by number of visible tabs
      // (doesn't include app menu trigger which shouldn't change size).
      // Minus one (for the left-side border of each tab)
      visibleTabSize = (tabContainerW - appTriggerSize) / sizeableTabs.length - 1;

      if (visibleTabSize < defaultTabSize) {
        visibleTabSize = defaultTabSize;
      }

      var a = void 0;
      var prevWidth = void 0;
      var cutoff = 'no';
      var isSideBySide = this.element.closest('.side-by-side').length === 1;

      for (var i = 0; i < sizeableTabs.length; i++) {
        a = sizeableTabs.eq(i).children('a');
        a[0].style.width = '';

        if (this.settings.moduleTabsTooltips === true) {
          cutoff = 'no';

          prevWidth = parseInt(window.getComputedStyle(sizeableTabs[i]).width, 10);

          if (prevWidth > visibleTabSize - anchorPadding) {
            cutoff = 'yes';
          }
          a.data('cutoffTitle', cutoff);
        }

        var diff = 0;
        if (Environment.os.name === 'ios' && Environment.devicespecs.isMobile && isSideBySide) {
          diff = 25;
        }
        sizeableTabs[i].style.width = visibleTabSize - diff + 'px';
        a[0].style.width = visibleTabSize - diff + 'px';
      }

      this.adjustSpilloverNumber();
    },


    /**
     * @private
     * @returns {void}
     */
    adjustSpilloverNumber: function adjustSpilloverNumber() {
      var moreDiv = this.moreButton.find('.more-text');
      var tabs = this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)');
      var overflowedTabs = this.getOverflowTabs();

      if (tabs.length <= overflowedTabs.length) {
        moreDiv.text('' + Locale.translate('Tabs'));
      } else {
        moreDiv.text('' + Locale.translate('More'));
      }

      var countDiv = this.moreButton.find('.count');
      if (!countDiv.length) {
        countDiv = $('<span class="count"></span>');
        this.moreButton.children('span').first().prepend(countDiv);
      }

      countDiv.text(overflowedTabs.length + ' ');
    },


    /**
     * Selects a Tab
     * @param {string} href a string representing the HTML `id` attribute of the new tab panel.
     * @returns {void}
     */
    select: function select(href) {
      var modHref = href.replace(/#/g, '');
      var anchor = this.getAnchor(modHref);

      this.positionFocusState(undefined, false);
      this.focusBar(anchor.parent());

      if (!this.activate(anchor.attr('href'))) {
        return;
      }
      this.changeHash(modHref);

      anchor.focus();
    },


    /**
     * Builds tab popupmenu
     * @param {string} startingHref a string representing the HTML `href` attribute of the popupmenu item to be selected.
     * @returns {void}
     */
    buildPopupMenu: function buildPopupMenu(startingHref) {
      var self = this;
      if (self.popupmenu) {
        self.popupmenu.destroy();
        $('#tab-container-popupmenu').off('focus.popupmenu').remove();
        $(document).off('keydown.popupmenu');
      }

      // Build the new markup for the popupmenu if it doesn't exist.
      // Reset it if it does exist.
      var menuHtml = $('#tab-container-popupmenu');
      var shouldBeSelectable = '';
      if (this.isScrollableTabs()) {
        shouldBeSelectable = ' is-selectable';
      }

      if (menuHtml.length === 0) {
        menuHtml = $('<ul id="tab-container-popupmenu" class="tab-list-spillover' + shouldBeSelectable + '">').appendTo('body');
      } else {
        menuHtml.html('');
      }

      // Build menu options from overflowed tabs
      var tabs = self.tablist.children('li');
      var isRTL = Locale.isRTL();

      function buildMenuItem(item) {
        var $item = $(item);
        var $itemA = $item.children('a');

        if ($item.is(':hidden')) {
          return;
        }

        if (!self.isScrollableTabs() && !self.isTabOverflowed($item)) {
          return;
        }

        if ($item.is('.separator')) {
          $item.clone().appendTo(menuHtml);
          return;
        }

        var popupLi = $item.clone();
        var popupA = popupLi.children('a');

        popupLi[0].classList.remove('tab');
        if (popupLi[0].classList.contains('is-selected')) {
          popupLi[0].classList.remove('is-selected');
          if (self.isScrollableTabs()) {
            popupLi[0].classList.add('is-checked');
          }
        }

        popupLi[0].removeAttribute('style');

        popupLi.children('.icon').off().appendTo(popupA);
        popupLi.appendTo(menuHtml);

        // Link tab to its corresponding "More Tabs" menu option
        $item.data('moremenu-link', popupA);
        popupA.find('.icon-more').remove();

        // Link "More Tabs" menu option to its corresponding Tab.
        // Remove onclick methods from the popup <li> because they are called
        // on the "select" event in context of the original button
        popupA.data('original-tab', $itemA);
        popupA.onclick = undefined;

        if (!$item.is('.has-popupmenu')) {
          return;
        }

        // If this is a Dropdown Tab, clone its menu and add it to the "More Tabs" menu
        // As a submenu of the "popupLi".
        var submenu = $('#' + item.getAttribute('aria-controls'));
        var clone = submenu.clone();
        var cloneLis = clone.children('li');

        clone[0].classList.remove('has-popupmenu');

        cloneLis.each(function (i) {
          var li = $(this);
          var a = li.children('a');
          var originalLi = submenu.children('li').eq(i);
          var originalA = originalLi.children('a');

          a.data('original-tab', originalA);
          originalA.data('moremenu-link', a);
        });

        clone.insertAfter(popupA);
      }

      // Build spillover menu options
      for (var i = 0; i < tabs.length; i++) {
        buildMenuItem(tabs[i]);
      }

      self.tablist.children('li:not(.separator)').removeClass('is-focused');
      var xOffset = 1;
      if (!this.isScrollableTabs()) {
        xOffset = 3;
      }

      // Invoke the popup menu on the button.
      self.moreButton.popupmenu({
        autoFocus: false,
        attachToBody: true,
        menu: 'tab-container-popupmenu',
        trigger: 'immediate',
        offset: { x: xOffset }
      });
      self.moreButton.addClass('popup-is-open');
      self.popupmenu = self.moreButton.data('popupmenu');

      self.positionFocusState(self.moreButton);

      function closeMenu() {
        $(this).off('close.tabs selected.tabs');
        self.moreButton.removeClass('popup-is-open');
        self.positionFocusState(undefined);
        self.focusBar();
      }

      function selectMenuOption(e, anchor) {
        var href = anchor.attr('href');
        var id = href.substr(1, href.length);
        var tab = self.doGetTab(id) || $();
        var a = tab ? tab.children('a') : $();
        var originalTab = anchor.data('original-tab').parent();

        if (originalTab.is('.add-tab-button')) {
          a = self.handleAddButton();
          originalTab = a.parent();
          href = a.attr('href');
          self.element.trigger('tab-added', [a]);
        }

        self.activate(href);

        // Fire an onclick event associated with the original tab from the spillover menu
        if (tab.length && a.length && typeof a[0].onclick === 'function') {
          a[0].onclick.apply(a[0]);
        }

        // Focus the More Button
        // NOTE: If we switch the focusing-operations back to how they used to be
        // (blue bar moving around with the focus state)
        // remove the line below.
        self.moreButton.focus();

        self.scrollTabList(tab);
      }

      self.moreButton.on('close.tabs', closeMenu).on('selected.tabs', selectMenuOption);

      var menu = self.popupmenu.menu;

      function handleDestroy() {
        menu.off();
        self.hideFocusState();
        $('#tab-container-popupmenu').remove();
      }

      function handleDismissibleIconClick(e) {
        var icon = $(this);
        var li = icon.closest('li');

        if (!li.is('.dismissible') || !icon.is('.close')) {
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        if (li.is('.dismissible') && li.is('.has-popupmenu') && li.is('.submenu')) {
          var listMenu = li.find('.wrapper').children().children();
          var hrefs = [];
          $.each(listMenu, function (i, item) {
            hrefs.push(item.children[0].href);
          });
          self.closeDismissibleTabs(hrefs);
        } else {
          self.closeDismissibleTab(li.children('a').attr('href'));
        }
        self.popupmenu.close();
      }

      menu.on('destroy.popupmenu', handleDestroy).on('touchend.popupmenu touchcancel.popupmenu', '.icon', handleDismissibleIconClick).on('click.popupmenu', '.icon', handleDismissibleIconClick);

      // If the optional startingIndex is provided, focus the popupmenu on the matching item.
      // Otherwise, focus the first item in the list.
      if (startingHref) {
        self.popupmenu.highlight(menu.find('a[href="' + startingHref + '"]'));
      } else if (self.tablist.children('.is-selected').length > 0) {
        self.popupmenu.highlight(menu.find('a[href="' + self.tablist.children('.is-selected').children('a').attr('href') + '"]'));
      } else {
        self.popupmenu.highlight(menu.find('li:first-child > a'));
      }

      // Overrides a similar method in the popupmenu code that controls escaping of
      // this menu when pressing certain keys.  We override this here so that the
      // controls act in a manner as if all tabs are still visible (for accessiblity
      // reasons), meaning you can use left and right to navigate the popup menu options
      // as if they were tabs.
      $(document).bindFirst('keydown.popupmenu', function (e) {
        var key = e.which;
        var currentMenuItem = $(e.target);

        function isFocusedElement() {
          return this === document.activeElement;
        }

        function prevMenuItem() {
          // If the first item in the popup menu is already focused, close the menu and focus
          // on the last visible item in the tabs list.
          var first = menu.find('li:first-child > a');
          if (first.filter(isFocusedElement).length > 0) {
            e.preventDefault();
            $(document).off(e);
            self.popupmenu.close();
            self.findLastVisibleTab();
          }
        }

        function nextMenuItem() {
          // If the last item in the popup menu is already focused, close the menu and focus
          // on the first visible item in the tabs list.
          var last = menu.find('li:last-child > a');
          if (last.filter(isFocusedElement).length > 0 && last.parent().is(':not(.submenu)')) {
            e.preventDefault();
            $(document).off(e);
            self.popupmenu.close();

            if (self.settings.addTabButton) {
              self.addTabButton.focus();
              return;
            }
            self.focusFirstVisibleTab();
          }
        }

        // Alt+Del or Alt+Backspace closes a dropdown tab item
        function closeDropdownMenuItem() {
          if (!e.altKey || !currentMenuItem.parent().is('.dismissible')) {
            return;
          }
          // self.popupmenu.close();
          self.closeDismissibleTab(currentMenuItem.attr('href'));
        }

        var pseudoKeycode = void 0;

        switch (key) {
          case 8:
          case 46:
            closeDropdownMenuItem(e);
            break;
          case 37:
            // left
            pseudoKeycode = isRTL ? 40 : 38;
            if (currentMenuItem.is('a')) {
              if (currentMenuItem.parent().is(':not(:first-child)')) {
                e.preventDefault(); // Prevent popupmenu from closing on left key
              }
              $(document).trigger({ type: 'keydown.popupmenu', which: pseudoKeycode });
            }
            break;
          case 38:
            // up
            prevMenuItem();
            break;
          case 39:
            // right
            pseudoKeycode = isRTL ? 38 : 40;
            if (currentMenuItem.is('a') && !currentMenuItem.parent('.submenu').length) {
              $(document).trigger({ type: 'keydown.popupmenu', which: pseudoKeycode });
            }
            break;
          case 40:
            // down
            nextMenuItem();
            break;
          default:
            break;
        }
      });
    },


    /**
     * Used for checking if a particular tab (in the form of a jquery-wrapped list item)
     * is spilled into the overflow area of the tablist container <UL>.
     * @param {jQuery} li tab list item
     * @returns {boolean} whether or not the tab is overflowed.
     */
    isTabOverflowed: function isTabOverflowed(li) {
      if (this.isVerticalTabs() || this.isScrollableTabs()) {
        return false;
      }

      if (this.tablist.scrollTop() > 0) {
        this.tablist.scrollTop(0);
      }

      var liTop = Math.round(li[0].getBoundingClientRect().top);
      var tablistTop = Math.round(this.tablist[0].getBoundingClientRect().top + 1);

      // +1 to compensate for top border on Module Tabs
      if (this.isModuleTabs()) {
        tablistTop += 1;
      }

      return liTop > tablistTop;
    },


    /**
     * @returns {jQuery} representing the last visible tab.
     */
    findLastVisibleTab: function findLastVisibleTab() {
      var tabs = this.tablist.children('li:not(.separator):not(.hidden):not(.is-disabled)');
      var targetFocus = tabs.first();

      // if Scrollable Tabs, simply get the last tab and focus.
      if (this.isScrollableTabs()) {
        return tabs.last().find('a').focus();
      }

      while (!this.isTabOverflowed(targetFocus)) {
        targetFocus = tabs.eq(tabs.index(targetFocus) + 1);
      }

      return tabs.eq(tabs.index(targetFocus) - 1).find('a').focus();
    },


    /**
     * @returns {void}
     */
    focusFirstVisibleTab: function focusFirstVisibleTab() {
      var tabs = this.tablist.children('li:not(.separator):not(.hidden):not(.is-disabled)');
      tabs.eq(0).find('a').focus();
    },


    /**
     * Moves the animated "selected" state bar to a new tab
     * @param {jQuery} li the new tab list item
     * @param {function} callback fires after the animation is completed.
     * @returns {void}
     */
    focusBar: function focusBar(li, callback) {
      if (!this.hasAnimatedBar()) {
        return;
      }

      if (!(li instanceof $) || !li.length) {
        return;
      }

      var self = this;
      var target = li;
      var scrollingTablist = this.tablistContainer;
      var isRTL = Locale.isRTL();
      var tablistScrollWidth = void 0;
      var tablistScrollLeft = void 0;
      var anchorStyle = void 0;

      this.animatedBar.removeClass('no-transition');

      if (!target || target === undefined || !target.length || !self.anchors.length) {
        this.animatedBar.removeClass('visible');
        return;
      }

      var targetStyle = window.getComputedStyle(target[0], null);
      var paddingRight = parseInt(targetStyle.getPropertyValue('padding-right'), 10) || 0;
      var width = parseInt(targetStyle.getPropertyValue('width'), 10) || 0;

      if (target.is('.tab')) {
        anchorStyle = window.getComputedStyle(target.children('a')[0]);
        paddingRight += parseInt(anchorStyle.getPropertyValue('padding-right'), 10) || 0;
      }

      var left = isRTL ? paddingRight + target.position().left + target.outerWidth(true) : target.position().left;

      clearTimeout(self.animationTimeout);
      this.animatedBar.addClass('visible');

      function animationTimeout(cb) {
        var style = self.animatedBar[0].style;
        tablistScrollLeft = scrollingTablist[0].scrollLeft;
        tablistScrollWidth = scrollingTablist[0].scrollWidth;

        if (isRTL) {
          style.right = tablistScrollWidth + paddingRight - (left + tablistScrollLeft) + 'px';
        } else {
          style.left = left + tablistScrollLeft + 'px';
        }
        style.width = width + 'px';

        if (cb && typeof cb === 'function') {
          cb();
        }
      }

      animationTimeout(callback);
    },


    /**
     * Clears the animated "selected" state bar away.
     * @returns {void}
     */
    defocusBar: function defocusBar() {
      if (!this.hasAnimatedBar()) {
        return;
      }

      var self = this;
      var left = Locale.isRTL() ? 0 : self.animatedBar.position().left + self.animatedBar.outerWidth() / 2;

      clearTimeout(self.animationTimeout);

      this.animatedBar[0].style.left = left + 'px';
      this.animatedBar[0].style.width = 0;

      this.animationTimeout = setTimeout(function () {
        if (self.animatedBar && self.animatedBar.length) {
          self.animatedBar.removeClass('visible').removeAttr('style');
        }
      }, 350);
    },


    /**
     * Wrapper for the Soho behavior _smoothScrollTo()_ that will determine scroll distance.
     * @param {jQuery[]} target - the target <li> or <a> tag
     * @param {number} duration - the time it will take to scroll
     * @returns {undefined}
     */
    scrollTabList: function scrollTabList(target) {
      if (!this.tablistContainer || !target || !(target instanceof $) || !target.length) {
        return;
      }

      var tabCoords = DOM.getDimensions(target[0]);
      var tabContainerDims = DOM.getDimensions(this.tablistContainer[0]);
      var d = void 0;

      var FADED_AREA = 40; // the faded edges on the sides of the tabset
      var adjustedLeft = tabCoords.left;
      var adjustedRight = tabCoords.right;

      if (adjustedLeft < tabContainerDims.left + FADED_AREA) {
        d = Math.round(Math.abs(tabContainerDims.left - adjustedLeft)) * -1 - FADED_AREA;
      }
      if (adjustedRight > tabContainerDims.right - FADED_AREA) {
        d = Math.round(Math.abs(adjustedRight - tabContainerDims.right)) + FADED_AREA;
      }

      if (d === 0) {
        d = undefined;
      }

      // Scroll the tablist container
      this.tablistContainer.smoothScroll(d, 250);
    },


    /**
     * Hides the focus state, if it's visible.
     * @returns {void}
     */
    hideFocusState: function hideFocusState() {
      this.focusState.removeClass('is-visible');
    },


    /**
     * Updates the position of the focus state, to the tab/button that currently has focus.
     * @param {jQuery[]|HTMLElement} target the element that will receive the focus state
     * @param {boolean} [unhide] if true, unhides the focus state if it's previously been hidden.
     * @returns {void}
     */
    positionFocusState: function positionFocusState(target, unhide) {
      var self = this;

      // TODO: Recheck this and improve
      if (target !== undefined) {
        target = $(target);
      } else if (self.moreButton.hasClass('is-selected')) {
        target = self.moreButton;
      } else if (self.tablist.children('.is-selected').length > 0) {
        target = self.tablist.children('.is-selected').children('a');
      }

      /*
      NOTE: this used to replace the code directly above
      target = target !== undefined ? $(target) :
        self.moreButton.hasClass('is-selected') ? self.moreButton :
        self.tablist.children('.is-selected').length > 0 ?
        self.tablist.children('.is-selected').children('a') : undefined;
      */

      if (!target || target === undefined || !target.length || target.is(this.moreButton) && this.isScrollableTabs()) {
        this.focusState.removeClass('is-visible');
        return;
      }

      // Use the parent <li> for anchors to get their dimensions.
      if (target.is('a')) {
        target = target.parent();
      }

      // Move the focus state from inside the tab list container, if applicable.
      // Put it back into the tab list container, if not.
      if (target.is('.add-tab-button, .tab-more')) {
        if (!this.focusState.parent().is(this.element)) {
          this.focusState.prependTo(this.element);
        }
      } else if (!this.focusState.parent().is(this.tablistContainer)) {
        this.focusState.prependTo(this.tablistContainer);
      }

      var focusStateElem = this.focusState[0];
      var targetPos = DOM.getDimensions(target[0]);
      var targetClassList = target[0].classList;
      var isNotHeaderTabs = !this.isHeaderTabs() || this.isHeaderTabs() && this.element[0].classList.contains('alternate');
      var isVerticalTabs = this.isVerticalTabs();
      var isRTL = Locale.isRTL();
      var tabMoreWidth = !isVerticalTabs ? this.moreButton.outerWidth(true) : 0;
      var parentContainer = this.element;
      var scrollingTablist = this.tablistContainer;
      var accountForPadding = scrollingTablist && this.focusState.parent().is(scrollingTablist);

      function adjustForParentContainer(targetRectObj, parentElement, tablistContainer) {
        var parentRect = parentElement[0].getBoundingClientRect();
        var parentPadding = void 0;
        var tabLeftMargin = void 0;
        var tablistScrollWidth = void 0;
        var tablistScrollLeft = void 0;

        // Adjust from the top
        targetRectObj.top -= parentRect.top;
        if (isVerticalTabs) {
          targetRectObj.top += parentElement[0].scrollTop;
        }

        if (isRTL) {
          targetRectObj.right = parentRect.right - targetRectObj.right;
        } else {
          targetRectObj.left -= parentRect.left;
        }

        // If inside a scrollable tablist, account for the scroll position
        if (tablistContainer) {
          tablistScrollLeft = tablistContainer ? tablistContainer[0].scrollLeft : 0;
          tablistScrollWidth = tablistContainer ? tablistContainer[0].scrollWidth : 0;

          if (isRTL && !isVerticalTabs) {
            // TODO: Improve this calculation because there's something off
            var tmpLeft = targetRectObj.left;
            if (isNotHeaderTabs) {
              tabLeftMargin = parseInt(window.getComputedStyle(target[0]).marginLeft, 10);
              targetRectObj.left = tablistScrollWidth - tabLeftMargin - targetRectObj.right + tablistScrollLeft;
              targetRectObj.right = tablistScrollWidth - tabLeftMargin - tmpLeft + tablistScrollLeft;
            } else {
              targetRectObj.left = tablistScrollWidth - (targetRectObj.right + tablistScrollLeft + tabMoreWidth + 32);
              targetRectObj.right = tablistScrollWidth - (tmpLeft + tablistScrollLeft + tabMoreWidth + 32);
            }
          } else {
            targetRectObj.left += tablistScrollLeft;
            targetRectObj.right += tablistScrollLeft;
          }

          if (accountForPadding) {
            parentPadding = parseInt(window.getComputedStyle(parentElement[0])['padding' + (isRTL ? 'Right' : 'Left')], 10);
            targetRectObj.left += isRTL ? parentPadding : parentPadding * -1;
            targetRectObj.right += isRTL ? parentPadding : parentPadding * -1;
          }
        }

        // Alternate Header Tabs have 1px removed from bottom to prevent overlap
        // onto the bottom border
        if (isNotHeaderTabs && !isVerticalTabs) {
          targetRectObj.height -= 1;
        }

        return targetRectObj;
      }

      // Adjust the values one more time if we have tabs contained inside of a
      // page-container, or some other scrollable container.
      targetPos = adjustForParentContainer(targetPos, parentContainer, scrollingTablist);

      // build CSS string containing each prop and set it:
      var targetPosString = '';
      Object.keys(targetPos).forEach(function (key) {
        if (targetPosString.length) {
          targetPosString += ' ';
        }
        targetPosString += key + ': ' + targetPos[key] + 'px;';
      });
      focusStateElem.style.cssText = targetPosString;

      var selected = targetClassList.contains('is-selected') ? 'add' : 'remove';
      focusStateElem.classList[selected]('is-selected');

      var doHide = unhide === true ? 'add' : 'remove';
      focusStateElem.classList[doHide]('is-visible');
    },


    /**
     * Causes the entire tabset to reset with new settings.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },


    /**
     * Disables all non-active tabs in the list
     * @returns {void}
     */
    disableOtherTabs: function disableOtherTabs() {
      return this.disable(true);
    },


    /**
     * Disables the entire Tab Component
     * @param {boolean} isPartial whether or not this disable call is a partial
     *  disabling of the tabset
     * @returns {void}
     */
    disable: function disable(isPartial) {
      if (!isPartial) {
        this.element.prop('disabled', true).addClass('is-disabled');
      }

      if (!this.disabledElems) {
        this.disabledElems = [];
      }

      var self = this;
      var tabs = this.tablist.children('li:not(.separator)');
      if (isPartial) {
        tabs = tabs.filter(':not(.application-menu-trigger)');
      }

      tabs.each(function () {
        var li = $(this);
        var a = li.children('a');

        if (isPartial && self.isActive(a.attr('href'))) {
          return;
        }

        if (li.is('.is-disabled') || a.prop('disabled') === true) {
          self.disabledElems.push({
            elem: li,
            originalTabindex: li.attr('tabindex'),
            originalDisabled: a.prop('disabled')
          });
        }

        li.addClass('is-disabled');
        a.prop('disabled', true);

        if (li.is('.application-menu-trigger') || li.is('.add-tab-button')) {
          return;
        }

        var panel = $(a.attr('href'));
        panel.addClass('is-disabled');
        panel.find('*').each(function () {
          var t = $(this);

          // These are shadow inputs.  They are already handled by virtue of running
          // .disable() on the original select tag.
          if (t.is('input.dropdown, input.multiselect')) {
            return;
          }

          if (t.attr('tabindex') === '-1' || t.attr('disabled')) {
            self.disabledElems.push({
              elem: t,
              originalTabindex: t.attr('tabindex'),
              originalDisabled: t.prop('disabled')
            });
          }

          t.disable();
        });
      });

      this.moreButton.addClass('is-disabled');

      if (this.isModuleTabs() && !isPartial) {
        this.element.children('.toolbar').disable();
      }

      this.updateAria($());
    },


    /**
     * Enables the entire Tabs component
     * @returns {void}
     */
    enable: function enable() {
      this.element.prop('disabled', false).removeClass('is-disabled');

      var self = this;
      var tabs = this.tablist.children('li:not(.separator)');

      tabs.each(function () {
        var li = $(this);
        var a = li.children('a');

        li.removeClass('is-disabled');
        a.prop('disabled', false);

        if (li.is('.application-menu-trigger') || li.is('.add-tab-button')) {
          return;
        }

        var panel = $(a.attr('href'));
        panel.removeClass('is-disabled');
        panel.find('*').each(function () {
          var t = $(this);
          if (t.enable && typeof t.enable === 'function') {
            t.enable();
          }
        });

        $.each(self.disabledElems, function (i, obj) {
          var attrTarget = obj.elem.is('.tab') ? obj.elem.children('a') : obj.elem;
          if (obj.elem.disable && typeof obj.elem.disable === 'function') {
            obj.elem.disable();
          }

          if (obj.elem.is('li')) {
            obj.elem.addClass('is-disabled');
            return;
          }

          // These are shadow inputs.  They are already handled by virtue of
          // running .disable() on the original select tag.
          if (obj.elem.is('input.dropdown, input.multiselect')) {
            return;
          }

          obj.elem.attr('tabindex', obj.originalTabindex);
          attrTarget.prop('disabled', obj.originalDisabled);
        });
      });

      this.moreButton.removeClass('is-disabled');

      if (this.isModuleTabs()) {
        this.element.children('.toolbar').enable();
      }

      this.disabledElems = [];

      this.updateAria(this.tablist.find('.is-selected > a'));
    },


    /**
     * Pass-through for the `remove()` method, which gets used for removing a dismissible tab.
     * @param {string} tabId the ID of the target tab panel
     * @returns {this} component instance
     */
    closeDismissibleTab: function closeDismissibleTab(tabId) {
      return this.remove(tabId);
    },


    /**
     * Remove top level dismissible tab with dropdown
     * @param {array} tabUrlArray the Array of urls from the target popupmenu
     */
    closeDismissibleTabs: function closeDismissibleTabs(tabUrlArray) {
      var _this4 = this;

      tabUrlArray.forEach(function (tabUrl) {
        var tabId = tabUrl.match(/#.*/);
        return _this4.remove(tabId[0]);
      });
    },


    /**
     * Tears down this instance of the tabs component by removing events,
     * other components, and extraneous markup.
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.panels.removeAttr('style');

      this.tablist.off().removeAttr('role').removeAttr('aria-multiselectable');

      var tabs = this.tablist.children('li');
      tabs.off().removeAttr('role').removeClass('is-selected');

      var dds = tabs.filter('.has-popupmenu');
      dds.each(function () {
        var popup = $(this).data('popupmenu');
        if (popup) {
          popup.menu.children('li:not(.separator)').each(function () {
            var li = $(this);
            var a = li.children('a');
            var panel = a.data('panel-link');

            $.removeData(a[0], 'panel-link');
            if (panel && panel.length) {
              $.removeData(panel[0], 'tab-link');
            }
          });
          popup.destroy();
        }
      });

      this.panels.off();

      this.anchors.off().removeAttr('role').removeAttr('aria-expanded').removeAttr('aria-selected').removeAttr('tabindex');

      if (this.settings.moduleTabsTooltips) {
        this.anchors.each(function () {
          var api = $(this).data('tooltip');
          if (api && typeof api.destroy === 'function') {
            api.destroy();
          }
        });
      }

      this.element.off('focusout.tabs updated.tabs activated.tabs');
      $('body').off('resize.tabs' + this.tabsIndex);
      this.tabsIndex = undefined;

      if (this.moreButton.data('popupmenu')) {
        var popup = this.moreButton.data('popupmenu');
        popup.menu.find('li:not(.separator)').each(function () {
          var li = $(this);
          var a = li.children('a');

          if (a.data('original-tab')) {
            $.removeData(a[0], 'original-tab');
          }
        });
        popup.destroy();
      }

      this.removeHelperMarkupEvents();

      if (this.tablistContainer) {
        this.tablistContainer.off('mousewheel.tabs');
      }

      this.focusState.remove();
      this.focusState = undefined;

      if (this.hasAnimatedBar()) {
        this.animatedBar.remove();
        this.animatedBar = undefined;
      }
      $('.tab-panel input').off('error.tabs valid.tabs');

      return this;
    },


    /**
     * Destroys this component instance, removing its attachment from its parent element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$_);
    }
  };

  /**
   * jQuery component wrapper for Tabs Component
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.tabs = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$_);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$_, new Tabs(this, settings));
      }
    });
  };

  // Deprecated the old Vertical Tabs code in favor of using the Tabs class.
  $.fn.verticaltabs = $.fn.tabs;

  // Component Name
  var COMPONENT_NAME$$ = 'tag';

  // Default Tag Options
  var TAG_DEFAULTS = {};

  /**
  * Implements functionality on tag objects, such as closing tabs.
  * @class Tag
  * @param {string} element The component element.
  * @param {string} settings The component settings.
  */
  function Tag(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TAG_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Tag Methods
  Tag.prototype = {
    init: function init() {
      this.element.hideFocus();
      this.handleEvents();
    },


    /**
     * Remove the tag from the DOM
     * @private
     * @param {object} event Type.
     * @param {string} el The element.
     * @returns {void}
     */
    remove: function remove(event, el) {
      el = el instanceof jQuery ? el : $(el);
      var parent = el.parent();

      /**
      * Fires before tag remove.
      *
      * @event beforetagremove
      * @memberof Tag
      * @type {object}
      * @property {object} event - The jquery event object
      * @property {object} The event used for removing and element
      */
      this.element.triggerHandler('beforetagremove', { event: event, element: el });
      el.remove();

      /**
      * Fires after tag remove.
      *
      * @event aftertagremove
      * @memberof Tag
      * @type {object}
      * @property {object} event - The jquery event object
      */
      parent.triggerHandler('aftertagremove', { event: event });
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.element.off('keydown.tag');
      $('.dismissable-btn, .dismissible-btn', this.element).off('click.tag').remove();
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, TAG_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$$);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      var btnDismissable = $('' + ('<span class="dismissible-btn">\n        ' + $.createIcon('close') + '\n        <span class="audible"> ' + Locale.translate('Close') + '</span>\n      </span>'));
      var dismissibleClass = '.is-dismissable, .is-dismissible';

      // EPC: Deprecating "dismissable" in favor of "dismissible" as of 4.3.0
      if (self.element.is(dismissibleClass)) {
        self.element.append(btnDismissable);

        /**
        * Fires when the tag is clicked (if enabled).
        * @event click
        * @memberof Tag
        * @type {object}
        * @property {object} event - The jquery event object
        */
        btnDismissable.on('click.tag', function (event) {
          _this.remove(event, _this.element);
        });

        /**
        * Fires when the tag is focused.
        * @event keydown
        * @memberof Tag
        * @type {object}
        * @property {object} event - The jquery event object
        */
        this.element.on('keydown.tag', function (event) {
          var e = event || window.event;
          if (e.keyCode === 8) {
            // Backspace
            self.remove(event, this);
          }
        });
      }
    }
  };

  // Initialize the plugin (Once)
  $.fn.tag = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$$);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$$, new Tag(this, settings));
      }
    });
  };

  // Name of this component
  var COMPONENT_NAME$10 = 'textarea';

  // Component Options
  var TEXTAREA_DEFAULTS = {
    autoGrow: false,
    autoGrowAnimate: true,
    autoGrowAnimateSpeed: 200,
    autoGrowMaxHeight: null,
    characterCounter: true,
    maxLength: null,
    printable: true,
    charRemainingText: null,
    charMaxText: null
  };

  /**
  * The Textarea Component wraps a standard HTML Textarea element and provides additional features.
  * @class Textarea
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.autoGrow = false] Will automatically expand the textarea to fit the contents when typing.
  * @param {boolean} [settings.autoGrowAnimate  = true] Will animate the textarea grow.
  * @param {number} [settings.autoGrowAnimateSpeed = 200] The speed of the animation.
  * @param {number} [settings.autoGrowMaxHeight = null] The Max Height of the textarea when autoGrow is enabled.
  * @param {boolean} [settings.characterCounter = true] Displays a counter that counts down from the maximum.
  * @param {boolean} [settings.maxLength = number] Maximum characters allowed in textarea.
  * length allowed.
  * @param {boolean} [settings.printable = true] Determines whether or not the text area can be displayed on a
  * printed page.
  * @param {null|String} [settings.charRemainingText = 'Characters Left']  Text that will be used in place of the "remaining"
  * text defaulting to a localized 'Characters Left'.
  * @param {null|String} [settings.charMaxText = 'Character count maximum of']  Text that will be used in place of the "Max" text.
  * Defaults to a localized Version of 'Character count maximum of'.
  */
  function Textarea(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TEXTAREA_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  Textarea.prototype = {

    /**
     * @private
     */
    init: function init() {
      this.isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
      this.isSafari = navigator.userAgent.indexOf('Safari') !== -1 && navigator.userAgent.indexOf('Chrome') === -1 && navigator.userAgent.indexOf('Android') === -1;

      this.element.addClass(this.element.is('.textarea-xs') ? 'input-xs' : //eslint-disable-line
      this.element.is('.textarea-sm') ? 'input-sm' : //eslint-disable-line
      this.element.is('.textarea-lg') ? 'input-lg' : ''); //eslint-disable-line

      if (this.settings.characterCounter && this.getMaxLength()) {
        this.counter = $('<span class="textarea-wordcount">Chars Left..</span>').insertAfter(this.element);
      }
      if (this.settings.printable) {
        this.printarea = $('<span class="textarea-print"></span>').insertBefore(this.element);
      }

      if (this.element.hasClass('autogrow')) {
        this.settings.autoGrow = true;
      }

      if (this.settings.autoGrow && this.element.length) {
        this.element.css('overflow', 'hidden');
        this.handleResize(this);
      }

      this.handleEvents();
      this.updateCounter();
    },


    /**
     * Determines if the text is selected.
     * @private
     * @param  {object}  input The input dom element (jQuery)
     * @returns {boolean} True if the text is selected in the input.
     */
    isSelected: function isSelected(input) {
      if (typeof input.selectionStart === 'number') {
        return input.selectionStart === 0 && input.selectionEnd === input.value.length;
      } else if (typeof document.selection !== 'undefined') {
        return document.selection.createRange().text === input.value;
      }
      return false;
    },


    /**
     * Checks a keycode value and determines if it belongs to a printable character.
     * @private
     * @param {number} keycode - a number representing an ASCII keycode value
     * @param {boolean} shiftKey - a boolean set to true if shift key is being pressed
     * @returns {boolean} Returns true if the key is a printable one.
     */
    isPrintable: function isPrintable(keycode, shiftKey) {
      // (keycode > 47 && keycode < 58) || // number keys
      // (keycode > 64 && keycode < 91) || // letter keys
      // (keycode > 95 && keycode < 112) || // numpad keys
      // (keycode > 185 && keycode < 193) || // ;=,-./` (in order)
      // (keycode > 218 && keycode < 223); // [\]' (in order)

      var valid = false;

      if (shiftKey) {
        valid = keycode > 64 && keycode < 91 || // letter keys
        keycode >= 33 && keycode <= 38 || keycode >= 40 && keycode <= 43 || keycode === 126 || keycode === 58 || keycode === 60 || keycode >= 123 && keycode <= 125 || keycode === 94 || keycode === 95 || keycode >= 62 && keycode <= 64;
      } else {
        valid = keycode === 13 || // enter key
        keycode >= 48 && keycode <= 57 || // number keys
        keycode >= 97 && keycode <= 122 || // letter keys
        keycode === 59 || keycode === 61 || keycode >= 44 && keycode <= 47 || keycode === 96 || // ;=,-./` (in order)
        keycode >= 91 && keycode <= 93 || keycode === 39; // [\]' (in order)
      }

      return valid;
    },


    /**
    * Resizes the texarea based on the content.
    * @private
    * @param {obkect} self The textaarea api
    * @param {event} e The resive event object
    */
    handleResize: function handleResize(self, e) {
      var value = self.element.val();
      var oldHeight = self.element.innerHeight();
      var newHeight = self.element.get(0).scrollHeight;
      var minHeight = self.element.data('autogrow-start-height') || 0;
      var maxHeight = self.settings.autoGrowMaxHeight || 0;
      var clone = void 0;

      if (maxHeight > 0 && maxHeight < newHeight) {
        newHeight = maxHeight;
        self.element.css('overflow', '');
        if (oldHeight === newHeight) {
          return;
        }
      } else {
        self.element.css('overflow', 'hidden');
      }

      if (oldHeight < newHeight) {
        self.scrollTop = 0;

        if (self.settings.autoGrowAnimate && newHeight !== maxHeight) {
          self.element.stop().animate({ height: newHeight }, self.settings.autoGrowAnimateSpeed);
        } else {
          self.element.innerHeight(newHeight);
        }
      } else if (!e || e.which === 8 || e.which === 46 || e.ctrlKey && e.which === 88) {
        if (oldHeight > minHeight) {
          clone = self.element.clone().addClass('clone').css({ position: 'absolute', zIndex: -10, height: '' }).val(xssUtils.sanitizeHTML(value));

          self.element.after(clone);
          do {
            newHeight = clone[0].scrollHeight - 1;
            clone.innerHeight(newHeight);
          } while (newHeight === clone[0].scrollHeight);

          newHeight++;
          clone.remove();

          if (newHeight < minHeight) {
            newHeight = minHeight;
          }

          if (oldHeight > newHeight && self.settings.autoGrowAnimate) {
            self.element.stop().animate({ height: newHeight }, self.settings.autoGrowAnimateSpeed);
          } else {
            self.element.innerHeight(newHeight);
          }
        } else {
          self.element.innerHeight(minHeight);
        }
      }
    },


    /**
     * Counts the number of line breaks in a string
     * @private
     * @param {string} s The string to test.
     * @returns {number} The number of found line countLinebreaks
     */
    countLinebreaks: function countLinebreaks(s) {
      return (s.match(/\n/g) || []).length;
    },


    /**
     * Updates the descriptive markup (counter, etc) to notify the user how many
     * characters can be typed.
     * @private
     * @param {object} self The current object.
     */
    updateCounter: function updateCounter() {
      var self = this;
      var value = self.element.val();
      var isExtraLinebreaks = this.isChrome || this.isSafari;
      var length = value.length + (isExtraLinebreaks ? this.countLinebreaks(value) : 0);
      var max = self.getMaxLength();
      var remaining = parseInt(max, 10) - length;
      var text = (self.settings.charRemainingText ? self.settings.charRemainingText : //eslint-disable-line
      Locale.translate('CharactersLeft') === 'CharactersLeft' ? 'Characters Left' : Locale.translate('CharactersLeft')).replace('{0}', remaining.toString());

      if (self.counter) {
        if (length >= max) {
          text = self.settings.charMaxText ? self.settings.charMaxText.replace('{0}', max) : Locale.translate('CharactersMax') + max;
          self.counter.text(text);
          self.counter.removeClass('almost-empty');
        } else {
          self.counter.text(text);
          if (remaining < 10) {
            self.counter.addClass('almost-empty');
          } else {
            self.counter.removeClass('almost-empty');
          }
        }
      }

      self.printarea.text(self.element.val());
    },


    /**
     * Enables this component instance.
     */
    enable: function enable() {
      this.element.prop('disabled', false).prop('readonly', false);
    },


    /**
     * Disables this component instance.
     */
    disable: function disable() {
      this.element.prop('disabled', true);
    },


    /**
     * Returns true if the texarea is disabled
     * @returns {boolean} True if the elemet is disabled.
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Sets this component instance to "readonly"
     */
    readonly: function readonly() {
      this.element.prop('readonly', true);
    },


    /**
     * Call whenever the plugin's settings are changed
     * @param {object} settings The settings object.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.destroy();
      this.init();
    },


    /**
     * Returns max length if setting exists
     * @private
     * @returns {number} maxLength property in settings if exist otherwise maxlength attribute is returned if exist
     */
    getMaxLength: function getMaxLength() {
      if (this.settings.maxLength) {
        return this.settings.maxLength;
      } else if (this.element.attr('maxlength')) {
        return parseInt(this.element.attr('maxlength'), 10);
      }

      return undefined;
    },


    /**
     * Destroys this component instance and unlinks it from its element.
     */
    destroy: function destroy() {
      if (this.printarea && this.printarea.length) {
        this.printarea.remove();
      }
      if (this.counter && this.counter.length) {
        this.counter.remove();
      }
      this.element.off('keyup.textarea, focus.textarea, updated.dropdown, keypress.textarea, blur.textarea');
    },


    /**
     * Handle key events for functionality like counter and autoGrow.
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('keyup.textarea', function (e) {
        var value = self.element.val();
        var isExtraLinebreaks = self.isChrome || self.isSafari;
        var length = value.length + (isExtraLinebreaks ? self.countLinebreaks(value) : 0);
        var max = self.getMaxLength();

        self.updateCounter();

        if (length >= max) {
          e.preventDefault();
          return false;
        }

        if (self.settings.autoGrow) {
          self.handleResize(self, e);
        }

        return true;
      }).on('focus.textarea', function () {
        if (self.counter) {
          self.counter.addClass('focus');
        }
      }).on('updated.dropdown', function () {
        self.updated();
      }).on('keypress.textarea', function (e) {
        var value = self.element.val();
        var isExtraLinebreaks = self.isChrome || self.isSafari;
        var length = value.length + (isExtraLinebreaks ? self.countLinebreaks(value) : 0);
        var max = self.getMaxLength();

        if ([97, 99, 118, 120].indexOf(e.which) > -1 && (e.metaKey || e.ctrlKey)) {
          self.updateCounter();
          return;
        }

        if (!self.isPrintable(e.which, e.shiftKey)) {
          return;
        }

        if (length >= max && !self.isSelected(this)) {
          e.preventDefault();
        }
      }).on('blur.textarea', function () {
        self.updateCounter();
        if (self.counter) {
          self.counter.removeClass('focus');
        }
      });
    }
  };

  /**
   * jQuery Component wrapper for Textarea
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} textarea elements being acted on.
   */
  $.fn.textarea = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$10);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$10, new Textarea(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$11 = 'toolbar';

  /**
   * The Toolbar Component manages various levels of application navigation.
   * It contains a group of buttons that functionally related content. Each panel
   * consists of two levels: the top level identifies the category or section header,
   * and the second level provides the associated options.
   *
   * @class Toolbar
   * @param {HTMLElement|jQuery[]} element the base Toolbar element
   * @param {object} [settings] incoming settings
   *
   * @param {boolean} [settings.rightAligned=false] Will always attempt to right-align the contents of
   *  the toolbar. By default if there is no title it will left align. This forces right alignment.
   * @param {number} [settings.maxVisibleButtons=3] Total amount of buttons that can be present, not
   *  including the More button.
   * @param {boolean} [settings.resizeContainers=true] If true, uses Javascript to size the Title and
   *  Buttonset elements in a way that shows as much of the Title area as possible.
   * @param {boolean} [settings.favorButtonset=true] If "resizeContainers" is true, setting this to
   *  true will try to display as many buttons as possible while resizing the toolbar.
   *  Setting to false attempts to show the entire title instead.
   * @param {object} [settings.moreMenuSettings] If defined, provides a toolbar-level method of
   *  defining settings that will be applied to the More Actions button's popupmenu instance.
   * @param {boolean} [settings.noSearchfieldReinvoke=false] If true, does not manage the lifecycle
   *  of an internal toolbarsearchfield automatically.  Allows an external controller
   *  to do it instead.
   */
  var TOOLBAR_DEFAULTS = {
    rightAligned: false,
    maxVisibleButtons: 3,
    resizeContainers: true,
    favorButtonset: true,
    moreMenuSettings: undefined,
    noSearchfieldReinvoke: false
  };

  function Toolbar(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, TOOLBAR_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Toolbar.prototype = {

    /**
     * Initializes the Toolbar Component
     * @private
     * @chainable
     * @returns {this} component instance
     */
    init: function init() {
      return this.setup().build().handleEvents();
    },


    /**
     * Detects discrepencies in settings.  In general, configures the component
     * based on user settings.
     * @private
     * @chainable
     * @returns {this} component instance
     */
    setup: function setup() {
      // Can't have zero buttons
      if (this.settings.maxVisibleButtons <= 0) {
        this.settings.maxVisibleButtons = TOOLBAR_DEFAULTS.maxVisibleButtons;
      }

      return this;
    },


    /**
     * Adds additional markup, wraps some internal elements, and helps construct a
     * complete Toolbar representation in the HTML Markup. This method also builds the
     * "More Actions" menu and ties its elements to the toolbar items.
     * @private
     * @chainable
     * @returns {this} component instance
     */
    build: function build() {
      var self = this;

      this.element.attr('role', 'toolbar');
      if (this.settings.resizeContainers && this.element.is(':not(:hidden)')) {
        this.element[0].classList.add('do-resize');
      }

      this.buildAriaLabel();

      // keep track of how many popupmenus there are with an ID.
      // Used for managing events that are bound to $(document)
      if (!this.id) {
        this.id = parseInt($('.toolbar, .formatter-toolbar').index(this.element), 10);
      }

      // Check for a "title" element.  This element is optional.
      // If a title element exists, a tooltip will be created for when it's not
      // possible to show the entire title text on screen.
      this.title = this.element.children('.title');
      if (this.title.length) {
        this.element[0].classList.add('has-title');

        this.cutoffTitle = false;
        this.title.on('beforeshow.toolbar', function () {
          return self.cutoffTitle;
        }).tooltip({
          content: '' + this.title.text().trim()
        });
      } else {
        this.element[0].classList.remove('has-title');
      }

      // Container for main group of buttons and input fields.  Only these spill into the More menu.
      this.buttonset = this.element.children('.buttonset');
      if (!this.buttonset.length) {
        this.buttonset = $('<div class="buttonset"></div>');
        if (this.title.length) {
          this.buttonset.insertAfter(this.title);
        } else {
          this.buttonset.prependTo(this.element);
        }
      }

      this.element[this.settings.rightAligned ? 'addClass' : 'removeClass']('right-aligned');

      // Add and invoke More Button, if it doesn't exist
      this.more = this.element.find('.btn-actions');
      if (this.more.length === 0 && !this.element.hasClass('no-actions-button')) {
        var moreContainer = this.element.find('.more');

        if (!moreContainer.length) {
          moreContainer = $('<div class="more"></div>').appendTo(this.element);
        }

        this.more = $('<button class="btn-actions" type="button"></button>').html($.createIcon({ icon: 'more' }) + '<span class="audible">' + Locale.translate('MoreActions') + '</span>').attr('title', Locale.translate('More')).appendTo(moreContainer);
      }

      // Reference all interactive items in the toolbar
      this.buttonsetItems = this.buttonset.children('button').add(this.buttonset.find('input')); // Searchfield Wrappers

      // Items contains all actionable items in the toolbar, including the ones in
      // the title, and the more button
      this.items = this.buttonsetItems.add(this.title.children('button')).add(this.more);

      // Invoke buttons
      var buttons = this.items.filter('button, input[type="button"], [class^="btn"]');
      buttons.each(function () {
        var buttonControl = $(this).data('button');
        if (!buttonControl) {
          $(this).button();
        }

        var tooltipControl = $(this).data('tooltip');
        if (!tooltipControl && $(this).attr('title')) {
          $(this).tooltip();
        }
      });

      // Invoke searchfields
      if (!this.settings.noSearchfieldReinvoke) {
        var searchfields = this.items.filter('.searchfield, .toolbar-searchfield-wrapper, .searchfield-wrapper');
        searchfields.each(function (i, item) {
          var sf = $(item);
          if (sf.is('.toolbar-searchfield-wrapper, .searchfield-wrapper')) {
            sf = sf.children('.searchfield');
          }

          if (!sf.data('searchfield')) {
            var searchfieldOpts = $.extend({}, utils.parseSettings(sf[0]));
            sf.searchfield(searchfieldOpts);
          }
        });
      }

      // Setup the More Actions Menu.  Add Menu Items for existing buttons/elements in
      // the toolbar, but hide them initially. They are revealed when overflow checking
      // happens as the menu is opened.
      var popupMenuInstance = this.more.data('popupmenu');
      var moreAriaAttr = this.more.attr('aria-controls');

      if (!popupMenuInstance) {
        this.moreMenu = $('#' + moreAriaAttr);
        if (!this.moreMenu.length) {
          this.moreMenu = this.more.next('.popupmenu, .popupmenu-wrapper');
        }
        if (!this.moreMenu.length) {
          this.moreMenu = $('<ul id="popupmenu-toolbar-' + this.id + '" class="popupmenu"></ul>').insertAfter(this.more);
        }

        // Allow toolbar to understand pre-wrapped popupmenus
        // Angular Support -- See SOHO-7008
        if (this.moreMenu.is('.popupmenu-wrapper')) {
          this.moreMenu = this.moreMenu.children('.popupmenu');
        }
      } else {
        this.moreMenu = popupMenuInstance.menu;
      }

      function menuItemFilter() {
        return $(this).parent('.buttonset, .inline').length;
      }

      var menuItems = [];
      this.items.not(this.more).filter(menuItemFilter).each(function () {
        menuItems.push(self.buildMoreActionsMenuItem($(this)));
      });

      menuItems.reverse();
      $.each(menuItems, function (i, item) {
        if (item.text() !== '') {
          item.prependTo(self.moreMenu);
        }
      });

      this.defaultMenuItems = this.moreMenu.children('li:not(.separator)');
      this.hasDefaultMenuItems = this.defaultMenuItems.length > 0;

      // Setup an Event Listener that will refresh the contents of the More Actions
      // Menu's items each time the menu is opened.
      var menuButtonSettings = utils.extend({}, this.settings.moreMenuSettings, {
        trigger: 'click',
        menu: this.moreMenu
      }, this.hasDefaultMenuItems ? { predefined: this.defaultMenuItems } : {});
      if (popupMenuInstance) {
        this.more.on('beforeopen.toolbar', function () {
          self.refreshMoreActionsMenu(self.moreMenu);
        }).triggerHandler('updated', [menuButtonSettings]);
      } else {
        this.more.popupmenu(menuButtonSettings).on('beforeopen.toolbar', function () {
          self.refreshMoreActionsMenu(self.moreMenu);
        });
      }

      // Setup the tabindexes of all items in the toolbar and set the starting active button.
      function setActiveToolbarItem() {
        self.items.attr('tabindex', '-1');

        var active = self.items.filter('.is-selected');
        if (active.length) {
          self.activeButton = active.first().attr('tabindex', '0');
          self.items.not(self.activeButton).removeClass('is-selected');
          return;
        }

        // Set active to the first item in the toolbar.
        active = self.items.filter(':visible:not(:disabled)').first().attr('tabindex', '0');
        self.activeButton = active;

        // If the whole toolbar is hidden (contextual toolbars, etc),
        // automatically set the first non-disabled item as visible
        if (self.element.is(':hidden, .is-hidden')) {
          self.activeButton = self.items.filter(':not(:disabled)').first().attr('tabindex', '0');
          return;
        }

        if (self.isItemOverflowed(active)) {
          active.attr('tabindex', '-1');
          self.activeButton = self.more.addClass('is-selected').attr('tabindex', '0');
        }
      }

      setActiveToolbarItem();

      // Toggles the More Menu based on overflow of toolbar items
      this.adjustMenuItemVisibility();
      this.handleResize();

      /**
       * Fires when the Toolbar has completely rendered all its DOM elements.
       *
       * @event rendered
       * @memberof Toolbar
       * @param {jQuery.Event} e the jQuery Event object
       */
      this.element.triggerHandler('rendered');

      var searchfieldWrapper = this.buttonset.find('.searchfield-wrapper, .toolbar-searchfield-wrapper');
      if (searchfieldWrapper.length) {
        searchfieldWrapper.trigger('reanimate');
      }

      return this;
    },


    /**
     * Builds a single "More Actions Menu" item from a source toolbar item.
     * Also sets up linkage between the menu item and the original toolbar item to
     * allow events/properties to propagate when the More Actions item is acted upon.
     * @private
     * @param {jQuery[]} item the source item from the toolbar.
     * @returns {jQuery[]} a jQuery-wrapped <li> representing a More Actions menu
     *  implementation of the toolbar item.
     */
    buildMoreActionsMenuItem: function buildMoreActionsMenuItem(item) {
      var popupLi = void 0;

      // If this item should be skipped, just return out
      if (item.data('skipit') === true) {
        item.data('skipit', undefined);
        return popupLi;
      }

      // Attempt to re-use an existing <li>, if possible.
      // If a new one is created, setup the linkage between the original element and its
      // "More Actions" menu counterpart.
      var a = item.data('action-button-link');

      if (!a || !a.length) {
        popupLi = $('<li></li>');
        a = $('<a href="#"></a>').appendTo(popupLi);

        // Setup data links between the buttons and their corresponding list items
        item.data('action-button-link', a);
        a.data('original-button', item);
      } else {
        popupLi = a.parent();
      }

      // Refresh states
      if (item.hasClass('hidden')) {
        popupLi.addClass('hidden');
      }
      if (item.is(':disabled')) {
        popupLi.addClass('is-disabled');
        a.prop('disabled', true);
      } else {
        popupLi.removeClass('is-disabled');
        a.prop('disabled', false);
      }

      // Refresh Text
      a.text(this.getItemText(item));

      // Pass along any icons except for the dropdown (which is added as part of the submenu design)
      var submenuDesignIcon = $.getBaseURL('#icon-dropdown');
      var icon = item.children('.icon').filter(function () {
        var iconName = $(this).getIconName();
        return iconName && iconName !== submenuDesignIcon && iconName.indexOf('dropdown') === -1;
      });

      if (icon && icon.length) {
        a.html('<span>' + a.text() + '</span>');
        icon.clone().detach().prependTo(a);
      }

      var linkspan = popupLi.find('b');
      if (linkspan.length) {
        this.moreMenu.addClass('has-icons');
        linkspan.detach().prependTo(popupLi);
      }

      function addItemLinksRecursively(menu, diffMenu, parentItem) {
        var children = menu.children('li');
        var id = diffMenu.attr('id');

        diffMenu.children('li').each(function (i, diffMenuItem) {
          var dmi = $(diffMenuItem); // "Diffed" Menu Item
          var omi = children.eq(i); // Corresponding "Original" menu item
          var dmiA = dmi.children('a'); // Anchor inside of "Diffed" menu item
          var omiA = omi.children('a'); // Anchor inside of "Original" menu item
          var dmiID = dmi.attr('id');
          var dmiAID = dmiA.attr('id');

          // replace menu item ids with spillover-menu specific ids.
          if (dmiID) {
            dmi.removeAttr('id').attr('data-original-menu-item', dmiID);
          }
          if (dmiAID) {
            dmiA.removeAttr('id').attr('data-original-menu-anchor', dmiAID);
          }

          omiA.data('action-button-link', dmiA);
          dmiA.data('original-button', omiA);

          var omiSubMenu = omi.children('.wrapper').children('.popupmenu');
          var dmiSubMenu = dmi.children('.wrapper').children('.popupmenu');

          if (omiSubMenu.length && dmiSubMenu.length) {
            addItemLinksRecursively(omiSubMenu, dmiSubMenu, dmi);
          }
        });

        diffMenu.removeAttr('id').attr('data-original-menu', id);
        parentItem.addClass('submenu');

        var appendTarget = void 0;
        if (parentItem.is(popupLi)) {
          appendTarget = parentItem.children('.wrapper');
          if (!appendTarget || !appendTarget.length) {
            appendTarget = $('<div class="wrapper"></div>');
          }
          appendTarget.html(diffMenu);
          parentItem.append(appendTarget);
        }
      }

      if (item.is('.btn-menu')) {
        if (!item.data('popupmenu')) {
          item.popupmenu();
        } else if (!a.children('.icon.arrow').length) {
          a.append($.createIcon({
            classes: 'icon arrow icon-dropdown',
            icon: 'dropdown'
          }));
        }

        var menu = item.data('popupmenu').menu;
        var diffMenu = menu.clone();

        addItemLinksRecursively(menu, diffMenu, popupLi);
      }

      if (item.is('[data-popdown]')) {
        item.popdown();
      }

      return popupLi;
    },


    /**
     * Refreshes the More Actions Menu items' text content, icons, states, and submenu content
     * based on changes made directly to their counterpart elements in the Toolbar.  Can also
     * optionally refresh only part of the menu.
     * @param {jQuery[]} menu the menu/submenu to be refreshed.
     */
    refreshMoreActionsMenu: function refreshMoreActionsMenu(menu) {
      var self = this;

      $('li > a', menu).each(function () {
        var a = $(this);
        var li = a.parent();
        var item = a.data('originalButton');
        var itemParent = void 0;
        var text = self.getItemText(item);
        var submenu = void 0;

        if (item) {
          if (a.find('span').length) {
            a.find('span').text(text.trim());
          } else {
            a.text(text.trim());
          }

          if (item.isHiddenAtBreakpoint() || item.parent().isHiddenAtBreakpoint()) {
            li.addClass('hidden');
          } else {
            li.removeClass('hidden');
          }

          if (item.parent().is('.is-disabled') || item.is(':disabled')) {
            // if it's disabled menu item, OR a disabled menu-button
            li.addClass('is-disabled');
            a.prop('disabled', true);
            a.attr('tabindex', '-1');
          } else {
            li.removeClass('is-disabled');
            a.prop('disabled', false);
          }

          if (item.is('a')) {
            itemParent = item.parent('li');

            if (itemParent.is('.is-checked')) {
              li.addClass('is-checked');
            } else {
              li.removeClass('is-checked');
            }
          }

          if (item.is('.btn-menu')) {
            submenu = a.parent().find('.popupmenu').first();
            self.refreshMoreActionsMenu(submenu);
          }
        }
      });
    },


    /**
     * Gets the complete text contnts of a Toolbar Item, in order to create its
     * corresponding "more actions" menu item.
     *
     * Order of operations for populating the List Item text:
     * 1. span contents (.audible), then
     * 2. button title attribute, then
     * 3. tooltip text (if applicable)
     * @param {jQuery[]} item the item being evaluated.
     * @returns {string} the complete text representation.
     */
    getItemText: function getItemText(item) {
      if (!item) {
        return '';
      }
      var span = item.find('span').first();
      var title = item.attr('title');
      var tooltip = item.data('tooltip');
      var tooltipText = tooltip && typeof tooltip.content === 'string' ? tooltip.content : undefined;
      var popupLiText = void 0;

      if (title !== '' && title !== undefined) {
        popupLiText = title;
      } else if (tooltipText) {
        popupLiText = tooltipText;
      } else if (span.length) {
        popupLiText = span.text();
      } else {
        popupLiText = item.text();
      }

      return xssUtils.stripHTML(popupLiText);
    },


    /**
     * Sets up all necessary event handling on a Toolbar component
     * @private
     * @chainable
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.items.off('keydown.toolbar').on('keydown.toolbar', function (e) {
        self.handleKeys(e);
      }).off('click.toolbar').on('click.toolbar', function (e) {
        self.handleClick(e);
      });

      this.items.filter('.btn-menu, .btn-actions').off('close.toolbar').on('close.toolbar', function onClosePopup() {
        var el = $(this);
        var last = void 0;

        if (el.is('.is-overflowed')) {
          last = self.getLastVisibleButton();
          if (last && last.length) {
            last[0].focus();
          }
          return;
        }

        if (document.activeElement && document.activeElement.tagName === 'INPUT') {
          return;
        }
        el.focus();
        self.buttonset.scrollTop(0);
      });

      this.items.not(this.more).off('selected.toolbar').on('selected.toolbar', function (e, anchor) {
        e.stopPropagation();
        self.handleSelected(e, anchor);
      });

      this.more.on('keydown.toolbar', function (e) {
        self.handleKeys(e);
      }).on('beforeopen.toolbar', function () {
        self.adjustMenuItemVisibility();
      }).on('selected.toolbar', function (e, anchor) {
        e.stopPropagation();
        self.handleSelected(e, anchor);
      });

      // Handle possible AJAX calls on Toolbar Menu buttons
      // TODO: Need to handle mouseenter/touchstart/keydown events that will cause this to trigger,
      // instead of directly handling this itself.
      this.more.off('show-submenu.toolbar').on('show-submenu.toolbar', function (e, li) {
        self.handleTransferToMenuButtonItem(e, li);
      });

      this.element.off('updated.toolbar').on('updated.toolbar', function (e, settings) {
        e.stopPropagation();
        self.updated(settings);
      }).off('recalculate-buttons.toolbar').on('recalculate-buttons.toolbar', function (e, containerDims) {
        self.handleResize(containerDims);
      }).off('scrollup.toolbar').on('scrollup.toolbar', function () {
        var moduleTabsParent = self.element.parents('.tab-container.module-tabs');
        if (moduleTabsParent.length) {
          moduleTabsParent.scrollTop(0);
        }
      });

      $('body').off('resize.toolbar-' + this.id).on('resize.toolbar-' + this.id, function () {
        self.handleResize();
      });

      // Trigger _handleResize()_ once to fix container sizes.
      this.handleResize();

      return this;
    },


    /**
     * Event Handler for the Soho Popupmenu's custom 'show-submenu' event, specifically for
     * the case of a menu button that's been spilled over into this Toolbar's More Actions menu.
     * @param {jQuery.Event} e custom `show-submenu` jQuery event
     * @param {jQuery[]} li the `li.submenu` element.
     */
    handleTransferToMenuButtonItem: function handleTransferToMenuButtonItem(e, li) {
      var originalMenuButton = li.children('a').data('original-button');
      if (!originalMenuButton) {
        return;
      }

      var popupAPI = originalMenuButton.data('popupmenu');
      if (!popupAPI || typeof popupAPI.settings.beforeOpen !== 'function') {
        return;
      }

      // Call out to the MenuButton's AJAX source, get its contents, and populate
      // the corresponding More Actions menu sub-item.
      popupAPI.callSource(e);
      this.buildMoreActionsMenuItem(originalMenuButton);
    },


    /**
     * Event handler for the Soho `selected` event on toolbar items
     * @private
     * @param {jQuery.Event} e custom `selected` event
     * @param {jQuery[]} anchor a reference to the anchor that was selected
     * @returns {void}
     */
    handleSelected: function handleSelected(e, anchor) {
      var itemLink = anchor.data('original-button');
      var li = anchor.parent();
      var itemEvts = void 0;
      var toolbarEvts = void 0;
      var popup = void 0;
      var popupTrigger = void 0;

      // Don't continue if hidden/readonly/disabled
      if (li.is('.hidden, .is-disabled') || anchor.is('[readonly], [disabled]')) {
        e.preventDefault();
        return;
      }

      if (itemLink && itemLink.length > 0) {
        itemEvts = itemLink.listEvents();
        toolbarEvts = this.element.listEvents();

        // Make sure the active button is set properly
        this.setActiveButton(itemLink);

        // Handle popdowns with a custom placement algorithm that correctly pops the menu
        // open against the "More Actions" button instead of in an empty space
        // SOHO-7087
        if (itemLink.is('[data-popdown]')) {
          popupTrigger = itemLink.data('popdown');

          if (this.isItemOverflowed(itemLink)) {
            popupTrigger.settings.trigger = this.more;
            popupTrigger.updated();
          }
        }

        // Fire Angular Events
        if (itemLink.attr('ng-click') || itemLink.attr('data-ng-click')) {
          itemLink.trigger('click');
          return;
        }

        // Check the Toolbar Button for the existence of certain event types.
        // Checks the button, and checks the toolbar container element for delegated events.
        var evtTypes = ['click', 'touchend', 'touchcancel'];
        for (var i = 0; i < evtTypes.length; i++) {
          var type = evtTypes[i];

          // Check toolbar element for delegated-down events first
          if (toolbarEvts && toolbarEvts[type] && toolbarEvts[type].delegateCount > 0) {
            var el = this.element;
            var evt = $.Event(type);

            evt.target = el.find(itemLink)[0];
            el.trigger(evt);
            return;
          }

          // Check for events directly on the element
          if (itemEvts && itemEvts[type] || itemLink[0]['on' + type]) {
            itemLink.trigger(type);
            return;
          }
        }

        // If the linked element is a child of a menu button, trigger its 'selected' event.
        popup = itemLink.parents('.popupmenu');
        popupTrigger = popup.data('trigger');
        if (popup.length && popupTrigger instanceof $ && popupTrigger.length) {
          popupTrigger.triggerHandler('selected', [itemLink]);
          return;
        }

        // Manually Trigger Select on the linked item, since it won't be done by another event
        this.triggerSelect(itemLink);
        return;
      }

      // If no item link exists, it's a pre-defined menu item.
      // Trigger 'selected' manually on the toolbar element.
      // Normally this would happen by virtue of triggering the "click"
      // handlers on a linked button above.
      this.triggerSelect(anchor);
    },


    /**
     * Event handler for clicks on toolbar items
     * @private
     * @listens {jQuery.Event} e
     * @param {jQuery.Event} e jQuery click event
     * @returns {boolean} basic "false" return expected for click events
     */
    handleClick: function handleClick(e) {
      this.setActiveButton($(e.currentTarget));
      this.triggerSelect($(e.currentTarget));
      return false;
    },


    /**
     * Event handler for key presses on toolbar items
     * @private
     * @listens {jQuery.Event} e
     * @param {jQuery.Event} e `keypress` event
     * @returns {void}
     */
    handleKeys: function handleKeys(e) {
      var self = this;
      var key = e.which;
      var target = $(e.target);
      var isActionButton = target.is('.btn-actions');
      var isRTL = Locale.isRTL();

      if (key === 37 && target.is(':not(input)') || key === 38 && target.is(':not(input.is-open)')) {
        // Don't navigate away if Up Arrow in autocomplete field that is open
        e.preventDefault();

        if (isActionButton) {
          self.setActiveButton(isRTL ? self.getFirstVisibleButton() : self.getLastVisibleButton());
        } else {
          self.navigate(isRTL ? 1 : -1);
        }
      }

      if (key === 39 && target.is(':not(input)') || key === 40 && target.is(':not(input.is-open)')) {
        // Don't navigate away if Down Arrow in autocomplete field that is open
        e.preventDefault();

        if (isActionButton) {
          self.setActiveButton(isRTL ? self.getLastVisibleButton() : self.getFirstVisibleButton());
        } else {
          self.navigate(isRTL ? -1 : 1);
        }
      }
    },


    /**
     * Re-renders the toolbar element and adjusts all internal parts to account for the new size.
     * @param {object} [containerDims] an object containing dimensions that can be set
     *  on the Toolbar's title and buttonset elements.
     * @param {number} [containerDims.title] represents the width that will be applied
     *  to the title element
     * @param {number} [containerDims.buttonset] represents the width that will be
     *  applied to the buttonset element
     * @returns {void}
     */
    handleResize: function handleResize(containerDims) {
      if (this.settings.resizeContainers) {
        var title = containerDims ? containerDims.title : undefined;
        var buttonset = containerDims ? containerDims.buttonset : undefined;

        this.sizeContainers(title, buttonset);
      }

      var buttons = this.getButtonsetButtons();
      for (var i = 0; i < buttons.length; i++) {
        buttons[i].removeClass('is-overflowed');
      }

      if (this.element.is(':not(:hidden)')) {
        this.adjustMenuItemVisibility();
        this.toggleMoreMenu(); // Added 9/16/2015 due to issue HFC-2876
      }
    },


    /**
     * Resizes the Toolbar's internal container areas (title, buttonset) to make
     * efficient use of their space.
     * @private
     * @chainable
     * @param {number} titleSize desired size of the title element.
     * @param {number} buttonsetSize desired size of the buttonset element.
     */
    sizeContainers: function sizeContainers(titleSize, buttonsetSize) {
      var containerElem = this.element[0];
      var titleElem = this.title[0];
      var buttonsetElem = this.buttonset[0];
      var moreElem = this.more[0];

      // Don't do this at all unless we have a title element (which is optional)
      if (!this.title || !this.title.length) {
        return;
      }

      // If the element's hidden and has defined sizes, remove them so we can use the defaults.
      if (this.element.is(':hidden')) {
        buttonsetElem.style.width = '';
        titleElem.style.width = '';
        containerElem.classList.remove('do-resize');
        return;
      }

      var WHITE_SPACE = 30;
      var MIN_TITLE_SIZE = 44 + WHITE_SPACE;
      var MIN_BUTTONSET_SIZE = 0;

      buttonsetElem.style.width = '';
      titleElem.style.width = '';

      if (!containerElem.classList.contains('do-resize')) {
        containerElem.classList.add('do-resize');
      }

      var toolbarDims = $(containerElem).getHiddenSize();
      var buttonsetDims = $(buttonsetElem).getHiddenSize();
      var titleDims = $(titleElem).getHiddenSize();
      var moreDims = $(moreElem).getHiddenSize();
      var toolbarPadding = parseInt(toolbarDims.padding.left, 10) + parseInt(toolbarDims.padding.right, 10);

      if (isNaN(moreDims.width)) {
        moreDims.width = 50;
      }

      if (isNaN(buttonsetDims.width) || buttonsetDims.width < MIN_BUTTONSET_SIZE) {
        buttonsetDims.width = MIN_BUTTONSET_SIZE;
      }

      function addPx(val) {
        return val + 'px';
      }

      // Get the target size of the title element
      var self = this;
      var hasTitleSizeGetter = titleSize !== undefined && !isNaN(titleSize);
      var hasButtonsetSizeGetter = buttonsetSize !== undefined && !isNaN(buttonsetSize);
      var d = void 0;
      this.cutoffTitle = false;

      // Determine the target sizes for title, based on external setters,
      //  or building an estimated size.
      function getTargetTitleWidth() {
        if (hasTitleSizeGetter) {
          return parseInt(titleSize, 10);
        }
        if (self.settings.favorButtonset === true) {
          return toolbarDims.width - (toolbarPadding + (hasButtonsetSizeGetter ? parseInt(buttonsetSize, 10) : buttonsetDims.width) + moreDims.width);
        }
        return titleDims.scrollWidth;
      }
      var targetTitleWidth = getTargetTitleWidth();

      // Determine the target sizes for buttonset
      function getTargetButtonsetWidth() {
        if (hasButtonsetSizeGetter) {
          return parseInt(buttonsetSize, 10);
        }
        if (self.settings.favorButtonset === true) {
          return buttonsetDims.width;
        }
        return toolbarDims.width - (toolbarPadding + (hasTitleSizeGetter ? parseInt(titleSize, 10) : titleDims.scrollWidth) + moreDims.width);
      }
      var targetButtonsetWidth = getTargetButtonsetWidth();

      if (this.settings.favorButtonset) {
        // Cut off the buttonset anyway if title is completely hidden.  Something's gotta give!
        if (targetTitleWidth < MIN_TITLE_SIZE) {
          this.cutoffTitle = true;
          d = Math.abs(targetTitleWidth - MIN_TITLE_SIZE);
          targetTitleWidth = MIN_TITLE_SIZE;
          targetButtonsetWidth -= d;
        }

        buttonsetElem.style.width = addPx(targetButtonsetWidth + 2);
        titleElem.style.width = addPx(targetTitleWidth - 2);

        // Recheck if title is overflowed to ellipsis
        if (titleElem.textContent && targetTitleWidth < stringUtils.textWidth(titleElem.textContent.trim())) {
          this.cutoffTitle = true;
        }

        return;
      }
      //= =========================
      // Favor the title element
      // Cut off the title anyway if buttonset is completely hidden.  Something's gotta give!
      if (targetButtonsetWidth < MIN_BUTTONSET_SIZE) {
        this.cutoffTitle = true;
        d = Math.abs(targetButtonsetWidth - MIN_BUTTONSET_SIZE);
        targetButtonsetWidth = MIN_BUTTONSET_SIZE;
        targetTitleWidth -= d;
      }

      // Always favor the title by one extra px for Chrome
      titleElem.style.width = addPx(targetTitleWidth + 2);
      buttonsetElem.style.width = addPx(targetButtonsetWidth - 2);
    },


    /**
     * Changes the "active" button on the toolbar.
     * @param {number} direction can be `-1` (previous), `1` (next), or `0` (remain on current).
     * @returns {void}
     */
    navigate: function navigate(direction) {
      var items = this.items.filter(':visible:not(:disabled)');
      var current = items.index(this.activeButton);
      var next = current + direction;
      var target = void 0;

      if (next >= 0 && next < items.length) {
        target = items.eq(next);
      }

      if (next >= items.length) {
        target = items.first();
      }

      if (next === -1) {
        target = items.last();
      }

      if (this.isItemOverflowed(target)) {
        target = this.more;
      }

      this.setActiveButton(target);
    },


    /**
     * Gets a reference to the last visible (not overflowed) button inside of the buttonset.
     * @returns {jQuery[]} the last visible button in the buttonset.
     */
    getLastVisibleButton: function getLastVisibleButton() {
      var items = $(this.items.get().reverse()).not(this.more);
      var target = void 0;
      var i = 0;
      var elem = void 0;

      while (!target && i < items.length) {
        elem = $(items[i]);
        if (!this.isItemOverflowed(elem)) {
          target = elem;
          break;
        }
        i++;
      }

      if (!target || target.length === 0) {
        target = items.first();
      }

      while (target.length && target.is('.separator, *:disabled, *:hidden')) {
        target = target.prev();
      }

      return target;
    },


    /**
     * Gets a reference to the first visible (not overflowed) button inside of the buttonset.
     * @returns {jQuery[]} the first visible button in the buttonset.
     */
    getFirstVisibleButton: function getFirstVisibleButton() {
      var i = 0;
      var items = this.items;
      var target = items.eq(i);

      while (target.is('.separator, *:disabled, *:hidden')) {
        i++;
        target = items.eq(i);
      }

      return target;
    },


    /**
     * Sets the currently "active" (focused) Toolbar item
     * @param {jQuery[]} activeButton the preferred target element to make active.
     * @param {boolean} [noFocus] if defined, prevents this method from giving focus
     *  to the new active button.
     */
    setActiveButton: function setActiveButton(activeButton, noFocus) {
      // Return out of this if we're clicking the currently-active item
      if (activeButton[0] === this.activeButton[0]) {
        return;
      }

      var self = this;

      function getMoreOrLast() {
        if (self.hasNoMoreButton() || !self.element.hasClass('has-more-button')) {
          return self.getLastVisibleButton();
        }

        return self.more;
      }

      function getActiveButton() {
        // Menu items simply set the "More Actions" button as active
        if (activeButton.is('a')) {
          return getMoreOrLast();
        }

        // If it's the more button, hide the tooltip and set it as active
        var tooltip = self.more.data('tooltip');
        if (activeButton[0] === self.more[0]) {
          if (tooltip && tooltip.tooltip.is(':not(.hidden)')) {
            tooltip.hide();
          }
          return getMoreOrLast();
        }

        // Overflowed items also set
        if (self.isItemOverflowed(activeButton)) {
          if (!activeButton.is('.searchfield')) {
            return getMoreOrLast();
          }
        }

        return activeButton;
      }

      this.items.add(this.more).attr('tabindex', '-1').removeClass('is-selected');

      this.activeButton = getActiveButton();
      this.activeButton.addClass('is-selected').attr('tabindex', '0');

      if (!noFocus && this.activeButton[0]) {
        this.activeButton[0].focus();

        /**
         * Fires when the Toolbar's currently `active` element has changed.
         *
         * @event navigate
         * @memberof Toolbar
         * @param {jQuery.Event} e the jQuery Event object
         * @param {jQuery} activeButton a reference to the new active button.
         */
        this.element.triggerHandler('navigate', [this.activeButton]);
      }
    },


    /**
     * Triggers a "selected" event on the base Toolbar element using a common element as an argument.
     * @param {HTMLElement|SVGElement|jQuery[]} element a jQuery Object containing an
     *  anchor tag, button, or input field.
     */
    triggerSelect: function triggerSelect(element) {
      var elem = $(element);
      if (elem.is(this.more) || elem.is('.btn-menu, li.submenu')) {
        return;
      }

      /**
       * Fires when a Toolbar item is selected.
       *
       * @event selected
       * @memberof Toolbar
       * @property {jQuery.Event} e the jQuery event object
       * @property {jQuery[]} itemLink a reference to the corresponding toolbar item, wrapped in a jQuery selector
       */
      this.element.triggerHandler('selected', [elem]);
    },


    /**
     * Assembles and returns a list of all buttons inside the Buttonset element.
     * @returns {array} of elements inside the buttonset
     */
    getButtonsetButtons: function getButtonsetButtons() {
      var buttons = [];
      var items = this.buttonsetItems;
      var item = void 0;

      for (var i = 0; i < items.length; i++) {
        item = items.eq(i);
        if (item.data('action-button-link') !== undefined && item.is(':not(.searchfield)')) {
          buttons.push(item);
        }
      }

      return buttons;
    },


    /**
     * Gets and Iterates through a list of toolbar items and determines which are
     * currently overflowed, and which are visible.
     * @param {array} buttons an Array of jQuery-wrapped elements that represents toolbar items.
     * @returns {object} containing a `visible` items array, and a `hidden` items array.
     */
    getVisibleButtons: function getVisibleButtons(buttons) {
      var self = this;
      var hiddenButtons = [];
      var visibleButtons = [];

      if (!buttons || !Array.isArray(buttons)) {
        buttons = this.getButtonsetButtons();
      }

      for (var i = 0; i < buttons.length; i++) {
        buttons[i][0].classList.remove('is-overflowed');
      }

      function getButtonVisibility(button) {
        if (!self.isItemOverflowed(button)) {
          visibleButtons.push(button);
        } else {
          hiddenButtons.push(button);
        }
      }

      for (var _i = 0; _i < buttons.length; _i++) {
        getButtonVisibility(buttons[_i]);
      }

      return {
        visible: visibleButtons,
        hidden: hiddenButtons
      };
    },


    /**
     * Gets and Iterates through the full list of Toolbar Items and determines which
     *  ones should currently be present in the More Actions menu.
     * @private
     * @param {object} items an object (normally generated by `_.getVisibleButtons()`)
     *  containing arrays of currently visible and hidden buttons, along with some meta-data.
     * @returns {void}
     */
    adjustMenuItemVisibility: function adjustMenuItemVisibility(items) {
      var iconDisplay = 'removeClass';

      if (!items) {
        items = this.getVisibleButtons();
      }

      function toggleClass($elem, doHide) {
        var elem = $elem[0];
        var li = $elem.data('action-button-link').parent()[0];
        var elemIsHidden = $elem.isHiddenAtBreakpoint();

        if (doHide) {
          li.classList.add('hidden');
          elem.classList.remove('is-overflowed');
          return;
        }

        if (!elemIsHidden) {
          li.classList.remove('hidden');
        }
        elem.classList.add('is-overflowed');

        if ($elem.find('.icon').length) {
          iconDisplay = 'addClass';
        }
      }

      var i = 0;
      for (i; i < items.visible.length; i++) {
        toggleClass(items.visible[i], true);
      }
      for (i = 0; i < items.hidden.length; i++) {
        toggleClass(items.hidden[i], false);
      }

      var numIcons = 0;
      this.moreMenu.find('.icon').each(function () {
        if (!$(this).parent().parent().hasClass('hidden')) {
          numIcons++;
        }
      });

      if (numIcons > 0) {
        iconDisplay = 'addClass';
      }

      this.moreMenu[iconDisplay]('has-icons');
    },


    /**
     * Detects whether or not a toolbar item is currently overflowed.  In general,
     *  toolbar items are considered overflow if their right-most edge sits past the
     *  right-most edge of the buttonset border.  There are some edge-cases.
     * @param {jQuery[]} item the Toolbar item being tested.
     * @returns {boolean} whether or not the item belongs in the More Actions menu
     */
    isItemOverflowed: function isItemOverflowed(item) {
      // No items will be overflowed if the `More Actions` menu is purposefully disabled.
      if (this.moreButtonIsDisabled()) {
        return false;
      }

      if (!item || item.length === 0) {
        return true;
      }

      var itemIndexInButtonset = this.buttonsetItems.filter(':not(.hidden)').index(item);
      var maxVisibleButtons = this.settings.maxVisibleButtons;

      // the `maxVisibleButtons` calculation should include a visible More Actions button.
      // Subtract one from the `maxVisibleButtons` setting to account for the More Button,
      // if it's visible. See SOHO-7237
      if (this.moreButtonIsVisible()) {
        maxVisibleButtons -= 1;
      }

      // In cases where a Title is present and buttons are right-aligned,
      // only show up to the maximum allowed.
      if (this.title.length) {
        if (itemIndexInButtonset >= maxVisibleButtons) {
          return true;
        }
      }

      if (this.buttonset.scrollTop() > 0) {
        this.buttonset.scrollTop(0);
      }

      // unwrap from jQuery
      if (item instanceof $ && item.length) {
        item = item[0];
      }

      var classList = item.classList;
      var style = window.getComputedStyle(item);

      if (classList.contains('btn-actions')) {
        return true;
      }
      if (classList.contains('searchfield')) {
        return false;
      }
      if (style.display === 'none') {
        return true;
      }

      var isRTL = Locale.isRTL();
      var itemRect = item.getBoundingClientRect();
      var buttonsetRect = this.buttonset[0].getBoundingClientRect();
      var itemOutsideXEdge = isRTL ? itemRect.left <= buttonsetRect.left : itemRect.right >= buttonsetRect.right;
      var itemBelowYEdge = itemRect.bottom >= buttonsetRect.bottom;

      return itemBelowYEdge === true || itemOutsideXEdge === true;
    },


    /**
     * @returns {boolean} whether or not this toolbar is able to have a More Button
     */
    moreButtonIsDisabled: function moreButtonIsDisabled() {
      return this.element[0].classList.contains('no-actions-button');
    },


    /**
     * Detection for this toolbar to have a More Button
     * This method is slated to be removed in a future v4.10.0 or v5.0.0.
     * @deprecated as of v4.4.0. Please use `moreButtonIsDisabled()` instead.
     * @returns {boolean} whether or not the More Actions button is disabled.
     */
    hasNoMoreButton: function hasNoMoreButton() {
      return deprecateMethod(this.moreButtonIsDisabled, this.hasNoMoreButton).apply(this);
    },


    /**
    * Detection for whether or not More Actions menu is currently visible.  This is
    * different than the More Actions menu being disabled.  This check determines
    * whether or not items have spilled over, causing the menu to be shown or hidden.
    * @returns {boolean} whether or not More Actions menu is currently visible.
    */
    moreButtonIsVisible: function moreButtonIsVisible() {
      return this.element[0].classList.contains('has-more-button');
    },


    /**
     * Determines whether or not the "more actions" button should be displayed.
     * @private
     * @returns {undefined} whether or not the "more actions" button should be displayed.
     */
    toggleMoreMenu: function toggleMoreMenu() {
      if (this.moreButtonIsDisabled()) {
        return;
      }

      var overflowItems = this.moreMenu.children('li:not(.separator)');
      var hiddenOverflowItems = overflowItems.not('.hidden');

      var method = 'removeClass';
      if (hiddenOverflowItems.length > 0) {
        method = 'addClass';
      }

      this.element[method]('has-more-button');

      var popupAPI = this.more.data('popupmenu');
      if (method === 'removeClass') {
        if (!popupAPI) {
          return;
        }

        popupAPI.close();

        var menuItems = popupAPI.menu.find('li:not(.separator)').children('a');
        var shouldFocus = false;

        menuItems.add(this.more).each(function () {
          if (document.activeElement === this) {
            shouldFocus = true;
          }
        });

        if (shouldFocus) {
          var lastVisibleButton = this.getLastVisibleButton()[0];
          if (lastVisibleButton) {
            lastVisibleButton.focus();
          }
        }
      }
    },


    /**
     * Creates an `aria-label` attribute on the toolbar, for bettery accessibility.
     * Based on AOL Access Guidelines:
     * http://access.aol.com/dhtml-style-guide-working-group/#toolbar
     * @private
     * @returns {void}
     */
    buildAriaLabel: function buildAriaLabel() {
      // Don't re-build if one already exists.
      if (this.element.attr('aria-label')) {
        return;
      }

      var isHeader = this.element.closest('.header').length === 1;
      var id = this.element.attr('id') || '';
      var title = this.element.children('.title');
      var prevLabel = this.element.prev('label');
      var prevSpan = this.element.prev('.label');

      function getLabelText() {
        if (isHeader) {
          return $('header.header').find('h1').text();
        }
        if (title.length) {
          return title.filter('div').text();
        }
        if (prevLabel.length) {
          return prevLabel.text();
        }
        if (prevSpan.length) {
          return prevSpan.text();
        }
        return id + ' ' + Locale.translate('Toolbar');
      }
      var labelText = getLabelText();

      this.element.attr('aria-label', labelText.replace(/\s+/g, ' ').trim());
    },


    /**
     * @param {object} [settings] incoming different settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.unbind().teardown().init();
    },


    /**
     * Enables the entire Toolbar component
     * @returns {void}
     */
    enable: function enable() {
      this.element.prop('disabled', false);
      this.items.prop('disabled', false);
      this.more.prop('disabled', false);
    },


    /**
     * Disables the entire Toolbar component
     * @returns {void}
     */
    disable: function disable() {
      this.element.prop('disabled', true);
      this.items.prop('disabled', true);
      this.more.prop('disabled', true).data('popupmenu').close();
    },


    /**
     * Removes currently associated event listeners from the Toolbar.
     * @private
     * @chainable
     * @returns {this} component instance
     */
    unbind: function unbind() {
      this.items.off('keydown.toolbar click.toolbar focus.toolbar blur.toolbar');

      this.more.off('keydown.toolbar beforeopen.toolbar selected.toolbar');
      $('body').off('resize.toolbar-' + this.id);
      return this;
    },


    /**
     * Returns the Toolbar's internal markup to its original state.
     * @chainable
     * @returns {this} component instance
     */
    teardown: function teardown() {
      var self = this;

      if (this.title && this.title.length) {
        var dataTooltip = this.title.off('beforeshow.toolbar').data('tooltip');
        if (dataTooltip) {
          dataTooltip.destroy();
        }
      }

      var moreMenuChildren = this.moreMenu.children('li');
      moreMenuChildren.each(function () {
        self.teardownMoreActionsMenuItem($(this), true);
      });

      // Remove AJAX-ified menu items.
      moreMenuChildren.not(this.defaultMenuItems).remove();

      return this;
    },


    /**
     * Tears down a More Actions Menu item.
     * @private
     * @param {jQuery[]} item the existing <li> from inside the More Actions menu.
     * @param {boolean} doRemove if defined, causes the list item to be removed from
     *  the more actions menu.
     */
    teardownMoreActionsMenuItem: function teardownMoreActionsMenuItem(item, doRemove) {
      var self = this;
      var li = $(item);
      var a = li.children('a');
      var itemLink = a.data('original-button');

      a.off('updated.toolbar mousedown.toolbar click.toolbar touchend.toolbar touchcancel.toolbar recalculate-buttons.toolbar');

      var icons = li.find('.icon');
      if (icons.length) {
        icons.remove();
      }

      var submenuContainer = void 0;
      if (li.is('.submenu')) {
        submenuContainer = li.children('.wrapper').children('.popupmenu');
        submenuContainer.children('li').each(function () {
          self.teardownMoreActionsMenuItem($(this), true);
        });
      }

      if (itemLink && itemLink.length) {
        $.removeData(a[0], 'original-button');
        $.removeData(itemLink[0], 'action-button-link');
        a.remove();

        if (submenuContainer) {
          submenuContainer.off().parent('.wrapper').off().remove();
        }

        if (doRemove) {
          li.remove();
        }
      }
    },


    /**
     * Destroys this Toolbar Component instance and completely disassociates it from
     *  its corresponding DOM Element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind().teardown();

      if (this.buttonset.children('.searchfield-wrapper').length) {
        var searchFields = this.buttonset.children('.searchfield-wrapper').children('.searchfield');
        if (searchFields.data('searchfield')) {
          searchFields.data('searchfield').destroy();
        }
      }

      if (this.more.length && this.more.data('popupmenu') !== undefined) {
        this.more.data('popupmenu').destroy();
      }

      this.element[0].classList.remove('do-resize');
      this.buttonset[0].style.width = '';
      if (this.title && this.title.length) {
        this.title[0].style.width = '';
      }

      this.element.removeAttr('role').removeAttr('aria-label');
      $.removeData(this.element[0], COMPONENT_NAME$11);
    }
  };

  /**
   * jQuery Component Wrapper for Toolbar
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.toolbar = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$11);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$11, new Toolbar(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$12 = 'toolbarflexitem';

  // Filters out buttons located inside of Searchfield wrappers.
  // Only `input` elements should be picked up by the item detector.
  function buttonFilter(elem) {
    var searchfieldWrapper = $(elem).parents('.searchfield-wrapper, .toolbar-searchfield-wrapper');
    return !searchfieldWrapper.length;
  }

  // Filters out hyperlinks that are part of menu/action button components
  function hyperlinkFilter(elem) {
    if (elem.nodeName !== 'A') {
      throw new Error('Unspecified error occured');
    }

    var wrapped = $(elem);
    return wrapped.parents('.popupmenu').length < 1;
  }

  // Toolbar Focusable Element Selectors.
  // Any of these element/class types are valid toolbar items.
  // TODO: Designate between "button" and "menu button"
  var TOOLBAR_ELEMENTS = [{ type: 'button', selector: 'button:not(.btn-menu):not(.btn-actions), input[type="button"]:not(.btn-menu):not(.btn-actions)', filter: buttonFilter }, { type: 'menubutton', selector: '.btn-menu' }, { type: 'actionbutton', selector: '.btn-actions' }, { type: 'hyperlink', selector: 'a[href]', filter: hyperlinkFilter }, { type: 'checkbox', selector: 'input[type="checkbox"]' }, { type: 'radio', selector: 'input[type="radio"]' }, { type: 'searchfield', selector: '.searchfield' }, { type: 'toolbarsearchfield', selector: '.toolbarsearchfield' // temporary
  }];

  // Mappings from toolbar item type to component API
  var TOOLBAR_COMPONENT_APIS = {
    actionbutton: 'popupmenu',
    menubutton: 'popupmenu',
    hyperlink: 'hyperlink',
    searchfield: 'searchfield',
    toolbarsearchfield: 'searchfield'
  };

  /**
   * Default Settings
   * @namespace
   */
  var TOOLBAR_FLEX_ITEM_DEFAULTS = {
    disabled: false,
    readOnly: false,
    hidden: false,
    componentSettings: undefined
  };

  /**
   * Gets the type of Toolbar Item that an element represents.
   * @param {HTMLElement} element being checked for a toolbar item.
   * @returns {string} representing the type
   */
  function getToolbarItemType(element) {
    var type = false;
    TOOLBAR_ELEMENTS.forEach(function (elemObj) {
      if (!$(element).is(elemObj.selector)) {
        return;
      }
      if (typeof elemObj.filter === 'function' && !elemObj.filter(element)) {
        return;
      }
      type = elemObj.type;
    });

    if (!type) {
      throw new Error('Element ' + element + ' is not a valid Toolbar Item Type.');
    }

    return type;
  }

  /**
   * Toolbar Item Wrapper Component
   * @constructor
   * @param {HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   */
  function ToolbarFlexItem(element, settings) {
    this.element = element;
    this.settings = utils.mergeSettings(this.element, settings, TOOLBAR_FLEX_ITEM_DEFAULTS);

    this.init();
  }

  ToolbarFlexItem.prototype = {

    /**
     * @property {string} type used to determine the type of toolbar item.  Certain toolbar item types
     *  have certain special properties.
     * @property {HTMLElement} section the parent toolbar section that this item is housed in.
     * @property {HTMLElement} toolbar the parent toolbar's base element.
     */
    type: undefined,

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      // internal flags
      this.type = getToolbarItemType(this.element);
      this.section = this.element.parentElement;
      this.toolbar = this.section.parentElement;
      this.trueSelected = false;
    },


    /**
     * @returns {boolean} whether or not the toolbar item is currently able to be focused, based
     *  on its `disabled`, `overflowed`, and `visible` properties.
     */
    get focusable() {
      if (this.disabled === true) {
        return false;
      }
      if (this.type === 'searchfield') {
        return true;
      }
      if (this.type === 'actionbutton' && this.hasNoOverflowedItems === true) {
        return false;
      }
      if (this.overflowed === true) {
        return false;
      }

      return this.visible;
    },

    /**
     * @returns {boolean} whether or not the toolbar item is the one that will currently be focused
     */
    get focused() {
      return this.element.tabIndex === 0;
    },

    /**
     * @param {boolean} boolean, if provided, sets a focused state on the toolbar item.
     * @returns {void}
     */
    set focused(boolean) {
      if (boolean) {
        this.element.tabIndex = 0;
        return;
      }
      this.element.tabIndex = -1;
    },

    /**
     * @returns {boolean} whether or not the Toolbar item is selected.
     */
    get selected() {
      return this.trueSelected;
    },

    /**
     * @param {boolean} boolean, if provided, sets a selected state on the toolbar item.
     * @returns {void}
     */
    set selected(boolean) {
      if (boolean) {
        this.trueSelected = true;
        this.element.classList.add('is-selected');
        this.triggerSelectedEvent();

        if (this.selectedAnchor) {
          delete this.selectedAnchor;
        }
        return;
      }
      this.trueSelected = false;
      this.element.classList.remove('is-selected');
    },

    /**
     * Retrieves an item's main Soho Component instance.
     * @returns {object} Soho Component instance, if applicable
     */
    get componentAPI() {
      var $element = $(this.element);
      var componentType = TOOLBAR_COMPONENT_APIS[this.type];

      if (!componentType) {
        return undefined;
      }

      return $element.data(componentType);
    },

    /**
     * @returns {ToolbarFlex} the parent toolbar API
     */
    get toolbarAPI() {
      if (this.settings.toolbarAPI) {
        return this.settings.toolbarAPI;
      }
      return $(this.toolbar).data('toolbar-flex');
    },

    /**
     * @fires selected
     * @returns {void}
     */
    triggerSelectedEvent: function triggerSelectedEvent() {
      // Searchfields aren't "selectable" in the same way actionable items are,
      // so they shouldn't fire the "selected" event.
      if (this.type === 'searchfield' || this.type === 'toolbarsearchfield') {
        return;
      }

      var eventArgs = [this];

      // MenuButton types pass the currently-selected anchor
      if ((this.type === 'menubutton' || this.type === 'actionbutton') && this.selectedAnchor) {
        eventArgs.push(this.selectedAnchor);
      }

      $(this.element).trigger('selected', eventArgs);
    },


    /**
     * Causes the toolbar item to become visible.
     * @returns {void}
     */
    show: function show() {
      this.visible = true;
    },


    /**
     * Causes the toolbar item to become hidden.
     * @returns {void}
     */
    hide: function hide() {
      this.visible = false;
    },


    /**
     * Toggles the Toolbar item's visiblity.
     * @param {boolean} boolean whether or not the `hidden` class should be set.
     */
    set visible(boolean) {
      // NOTE: Temporary until Searchfield handles this better internally.
      var isSearchfield = this.type === 'searchfield' || this.type === 'toolbarsearchfield';

      if (boolean) {
        if (isSearchfield) {
          this.element.parentNode.classList.remove('hidden');
        }
        this.element.classList.remove('hidden');
        return;
      }

      if (isSearchfield) {
        this.element.parentNode.classList.add('hidden');
      }
      this.element.classList.add('hidden');
    },

    /**
     * @returns {boolean} whether or not the Toolbar Item is visible.
     */
    get visible() {
      return this.element.className.indexOf('hidden') === -1;
    },

    /**
     * @returns {void}
     */
    enable: function enable() {
      this.disabled = false;
      if (this.hasReadOnly) {
        this.readOnly = false;
      }
    },


    /**
     * @returns {boolean} whether or not the element is disabled
     */
    get disabled() {
      return this.element.disabled;
    },

    /**
     * @param {boolean} boolean, if provided, sets a disabled state on the toolbar item.
     * @returns {void}
     */
    set disabled(boolean) {
      if (boolean) {
        this.element.disabled = true;
        this.element.setAttribute('aria-disabled', true);
        this.element.readOnly = false;
        return;
      }

      this.element.disabled = false;
      this.element.removeAttribute('aria-disabled');
    },

    /**
     * @returns {boolean} whether or not `readOnly` as a property exists on this HTMLElement type.
     */
    get hasReadOnly() {
      return 'readOnly' in this.element;
    },

    /**
     * @returns {boolean} element's readOnly prop
     */
    get readOnly() {
      if (!this.hasReadOnly) {
        return false;
      }
      return this.element.readOnly;
    },

    /**
     * @param {boolean} boolean, if provided, sets a readOnly state on the toolbar item, if possible.
     * @returns {void}
     */
    set readOnly(boolean) {
      if (!this.hasReadOnly) {
        return;
      }

      if (boolean) {
        this.disabled = false;
        this.element.disabled = false;
        this.element.readOnly = true;
        return;
      }

      this.element.readOnly = false;
    },

    /**
     * @returns {boolean} whether or not the item is pushed into overflow by the boundaries
     *  of its container element.
     */
    get overflowed() {
      var isRTL = Environment.rtl;
      var elemRect = this.element.getBoundingClientRect();
      var sectionRect = this.section.getBoundingClientRect();

      if (isRTL) {
        return elemRect.left < sectionRect.left;
      }
      return elemRect.right > sectionRect.right;
    },

    /**
     * @param {boolean} isTrue whether or not the more actions menu has overflowed items, causing it to become displayed
     * @returns {void}
     */
    set hasNoOverflowedItems(isTrue) {
      if (this.type !== 'actionbutton') {
        return;
      }

      var popupmenuLength = this.componentAPI.toData({ noMenuWrap: true }).length;
      var menuIsEmpty = popupmenuLength - this.predefinedItems.length < 1;

      if (isTrue && menuIsEmpty) {
        this.element.classList.add('no-overflowed-items');
        this.trueHasNoOverflowedItems = true;

        if (this.focused) {
          this.toolbarAPI.focusedItem = this;
          this.toolbarAPI.navigate(-1, undefined, true);
        }
        return;
      }
      this.trueHasNoOverflowedItems = false;
      this.element.classList.remove('no-overflowed-items');
    },

    /**
     *
     */
    get hasNoOverflowedItems() {
      if (!this.componentAPI) {
        return true;
      }
      return this.trueHasNoOverflowedItems;
    },

    /**
     * Sets up all event listeners for this element.
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      var $element = $(this.element);

      if (this.type === 'menubutton' || this.type === 'actionbutton') {
        // Listen to the Popupmenu's selected event
        $element.on('selected.' + COMPONENT_NAME$12, function (e, anchor) {
          if (_this.selectedAnchor) {
            return;
          }

          e.stopPropagation();

          if (_this.type === 'actionbutton') {
            var li = $(anchor).parent();
            var itemLink = li.data('originalButton');
            var itemLinkAPI = $(itemLink).data('toolbarflexitem');
            var elementLink = void 0;

            if (li.parents('ul').length > 1) {
              elementLink = li.data('original-menu-element');
              itemLink = li.parents('li').last().data('originalButton');
              itemLinkAPI = $(itemLink).data('toolbarflexitem');
            }

            // If this item is linked to another toolbar item, trigger its `selected` event instead
            // of the one on the item in this menu.
            if (itemLinkAPI) {
              if (elementLink) {
                e.preventDefault();
                itemLinkAPI.selectedAnchor = $(elementLink).children('a');
              } else {
                // case of a menu button overflowed into more actions
                itemLinkAPI.selectedAnchor = anchor;
              }
              itemLinkAPI.selected = true;
              return;
            }
          }

          self.selectedAnchor = anchor;
          self.selected = true;
        });
      }

      if (this.type === 'actionbutton') {
        $element.on('beforeopen.' + COMPONENT_NAME$12, this.handleActionButtonBeforeOpen.bind(this));
        $('body').off('resize.' + COMPONENT_NAME$12).on('resize.' + COMPONENT_NAME$12, this.handleActionButtonResize.bind(this));
      }

      $element.on('focus.' + COMPONENT_NAME$12, this.handleFocus.bind(this));
    },


    /**
     * If this element is an Action Button, this listener runs before its popupmenu is opened
     * To determine which elements need to be shown/hidden.
     * @private
     * @returns {void}
     */
    handleActionButtonBeforeOpen: function handleActionButtonBeforeOpen() {
      this.refreshMoreActionsMenu();
    },


    /**
     * If this element is an Action Button, this listener runs whenever Soho's custom resize event
     * on the `<body>` tag fires, to determine which elements need to be shown/hidden.
     * @private
     * @returns {void}
     */
    handleActionButtonResize: function handleActionButtonResize() {
      this.refreshMoreActionsMenu();
    },


    /**
     * @private
     * @param {FocusEvent} e `focus`
     * @returns {void}
     */
    handleFocus: function handleFocus(e) {
      if (e.target && e.target === this.element) {
        this.toolbarAPI.focusedItem = this;
      }
    },


    /**
     * Renders extra markup or anything else needed on the toolbar item
     * @returns {void}
     */
    render: function render() {
      this.disabled = this.disabled;
      if (this.hasReadOnly) {
        this.readonly = this.readonly;
      }

      // Setup component APIs, if applicable.
      // NOTE: Soho Initializer doesn't invoke these automatically, by nature of the
      // base elements existing inside the Flex Toolbar.
      var $element = $(this.element);
      var componentType = TOOLBAR_COMPONENT_APIS[this.type];
      if (componentType) {
        var api = $element.data(componentType);
        if (!api) {
          $element[componentType](this.settings.componentSettings);
        } else {
          api.updated(this.settings.componentSettings);
        }
      }

      // Action Buttons need more stuff
      if (this.type === 'actionbutton') {
        this.renderMoreActionsMenu();
        this.refreshMoreActionsMenu();
      }

      this.handleEvents();
    },


    /**
     * Uses data from Toolbar Items to build Toolbar-linked, pre-defined items for the More Actions menu.
     * NOTE: This method only runs when this toolbar item is a "More Actions" button
     * @private
     * @returns {void}
     */
    renderMoreActionsMenu: function renderMoreActionsMenu() {
      var menuAPI = this.componentAPI;
      if (!menuAPI || !this.toolbarAPI) {
        return;
      }

      // If the menu doesn't already exist, pre-define it.
      var $menu = menuAPI.menu;
      if (!$menu || !$menu.length) {
        $menu = $('<ul class="popupmenu"></ul>').insertAfter(this.element);
      }

      this.teardownPredefinedItems();

      // Add Toolbar Items
      var data = this.toolbarAPI.toPopupmenuData();
      var menuItems = $(menuAPI.renderItem(data));
      this.predefinedItems = menuItems;
      this.linkToolbarItems(data);

      // Notify the Popupmenu of predefined items
      $menu.prepend(this.predefinedItems);
      menuAPI.updated({
        menu: $menu,
        predefined: menuItems
      });

      this.menuRendered = true;
    },


    /**
     * Refreshes the state of menu items in a "More Actions" menu that were constructed by the Flex Toolbar.
     * @private
     * @returns {void}
     */
    refreshMoreActionsMenu: function refreshMoreActionsMenu() {
      if (this.type !== 'actionbutton') {
        return;
      }

      this.hasNoOverflowedItems = true;

      var menuAPI = this.componentAPI;
      if (!menuAPI || !this.toolbarAPI) {
        return;
      }

      // If there are toolbar items, but no predefined items, render the more-actions menu
      if ((!this.predefinedItems || !this.predefinedItems.length) && this.toolbarAPI.items.length) {
        this.renderMoreActionsMenu();
      }

      var hasNoOverflowedItems = true;

      // Called at the end of the item refresh.
      // Uses the Popupmenu's API to add overflow information.
      function itemRefreshCallback(menuItem, data) {
        if (data.isSubmenuItem) {
          return;
        }

        if (data.overflowed === true) {
          menuItem.classList.add('is-overflowed');

          if (data.visible) {
            menuItem.classList.remove('hidden');
          }

          hasNoOverflowedItems = false;
          return;
        }

        menuItem.classList.remove('is-overflowed');
        menuItem.classList.add('hidden');
      }

      // Each Linked Toolbar Item will be refreshed by the Popupmenu API
      this.toolbarAPI.items.forEach(function (item) {
        if (!item.actionButtonLink) {
          return;
        }

        var itemData = item.toPopupmenuData();
        itemData.overflowed = item.overflowed;

        menuAPI.refreshMenuItem(item.actionButtonLink, itemData, itemRefreshCallback);
      });

      // Set a record for display
      this.hasNoOverflowedItems = hasNoOverflowedItems;
    },


    /**
     * Removes links between the current set of Toolbar Items to `More Actions` menu items.
     * @private
     * @returns {void}
     */
    unlinkToolbarItems: function unlinkToolbarItems() {
      if (this.type !== 'actionbutton' || !this.menuRendered || !this.predefinedItems || !this.predefinedItems.length) {
        return;
      }

      function doUnlinkSubmenuItem(actionMenuElement) {
        var $originalMenuElement = $($(actionMenuElement).data('original-menu-element'));
        $originalMenuElement.removeData('action-button-link');
        $(actionMenuElement).removeData('original-menu-element');

        if ($originalMenuElement.hasClass('submenu')) {
          var submenuItems = actionMenuElement.querySelector('.popupmenu').children;
          for (var j = 0; j < submenuItems.length; j++) {
            doUnlinkSubmenuItem(submenuItems[j]);
          }
        }
      }

      function doUnlinkToolbarItems(i, itemElement) {
        var originalButton = $(itemElement).data('originalButton');
        var originalButtonAPI = $(originalButton).data('toolbarflexitem');

        originalButtonAPI.actionButtonLink = null;
        $(itemElement).removeData('original-button');

        if (originalButtonAPI.type === 'menubutton') {
          var submenuItems = itemElement.querySelector('.popupmenu').children;
          for (var j = 0; j < submenuItems.length; j++) {
            doUnlinkSubmenuItem(submenuItems[j]);
          }
        }
      }

      this.predefinedItems.each(doUnlinkToolbarItems);
    },


    /**
     * Links the current set of Toolbar Items to the `More Actions` menu items.
     * @private
     * @param {object} popupmenuData incoming popupmenu data
     * @returns {void}
     */
    linkToolbarItems: function linkToolbarItems(popupmenuData) {
      if (this.type !== 'actionbutton' || !popupmenuData) {
        return;
      }

      if (!Array.isArray(popupmenuData)) {
        popupmenuData = popupmenuData.menu;
      }

      function doLinkSubmenuItem(menuItemData, actionMenuElement) {
        var originalMenuElement = menuItemData.elementLink;
        $(originalMenuElement).data('action-button-link', actionMenuElement);
        $(actionMenuElement).data('original-menu-element', originalMenuElement);

        var submenu = menuItemData.submenu;
        if (submenu && submenu.length) {
          var submenuItems = actionMenuElement.querySelector('.popupmenu').children;
          for (var j = 0; j < submenuItems.length; j++) {
            doLinkSubmenuItem(submenu[j], submenuItems[j]);
          }
        }
      }

      function doLinkToolbarItems(i, itemElement) {
        var originalButtonAPI = popupmenuData[i].itemLink;
        originalButtonAPI.actionButtonLink = itemElement;
        $(itemElement).data('original-button', originalButtonAPI.element);

        var submenu = popupmenuData[i].submenu;
        if (submenu && submenu.length) {
          var submenuItems = itemElement.querySelector('.popupmenu').children;
          for (var j = 0; j < submenuItems.length; j++) {
            doLinkSubmenuItem(submenu[j], submenuItems[j]);
          }
        }
      }

      this.predefinedItems.each(doLinkToolbarItems);
    },


    /**
     * Converts the contents of the Toolbar Item to a data structure that's compatible with a Popupmenu component.
     * This data structure can be used to populate the contents of a "More Actions" menu.
     * @returns {object} an object representation of the Toolbar Item as a Popupmenu Item.
     */
    toPopupmenuData: function toPopupmenuData() {
      if (this.type === 'searchfield' || this.type === 'toolbarsearchfield' || this.type === 'actionbutton') {
        return undefined;
      }

      var itemData = {
        itemLink: this,
        disabled: this.disabled,
        visible: this.visible
      };

      var icon = this.element.querySelector('.icon:not(.close):not(.icon-dropdown) > use');
      if (icon) {
        itemData.icon = icon.getAttribute('xlink:href').replace('#icon-', '');
      }

      if (this.type === 'button' || this.type === 'menubutton') {
        itemData.text = this.element.textContent.trim();
      }

      function addMenuElementLinks(menu, data) {
        var elems = menu.querySelectorAll('li:not(.heading)');
        data.forEach(function (item, i) {
          item.elementLink = elems[i];
          if (item.submenu) {
            var submenu = elems[i].querySelector('.popupmenu');
            item.submenu = addMenuElementLinks(submenu, item.submenu);
          }
        });
        return data;
      }

      // Add links to the menubutton's menu item elements to the Popupmenu data
      if (this.type === 'menubutton') {
        var menuElem = this.componentAPI.menu;
        var originalSubmenuData = this.componentAPI.toData({ noMenuWrap: true });
        itemData.id = this.componentAPI.element[0].id;
        itemData.submenu = addMenuElementLinks(menuElem[0], originalSubmenuData);
      }

      return itemData;
    },


    /**
     * Converts the current state of the toolbar item to an object structure that can be
     * easily passed back/forth and tested.
     * @returns {object} containing the current Toolbar Item state.
     */
    toData: function toData() {
      var itemData = {
        type: this.type,
        disabled: this.disabled,
        focused: this.focused,
        selected: this.selected,
        overflowed: this.overflowed,
        visible: this.visible
      };

      if (this.hasReadOnly) {
        itemData.readOnly = this.readOnly;
      }

      if (this.actionButtonLink) {
        itemData.actionButtonLink = this.actionButtonLink;
      }

      if (this.componentAPI) {
        itemData.componentAPI = this.componentAPI;
      }

      var icon = this.element.querySelector('.icon:not(.close):not(.icon-dropdown) > use');
      if (icon) {
        itemData.icon = icon.getAttribute('xlink:href').replace('#icon-', '');
      }

      if (this.type === 'button' || this.type === 'menubutton') {
        itemData.text = this.element.textContent.trim();
      }

      if (this.type === 'actionbutton') {
        itemData.predefinedItems = this.predefinedItems;
      }

      if (this.type === 'menubutton' || this.type === 'actionbutton') {
        // TODO: Need to convert a Popupmenu's contents to the object format with this method
        itemData.submenu = this.componentAPI.toData({ noMenuWrap: true });
      }

      return itemData;
    },


    /**
     * Completely updates this component with (optional) new settings.
     * @param {object} [settings] incoming settings
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.teardown();
      this.init();
    },


    /**
     * @private
     * @returns {void}
     */
    teardownPredefinedItems: function teardownPredefinedItems() {
      if (this.type !== 'actionbutton') {
        return;
      }

      this.unlinkToolbarItems();
      if (this.predefinedItems && this.predefinedItems.length) {
        this.predefinedItems.remove();
      }
    },


    /**
     * Unbinds events and removes preset internal flags for this component.
     * @returns {void}
     */
    teardown: function teardown() {
      $(this.element).off('selected.' + COMPONENT_NAME$12).off('beforeopen.' + COMPONENT_NAME$12).off('focus.' + COMPONENT_NAME$12);

      $('body').off('resize.' + COMPONENT_NAME$12);

      this.teardownPredefinedItems();

      delete this.type;
      delete this.selected;
      delete this.focusable;
      delete this.visible;
      delete this.disabled;
      delete this.readOnly;

      delete this.section;
      delete this.toolbar;
      delete this.trueSelected;
      delete this.menuRendered;
    }
  };

  /**
   * jQuery component wrapper for Toolbar Flex Item Component
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.toolbarflexitem = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$12);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$12, new ToolbarFlexItem(this, settings));

        // Remove the jQuery Component reference from $.data
        var oldDestroy = instance.destroy;
        instance.destroy = function () {
          if (typeof oldDestroy === 'function') {
            oldDestroy.call(this);
          }
          $.removeData(this, COMPONENT_NAME$12);
        };
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$13 = 'toolbar-flex';

  /**
   * Component Default Settings
   * @namespace
   */
  var TOOLBAR_FLEX_DEFAULTS = {
    // ajax function to be called before the more menu is opened
    beforeMoreMenuOpen: null
  };

  /**
   * @constructor
   * @param {HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   */
  function ToolbarFlex(element, settings) {
    this.element = element;
    this.settings = utils.mergeSettings(this.element, settings, TOOLBAR_FLEX_DEFAULTS);

    this.init();
  }

  ToolbarFlex.prototype = {

    /**
     * @private
     */
    trueFocusedItem: undefined,

    sections: [],

    items: [],

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      var _this = this;

      this.sections = utils.getArrayFromList(this.element.querySelectorAll('.toolbar-section'));
      this.items = this.getElements().map(function (item) {
        var itemComponentSettings = {};
        if ($(item).hasClass('btn-actions') && !!_this.settings.beforeMoreMenuOpen) {
          itemComponentSettings.beforeOpen = _this.settings.beforeMoreMenuOpen;
        }
        $(item).toolbarflexitem({
          toolbarAPI: _this,
          componentSettings: itemComponentSettings
        });
        return $(item).data('toolbarflexitem');
      });

      if (!this.items) {
        return;
      }

      // Check for a focused item
      this.items.forEach(function (item) {
        if (item.focused) {
          if (_this.focusedItem === undefined) {
            _this.focusedItem = item;
          } else {
            item.focused = false;
          }
        }
      });
      if (!this.focusedItem) {
        this.focusedItem = this.items[0];
      }

      this.render();
      this.handleEvents();
    },


    /**
     * @returns {void}
     */
    render: function render() {
      this.element.setAttribute('role', 'toolbar');
      this.items.forEach(function (item) {
        item.render();
      });
    },


    /**
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.keydownListener = this.handleKeydown.bind(this);
      this.element.addEventListener('keydown', this.keydownListener);

      this.keyupListener = this.handleKeyup.bind(this);
      this.element.addEventListener('keyup', this.keyupListener);

      this.clickListener = this.handleClick.bind(this);
      this.element.addEventListener('click', this.clickListener);

      $(this.element).on('selected.' + COMPONENT_NAME$13, function (e) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        log('dir', args);
      });

      // Inlined Searchfields can cause navigation requiring a focus change to occur on collapse.
      $(this.element).on('collapsed-responsive.' + COMPONENT_NAME$13, function (e, direction) {
        e.stopPropagation();
        _this2.navigate(direction, null, true);
      });
    },


    /**
     * Event Handler for internal `keydown` events.
     * @private
     * @param {KeyboardEvent} e `keydown`
     * @returns {void}
     */
    handleKeydown: function handleKeydown(e) {
      var target = e.target;

      // Toolbar Items get handled separately.
      if ($(target).data('toolbarflexitem')) {
        this.handleItemKeydown(e);
        // return;
      }
    },


    /**
     * Event Handler for internal `keydown` events, specifically on Toolbar Items.
     * @private
     * @param {KeyboardEvent} e `keydown`
     * @returns {void}
     */
    handleItemKeydown: function handleItemKeydown(e) {
      var key = e.key;
      var item = this.getItemFromElement(e.target);
      function preventScrolling() {
        e.preventDefault();
      }

      // NOTE: 'Enter' and 'SpaceBar' are purposely not handled on keydown, since
      // a `click` event will be fired on Toolbar items while pressing either of these keys.
      if (key === 'Enter') {
        this.clickByEnterKey = true;
        return;
      }

      if (key === ' ') {
        // SpaceBar
        if (item.type === 'hyperlink') {
          this.select(e.target);
        }
        return;
      }

      // Left Navigation
      var leftNavKeys = ['ArrowLeft', 'Left', 'ArrowUp', 'Up'];
      if (leftNavKeys.indexOf(key) > -1) {
        if (item.type === 'searchfield' && (key === 'ArrowLeft' || key === 'Left')) {
          return;
        }
        this.navigate(-1, undefined, true);
        preventScrolling();
        return;
      }

      // Right Navigation
      var rightNavKeys = ['ArrowRight', 'Right', 'ArrowDown', 'Down'];
      if (rightNavKeys.indexOf(key) > -1) {
        if (item.type === 'searchfield' && (key === 'ArrowRight' || key === 'Right')) {
          return;
        }
        this.navigate(1, undefined, true);
        preventScrolling();
      }
    },


    /**
     * Event Handler for internal `keyup` events
     * @private
     * @param {KeyboardEvent} e `keyup`
     * @returns {void}
     */
    handleKeyup: function handleKeyup(e) {
      this.clearClickByEnter(e);
    },


    /**
     * Event Handler for internal `click` events
     * @private
     * @param {MouseEvent} e `click`
     * @returns {void}
     */
    handleClick: function handleClick(e) {
      var target = e.target;

      // Toolbar Items get handled separately.
      if ($(target).data('toolbarflexitem')) {
        this.handleItemClick(e);
      }

      this.clearClickByEnter();
    },


    /**
     * Event Handler for internal `click` events, specifically on Toolbar Items.
     * @private
     * @param {MouseEvent} e `click`
     * @returns {void}
     */
    handleItemClick: function handleItemClick(e) {
      var item = this.getItemFromElement(e.target);

      this.select(item);
      this.focusedItem = item;
    },


    /**
     * @private
     * @param {Event} e incoming event of multiple types
     * @returns {void}
     */
    clearClickByEnter: function clearClickByEnter(e) {
      // Gets set in `this.handleItemKeydown` by pressing 'Enter'.
      if (this.clickByEnterKey) {
        // Prevents the enter key from triggering a `selected` event on the menu button.
        if (this.type === 'menubutton' || this.type === 'actionbutton') {
          e.preventDefault();
        }
        delete this.clickByEnterKey;
      }
    },


    /**
     * Gets all the elements currently inside the Toolbar Markup.
     * The array of items produced is ordered by Toolbar Section.
     * @returns {array} of Toolbar Items
     */
    getElements: function getElements() {
      var items = [];
      var allSelectors = [];

      // Build a really big selector containing all possible matches
      TOOLBAR_ELEMENTS.forEach(function (elemObj) {
        allSelectors.push(elemObj.selector);
      });
      allSelectors = allSelectors.join(', ');

      // Get all possible Toolbar Element matches
      // NOTE: Important that the toolbar items are picked up by the querySelector
      // in their actual, physical DOM order.
      var thisElems = utils.getArrayFromList(this.element.querySelectorAll(allSelectors));

      // Check each element for each type of toolbar item.
      // If there's a match, push to the item array.
      thisElems.forEach(function (elem) {
        var defined = false;
        TOOLBAR_ELEMENTS.forEach(function (elemObj) {
          if (defined || !$(elem).is(elemObj.selector)) {
            return;
          }
          if (typeof elemObj.filter === 'function') {
            if (!elemObj.filter(elem)) {
              return;
            }
          }
          defined = true;
          items.push(elem);
        });
      });

      return items;
    },


    /**
     * @param {HTMLElement|ToolbarFlexItem} element the element to be checked
     * @returns {ToolbarFlexItem} an instance of a Toolbar item
     */
    getItemFromElement: function getItemFromElement(element) {
      if (element instanceof ToolbarFlexItem) {
        return element;
      }

      var item = void 0;
      for (var i = 0; i < this.items.length; i++) {
        // Simple comparison of innerHTML to figure out if the elements match up
        if (this.items[i].element.innerHTML === element.innerHTML) {
          item = this.items[i];
        }
      }

      if (!item) {
        throw new Error('No Toolbar Item instance available for element ' + element + '.');
      }

      return item;
    },


    /**
     * If this toolbar contains a searchfield, this alias returns a reference to its ComponentAPI property.
     * If no searchfield exists, it returns `undefined`
     * @returns {Searchfield|undefined} a reference to the componentAPI of the searchfield item.
     */
    get searchfieldAPI() {
      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].type === 'searchfield') {
          return this.items[i].componentAPI;
        }
      }
      return undefined;
    },

    /**
     * @returns {ToolbarFlexItem|undefined} either a toolbar item, or undefined if one
     *  wasn't previously focused.
     */
    get focusedItem() {
      if (this.trueFocusedItem) {
        return this.trueFocusedItem;
      }
      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].focused === true) {
          return this.items[i];
        }
      }
      return undefined;
    },

    /**
     * Sets the currently focused item
     * @param {ToolbarFlexItem} item the item to be focused
     */
    set focusedItem(item) {
      if (this.items.length === 0) {
        return;
      }

      for (var i = 0; i < this.items.length; i++) {
        this.items[i].focused = false;
      }
      item.focused = true;
      this.trueFocusedItem = item;
    },

    // Flag for figuring out if a Toolbar's items are all completely unavailable for keyboard focus.
    get hasFocusableItems() {
      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].focusable === true) {
          return true;
        }
      }
      return false;
    },

    /**
     * @returns {boolean} determining whether or not the Flex Toolbar has the authority to currently control focus
     */
    get canManageFocus() {
      var activeElement = document.activeElement;
      if (this.element.contains(activeElement)) {
        return true;
      }

      // If the searchfield currently has focus, return true
      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].type === 'searchfield' && this.items[i].componentAPI.isFocused) {
          return true;
        }
      }

      if (activeElement.tagName === 'BODY') {
        return true;
      }

      return false;
    },

    /**
     * @returns {ToolbarFlexItem[]} all overflowed items in the toolbar
     */
    get overflowedItems() {
      var overflowed = [];

      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].overflowed === true) {
          overflowed.push(this.items[i]);
        }
      }

      return overflowed;
    },

    /**
     * Navigates among toolbar items and gets a reference to a potential target for focus.
     * @param {number} direction positive/negative value representing how many spaces to move
     * @param {number} [currentIndex] the index to start checking from
     *  the current focus either right/left respectively.
     * @param {boolean} [doSetFocus=false] if set to true, will cause navigation to also set focus.
     */
    navigate: function navigate(direction, currentIndex, doSetFocus) {
      if (this.hasFocusableItems === false) {
        log('No focusable items');
        return;
      }

      // reference the original direction for later, if placement fails.
      var originalDirection = 0 + direction;

      if (currentIndex === undefined || currentIndex === null) {
        currentIndex = this.items.indexOf(this.focusedItem);
      }

      log('Toolbar Navigation: ' + direction + ' points away from index ' + currentIndex);

      while (direction !== 0) {
        if (direction > 0) {
          if (currentIndex === this.items.length - 1) {
            currentIndex = 0;
          } else {
            currentIndex++;
          }
          --direction;
        }
        if (direction < 0) {
          if (currentIndex === 0) {
            currentIndex = this.items.length - 1;
          } else {
            --currentIndex;
          }
          direction++;
        }
      }

      var targetItem = this.items[currentIndex];
      if (targetItem.focusable === false) {
        this.navigate(originalDirection > 0 ? 1 : -1, currentIndex, doSetFocus);
        return;
      }

      // Retain a reference to the focused item and set focus, if applicable.
      this.focusedItem = targetItem;
      if (doSetFocus && this.canManageFocus) {
        this.focusedItem.element.focus();
      }
    },


    /**
     * @param {HTMLElement|ToolbarFlexItem} element an HTMLElement representing a
     *  Toolbar Item, or an actual ToolbarFlexItem API to use.
     * @returns {void}
     */
    select: function select(element) {
      var item = this.getItemFromElement(element);

      switch (item.type) {
        case 'searchfield':
        case 'actionbutton':
        case 'menubutton':
          {
            if (this.clickByEnterKey) {
              return;
            }
            item.selected = true;
            break;
          }
        default:
          item.selected = true;
          break;
      }

      log('log', 'Item ' + item + ' selected.');
    },


    /**
     * Exports everything in the current `items` array as Popupmenu-friendly data to be
     * converted to menu items.
     * NOTE: Searchfields and other Action Buttons are ignored
     * @returns {object} containing JSON-friendly Popupmenu data
     */
    toPopupmenuData: function toPopupmenuData() {
      var data = {
        noMenuWrap: true
      };

      var hasIcons = false;

      function getItemData(item) {
        var itemData = item.toPopupmenuData();
        if (itemData && itemData.icon) {
          hasIcons = true;
        }
        return itemData;
      }

      data.menu = this.items.filter(function (item) {
        if (item.type === 'actionbutton' || item.type === 'searchfield') {
          return false;
        }
        return true;
      }).map(function (item) {
        return getItemData(item);
      });

      data.hasIcons = hasIcons;

      return data;
    },


    /**
     * Exports everything in the current `items` array as a Flex Toolbar object structure
     * @returns {object} containing JSON-friendly Flex Toolbar data
     */
    toData: function toData() {
      var data = {};
      data.items = this.items.map(function (item) {
        return item.toData();
      });
      return data;
    },


    get disabled() {
      return this.trueDisabled;
    },

    set disabled(bool) {
      this.trueDisabled = bool;
      if (bool === true) {
        this.element.classList.add('is-disabled');
        return;
      }
      this.element.classList.remove('is-disabled');
    },

    /**
     * @param {object} [settings] incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.teardown();
      this.init();
    },


    /**
     * @returns {void}
     */
    teardown: function teardown() {
      this.element.removeEventListener('keydown', this.keydownListener);
      this.element.removeEventListener('keyup', this.keyupListener);
      this.element.removeEventListener('click', this.clickListener);

      $(this.element).off('selected.' + COMPONENT_NAME$13);
      $(this.element).off('collapsed-responsive.' + COMPONENT_NAME$13);

      this.items.forEach(function (item) {
        item.teardown();
      });

      delete this.items;
      delete this.sections;
    },


    /**
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
    }
  };

  /**
   * jQuery component wrapper for Toolbar Flex Component
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.toolbarflex = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$13);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$13, new ToolbarFlex(this, settings));

        // Remove the jQuery Component reference from $.data
        var oldDestroy = instance.destroy;
        instance.destroy = function () {
          if (typeof oldDestroy === 'function') {
            oldDestroy.call(this);
          }
          $.removeData(this, COMPONENT_NAME$13);
        };
      }
    });
  };

  /**
   * jQuery Component Wrapper for Toolbar Searchfield
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.toolbarsearchfield = $.fn.searchfield;

  // Component Name
  var COMPONENT_NAME$14 = 'trackdirty';

  // Default Trackdirty Options
  var TRACKDIRTY_DEFAULTS = {};

  /**
  * Track changes on the inputs passed in the jQuery selector and show a dirty indicator
  * @class Trackdirty
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  */
  function Trackdirty(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TRACKDIRTY_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Trackdirty Methods
  Trackdirty.prototype = {
    init: function init() {
      this.isIe = Environment.browser.name === 'ie';
      this.isIeEdge = Environment.browser.name === 'edge';

      this.handleEvents();
    },


    /**
     * Get the value or checked if checkbox or radio
     * @private
     * @param {object} element .
     * @param {boolean} isOriginal .
     * @returns {string} element value
     */
    valMethod: function valMethod(element, isOriginal) {
      switch (element.attr('type')) {
        case 'checkbox':
        case 'radio':
          return element.prop('checked');
        case 'file':
          {
            if (typeof isOriginal === 'boolean' && isOriginal) {
              var original = element.attr('original');
              return original !== undefined ? original : '';
            }

            var el = element.parent().find('[type="text"]');
            return el.val();
          }
        default:
          return element.val();
      }
    },


    /**
     * Get absolute position for an element
     * @private
     * @param {object} element .
     * @returns {object} position for given element
     */
    getAbsolutePosition: function getAbsolutePosition(element) {
      var pos = element.position();
      // eslint-disable-next-line
      element.parents().each(function () {
        var el = this;
        if (window.getComputedStyle(el, null).position === 'relative') {
          return false;
        }

        pos.left += el.scrollLeft;
        pos.top += el.scrollTop;
      });

      return { left: pos.left, top: pos.top };
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.element.removeClass('dirty').off('resetdirty.dirty change.dirty doresetdirty.dirty');

      if (this.settings && _typeof(this.settings.d) === 'object') {
        var d = this.settings.d;
        $('.icon-dirty, .msg-dirty', d.field).add(d.icon).add(d.msg).remove();
      }

      $.removeData(this.element[0], 'original');
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, TRACKDIRTY_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$14);
    },


    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var input = this.element;

      if (input.is('.editor')) {
        var textArea = input.parent().find('textarea');
        textArea.data('original', this.valMethod(textArea));
      }

      input.data('original', this.valMethod(input, true)).on('resetdirty.dirty', function () {
        if (input.is('.editor')) {
          var _textArea = input.parent().find('textarea');
          _textArea.data('original', _this.valMethod(_textArea));
        }

        input.data('original', _this.valMethod(input)).triggerHandler('doresetdirty.dirty');
      }).on('change.dirty doresetdirty.dirty', function (e) {
        var el = input;
        var field = input.closest('.field, .radio-group');
        var label = $('label:visible', field);
        var d = { class: '', style: '' };

        if (field.is('.field-fileupload')) {
          el = field.find('input.fileupload-background-transparent');
        }

        if (field.is('.editor-container')) {
          el = field.find('.editor-source');
        }

        // Used element without .field wrapper
        if (!label[0]) {
          label = input.next('label');
        }
        if (input.attr('data-trackdirty') !== 'true') {
          return;
        }

        // Add class to element
        input.addClass('dirty');

        // Set css class
        if (input.is('[type="checkbox"], [type="radio"]')) {
          d.class += ' dirty-' + input.attr('type');
          d.class += input.is(':checked') ? ' is-checked' : '';
        }
        if (input.is('select')) {
          d.class += ' is-select';
          el = input.next('.dropdown-wrapper').find('.dropdown');
        }

        // Add class and icon
        d.icon = el.prev();
        if (!d.icon.is('.icon-dirty')) {
          if (input.is('[type="checkbox"]')) {
            d.rect = _this.getAbsolutePosition(label);
            d.style = 'left:' + d.rect.left + 'px; top:' + d.rect.top + 'px;';
          } else if (input.is('.colorpicker') && !Locale.isRTL()) {
            d.rect = _this.getAbsolutePosition(input);
            d.style = 'left:' + d.rect.left + 'px; top:' + d.rect.top + 'px;';
          }
          d.icon = '<span class="icon-dirty' + d.class + '"></span>';
          d.msg = Locale.translate('MsgDirty') || '';
          d.msg = '<span class="audible msg-dirty">' + d.msg + '</span>';

          // Add icon and msg
          var firstInput = $($(el[0].parentElement).find('input')[0]);
          el = input.is('[type="radio"]') ? firstInput : el;

          if ($(el[0].parentElement).find('.icon-dirty').length === 0) {
            el.before(d.icon);
            label.append(d.msg);

            if (d.style && el.prev('.icon-dirty')[0]) {
              el.prev('.icon-dirty')[0].style.cssText = d.style;
            }
          }

          // Cache icon and msg
          d.icon = el.prev();
          d.msg = label.find('.msg-dirty');
        }

        // Handle resetting value back
        var original = input.data('original');
        var current = _this.valMethod(input);

        d.field = field;
        _this.settings.d = d;
        if (field.is('.editor-container')) {
          // editors values are further down it's tree in a textarea,
          // so get the elements with the value
          var _textArea2 = field.find('textarea');
          original = _textArea2.data('original');
          current = _this.valMethod(_textArea2);

          if (_this.isIe || _this.isIeEdge) {
            current = input[0].innerHTML;
          }
        }
        if (current === original || input.attr('multiple') && utils.equals(current, original)) {
          input.removeClass('dirty');
          $('.icon-dirty, .msg-dirty', field).add(d.icon).add(d.msg).remove();
          input.trigger(e.type === 'doresetdirty' ? 'afterresetdirty' : 'pristine');
          return;
        }

        /**
        * Fires when an inout becomes dirty.
        * @event resetdirty
        * @memberof Trackdirty
        * @property {object} event - The jquery event object
        */
        input.trigger('dirty');
      });
    }
  };

  /**
   * jQuery Component Wrapper for TrackDirty
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.trackdirty = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$14);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$14, new Trackdirty(this, settings));
      }
    });
  };

  // The name of this component.
  var COMPONENT_NAME$15 = 'tree';

  // The Component Defaults.
  var TREE_DEFAULTS = {
    selectable: 'single', // ['single'|'multiple']
    hideCheckboxes: false, // [true|false] -apply only with [selectable: 'multiple']
    menuId: null, // Context Menu to add to nodes
    useStepUI: false, // When using the UI as a stepped tree
    folderIconOpen: 'open-folder',
    folderIconClosed: 'closed-folder',
    sortable: false, // Allow nodes to be sortable
    onBeforeSelect: null,
    onExpand: null,
    onCollapse: null,
    originalEnablementState: null
  };

  /**
  * The tree Component displays a hierarchical list.
  * @class Tree
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.selectable = 'single'] 'single' or 'multiple'.
  * @param {boolean} [settings.hideCheckboxes = false] Only applies when `selectable` is set to 'multiple'.
  * @param {null|string} [settings.menuId] if defined, will be used to identify a Context Menu by ID attribute in which to add nodes.
  * @param {boolean} [settings.useStepUI = false] if `true`, turns this tree instance into a "Stepped" tree.
  * @param {string} [settings.folderIconOpen = 'open-folder']  the icon used when a tree folder node is open.
  * @param {string} [settings.folderIconClosed = 'closed-folder'] the icon used when a tree folder node is closed.
  * @param {boolean} [settings.sortable = false] if `true`, allows nodes to become sortable.
  * @param {null|function} [settings.onBeforeSelect] If defined as a function, fires that function as a callback before the selection on a node occurs.
  * @param {null|function} [settings.onExpand] If defined as a function, fires that function as a node is expanded.
  * @param {null|function} [settings.onCollapse] If defined as a function, fires that function as a node is collapsed.
  */
  function Tree(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, TREE_DEFAULTS);
    this.init();
  }

  // Tree Methods
  Tree.prototype = {

    /**
     * @private
     * @returns {undefined}
     */
    init: function init() {
      this.isIe11 = Environment.browser.name === 'ie' && Environment.browser.version === '11';
      this.initTree();
      this.handleKeys();
      this.setupEvents();

      if (this.loadData(this.settings.dataset) === -1) {
        this.syncDataset();
        this.initSelected();
        this.focusFirst();
        this.attachMenu(this.settings.menuId);
        this.createSortable();
      }
    },


    /**
     * Init Tree from ul, li, a markup structure in DOM
     * @private
    */
    initTree: function initTree() {
      var self = this;
      var s = this.settings;
      var links = this.element.find('a');
      var selectableAttr = this.element.attr('data-selectable');

      // Set attribute "data-selectable"
      s.selectable = typeof selectableAttr !== 'undefined' && (selectableAttr.toLowerCase() === 'single' || selectableAttr.toLowerCase() === 'multiple') ? selectableAttr : s.selectable;

      // Set isMultiselect and checkboxes show/hide
      this.isMultiselect = s.selectable === 'multiple';
      s.hideCheckboxes = s.hideCheckboxes || !this.isMultiselect;

      this.element.addClass(this.isMultiselect ? ' is-multiselect' : '');

      links.each(function () {
        var a = $(this);
        self.decorateNode(a);
      });
    },


    /**
     * Init selected notes
     * @private
    */
    initSelected: function initSelected() {
      var _this = this;

      var listItems = [].slice.call(this.element[0].querySelectorAll('li'));
      listItems.forEach(function (li) {
        return _this.setNodeStatus($(li.querySelector('a')));
      });
    },


    /**
     * Focus the first tree node
     * @private
     */
    focusFirst: function focusFirst() {
      var a = this.element[0].querySelector('a');
      if (a) {
        a.setAttribute('tabindex', '0');
      }
    },


    /**
     * Set focus
     * @private
     * @param {object} node .
     * @returns {void}
     */
    setFocus: function setFocus(node) {
      node = this.isjQuery(node) ? node[0] : node;
      if (!node) {
        return;
      }
      node.focus();
      node.classList.remove('hide-focus');
    },


    /**
     * From the LI, Read props and add stuff
     * @private
     * @param {object} a an anchor tag reference wrapped in a jQuery object.
     * @param {string} iconToSet icon for tree node.
     * @param {bool} hideCheckbox to show or hide checkbox for tree node.
     * @returns {void}
     */
    // Added parameters - To show check box and icon on demand for particular node
    decorateNode: function decorateNode(a, iconToSet, hideCheckbox) {
      a = this.isjQuery(a) ? a : $(a);

      var parentCount = 0;
      var badgeData = a[0].getAttribute('data-badge');
      var alertIcon = a[0].getAttribute('data-alert-icon');
      var isParentsDisabled = a.parentsUntil(this.element, 'ul[role=group].is-disabled').length > 0;
      var isDisabled = a[0].classList.contains('is-disabled') || isParentsDisabled;

      if (typeof badgeData !== 'undefined') {
        badgeData = utils.parseSettings(a, 'data-badge');
      }

      // Set initial 'role', 'tabindex', and 'aria selected' on each link (except the first)
      a[0].setAttribute('role', 'treeitem');
      a[0].setAttribute('tabindex', '-1');
      a[0].setAttribute('aria-selected', 'false');

      // Add Aria disabled
      if (isDisabled) {
        a[0].classList.add('is-disabled');
        a[0].setAttribute('aria-disabled', 'true');
        var childSection = a.next();

        if (childSection[0] && childSection[0].tagName.toLowerCase() === 'ul' && childSection[0].classList.contains('is-open')) {
          var childLinks = [].slice.call(childSection[0].querySelectorAll('a'));
          childLinks.forEach(function (link) {
            link.classList.add('is-disabled');
            link.setAttribute('aria-disabled', 'true');
          });
          var parentUls = [].slice.call(a[0].parentNode.querySelectorAll('ul'));
          parentUls.forEach(function (ul) {
            return ul.classList.add('is-disabled');
          });
        }
      }

      // ParentCount 'aria-level' to the node's level depth
      parentCount = a.parentsUntil(this.element, 'ul').length - 1;
      a[0].setAttribute('aria-level', parentCount + 1);

      // Set the current tree item node position relative to its aria-setsize
      var posinset = a.parent().index();
      a[0].setAttribute('aria-posinset', posinset + 1);

      // Set the current tree item aria-setsize
      var listCount = a.closest('li').siblings().length + 1;
      a[0].setAttribute('aria-setsize', listCount);

      // Set the current tree item node expansion state
      var subNode = a.next('ul');
      if (subNode[0] && subNode.children().length > 0) {
        a[0].setAttribute('aria-expanded', subNode[0].classList.contains('is-open') ? 'true' : 'false');
      }

      // Inject Icons
      var text = a.contents().filter(function () {
        return !$(this).is('.tree-badge'); // Do not include badge text
      }).text();

      a[0].textContent = '';
      if (a.children('svg.icon-tree').length === 0) {
        // Show provided icon if any, if empty string provided then show empty icon otherwise show document icon.
        if (iconToSet || iconToSet === '') {
          a[0].insertAdjacentHTML('afterbegin', $.createIcon({ icon: iconToSet, classes: ['icon-tree'] }));
        } else {
          a[0].insertAdjacentHTML('afterbegin', $.createIcon({ icon: 'tree-node', classes: ['icon-tree'] }));
        }

        if (this.settings.useStepUI) {
          a[0].insertAdjacentHTML('afterbegin', $.createIcon({ icon: alertIcon, classes: ['step-alert', 'icon-' + alertIcon] }));
        }
      }

      // Inject checkbox
      // Show check box for particular node on demand
      if (this.isMultiselect && (!this.settings.hideCheckboxes || hideCheckbox === false)) {
        a[0].insertAdjacentHTML('beforeend', '<span class="tree-checkbox"></span>');
      }

      // Inject badge
      var badgeHtml = this.getBadgeHtml(badgeData);
      if (badgeHtml !== '') {
        a[0].insertAdjacentHTML('beforeend', badgeHtml);
      }

      var span = document.createElement('span');
      span.classList.add('tree-text');
      span.textContent = text;
      a[0].appendChild(span);

      if (this.hasIconClass(a)) {
        // CreateIconPath
        this.setTreeIcon(a.find('svg.icon-tree'), a[0].getAttribute('class'));
      }

      // Adds role=group' to all subnodes
      if (subNode[0] && subNode[0].tagName.toLowerCase() === 'ul') {
        var aClass = a[0].getAttribute('class');
        subNode[0].setAttribute('role', 'group');
        subNode[0].parentNode.classList.add('folder');
        this.setTreeIcon(a.find('svg.icon-tree'), subNode[0].classList.contains('is-open') ? this.settings.folderIconOpen : this.settings.folderIconClosed);

        if (aClass && aClass.indexOf('open') === -1 && aClass.indexOf('closed') === -1) {
          a[0].setAttribute('class', isDisabled ? 'is-disabled' : '');
          this.setTreeIcon(a.find('svg.icon-tree'), subNode[0].classList.contains('is-open') ? this.settings.folderIconOpen : this.settings.folderIconClosed);
        }

        if (this.hasIconClass(a)) {
          aClass = a[0].getAttribute('class');
          this.setTreeIcon(a.find('svg.icon-tree'), subNode[0].classList.contains('is-open') ? aClass : aClass.replace('open', 'closed'));
        }
      }

      a.hideFocus();
    },


    /**
     * Sets the correct icon to use on a particular SVG element.
     * @private
     * @param {object} svg an SVG element reference wrapped in a jQuery object
     * @param {string} icon the ID of a Soho Icon type.
     * @returns {void}
     */
    setTreeIcon: function setTreeIcon(svg, icon) {
      if (!svg || typeof icon !== 'string') {
        return;
      }
      svg = this.isjQuery(svg) ? svg : $(svg);
      // Replace all "icon-", "hide-focus", "\s? - all spaces if any" with nothing
      var iconStr = icon.replace(/#?icon-|hide-focus|\s?/gi, '');
      svg.changeIcon(iconStr);
    },


    /**
     * Expands a collection of tree nodes.
     * @param {object} nodes - a jQuery-wrapped collection of tree node elements.
     If left undefined, this will automatically use all `ul[role=group]` elements.
     * @returns {void}
     */
    expandAll: function expandAll(nodes) {
      var _this2 = this;

      var groups = nodes;

      if (typeof groups !== 'undefined') {
        groups = this.isjQuery(groups) ? $.makeArray(groups) : groups;
      } else {
        groups = [].slice.call(this.element[0].querySelectorAll('ul[role=group]'));
      }

      groups.forEach(function (group) {
        var prev = group.previousElementSibling;
        group.parentNode.classList.add('is-open');
        group.classList.add('is-open');
        group.style.height = '';

        if (prev && prev.tagName.toLowerCase() === 'a') {
          var svg = prev.querySelector('svg.icon-tree');
          _this2.setTreeIcon(svg, _this2.settings.folderIconOpen);
          prev.setAttribute('aria-expanded', true);
          if (_this2.hasIconClass(prev)) {
            _this2.setTreeIcon(svg, prev.getAttribute('class'));
          }
        }
      });
    },


    /**
     * Collapses a collection of tree nodes.
     * @param {object} nodes - a jQuery-wrapped collection of tree node elements.
     If left undefined, this will automatically use all `ul[role=group]` elements.
     * @returns {void}
     */
    collapseAll: function collapseAll(nodes) {
      var _this3 = this;

      var groups = nodes;

      if (typeof groups !== 'undefined') {
        groups = this.isjQuery(groups) ? $.makeArray(groups) : groups;
      } else {
        groups = [].slice.call(this.element[0].querySelectorAll('ul[role=group]'));
      }

      groups.forEach(function (group) {
        var prev = group.previousElementSibling;
        group.parentNode.classList.remove('is-open');
        group.classList.remove('is-open');
        group.style.height = 0;

        if (prev && prev.tagName.toLowerCase() === 'a') {
          var svg = prev.querySelector('svg.icon-tree');
          _this3.setTreeIcon(svg, _this3.settings.folderIconClosed);
          prev.setAttribute('aria-expanded', false);
          prev.classList.remove('is-selected');
          if (_this3.hasIconClass(prev)) {
            _this3.setTreeIcon(svg, prev.getAttribute('class').replace('open', 'closed'));
          }
        }
      });
    },


    /**
     * Check if an object is an instance of a jQuery object
     * @private
     * @param {object} obj the object being tested.
     * @returns {boolean} true if jQuery
     */
    isjQuery: function isjQuery(obj) {
      // TODO: Move this to a Soho utility object?
      return obj && (obj instanceof jQuery || obj.constructor.prototype.jquery);
    },


    /**
     * Selects a tree node specifically using it's ID attribute.
     * @param {string} id - the ID string to use.
     * @returns {void}
     */
    selectNodeById: function selectNodeById(id) {
      this.selectNodeByJquerySelector('#' + id);
    },


    /**
     * Selects a tree node by [jquery selector] -or- [jquery object]
     * @private
     * @param {object} selector uses a string that represents a jQuery-wrapped
     element's ID attribute, or a jQuery-wrapped reference to the element itself.
     * @returns {void}
     */
    selectNodeByJquerySelector: function selectNodeByJquerySelector(selector) {
      var target = this.isjQuery(selector) ? selector : $(selector);
      if (target.length && !target.is('.is-disabled')) {
        var nodes = target.parentsUntil(this.element, 'ul[role=group]');
        this.expandAll(nodes);
        this.selectNode(target, true);
      }
    },


    /**
     * Deselects a tree node
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {boolean} focus - if defined, causes the node to become focused.
     * @returns {void}
     */
    unSelectedNode: function unSelectedNode(node, focus) {
      if (node.length === 0) {
        return;
      }

      var self = this;
      var aTags = $('a', this.element);

      aTags.attr('tabindex', '-1');
      node.attr('tabindex', '0');

      $('a:not(.is-disabled)', node.parent()).attr('aria-selected', 'false').parent().removeClass('is-selected');

      this.syncNode(node);
      this.setNodeStatus(node);

      if (focus) {
        node.focus();
      }

      // Set active css class
      var listItems = [].slice.call(this.element[0].querySelectorAll('li'));
      listItems.forEach(function (li) {
        return li.classList.remove('is-active');
      });
      node[0].parentNode.classList.add('is-active');

      setTimeout(function () {
        var jsonData = node.data('jsonData') || {};
        /**
        * Fires when the node is deselected.
        * @memberof Tree
        * @event unselected
        * @type {object}
        * @property {object} event - The jquery event object
        * @property {object} args for node element, item
        * @property {HTMLElement} args.node The DOM Element.
        * @property {HTMLElement} args.data The JSON data attached to the node.
        */
        self.element.triggerHandler('unselected', { node: node, data: jsonData });
      }, 0);
    },


    /**
     * Selects a tree node
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {boolean} focus - if defined, causes the node to become focused.
     * @returns {void}
     */
    selectNode: function selectNode(node, focus) {
      var self = this;
      var s = this.settings;

      if (node.length === 0) {
        return;
      }

      // Possibly Call the onBeforeSelect
      var result = void 0;
      if (typeof s.onBeforeSelect === 'function') {
        result = s.onBeforeSelect(node);
        if (result && result.done && typeof result.done === 'function') {
          // A promise is returned
          result.done(function (continueSelectNode) {
            if (continueSelectNode) {
              self.selectNodeFinish(node, focus);
            }
          });
        } else if (result) {
          // Boolean is returned instead of a promise
          self.selectNodeFinish(node, focus);
        }
      } else {
        // No Callback specified
        self.selectNodeFinish(node, focus);
      }
    },


    /**
     * Select the node when finished
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {boolean} focus - if defined, causes the node to become focused.
     * @param {object} e - jquery event.
     * @returns {void}
     */
    selectNodeFinish: function selectNodeFinish(node, focus, e) {
      // Don't do selection for toggle type only
      if (this.isMultiselect && e) {
        if (e.type === 'click' || e.type === 'touch') {
          if (e.target.classList.contains('icon') && node[0].parentNode.classList.contains('folder')) {
            return;
          }
        } else if (e.type === 'keydown') {
          var charCode = e.charCode || e.keyCode;
          if (charCode === 37 || charCode === 39) {
            return;
          }
        }
      }

      var self = this;
      var links = [].slice.call(this.element[0].querySelectorAll('a'));
      links.forEach(function (a) {
        return a.setAttribute('tabindex', '-1');
      });
      node[0].setAttribute('tabindex', '0');

      if (this.isMultiselect) {
        var links2 = [].slice.call(node[0].parentNode.querySelectorAll('a:not(.is-disabled)'));
        links2.forEach(function (a) {
          a.setAttribute('aria-selected', 'true');
          a.classList.add('is-selected');
          a.parentNode.classList.add('is-selected');
        });
      } else {
        if (node[0].classList.contains('is-selected')) {
          return;
        }
        links.forEach(function (a) {
          var link = $(a);
          var data = link.data('jsonData');
          if (data) {
            delete data.selected;
            link.data('jsonData', data);
          }
          a.setAttribute('aria-selected', 'false');
          a.classList.remove('is-selected');
          a.parentNode.classList.remove('is-selected');
        });
        node[0].setAttribute('aria-selected', 'true');
        node[0].classList.add('is-selected');
        node[0].parentNode.classList.add('is-selected');
      }

      this.syncNode(node);
      if (!this.loading) {
        this.setNodeStatus(node);
      }

      if (focus) {
        node.focus();
      }

      // Set active css class
      var listItems = [].slice.call(this.element[0].querySelectorAll('li'));
      listItems.forEach(function (li) {
        return li.classList.remove('is-active');
      });
      node[0].parentNode.classList.add('is-active');

      setTimeout(function () {
        var jsonData = node.data('jsonData') || {};
        /**
         * Fires when the node is selected.
         * @memberof Tree
         * @event unselected
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} args for node element, item
         * @property {HTMLElement} args.node The DOM Element.
         * @property {HTMLElement} args.data The JSON data attached to the node.
         */
        self.element.triggerHandler('selected', { node: node, data: jsonData });
      }, 0);
    },


    /**
     * Set current node status
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @returns {void}
     */
    setNodeStatus: function setNodeStatus(node) {
      var self = this;
      var data = node.data('jsonData');
      var nodes = void 0;

      // Not multiselect
      if (!this.isMultiselect) {
        var a = node[0];
        var li = a.parentNode;
        if (data && data.selected) {
          li.classList.add('is-selected');
          a.classList.add('is-selected');
          a.setAttribute('aria-selected', true);
        } else {
          li.classList.remove('is-selected', 'is-partial');
          a.classList.remove('is-selected', 'is-partial');
          a.setAttribute('aria-selected', false);
        }
        return;
      }

      var setStatus = function setStatus(thisNodes, isFirstSkipped) {
        thisNodes.forEach(function (li) {
          var a = $(li.querySelector('a'));
          var status = self.getSelectedStatus(a, isFirstSkipped);

          if (status === 'mixed') {
            li.classList.remove('is-selected', 'is-partial');
            li.classList.add('is-partial');
          } else if (status) {
            li.classList.remove('is-selected', 'is-partial');
            li.classList.add('is-selected');
          } else {
            li.classList.remove('is-selected', 'is-partial');
          }
          self.syncNode(a);
        });
      };

      // Multiselect
      var isFirstSkipped = false;
      nodes = [].slice.call(node[0].parentNode.querySelectorAll('li.folder'));
      setStatus(nodes, isFirstSkipped);

      isFirstSkipped = !(!nodes.length && data && !data.selected);
      nodes = node.parentsUntil(this.element, 'li.folder');
      nodes = [].slice.call(nodes.toArray());
      setStatus(nodes, isFirstSkipped);
    },


    /**
     * Get's a tree node's current 'selected' status
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {boolean} isFirstSkipped - ?
     * @returns {boolean} status as true|false|'mixed'
     */
    getSelectedStatus: function getSelectedStatus(node, isFirstSkipped) {
      var total = 0;
      var selected = 0;
      var unselected = 0;
      var data = void 0;

      node.parent().find('a').each(function (i) {
        if (isFirstSkipped && i === 0) {
          return;
        }
        total++;
        data = $(this).data('jsonData');
        if (data && data.selected) {
          selected++;
        } else {
          unselected++;
        }
      });

      var status = void 0;
      if (total === selected) {
        status = true;
      } else if (total === unselected) {
        status = false;
      } else {
        status = 'mixed';
      }
      return status;
    },


    /**
     * Changes a node's open/close status to its opposite form.
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {object} e jquery event
     * @returns {void}
     */
    toggleNode: function toggleNode(node, e) {
      var next = node.next();
      var self = this;
      var s = this.settings;
      var result = void 0;
      if (next[0] && next[0].tagName.toLowerCase() === 'ul' && next[0].getAttribute('role') === 'group') {
        if (next[0].classList.contains('is-open')) {
          if (typeof s.onCollapse === 'function') {
            result = s.onCollapse(node);
            if (result && result.done && typeof result.done === 'function') {
              // A promise is returned
              result.done(function (continueSelectNode) {
                if (continueSelectNode) {
                  self.selectNodeFinish(node, focus, e);
                }
              });
            } else if (result) {
              // Boolean is returned instead of a promise
              self.selectNodeFinish(node, focus, e);
            }
          } else {
            // No Callback specified
            self.selectNodeFinish(node, focus, e);
          }

          self.setTreeIcon(node.closest('.folder').removeClass('is-open').end().find('svg.icon-tree'), s.folderIconClosed);

          if (self.hasIconClass(node.closest('.folder a'))) {
            self.setTreeIcon(node.closest('.folder a').find('svg.icon-tree'), node.closest('.folder a').attr('class').replace('open', 'closed').replace(/\s?is-selected/, ''));
          }

          self.isAnimating = true;

          if (!self.isMultiselect) {
            self.unSelectedNode(node.parent().find('li.is-selected'), false);
            node[0].classList.remove('is-selected');
          }

          next.one('animateclosedcomplete', function () {
            next[0].classList.remove('is-open');
            self.isAnimating = false;
          }).animateClosed();

          node[0].setAttribute('aria-expanded', node[0].getAttribute('aria-expanded') !== 'true');
        } else {
          if (typeof s.onExpand === 'function') {
            result = s.onExpand(node);
            if (result && result.done && typeof result.done === 'function') {
              // A promise is returned
              result.done(function (continueSelectNode) {
                if (continueSelectNode) {
                  self.selectNodeFinish(node, focus, e);
                }
              });
            } else if (result) {
              // Boolean is returned instead of a promise
              self.selectNodeFinish(node, focus, e);
            }
          } else {
            // No Callback specified
            self.selectNodeFinish(node, focus, e);
          }

          var nodeData = node.data('jsonData');

          if (s.source && nodeData.children && nodeData.children.length === 0) {
            var response = function response(nodes) {
              var id = nodeData.id;
              var elem = self.findById(id);

              // Add DB and UI nodes
              elem.children = nodes;
              self.addChildNodes(elem, node.parent());
              node[0].classList.remove('is-loading');
              self.loading = false;

              // Open
              self.accessNode(next, node);

              // Sync data on node
              nodeData.children = nodes;
              node.data('jsonData', nodeData);
              self.selectNode(node, true);
              self.initSelected();
            };

            var args = { node: node, data: node.data('jsonData') };
            node[0].classList.add('is-loading');
            self.loading = true;
            self.settings.source(args, response);

            return;
          }
          self.accessNode(next, node);
        }
      }
    },


    /**
     * Access The Node
     * @private
     * @param  {object} next The next element.
     * @param  {object} node The DOM element.
     */
    accessNode: function accessNode(next, node) {
      var _this4 = this;

      var nodeClass = node.attr('class');

      this.setTreeIcon(node.closest('.folder').addClass('is-open').end().find('svg.icon-tree'), this.settings.folderIconOpen);

      if (this.hasIconClass(nodeClass)) {
        this.setTreeIcon(node.find('svg.icon-tree'), nodeClass.replace('is-selected', ''));
      }

      this.isAnimating = true;

      next.one('animateopencomplete', function () {
        _this4.isAnimating = false;
      }).addClass('is-open').css('height', 0).animateOpen();
      node[0].setAttribute('aria-expanded', node[0].getAttribute('aria-expanded') !== 'true');
    },


    /**
     * Open The Node
     * @private
     * @param  {object} nextTarget The next tree element
     * @param  {object} nodeTarget The DOM element to open.
     */
    openNode: function openNode(nextTarget, nodeTarget) {
      var self = this;
      var nodeData = nodeTarget.data('jsonData');

      if (self.settings.source && nodeData.children && nodeData.children.length === 0) {
        var response = function response(nodes) {
          var id = nodeData.id;
          var elem = self.findById(id);

          // Add DB and UI nodes
          elem.children = nodes;
          self.addChildNodes(elem, nodeTarget.parent());
          nodeTarget.removeClass('is-loading');
          self.loading = false;

          // Open
          self.accessNode(nextTarget, nodeTarget);

          // Sync data on node
          nodeData.children = nodes;
          nodeTarget.data('jsonData', nodeData);
          self.selectNode(nodeTarget, true);
          self.initSelected();
        };

        var args = { node: nodeTarget, data: nodeTarget.data('jsonData') };
        nodeTarget.addClass('is-loading');
        self.loading = true;
        self.settings.source(args, response);

        return;
      }
      self.accessNode(nextTarget, nodeTarget);
    },


    /**
     * Check if given value has icon class
     * @private
     * @param  {string|object} elemClass class or element has icon class
     * @returns  {boolean} true if has icon.
     */
    hasIconClass: function hasIconClass(elemClass) {
      if (typeof elemClass !== 'string') {
        if (this.isjQuery(elemClass)) {
          elemClass = elemClass.length > 1 ? elemClass.first()[0] : elemClass[0];
        }
        elemClass = elemClass.getAttribute('class');
      }
      return elemClass && elemClass.indexOf('icon') > -1;
    },


    /**
     * Close The Node
     * @private
     * @param  {object} nextTarget The next tree element
     * @param  {object} nodeTarget The DOM element to open.
     */
    closeNode: function closeNode(nextTarget, nodeTarget) {
      var self = this;
      self.setTreeIcon(nodeTarget.closest('.folder').removeClass('is-open').end().find('svg.icon-tree'), self.settings.folderIconClosed);

      if (self.hasIconClass(nodeTarget.closest('.folder a'))) {
        self.setTreeIcon(nodeTarget.closest('.folder a').find('svg.icon-tree'), nodeTarget.closest('.folder a').attr('class').replace('open', 'closed').replace(/\s?is-selected/, ''));
      }

      self.isAnimating = true;

      if (!self.isMultiselect) {
        self.unSelectedNode(nodeTarget.parent().find('li.is-selected'), false);
        nodeTarget.removeClass('is-selected');
      }

      nextTarget.one('animateclosedcomplete', function () {
        nextTarget.removeClass('is-open');
        self.isAnimating = false;
      }).animateClosed();

      nodeTarget.attr('aria-expanded', nodeTarget.attr('aria-expanded') !== 'true');
    },


    // Setup event handlers
    setupEvents: function setupEvents() {
      var self = this;
      self.element.on('updated.tree', function (e, newSettings) {
        self.updated(newSettings);
        self.initTree();
      });
    },


    // Handle Keyboard Navigation
    handleKeys: function handleKeys() {
      // Key Behavior as per: http://access.aol.com/dhtml-style-guide-working-group/#treeview
      var self = this;
      // On click give clicked element 0 tabindex and 'aria-selected=true', resets all other links
      this.element.on('click.tree', 'a:not(.is-clone)', function (e) {
        var target = $(this);
        var parent = this.parentNode;
        if (!target[0].classList.contains('is-disabled') && !target[0].classList.contains('is-loading')) {
          if (self.isMultiselect) {
            if (e.target.classList.contains('icon') && parent.classList.contains('folder')) {
              self.toggleNode(target, e);
            } else if (parent.classList.contains('is-selected') || parent.classList.contains('is-partial')) {
              self.unSelectedNode(target, true);
            } else {
              self.selectNode(target, true);
            }
          } else {
            self.selectNode(target, true);
            self.toggleNode(target, e);
          }
          e.stopPropagation();
        }

        if (self.popupEl && self.popupEl.data('popupmenu')) {
          self.popupEl.data('popupmenu').close();
          self.popupEl = null;
        }

        return false; // Prevent Click from Going to Top
      });

      this.element
      // Focus on "a" elements
      .on('focus.tree', 'a', function () {
        if (parseInt(this.getAttribute('aria-level'), 10) === 0 && parseInt(this.getAttribute('aria-posinset'), 10) === 1) {
          // First element if disabled
          if (this.classList.contains('is-disabled')) {
            var e = $.Event('keydown.tree');
            e.keyCode = 40; // move down
            $(this).trigger(e);
            return; // eslint-disable-line
          }
        }
      });

      // Handle Up/Down Arrow Keys and Space
      this.element.on('keydown.tree', 'a', function (e) {
        var charCode = e.charCode || e.keyCode;
        var target = $(this);
        var next = void 0;
        var prev = void 0;

        if (self.isAnimating) {
          return;
        }

        // Down arrow
        if (charCode === 40) {
          var nextNode = self.getNextNode(target);
          self.setFocus(nextNode);
        }

        // Up arrow,
        if (charCode === 38) {
          var prevNode = self.getPreviousNode(target);
          self.setFocus(prevNode);
        }

        // Space
        if (e.keyCode === 32) {
          target.trigger('click.tree');
        }

        // Left arrow
        if (charCode === 37) {
          if (Locale.isRTL()) {
            if (target.next().hasClass('is-open')) {
              prev = target.next().find('a:first');
              self.setFocus(prev);
            } else {
              self.toggleNode(target, e);
            }
          } else if (target.next().hasClass('is-open')) {
            self.toggleNode(target, e);
          } else {
            prev = target.closest('.folder').find('a:first');
            self.setFocus(prev);
          }
          e.stopPropagation();
          return false; // eslint-disable-line
        }

        // Right arrow
        if (charCode === 39) {
          if (Locale.isRTL()) {
            if (target.next().hasClass('is-open')) {
              self.toggleNode(target, e);
            } else {
              next = target.closest('.folder').find('a:first');
              self.setFocus(next);
            }
          } else if (target.next().hasClass('is-open')) {
            next = target.next().find('a:first');
            self.setFocus(next);
          } else {
            self.toggleNode(target, e);
            self.setFocus(target);
          }
          e.stopPropagation();
          return false; // eslint-disable-line
        }

        // Home  (fn-right on mac)
        if (charCode === 36) {
          next = self.element.find('a:first:visible');
          self.setFocus(next);
        }

        // End (fn-right on mac)
        if (charCode === 35) {
          next = self.element.find('a:last:visible');
          self.setFocus(next);
        }
      });

      // Handle Left/Right Arrow Keys
      // eslint-disable-next-line
      this.element.on('keypress.tree', 'a', function (e) {
        var charCode = e.charCode || e.keyCode;
        var target = $(this);

        if (charCode >= 37 && charCode <= 40 || charCode === 32) {
          e.stopPropagation();
          return false;
        }

        // Printable Chars Jump to first high level node with it...
        if (e.which !== 0) {
          // eslint-disable-next-line
          target.closest('li').nextAll().find('a:visible').each(function () {
            var node = $(this);
            var first = node.text().substr(0, 1).toLowerCase();
            var term = String.fromCharCode(e.which).toLowerCase();

            if (first === term) {
              self.setFocus(node);
              return false;
            }
          });
        }
      });
    },


    /**
     * Handle Loading JSON.
     * @param {object} dataset to load.
     * @returns {void}
     */
    loadData: function loadData(dataset) {
      // eslint-disable-line
      if (!dataset) {
        return -1;
      }
      var self = this;
      self.element.empty();

      self.loading = true;
      dataset = this.arrangeDataset(dataset);
      var html = '';
      self.jsonData = [];
      for (var i = 0, l = dataset.length; i < l; i++) {
        html += self.getNodeHtml(dataset[i], i);
      }

      self.element[0].insertAdjacentHTML('beforeend', html);
      var nodes = [].slice.call(self.element[0].querySelectorAll('a[role="treeitem"]'));
      nodes.forEach(function (node, i) {
        var a = $(node);
        var data = self.jsonData[i];
        a.data('jsonData', data);
        if (data.selected) {
          self.selectNode(a, data.focus);
        }
      });
      var dropdowns = [].slice.call(self.element[0].querySelectorAll('select.dropdown'));
      for (var _i = 0; _i < dropdowns.length; _i++) {
        var dropdown = dropdowns[_i];
        var data = self.jsonData[_i];
        if (data.disabled) {
          $(dropdown).dropdown().disable();
        } else {
          $(dropdown).dropdown().on('selected.tree', function () {
            var nodeToUpdate = self.findById(this.parentElement.previousElementSibling.id);
            nodeToUpdate.text = this.value;
            self.updateNode(nodeToUpdate);
          });
        }
      }
      self.jsonData = undefined;
      self.loading = false;

      self.syncDataset();
      self.initSelected();
      self.focusFirst();
      self.attachMenu(self.settings.menuId);
      self.createSortable();
    },


    /**
     * Rearrange the given or default dataset. if dataset use `parent` key to arrange nodes
     * @private
     * @param {object} dataset a data object.
     * @returns {object} arranged data object
     */
    arrangeDataset: function arrangeDataset(dataset) {
      if (!this.hasKeyInData('parent', dataset)) {
        return dataset;
      }

      dataset = dataset || this.settings.dataset;
      var arrangedData = JSON.parse(JSON.stringify(dataset));

      // Add given node to parent
      var addToParent = function addToParent(node) {
        var arranged = false;
        // Add child to given parent
        var addChild = function addChild(parent) {
          parent.children = parent.children || [];
          parent.children.push(node);
          arranged = true;
        };

        // Traverse in given data and arrange it
        var arrange = function arrange(data) {
          for (var i = 0; i < data.length && !arranged; i++) {
            if (data[i].id === node.parent) {
              addChild(data[i]);
            }
            if (typeof data[i].children !== 'undefined') {
              arrange(data[i].children);
            }
          }
        };
        arrange(arrangedData);
      };

      // Traverse in given data and add to parent
      var traverse = function traverse(data) {
        for (var i = 0; i < data.length; i++) {
          if (typeof data[i].parent !== 'undefined') {
            addToParent(data[i]);
          }
          if (typeof data[i].children !== 'undefined') {
            traverse(data[i].children);
          }
        }
      };
      traverse(dataset);

      // Clean old nodes with parent key
      var clean = function clean(data, id) {
        for (var i = 0; i < data.length; i++) {
          if (typeof data[i].children !== 'undefined') {
            clean(data[i].children, data[i].id);
          }
          if (typeof id === 'undefined' && typeof data[i].parent !== 'undefined' || typeof id !== 'undefined' && typeof data[i].parent !== 'undefined' && id !== data[i].parent) {
            data.splice(i, 1);
            i--;
          } else {
            delete data[i].parent;
          }
        }
      };
      clean(arrangedData);

      // Set and return the arranged data
      this.settings.dataset = arrangedData;
      return arrangedData;
    },


    /**
     * Check if given key is exists in dataset.
     * @private
     * @param {string} key to check.
     * @param {object} data to check in.
     * @returns {boolean} true if key found
     */
    hasKeyInData: function hasKeyInData(key, data) {
      var found = false;
      data = data || this.settings.dataset;

      /* eslint-disable no-restricted-syntax */
      var findkey = function findkey(obj) {
        for (var prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            // eslint-disable-line
            var value = obj[prop];
            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && !found) {
              findkey(value);
            } else if (key === prop) {
              found = true;
            }
            if (found) {
              break;
            }
          }
        }
      };
      /* eslint-enable no-restricted-syntax */

      for (var i = 0, l = data.length; i < l; i++) {
        if (found) {
          break;
        }
        findkey(data[i]);
      }
      return found;
    },


    /**
     * Create html for given json data.
     * @private
     * @param {object} data to do html.
     * @param {number} position for node.
     * @param {number} level for node.
     * @param {boolean} isParentsDisabled for node.
     * @returns {string} created html
     */
    getNodeHtml: function getNodeHtml(data, position, level, isParentsDisabled) {
      var selectHtml = '';
      var selectedOptionText = '';
      level = level || 0;
      position += 1;
      var s = this.settings;
      var isDisabled = isParentsDisabled || data.disabled || false;
      var a = {
        id: typeof data.id !== 'undefined' ? ' id="' + data.id + '"' : '',
        href: ' href="' + (typeof data.href !== 'undefined' ? data.href : '#') + '"',
        expanded: ' aria-expanded="' + (data.open ? 'true' : 'false') + '"',
        icon: data.icon || data.icon === '' ? data.icon : 'tree-node',
        alertIcon: '',
        alertIconAttr: typeof data.alertIcon !== 'undefined' ? ' data-alert-icon="' + data.alertIcon + '"' : '',
        text: '<span class="tree-text">' + data.text + '</span>',
        class: ['hide-focus'],
        ariaDisabled: isDisabled ? 'aria-disabled="true"' : '',
        checkbox: this.isMultiselect && (!this.settings.hideCheckboxes || data.hideCheckbox === false) ? '<span class="tree-checkbox"></span>' : '',
        badge: _typeof(data.badge) === 'object' ? this.getBadgeHtml(data.badge) : ''
      };
      this.jsonData.push(data);

      if (s.useStepUI) {
        a.alertIcon = '<svg class="icon step-alert icon-' + data.alertIcon + '" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-' + data.alertIcon + '"></use>';
      }

      var isChildren = typeof data.children !== 'undefined';
      var liClassList = isChildren ? 'folder' : '';
      liClassList += data.selected ? ' is-selected' : '';
      if (liClassList !== '') {
        liClassList += data.open ? ' is-open' : '';
        liClassList = ' class="' + liClassList + '"';
      }
      if (isDisabled) {
        a.class.push('is-disabled');
      }
      if (data.icon) {
        a.icon = data.icon;
        if (!isChildren || isChildren && /open|closed/i.test(data.icon)) {
          a.class.push(data.icon);
        }
      }
      if (isChildren) {
        if (data.open) {
          a.icon = data.icon && /open|closed/i.test(data.icon) ? data.icon : s.folderIconOpen;
          isParentsDisabled = isDisabled;
        } else {
          a.icon = data.icon && /open|closed/i.test(data.icon) ? data.icon.replace('open', 'closed') : s.folderIconClosed;
        }
      }
      a.icon = '#icon-' + a.icon.replace(/^#?icon-?/, '');
      a.class = ' class="' + a.class.join(' ') + '"';
      a.style = '';

      // Insert dropdown start
      if (data.type === 'dropdown') {
        a.style = 'style="display: none"';

        if (data.data) {
          selectHtml = '<select class="dropdown" close-on-select="true">';

          for (var i = 0; i < data.data.length; i++) {
            var option = data.data[i];
            if (option.value === data.text) {
              selectedOptionText = option.text;
              selectHtml += '<option value="' + option.value + '" selected>' + option.text + '</option>';
            } else {
              selectHtml += '<option value="' + option.value + '">' + option.text + '</option>';
            }
          }

          selectHtml += '</select><div class="dropdown-wrapper"><div class="dropdown"><span>' + selectedOptionText;
          selectHtml += '</span></div><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-dropdown"></use></svg></div>';
          selectHtml = '<div class="treeDropdown" style="width: 80px; margin-left: 35px; margin-bottom: -15px">' + selectHtml + '</div>';
        }
      }
      // Insert dropdown end

      var html = '\n      <li' + liClassList + '>\n        <a role="treeitem" aria-selected="false" tabindex="-1" ' + a.style + '\n          aria-level="' + level + '"\n          aria-position="' + position + '"\n          aria-setsize="' + position + '"\n          ' + (a.id + a.href + a.class + a.expanded + a.ariaDisabled + a.alertIconAttr) + '>\n            <svg class="icon-tree icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="' + a.icon + '"></use>\n            </svg>' + (a.checkbox + a.alertIcon + a.badge + a.text) + '\n        </a>\n        ' + selectHtml;

      if (isChildren) {
        html += '<ul class="folder' + (data.open ? ' is-open' : '') + '" role="group">';
        for (var _i2 = 0, l = data.children.length; _i2 < l; _i2++) {
          html += this.getNodeHtml(data.children[_i2], _i2, level + 1, isParentsDisabled);
        }
        html += '</ul>';
      }
      html += '</li>';

      return html;
    },


    /**
     * Create badge html.
     * @private
     * @param {object} badgeData to do html.
     * @returns {string} html created
     */
    getBadgeHtml: function getBadgeHtml(badgeData) {
      var badge = { html: '', style: '', class: ['badge', 'tree-badge'] };

      if (badgeData && !badgeData.remove) {
        badge.text = '';

        if (typeof badgeData.text !== 'undefined') {
          badge.text = badgeData.text.toString();
          if (badge.text.length === 1) {
            badge.class.push('round');
          }
        }

        if (/info|good|error|alert|pending/i.test(badgeData.type)) {
          badge.class.push(badgeData.type);
        } else if (badgeData.type && badgeData.type.charAt(0) === '#' && badgeData.type.length === 7) {
          badge.style = 'background-color: ' + badgeData.type + ' !important;';
        }
        if (badgeData.backColor) {
          badge.style = 'background-color: ' + badgeData.backColor + ' !important;';
        }
        if (badgeData.foreColor) {
          badge.style += 'color: ' + badgeData.foreColor + ' !important;';
        }
        if (badge.style !== '') {
          badge.style = ' style="' + badge.style + '"';
        }
        if (badge.text !== '') {
          if (badgeData.type && badgeData.type.indexOf('pending') !== -1) {
            badge.text = '';
          }
          badge.html = '<span class="' + badge.class.join(' ') + '"' + badge.style + '>' + badge.text + '</span>';
        }
      }
      return badge.html;
    },


    // Functions to Handle Internal Data Store
    addToDataset: function addToDataset(node, location) {
      var elem = void 0;
      var updatedNode = void 0;
      var index = void 0;

      if (node.parent) {
        elem = this.findById(node.parent);
      }

      // Update dataset after inserting node before or after other node
      if (location instanceof jQuery && location.is('li')) {
        updatedNode = this.findById($(location[0].parentNode.parentNode).find('a')[0].id);
        var childNodes = updatedNode.children || updatedNode.node.data('jsonData').children;
        index = childNodes.findIndex(function (element) {
          return element.text.trim() === $(location).text().trim();
        });

        childNodes.splice(index, 0, node);
      }

      if (location === 'bottom' && !node.parent && !elem) {
        this.settings.dataset.push(node);
      }

      if (location === 'top' && !node.parent && !elem) {
        this.settings.dataset.unshift(node);
      }

      if (node.parent && elem) {
        if (!elem.children) {
          elem.children = [];
        }

        if (location === 'bottom') {
          elem.children.push(node);
        } else {
          elem.children.unshift(node);
        }
      }

      return !(node.parent && !elem);
    },


    // Find the Node (Dataset) By Id
    findById: function findById(id, source) {
      var self = this;

      if (!source) {
        source = this.settings.dataset;
      }

      /* eslint-disable guard-for-in */
      /* eslint-disable no-restricted-syntax */
      for (var key in source) {
        var item = source[key];
        if (item.id === id) {
          return item;
        }

        if (item.children || item.node.data('jsonData').children) {
          var subresult = self.findById(id, item.children || item.node.data('jsonData').children);

          if (subresult) {
            return subresult;
          }
        }
      }
      /* eslint-enable no-restricted-syntax */
      /* eslint-enable guard-for-in */
      return null;
    },


    // Get node by ID if selected
    getNodeByIdIfSelected: function getNodeByIdIfSelected(id, source) {
      var node = this.findById(id, source);
      return node && node.selected ? node : null;
    },


    /**
     * Get selected nodes.
     * @returns {object} selected nodes
     */
    getSelectedNodes: function getSelectedNodes() {
      var node = void 0;
      var data = void 0;
      var selected = [];

      $('li.is-selected', this.element).each(function () {
        node = $('a:first', this);
        data = node.data('jsonData');
        selected.push({ node: node, data: data });
      });
      return selected;
    },
    getNextNode: function getNextNode(target) {
      var next = target.parent().next().find('a:first');
      var subTarget = target.next();

      // Move Into Children
      if (subTarget.is('ul.is-open')) {
        next = subTarget.find('a:first');
      }

      // Skip disabled
      if (next.hasClass('is-disabled')) {
        next = next.parent().next().find('a:first');
      }

      // Bottom of a group..{l=1000: max folders to be deep }
      if (next.length === 0) {
        for (var i = 0, l = 1000, closest = target; i < l; i++) {
          closest = closest.parent().closest('.folder');
          next = closest.next().find('a:first');
          if (next.length) {
            break;
          }
        }
      }

      // Another check for disabled
      if (next.hasClass('is-disabled')) {
        next = this.getNextNode(next);
      }

      return next;
    },
    getPreviousNode: function getPreviousNode(target) {
      var prev = target.parent().prev().find('a:first');
      var subTarget = prev.parent();

      // Move into children at bottom
      if (subTarget.is('.folder.is-open') && subTarget.find('ul.is-open a').length && !subTarget.find('ul.is-disabled').length) {
        prev = subTarget.find('ul.is-open a:last');
      }

      // Skip disabled
      if (prev.hasClass('is-disabled')) {
        prev = prev.parent().prev().find('a:first');

        // Another check if get to prev open folder
        subTarget = prev.parent();
        if (subTarget.is('.folder.is-open') && subTarget.find('ul.is-open a').length && !subTarget.find('ul.is-disabled').length) {
          prev = subTarget.find('ul.is-open a:last');
        }
      }

      // Top of a group
      if (prev.length === 0) {
        prev = target.closest('ul').prev('a');
      }

      // Another check for disabled
      if (prev.hasClass('is-disabled')) {
        prev = this.getPreviousNode(prev);
      }

      return prev;
    },


    /**
     * Sync the tree with the underlying dataset
     * @private
     * @param {object} node the jQuery element to sync (Optional)
     * @returns {void}
     */
    syncDataset: function syncDataset(node) {
      var json = [];
      var self = this;
      node = node || this.element;

      var items = [].slice.call(node.children('li').toArray());
      items.forEach(function (li) {
        json.push(self.syncNode(li.querySelector('a')));
      });

      this.settings.dataset = json;
      this.element.triggerHandler('rendered', { data: this.settings.dataset });
    },


    /**
     * Sync a node with its dataset record
     * @private
     * @param {object} node The node to sync (jQuery or DOM element)
     * @returns {object} synced node data
     */
    syncNode: function syncNode(node) {
      var self = this;
      var nodeJQ = this.isjQuery(node) ? node : $(node);
      node = nodeJQ[0];
      var parent = node.parentNode;
      var hasClass = function hasClass(el, className) {
        return el.classList.contains(className);
      };

      var entry = {
        node: nodeJQ,
        id: node.getAttribute('id'),
        text: node.querySelector('.tree-text').textContent
      };

      // Is folder open
      if (hasClass(node, 'is-open') || parent && parent.tagName.toLowerCase() === 'li' && hasClass(parent, 'is-open')) {
        entry.open = true;
      }

      // Href
      var href = node.getAttribute('href');
      if (href) {
        entry.href = href;
      }

      // Selected
      if (hasClass(parent, 'is-selected')) {
        entry.selected = true;
      }

      // Disabled
      if (hasClass(node, 'is-disabled')) {
        entry.disabled = true;
      }

      // Icon
      var classAttribute = node.getAttribute('class');
      if (classAttribute && classAttribute.indexOf('icon') > -1) {
        entry.icon = classAttribute;
      }

      // Children
      var ul = nodeJQ.next();
      if (ul[0] && ul[0].tagName.toLowerCase() === 'ul') {
        entry.children = [];

        var items = [].slice.call(ul.children('li').toArray());
        items.forEach(function (li) {
          entry.children.push(self.syncNode(li.querySelector('a')));
        });
      }

      // Merge json data
      var jsonData = nodeJQ.data('jsonData');
      if (jsonData) {
        delete jsonData.selected;
        delete jsonData.children;
        entry = $.extend({}, jsonData, entry);
      }

      nodeJQ.data('jsonData', entry);
      return entry;
    },


    /**
     * Add a node and all its related markup.
     * @param {object} nodeData to add.
     * @param {object} location in tree.
     * @param {string} isBeforeOrAfter to insert node before or after selected tree node.
     * @returns {object} li added
     */

    // Parameter added - to add node before or after the node
    addNode: function addNode(nodeData, location, isBeforeOrAfter) {
      var self = this;
      var selectedOptionText = void 0;
      var selectHtml = void 0;
      var option = void 0;

      var badgeAttr = _typeof(nodeData.badge) === 'object' ? JSON.stringify(nodeData.badge) : nodeData.badge;

      nodeData.href = typeof nodeData.href !== 'undefined' ? nodeData.href : '#';

      location = !location ? 'bottom' : location; // supports button or top or jquery node

      var a = document.createElement('a');
      a.setAttribute('id', nodeData.id);
      a.setAttribute('href', nodeData.href);
      if (typeof badgeAttr !== 'undefined') {
        a.setAttribute('data-badge', badgeAttr);
      }
      if (typeof nodeData.alertIcon !== 'undefined') {
        a.setAttribute('data-alert-icon', nodeData.alertIcon);
      }

      if (nodeData.text) {
        a.textContent = nodeData.text;
      }

      if (nodeData.disabled) {
        a.classList.add('is-disabled');
      }
      if (nodeData.icon) {
        a.classList.add(nodeData.icon);
      }

      var li = document.createElement('li');

      if (nodeData.open) {
        li.classList.add('is-open');
      }

      li.appendChild(a);

      // Insert dropdown start
      if (nodeData.type === 'dropdown') {
        a.setAttribute('style', 'display: none');

        if (nodeData.data) {
          selectHtml = '<select class="dropdown" close-on-select="true">';

          for (var i = 0; i < nodeData.data.length; i++) {
            option = nodeData.data[i];
            if (option.value === nodeData.text) {
              selectedOptionText = option.text;
              selectHtml += '<option value="' + option.value + '" selected>' + option.text + '</option>';
            } else {
              selectHtml += '<option value="' + option.value + '">' + option.text + '</option>';
            }
          }

          selectHtml += '</select><div class="dropdown-wrapper"><div class="dropdown"><span>' + selectedOptionText;

          selectHtml += '</span></div><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-dropdown"></use></svg></div>';

          $('<div class="treeDropdown" style="width: 80px; margin-left: 35px; margin-bottom: -15px">' + selectHtml + '</div>').appendTo(li);

          if (nodeData.disabled) {
            $(li).find('select.dropdown').dropdown().disable();
          } else {
            $(li).find('select.dropdown').dropdown().on('selected.tree', function () {
              var nodeToUpdate = self.findById(this.parentElement.previousElementSibling.id);
              nodeToUpdate.text = this.value;
              self.updateNode(nodeToUpdate);
            });
          }
        }
      }
      // Insert dropdown end

      // Handle Location
      var found = this.loading ? true : this.addToDataset(nodeData, location);

      if (nodeData.parent instanceof jQuery) {
        found = true;
      }

      // Insert node in between the node
      if (location instanceof jQuery && isBeforeOrAfter === 'before') {
        $(li).insertBefore(location);
        found = true;
      } else if (location instanceof jQuery && isBeforeOrAfter === 'after') {
        $(li).insertAfter(location);
        found = true;
      }

      if (location instanceof jQuery && (!nodeData.parent || !found) && !(nodeData.parent instanceof jQuery) && !(isBeforeOrAfter === 'before' || isBeforeOrAfter === 'after')) {
        location[0].appendChild(li);
        found = true;
      }

      if (location === 'bottom' && (!nodeData.parent || !found)) {
        this.element[0].appendChild(li);
      }

      if (location === 'top' && (!nodeData.parent || !found)) {
        this.element.prepend(li);
      }

      // Support ParentId in JSON Like jsTree
      if (nodeData.parent) {
        if (found && typeof nodeData.parent === 'string') {
          li = this.element.find('#' + nodeData.parent).parent();

          if (!nodeData.disabled && li.is('.is-selected') && typeof nodeData.selected === 'undefined') {
            nodeData.selected = true;
          }
          this.addAsChild(nodeData, li);
        }

        if (nodeData.parent && nodeData.parent instanceof jQuery) {
          li = nodeData.parent;
          if (nodeData.parent.is('a')) {
            li = nodeData.parent.parent();
          }
          this.addAsChild(nodeData, li);
        }
        if (this.isjQuery(li)) {
          nodeData.node = li.find('ul li a#' + nodeData.id);
        }
      } else {
        li = $(li);
        this.addChildNodes(nodeData, li);
        nodeData.node = li.children('a').first();
      }

      a = $(a);
      // Added parameter to show or hide checkbox according to node.
      this.decorateNode(a, nodeData.icon, nodeData.hideCheckbox);

      if (nodeData.selected) {
        this.selectNode(a, nodeData.focus);
      }

      a.data('jsonData', nodeData);
      return li;
    },


    /**
     * Add a node to an existing node, making it a folder if need be
     * @private
     * @param {object} nodeData data for node to be added.
     * @param {object} li parent node to add node.
     * @returns {void}
     */
    addAsChild: function addAsChild(nodeData, li) {
      li = this.isjQuery(li) ? li[0] : li;
      var ul = li.querySelector('ul');
      if (!ul) {
        li.insertAdjacentHTML('beforeend', '<ul class="folder"></ul>');
        ul = li.querySelector('ul');
      }

      if (nodeData.open) {
        ul.classList.add('is-open');
      }

      this.decorateNode(li.querySelector('a'));

      nodeData.parent = '';
      this.addNode(nodeData, $(ul));
    },


    /**
     * Add the children for the specified node element,
     * and if `nodeData.children` not passed will remove current children from node
     * @private
     * @param {object} nodeData data for children to be added.
     * @param {object} li parent node to add children.
     * @returns {void}
     */
    addChildNodes: function addChildNodes(nodeData, li) {
      var _this5 = this;

      li = this.isjQuery(li) ? li[0] : li;
      var ul = li.querySelector('ul');

      if (!nodeData.children) {
        if (ul) {
          ul.parentNode.removeChild(ul);
        }
        return;
      }

      if (!ul) {
        li.insertAdjacentHTML('beforeend', '<ul class="folder' + (nodeData.open ? ' is-open' : '') + '"></ul>');
        ul = li.querySelector('ul');
      }

      ul.innerHTML = '';

      if (nodeData.children) {
        nodeData.children.forEach(function (elem) {
          return _this5.addNode(elem, $(ul));
        });
      }
    },


    // Check for true value
    isTrue: function isTrue(v) {
      return typeof v !== 'undefined' && v !== null && (typeof v === 'boolean' && v === true || typeof v === 'string' && v.toLowerCase() === 'true');
    },


    // Check for false value
    isFalse: function isFalse(v) {
      return typeof v !== 'undefined' && v !== null && (typeof v === 'boolean' && v === false || typeof v === 'string' && v.toLowerCase() === 'false');
    },


    /**
     * Update fx rename a node.
     * @param {object} nodeData to update.
     * @returns {void}
     */
    updateNode: function updateNode(nodeData) {
      // Passed in the node element or find the node in the dataset and ui and sync it
      var elem = nodeData.node ? { node: nodeData.node } : this.findById(nodeData.id);
      if (!elem || !elem.node[0]) {
        return;
      }

      var parent = elem.node[0].parentNode;
      var nodetext = elem.node[0].querySelector('.tree-text');
      var isDisabled = this.isTrue(nodeData.disabled) || this.isFalse(nodeData.enabled);
      var isEnabled = this.isTrue(nodeData.enabled) || this.isFalse(nodeData.disabled);

      // Update badge
      if (nodeData.badge) {
        var badge = elem.node[0].querySelector('.tree-badge');
        if (!badge && !nodeData.badge.remove) {
          if (typeof nodeData.badge.text !== 'undefined' && $.trim(nodeData.badge.text) !== '') {
            var newBadge = document.createElement('span');
            newBadge.classList.add('tree-badge', 'badge');
            nodetext.parentNode.insertBefore(newBadge, nodetext);
            badge = elem.node[0].querySelector('.tree-badge');
          }
        }
        // Make update changes
        if (badge) {
          if (typeof nodeData.badge.text !== 'undefined') {
            nodeData.badge.text = nodeData.badge.text.toString();
            badge.textContent = nodeData.badge.text;
            badge.classList.remove('round');
            if (nodeData.badge.text.length === 1) {
              badge.classList.add('round');
            }
          }
          if (typeof nodeData.badge.type !== 'undefined') {
            badge.classList.remove('info', 'good', 'error', 'alert', 'pending');
            if (/info|good|error|alert|pending/i.test(nodeData.badge.type)) {
              badge.classList.add(nodeData.badge.type);
            } else if (nodeData.badge.type.charAt(0) === '#' && nodeData.badge.type.length === 7) {
              badge.style.backgroundColor = nodeData.badge.type;
            }

            if (nodeData.badge.type.indexOf('pending') !== -1) {
              badge.textContent = '';
            }
          }
          elem.badge = nodeData.badge;

          // Remove badge
          if (this.parseBool(nodeData.badge.remove)) {
            badge.parentNode.removeChild(badge);
            if (typeof elem.badge !== 'undefined') {
              delete elem.badge;
            }
          }
        }
      }

      if (nodeData.text) {
        nodetext.textContent = nodeData.text;
        elem.text = nodeData.text;
      }

      if (nodeData.icon) {
        this.setTreeIcon(elem.node[0].querySelector('svg.icon-tree'), nodeData.icon);
        elem.icon = nodeData.icon;
      } else if (nodeData.children && nodeData.children.length && !parent.classList.contains('folder')) {
        this.convertFileToFolder(elem.node);
      }

      if (isDisabled) {
        elem.node[0].classList.add('is-disabled');
        elem.node[0].setAttribute('aria-disabled', 'true');

        if (parent.classList.contains('folder') && parent.classList.contains('is-open')) {
          var nodes = [].slice.call(parent.querySelectorAll('a, ul[role=group]'));
          nodes.forEach(function (node) {
            node.classList.add('is-disabled');
            node.setAttribute('aria-disabled', 'true');
          });
        }
      }

      if (isEnabled) {
        var isParentsDisabled = elem.node.parentsUntil(this.element, 'ul[role=group].is-disabled').length > 0;

        if (!isParentsDisabled) {
          elem.node[0].classList.remove('is-disabled');
          elem.node[0].removeAttribute('aria-disabled');

          if (parent.classList.contains('folder') && parent.classList.contains('is-open')) {
            var _nodes = [].slice.call(parent.querySelectorAll('a, ul[role=group]'));
            _nodes.forEach(function (node) {
              node.classList.remove('is-disabled');
              node.removeAttribute('aria-disabled');
            });
          }
        }
      }

      if (nodeData.node) {
        this.syncDataset();
      }

      if (nodeData.children) {
        if (nodeData.children.length) {
          this.addChildNodes(nodeData, parent);
        } else {
          this.removeChildren(nodeData, parent);
        }
      }
      this.createSortable();
    },


    // Performs the usual Boolean coercion with the exception of
    // the strings "false" (case insensitive) and "0"
    parseBool: function parseBool(b) {
      return !/^(false|0)$/i.test(b) && !!b;
    },


    /**
     * Delete children nodes
     * @private
     * @param {object} nodeData data for icon to be replaced.
     * @param {object} li parent node to delete children.
     * @returns {void}
     */
    removeChildren: function removeChildren(nodeData, li) {
      li = this.isjQuery(li) ? li[0] : li;
      var ul = li.querySelector('ul');

      this.setTreeIcon(li.querySelector('svg.icon-tree'), nodeData.icon || 'icon-tree-node');
      li.classList.remove('folder', 'is-open');
      if (ul) {
        ul.parentNode.removeChild(ul);
      }
    },


    /**
     * Delete a node from the dataset or tree.
     * @param {object} nodeData to delete.
     * @returns {void}
     */
    removeNode: function removeNode(nodeData) {
      var elem = this.findById(nodeData.id);

      if (nodeData instanceof jQuery) {
        elem = nodeData;
        elem.parent().remove();
      } else if (elem) {
        elem.node.parent().remove();
      }

      if (!elem) {
        return;
      }
      this.syncDataset();
    },


    // Attach Context Menus
    attachMenu: function attachMenu(menuId) {
      var self = this;

      if (!menuId) {
        return;
      }

      this.element.off('contextmenu.tree').on('contextmenu.tree', 'a', function (e) {
        var node = $(this);
        e.preventDefault();
        self.popupEl = $(e.currentTarget).popupmenu({ menuId: menuId, eventObj: e, trigger: 'immediate', attachToBody: true }).off('selected').on('selected', function (event, args) {
          /**
          * Fires when the an attached context menu item is selected.
          *
          * @event menuselect
          * @memberof Tree
          * @type {object}
          * @property {object} event - The jquery event object
          * @property {object} args for node element, item
          * @property {HTMLElement} args.node The DOM Element.
          * @property {object} data.item The attached node data.
          */
          self.element.triggerHandler('menuselect', { node: node, item: args });
        });

        /**
        * Fires when the attached context menu is opened. Use it to update the menu as needed
        * @memberof Tree
        * @event menuopen
        * @type {object}
        * @property {object} event - The jquery event object
        * @property {object} args for node element, item
        * @property {HTMLElement} args.menu The menu item
        * @property {HTMLElement} args.node The DOM Element.
        */
        self.element.triggerHandler('menuopen', { menu: $('#' + menuId), node: node });
        return false;
      });
    },


    /**
     * Create sortable.
     * @private
     * @returns {void}
     */
    createSortable: function createSortable() {
      if (!this.settings.sortable) {
        return;
      }

      var self = this;
      var clone = void 0;
      var interval = void 0;
      var doDrag = void 0;

      self.targetArrow = self.element[0].previousElementSibling;
      self.linkSelector = 'a:not(.is-dragging-clone):not(.is-disabled)';

      if (!self.targetArrow || self.targetArrow && !self.targetArrow.classList.contains('tree-drag-target-arrow')) {
        var div = document.createElement('div');
        div.classList.add('tree-drag-target-arrow');
        self.element[0].parentNode.insertBefore(div, self.element[0]);
        self.targetArrow = self.element[0].previousElementSibling;
      }

      function isReady() {
        // Make sure all dynamic nodes sync
        if (!self.loading) {
          clearInterval(interval);

          var links = [].slice.call(self.element[0].querySelectorAll(self.linkSelector));
          links.forEach(function (link) {
            var a = $(link);

            // Quit if already binded with `drag`
            if (a.data('drag')) {
              return;
            }

            // Don't drag with folder icon, save for toggle nodes
            a.on('mousedown.tree', function (e) {
              e.preventDefault();

              if (e.which === 3) {
                doDrag = false;
              } else {
                doDrag = e.target.classList.contains('icon') ? !link.parentNode.classList.contains('folder') : true;
              }
            })

            // Invoke drag
            .drag({
              clone: true,
              cloneAppendTo: a.closest('li'),
              clonePosIsFixed: true
            })

            // Drag start =======================================
            .on('dragstart.tree', function (e, pos, thisClone) {
              if (!thisClone || !doDrag) {
                link.classList.remove('is-dragging');
                if (thisClone) {
                  thisClone[0].parentNode.removeChild(thisClone[0]);
                }
                return;
              }
              clone = thisClone;
              clone[0].removeAttribute('id');
              clone[0].classList.add('is-dragging-clone');

              var items = [].slice.call(clone[0].querySelectorAll('.tree-checkbox, .tree-badge'));
              items.forEach(function (node) {
                return node.parentNode.removeChild(node);
              });

              var startUl = a.closest('ul');
              self.sortable = {
                // Do not use index from each loop, get updated index on drag start
                startIndex: $(self.linkSelector, self.element).index(a),
                startNode: a,
                startIcon: $('svg.icon-tree', a).getIconName(),
                startUl: startUl,
                startLi: a.closest('li'),
                startFolderNode: startUl.prev('a'),
                startWidth: a.outerWidth()
              };

              self.element.triggerHandler('sortstart', self.sortable);
              e.preventDefault();
              e.stopImmediatePropagation();
            })

            // While dragging ===================================
            .on('drag.tree', function (e, pos) {
              if (!clone) {
                return;
              }
              clone[0].style.left = pos.left + 'px';
              clone[0].style.top = pos.top + 'px';
              clone[0].style.opacity = '1';
              self.setDragOver(clone, pos);
            })

            // Drag end =========================================
            .on('dragend.tree', function (e, pos) {
              self.targetArrow.style.display = 'none';
              var items = [].slice.call(self.element[0].querySelectorAll(self.linkSelector));
              items.forEach(function (node) {
                return node.classList.remove('is-over');
              });

              if (!clone || !self.sortable.overDirection) {
                return;
              }
              clone[0].style.left = pos.left + 'px';
              clone[0].style.top = pos.top + 'px';

              var start = self.sortable.startNode.parent();
              var end = self.sortable.overNode.parent();

              // Over
              if (self.sortable.overDirection === 'over') {
                if (!end[0].classList.contains('folder')) {
                  self.convertFileToFolder(self.sortable.overNode);
                }
                end[0].querySelector('ul').appendChild(start[0]);
                if (!end[0].classList.contains('is-open')) {
                  self.toggleNode(self.sortable.overNode, e);
                }
              } else if (self.sortable.overDirection === 'up') {
                // Up
                start.insertBefore(end);
              } else if (self.sortable.overDirection === 'down') {
                // Down
                if (end[0].classList.contains('is-open') && end[0].classList.contains('folder')) {
                  $('ul:first', end).prepend(start);
                } else {
                  start.insertAfter(end);
                }
              }

              // Restore file type
              if (!self.sortable.startUl[0].querySelector('li') && !!self.sortable.startFolderNode.data('oldData') && self.sortable.startFolderNode.data('oldData').type === 'file') {
                self.convertFolderToFile(self.sortable.startFolderNode);
              }

              // Fix: On windows 10 with IE-11 icons disappears
              utils.fixSVGIcons(start);

              self.element.triggerHandler('sortend', self.sortable);
              // Sync dataset and ui
              self.syncDataset();
              if (self.isMultiselect) {
                self.initSelected();
              }
            });
          });
        }
      }
      // Wait for make sure all dynamic nodes sync
      interval = setInterval(isReady, 10);
    },


    /**
     * Set actions while drag over.
     * @private
     * @param {object} clone node.
     * @param {object} pos node positions to compare.
     * @returns {void}
     */
    setDragOver: function setDragOver(clone, pos) {
      var self = this;
      var cloneSvg = clone[0].querySelector('svg.icon-tree');
      var treeRec = self.element[0].getBoundingClientRect();
      var extra = 20;
      var exMargin = void 0;
      var isParentsStartNode = void 0;
      var isBeforeStart = void 0;
      var isAfterSttart = void 0;
      var li = void 0;
      var a = void 0;
      var ul = void 0;
      var links = void 0;
      var rec = void 0;
      var left = void 0;
      var top = void 0;
      var direction = void 0;
      var doAction = void 0;

      // Set as out of range
      var outOfRange = function outOfRange() {
        self.sortable.overNode = null;
        self.sortable.overIndex = null;
        self.sortable.overDirection = null;

        self.targetArrow.style.display = 'none';
        self.setTreeIcon(cloneSvg, 'icon-cancel');
      };

      // Moving inside tree
      if (pos.top > treeRec.top - extra && pos.top < treeRec.bottom + extra && pos.left > treeRec.left - extra - self.sortable.startWidth && pos.left < treeRec.left + treeRec.height + extra) {
        extra = 2;
        links = [].slice.call(self.element[0].querySelectorAll(self.linkSelector));

        links.forEach(function (link, i) {
          direction = null;
          rec = link.getBoundingClientRect();

          // Moving on/around node range
          if (pos.top > rec.top - extra && pos.top < rec.bottom + extra) {
            a = $(link);

            // Moving on/around node has parents as same node need to rearrange
            // Cannot rearrange parents to child
            isParentsStartNode = !!a.parentsUntil(self.element, '.folder').filter(function () {
              return $('a:first', this).is(self.sortable.startNode) && self.sortable.startLi.is('.folder');
            }).length;
            if (isParentsStartNode) {
              outOfRange();
              return;
            }

            li = link.parentNode;
            left = rec.left;
            ul = a.closest('ul');
            exMargin = parseInt(li.style.marginTop, 10) > 0 ? 2 : 0;
            isBeforeStart = i - 1 === self.sortable.startIndex && ul.is(self.sortable.startUl);
            isAfterSttart = i + 1 === self.sortable.startIndex && ul.is(self.sortable.startUl);
            links.forEach(function (node) {
              return node.classList.remove('is-over');
            });

            // Apply actions
            /* eslint-disable no-loop-func */
            doAction = function doAction() {
              if (!direction) {
                outOfRange();
                return;
              }

              // Reset icon
              self.setTreeIcon(cloneSvg, self.sortable.startIcon);

              // Over
              if (direction === 'over') {
                self.targetArrow.style.display = 'none';
                if (!link.classList.contains('is-disabled')) {
                  link.classList.add('is-over');
                }
              } else {
                // Up -or- Down
                links.forEach(function (node) {
                  return node.classList.remove('is-over');
                });
                top = direction === 'up' ? rec.top - 1.5 - (li.classList.contains('is-active') ? 3 : 0) : rec.bottom + (li.nextElementSibling && li.nextElementSibling.classList.contains('is-active') ? -1 : 1.5) + exMargin;
                self.targetArrow.style.left = left + 'px';
                self.targetArrow.style.top = top + 'px';
                self.targetArrow.style.display = 'block';
              }

              // Set changes
              self.sortable.overNode = a;
              self.sortable.overIndex = i;
              self.sortable.overDirection = direction;
            };
            /* eslint-disable no-loop-func */

            // Set moveing directions
            if (i !== self.sortable.startIndex) {
              // If hover on link
              if (pos.left > rec.left - extra - self.sortable.startWidth && pos.left < rec.right + extra) {
                if (!isBeforeStart && pos.top < rec.top) {
                  direction = 'up';
                } else if (!isAfterSttart && pos.top > rec.top + extra * 2) {
                  direction = 'down';
                } else {
                  direction = 'over';
                }
              } else if (!isBeforeStart && pos.top < rec.top) {
                // Not hover on link
                direction = 'up';
              } else if (!isAfterSttart) {
                direction = 'down';
              }
            }
            doAction(direction);
          }
        });
      } else {
        // Out side from tree area
        outOfRange();
      }
    },


    // Convert file node to folder type
    convertFileToFolder: function convertFileToFolder(node) {
      var newFolder = document.createElement('ul');
      newFolder.setAttribute('role', 'group');
      var oldData = {
        icon: $('svg.icon-tree', node).getIconName(),
        type: 'file'
      };
      if (this.hasIconClass(node)) {
        var iconClass = node.attr('class').replace(/\s?is-selected/, '');
        oldData.iconClass = iconClass;
        node.removeClass(iconClass);
      }
      node.data('oldData', oldData);
      var parent = node[0].parentNode;
      if (parent && parent.tagName.toLowerCase() === 'li') {
        parent.classList.add('folder');
        parent.appendChild(newFolder);
      }
      this.setTreeIcon($('svg.icon-tree', node), this.settings.folderIconClosed);
    },


    // Convert folder node to file type
    convertFolderToFile: function convertFolderToFile(node) {
      var parent = node.parent('.folder');
      parent.removeClass('folder is-open');
      $('ul:first', parent).remove();
      if (parent.length) {
        this.setTreeIcon($('svg.icon-tree', node), node.data('oldData') ? node.data('oldData').icon : 'tree-node');
        if (node.data('oldData') && node.data('oldData').iconClass) {
          node.addClass(node.data('oldData').iconClass);
        }
        node.data('oldData', null);
      }
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      if (this.settings.sortable) {
        this.element.find('a').each(function () {
          var a = $(this);
          var dragApi = a.data('drag');
          a.off('mousedown.tree');
          if (!!dragApi && !!dragApi.destroy) {
            dragApi.destroy();
          }
        });
        this.element.prev('.tree-drag-target-arrow').remove();
      }
      this.element.off('contextmenu.tree updated.tree click.tree focus.tree keydown.tree keypress.tree');

      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, TREE_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      this.element.empty();
      $.removeData(this.element[0], COMPONENT_NAME$15);
    },


    /**
     * Disables all nodes in the Tree component
     * @returns {void}
     */
    disable: function disable() {
      var nodes = [].slice.call(this.element[0].querySelectorAll('a'));
      nodes.forEach(function (node) {
        node.classList.add('is-disabled');
        node.setAttribute('aria-disabled', 'true');
      });
    },


    /**
     * Enables all nodes in the Tree component
     * @returns {void}
     */
    enable: function enable() {
      var nodes = [].slice.call(this.element[0].querySelectorAll('a'));
      nodes.forEach(function (node) {
        node.classList.remove('is-disabled');
        node.removeAttribute('aria-disabled');
      });
    },


    /**
     * Preserves all nodes' enablement states in the Tree component
     * @returns {array} of node objects containing attributes nodeId and state (enablement state)
     */
    preserveEnablementState: function preserveEnablementState() {
      var nodes = [].slice.call(this.element[0].querySelectorAll('a'));
      var enablementStates = [];

      nodes.forEach(function (node) {
        if (node.classList.contains('is-disabled') || node.getAttribute('aria-disabled') === true) {
          enablementStates.push({ nodeId: node.id, state: 'disabled' });
        } else {
          enablementStates.push({ nodeId: node.id, state: 'enabled' });
        }
      });

      this.settings.originalEnablementState = enablementStates;
      return enablementStates;
    },


    /**
     * Restores all nodes' original enablement states in the Tree component
     * @returns {void}
     */
    restoreEnablementState: function restoreEnablementState() {
      var _this6 = this;

      var nodes = [].slice.call(this.element[0].querySelectorAll('a'));

      // check to prevent error if preserveEnablementState() has not been invoked
      if (!(this.settings.originalEnablementState === null)) {
        nodes.forEach(function (node) {
          _this6.settings.originalEnablementState.forEach(function (origNode) {
            if (origNode.nodeId === node.id) {
              if (origNode.state === 'disabled') {
                node.classList.add('is-disabled');
                node.setAttribute('aria-disabled', 'true');
              } else {
                node.classList.remove('is-disabled');
                node.removeAttribute('aria-disabled');
              }
            }
          });
        });
      }
    }
  };

  /**
   * jQuery Component Wrapper for Tree
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.tree = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$15);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$15, new Tree(this, settings));
      }
    });
  };

  // Shared Imports

  // Settings and Options
  var COMPONENT_NAME$16 = 'treemap';

  // Default Radar Options
  var TREEMAP_DEFAULTS = {
    dataset: [],
    redrawOnResize: true,
    margin: { top: 20, right: 20, bottom: 20, left: 20 },
    colors: ['#133C59', '#134D71', '#1D5F8A', '#2578A9', '#368AC0', '#54A1D3', '#69B5DD', '#8DC9E6', '#ADD8EB', '#4B2A5E', '#5D3E70', '#6E5282', '#806594', '#9279A6', '#A38DB7', '#B59ECA', '#C7B4DB', '#DACCEC', '#0E5B52', '#206B62', '#317C73', '#448D83', '#579E95', '#69ADA3', '#7CC0B5', '#8ED1C6', '#A9E1D6'],
    showLabel: true,
    labelFormatter: '.0%',
    showTitle: true,
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' }
  };

  /**
   * A radar chart is a diagram representing hierarchical data in the form of nested rectangles,
   * the area of each corresponding to its numerical value.
   * @class Treemap
   * @param {string} element The plugin element for the constuctor
   * @param {string} settings The settings element.
   * @param {array} settings.dataset The data to use in the radar
   * @param {boolean} [settings.redrawOnResize = true] If false, the component will not resize when resizing the page.
   * @param {object} [settings.margin] The margins of the SVG, which you may want to adjust depending on text location.
   * @param {array} [settings.colors] An array of colors used in sequence from front to end of the array.
   * @param {boolean} [settings.showLabel] If false then the percentage wont be shown in the blocks.
   * @param {string} [settings.labelFormatter] The d3 formatter function for the value label.
   * @param {boolean} [settings.showTitle] If true then the first name will be used for the title area.
   * @param {object} [settings.emptyMessage] An empty message will be displayed when there is no chart data.
   * This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results', icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}
   *  }`
  *   Set this to null for no message or will default to 'No Data Found with an icon.'
  */
  function Treemap(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TREEMAP_DEFAULTS);
    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.element = $(element);
    this.init();
  }

  // Plugin Methods
  Treemap.prototype = {

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.build().handleEvents();

      /**
      * Fires when the chart is complete done rendering, for customization.
      * @event rendered
      * @memberof Treemap
      * @property {object} event - The jquery event object
      * @property {array} svg - The svg object.
      */
      this.element.trigger('rendered', [this.svg]);

      return this;
    },


    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      this.updateData(this.settings.dataset);
      return this;
    },


    /**
     * Update the chart with a new dataset
     * @param  {object} data The data to use.
     */
    updateData: function updateData(data) {
      var _this = this;

      var margin = Object.create(this.settings.margin);
      var width = this.element.parent().width() - margin.left - margin.right;
      var height = this.element.parent().height() - margin.top - margin.bottom;
      // Define the colors
      var color = d3.scaleOrdinal().range(this.settings.colors);

      // Handle Empty Data Set
      if (data.length === 0) {
        this.element.emptymessage(this.settings.emptyMessage);
        return;
      }

      // Show the title area
      if (this.settings.showTitle && data.name) {
        d3.select(this.element[0]).append('div').attr('class', 'chart-treemap-title').text(data.name);

        height -= 35;
        margin.top -= 19;
      }

      // Run the d3 tree map algorithm
      var treemap = d3.treemap().size([width, height]);

      // Set the height / width and class
      this.root = d3.select(this.element[0]).classed('chart-treemap', true).append('div').style('position', 'relative').style('width', width + margin.left + margin.right + 'px').style('height', height + margin.top + margin.bottom + 'px').style('left', margin.left + 'px').style('top', margin.top + 'px');

      // Format the data into a hierarchy tree
      var root = d3.hierarchy(data, function (d) {
        return d.children;
      }).sum(function (d) {
        return d.value;
      });
      var tree = treemap(root);

      this.total = d3.sum(tree.leaves(), function (d) {
        return d.value;
      });

      // Add the tree map nodes
      this.root.datum(root).selectAll('.chart-treemap-node').data(tree.leaves()).enter().append('div').attr('class', 'chart-treemap-node').style('left', function (d) {
        return d.x0 + 'px';
      }).style('top', function (d) {
        return d.y0 + 'px';
      }).style('width', function (d) {
        return Math.max(0, d.x1 - d.x0 - 1) + 'px';
      }).style('height', function (d) {
        return Math.max(0, d.y1 - d.y0 - 1) + 'px';
      }).style('background', function (d) {
        if (!d || !d.parent || !d.parent.data) {
          return '';
        }
        return color(d.parent.data.name);
      }).text(function (d) {
        return d.data.name;
      });

      if (this.settings.showLabel) {
        this.root.selectAll('.chart-treemap-node').append('span').attr('class', 'chart-treemap-percent').text(function (d) {
          return d3.format(_this.settings.labelFormatter)(d.value / _this.total);
        });
      }
    },


    /**
     * Sets up event handlers for this component and its sub-elements.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element.on('updated.' + COMPONENT_NAME$16, function () {
        _this2.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on('resize.' + COMPONENT_NAME$16, function () {
          _this2.handleResize();
        });

        this.element.on('resize.' + COMPONENT_NAME$16, function () {
          _this2.handleResize();
        });
      }

      return this;
    },


    /**
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },


    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      this.element.empty();
      return this.build();
    },


    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      this.element.off('updated.' + COMPONENT_NAME$16);
      $('body').off('resize.' + COMPONENT_NAME$16);
      return this;
    },


    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('chart-treemap');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$16);
    }
  };

  /**
   * jQuery Component Wrapper for Tremmap
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.treemap = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$16);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$16, new Treemap(this, settings));
      }
    });
  };

  // jQuery Components

  // Component Name
  var COMPONENT_NAME$17 = 'wizard';

  // Component Default Settings
  var WIZARD_DEFAULTS = {
    ticks: null
  };

  /**
   * A horizontal form based wizard component.
   * @class Wizard
   * @param {jQuery[]|HTMLElement} element the Wizard container
   * @param {object} [settings] incoming settings
   * @param {jQuery[]} [settings.ticks]  Defines the data to use, must be specified.
   */
  function Wizard(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, WIZARD_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Wizard.prototype = {

    /**
     * @private
     */
    init: function init() {
      this.build().handleEvents();
    },


    /**
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      this.header = this.element.find('.wizard-header');
      if (!this.header.length) {
        this.header = $('<div class="wizard-header"></div>').appendTo(this.element);
      }

      this.bar = this.element.find('.bar');
      if (!this.bar.length) {
        this.bar = $('<div class="bar"></div>').appendTo(this.header);
      }

      this.completedRange = this.element.find('.completed-range');
      if (!this.completedRange.length) {
        this.completedRange = $('<div class="completed-range"></div>').appendTo(this.bar);
      }

      this.buildTicks().updateRange();

      return this;
    },


    /**
     * Builds the HTML Markup that draws out defined Wizard tick marks.
     * @private
     * @returns {this} component instance
     */
    buildTicks: function buildTicks() {
      var settingTicks = this.settings.ticks;
      var self = this;

      this.ticks = this.bar.children('.tick');

      if (!this.ticks.length && settingTicks) {
        for (var i = 0; i < settingTicks.length; i++) {
          var link = $('<a ng-click="handleClick()" class="tick ' + (settingTicks[i].state ? settingTicks[i].state : '') + '" href="' + (settingTicks[i].href ? settingTicks[i].href : '#') + '"><span class="label">' + settingTicks[i].label + '</span></a>');

          if (settingTicks[i].ngClick) {
            link.attr('ng-click', settingTicks[i].ngClick);
          }

          self.bar.append(link);
        }
        this.ticks = this.bar.children('.tick');
      }
      this.positionTicks();

      $('.tick', self.element).each(function () {
        var tick = $(this);
        if (tick.hasClass('is-disabled')) {
          tick.removeAttr('onclick ng-click');
        }
      });

      this.element.find('.wizard-header')[0].style.opacity = '1';
      return this;
    },
    positionTicks: function positionTicks() {
      var l = this.ticks.length;
      var delta = 100 / (l - 1);
      var tickPos = [];

      function getPoint(i) {
        if (i === 0) {
          return 0;
        }
        if (i === l - 1) {
          return 100;
        }
        return delta * i;
      }

      for (var i = 0; i < l; i++) {
        tickPos.push(getPoint(i));
      }

      this.ticks.each(function (i) {
        var tick = $(this);
        var label = tick.children('.label');
        var left = (Locale ? Locale.isRTL() : false) ? 100 - tickPos[i] : tickPos[i];

        this.style.left = left + '%';

        for (var i2 = 0, l2 = label.length; i2 < l2; i2++) {
          label[i2].style.left = '-' + (label.outerWidth() / 2 - tick.outerWidth() / 2) + 'px';
        }

        if (tick.is('.is-disabled')) {
          tick.attr('tabindex', '-1');
        }
      });
    },


    /**
     * Re-renders the Wizard Range with updated ticks
     * @private
     * @returns {this} component instance
     */
    updateRange: function updateRange() {
      var currentTick = this.ticks.filter('.current').last();
      var widthPercentage = 0;

      if (currentTick.length) {
        widthPercentage = 100 * parseFloat(window.getComputedStyle(currentTick[0]).left) / parseFloat(window.getComputedStyle(currentTick.parent()[0]).width);
        widthPercentage = (Locale ? Locale.isRTL() : false) ? 100 - widthPercentage : widthPercentage;
      }

      this.completedRange[0].style.width = widthPercentage + '%';
      return this;
    },


    /**
     * Update the wizard component with new settings.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.buildTicks().updateRange();

      return this;
    },


    /**
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.ticks.off('click.wizard');
      this.element.off('updated.wizard');

      this.ticks.remove();
      return this;
    },


    /**
     * Activates one of the Wizard's ticks.
     * This method is slated to be removed in a future v4.10.0 or v5.0.0.
     * @deprecated as of v4.4.0.  Please use `activate()` instead.
     * @param {jQuery.Event} e the activate event object
     * @param {jQuery[]|HTMLElement} tick the target tick to be activated
     * @returns {this} component instance
     */
    select: function select(e, tick) {
      return deprecateMethod(this.activate, this.select).apply(this, [e, tick]);
    },


    /**
     * Activates one of the Wizard's ticks.
     * Tick can either be a number (representing the tick's index) or a jQuery
     * element reference to a tick.
     * @param {jQuery.Event} e the activate event object
     * @param {jQuery[]|HTMLElement} tick the target tick to be activated
     * @returns {this} component instance
     */
    activate: function activate(e, tick) {
      if (e === undefined && !tick) {
        return this;
      }

      var self = this;

      function getTick() {
        var target = void 0;

        // Use the first variable as the tick definition or index if "e" is null,
        // undefined, or not an event object. This is for backwards compatibility with
        // this control's old select() method, which took an index as an argument.
        if (e !== undefined && (e === undefined || e === null || !e.type || !e.target) && !tick) {
          tick = e;
        }

        if (tick === undefined) {
          target = $(e.target);
          return target.is('.label') ? target.parent() : target;
        }

        if (typeof tick === 'number') {
          return self.ticks.eq(tick);
        }

        return tick;
      }

      tick = getTick();

      if (e && (tick.is('[disabled], .is-disabled') || !tick.is('a'))) {
        e.preventDefault();
        e.stopPropagation();
        return this;
      }

      /**
       * Fires before a step is activated/pressed. You can cancel selection by returning a 'beforeactivate'
       * handler as 'false'
       * @event beforeactivate
       * @memberof Wizard
       * @property {object} event - The jquery event object
       * @property {HTMLElement} tick - The tick (link) that was activated.
       */
      var canNav = this.element.triggerHandler('beforeactivate', [tick]);
      if (canNav === false) {
        return this;
      }

      var trueIndex = this.ticks.index(tick);
      this.ticks.removeClass('complete current').eq(trueIndex).addClass('current').prevAll('.tick').addClass('complete');

      this.updateRange();

      /**
       * Fires while a step is activated/pressed.
       * handler as 'false'
       * @event activated
       * @memberof Wizard
       * @property {object} event - The jquery event object
       * @property {HTMLElement} tick - The tick (link) that was activated.
       */
      this.element.trigger('activated', [tick]);

      /**
       * Fires after a step is activated/pressed. And the new Dom is loaded.
       * handler as 'false'
       * @event afteractivated
       * @memberof Wizard
       * @property {object} event - The jquery event object
       * @property {HTMLElement} tick - The tick (link) that was activated.
       */
      setTimeout(function () {
        self.element.trigger('afteractivated', [tick]);
      }, 300);

      return this;
    },


    /**
     * Destroy and remove added markup and events
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$17);
    },


    /**
     * This component listens to the following events:
     * @private
     * @listens updated custom updated event
     * @listens click jQuery click event
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('updated', function () {
        self.updated();
      });

      this.ticks.on('click.wizard', function (e) {
        self.activate(e, $(this));
      });

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Wizard
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.wizard = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$17);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$17, new Wizard(this, settings));
      }
    });
  };

  /**
  * A object containing all the supported UI formatters.
  * @private
  */
  var formatters = {
    Text: function Text(row, cell, value) {
      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      return str;
    },
    Input: function Input(row, cell, value, col) {
      if (col.inlineEditor) {
        var html = '<label for="datagrid-inline-input-' + row + '-' + cell + '" class="audible">' + col.name + '</label><input id="datagrid-inline-input-' + row + '-' + cell + '" class="' + (col.align === 'right' ? 'is-number-mask' : '') + '" value="' + value + '">';

        return html;
      }

      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      return str;
    },
    Placeholder: function Placeholder(row, cell, value, col, item) {
      if (col.placeholder && value === '') {
        var placeholder = col.placeholder;
        var getType = {};
        if (getType.toString.call(placeholder) === '[object Function]') {
          placeholder = placeholder(row, cell, value, col, item);
        } else if (item && placeholder in item) {
          placeholder = item[placeholder];
        }
        var html = '<span class="is-placeholder">' + placeholder + '</span>';

        return html;
      }

      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      return str;
    },
    Ellipsis: function Ellipsis(row, cell, value, col) {
      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      col.textOverflow = 'ellipsis';
      return str;
    },
    Password: function Password(row, cell, value) {
      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      return str.replace(/./g, '*');
    },
    Readonly: function Readonly(row, cell, value) {
      return '<span class="is-readonly">' + (value === null || value === undefined ? '' : value) + '</span>';
    },
    Date: function Date(row, cell, value, col, isReturnValue) {
      var formatted = value === null || value === undefined ? '' : value;
      var value2 = void 0;

      if (typeof value === 'string' && value) {
        if (col.sourceFormat) {
          value2 = Locale.parseDate(value, typeof col.sourceFormat === 'string' ? { pattern: col.sourceFormat } : col.sourceFormat);
        } else {
          value2 = Locale.parseDate(value, typeof col.dateFormat === 'string' ? { pattern: col.dateFormat } : col.dateFormat);
        }

        if (value2) {
          formatted = Locale.formatDate(value2, typeof col.dateFormat === 'string' ? { pattern: col.dateFormat } : col.dateFormat);
        } else {
          formatted = Locale.formatDate(value, typeof col.dateFormat === 'string' ? { pattern: col.dateFormat } : col.dateFormat);

          if ((formatted === 'NaN/NaN/NaN' || !formatted) && formatted !== '') {
            // show invalid dates not NaN/NaN/NaN
            formatted = value;
          }
        }
      } else if (value) {
        formatted = Locale.formatDate(value, typeof col.dateFormat === 'string' ? { pattern: col.dateFormat } : col.dateFormat);
      }

      if (!col.editor || isReturnValue === true) {
        return formatted;
      }
      return '<span class="trigger">' + formatted + '</span>' + $.createIcon({ icon: 'calendar', classes: ['icon-calendar'] });
    },
    Time: function Time(row, cell, value, col) {
      var formatted = value === null || value === undefined ? '' : value;
      var localeDateFormat = (typeof Locale === 'undefined' ? 'undefined' : _typeof(Locale)) === 'object' && Locale.calendar().dateFormat ? Locale.calendar().dateFormat.short : null;
      var localeTimeFormat = (typeof Locale === 'undefined' ? 'undefined' : _typeof(Locale)) === 'object' && Locale.calendar().timeFormat ? Locale.calendar().timeFormat : null;
      var value2 = void 0;

      var parseTime = function parseTime(timeString) {
        if (timeString === '') {
          return null;
        }
        var time = timeString.match(/(\d+)(?::(\d\d))(?::(\d\d))?\s*([pP]?)/i);
        if (time === null) {
          return null;
        }
        var d = new Date();
        d.setHours(parseInt(time[1], 10) + (time[4] ? 12 : 0));
        d.setMinutes(parseInt(time[2], 10) || 0);
        d.setSeconds(parseInt(time[3], 10) || 0);
        return d;
      };

      if (typeof value === 'string' && value) {
        value2 = Locale.formatDate(parseTime(value), { pattern: localeDateFormat + ' ' + (col.sourceFormat || col.timeFormat || localeTimeFormat) });

        if (value2) {
          formatted = value2.slice(value2.indexOf(' '));
        }
      } else if (value) {
        value2 = Locale.formatDate(value, { pattern: localeDateFormat + ' ' + (col.sourceFormat || col.timeFormat || localeTimeFormat) });
        if (value2) {
          formatted = value2.slice(value2.indexOf(' '));
        }
      }

      // Remove extra space in begining
      formatted = formatted.replace(/^\s/, '');

      if (!col.editor) {
        return formatted;
      }
      return '<span class="trigger">' + formatted + '</span>' + $.createIcon({ icon: 'clock', classes: ['icon-clock'] });
    },
    Autocomplete: function Autocomplete(row, cell, value) {
      var formatted = value === null || value === undefined ? '' : value;
      return formatted;
    },
    Lookup: function Lookup(row, cell, value, col, item) {
      var formatted = value === null || value === undefined ? '' : value;
      if (!col.editor) {
        return formatted;
      }

      if (col.editorOptions && typeof col.editorOptions.field === 'function') {
        formatted = col.editorOptions.field(item, null, null);
      }

      if (formatted === null || formatted === undefined || formatted === '') {
        formatted = '';
      }
      return '<span class="trigger ' + (col.align === 'right' ? 'align-text-right' : '') + '">' + formatted + '</span>' + $.createIcon({ icon: 'search-list', classes: ['icon-search-list'] });
    },
    Decimal: function Decimal(row, cell, value, col) {
      var formatted = value;
      if (typeof Locale !== 'undefined' && formatted !== null && formatted !== undefined && formatted !== '') {
        formatted = Locale.formatNumber(value, col.numberFormat);
      }
      return formatted === null || formatted === undefined || formatted === 'NaN' ? '' : formatted;
    },
    Integer: function Integer(row, cell, value, col) {
      var formatted = value;
      if (typeof Locale !== 'undefined' && formatted !== null && formatted !== undefined && formatted !== '') {
        formatted = Locale.formatNumber(value, col.numberFormat || { style: 'integer' });
      }
      return formatted === null || formatted === undefined || formatted === 'NaN' ? '' : formatted;
    },
    Hyperlink: function Hyperlink(row, cell, value, col, item, api) {
      var colHref = col.href || '#';

      // Support for dynamic links based on content
      if (col.href && typeof col.href === 'function') {
        colHref = col.href(row, cell, item, col);
        // Passing a null href will produce "just text" with no link
        if (colHref == null) {
          return col.text || value;
        }
      } else {
        colHref = colHref.replace('{{value}}', value);
      }

      var textValue = col.text || value;
      if (!textValue && !col.icon) {
        return '';
      }

      return col.icon ? '<a href="' + colHref + '" class="btn-icon row-btn ' + (col.cssClass || '') + '" ' + (!api.settings.rowNavigation ? '' : 'tabindex="-1"') + (col.hyperlinkTooltip ? ' title="' + col.hyperlinkTooltip + '"' : '') + '>\n          ' + $.createIcon({ icon: col.icon, file: col.iconFile }) + '\n          <span class="audible">' + textValue + '</span>\n        </a>' : '<a href="' + colHref + '" ' + (!api.settings.rowNavigation ? '' : 'tabindex="-1"') + ' role="presentation" class="hyperlink ' + (col.cssClass || '') + '"' + (col.target ? ' target="' + col.target + '"' : '') + (col.hyperlinkTooltip ? ' title="' + col.hyperlinkTooltip + '"' : '') + '>' + textValue + '</a>';
    },
    Template: function Template(row, cell, value, col, item) {
      var tmpl = col.template;
      var renderedTmpl = '';

      if (Tmpl && item && tmpl) {
        renderedTmpl = Tmpl.compile('{{#dataset}}' + tmpl + '{{/dataset}}', { dataset: item });
      }

      return renderedTmpl;
    },
    Drilldown: function Drilldown() {
      var text = Locale.translate('Drilldown');

      if (text === undefined) {
        text = '';
      }

      return '<button type="button" tabindex="-1" class="btn-icon small datagrid-drilldown">\n         ' + $.createIcon({ icon: 'drilldown' }) + '\n        <span>' + text + '</span>\n      </button>';
    },
    RowReorder: function RowReorder() {
      var text = Locale.translate('ReorderRows');

      if (text === undefined) {
        text = 'Reorder Rows';
      }

      return '<div class="datagrid-reorder-icon">\n         ' + $.createIcon({ icon: 'drag' }) + '\n        <span class="audible">' + text + '</span>\n      </div>';
    },
    Checkbox: function Checkbox(row, cell, value, col, item, api) {
      var isChecked = void 0;

      // Use isChecked function if exists
      if (col.isChecked) {
        isChecked = col.isChecked(value);
      } else {
        // treat 1, true or '1' as checked
        isChecked = value === undefined ? false : value === true;
      }

      // We add hidden Yes/No text so that the exported excel spreadsheet shows
      // this text in checkbox columns
      var hiddenText = '<span class="hidden" aria-hidden="true" role="presentation"> ' + Locale.translate(isChecked ? 'Yes' : 'No') + '</span>';

      var animate = api.wasJustUpdated;
      api.wasJustUpdated = false;
      return '<div class="datagrid-checkbox-wrapper"><span role="checkbox" aria-label="' + col.name + '" class="datagrid-checkbox\n     ' + (isChecked ? 'is-checked ' + (!animate ? ' no-animation' : ' ') : '') + '" aria-checked="' + isChecked + '"></span>' + hiddenText + '</div>';
    },
    SelectionCheckbox: function SelectionCheckbox(row, cell, value, col, item, api) {
      var isChecked = value === undefined ? false : value === true;
      if (!value) {
        isChecked = api.isRowSelected(item);
      }
      return '<div class="datagrid-checkbox-wrapper"><span role="checkbox" aria-label="' + (col.name ? col.name : Locale.translate('Select')) + '" class="datagrid-checkbox datagrid-selection-checkbox' + (isChecked ? ' is-checked no-animate' : '') + '" aria-checked="' + isChecked + '"></span></div>';
    },
    Actions: function Actions(row, cell, value, col) {
      // Render an Action Formatter
      return '<button type="button" class="btn-actions" aria-haspopup="true" aria-expanded="false" aria-owns="' + col.menuId + ' +\'">\n        <span class="audible">' + col.title + '</span>\n        ' + $.createIcon({ icon: 'more' }) + '\n      </button>';
    },


    // Multi Line TextArea
    Textarea: function Textarea(row, cell, value) {
      var formatted = value === null || value === undefined ? '' : value;
      return '<span class="datagrid-multiline-text">' + formatted + '</span>';
    },


    // Rich Text Editor
    Editor: function Editor(row, cell, value, col) {
      var formatted = value === null || value === undefined ? '' : value;
      var classes = 'is-editor';
      classes += col.singleline ? ' is-singleline' : ' datagrid-multiline-text';
      classes += col.contentTooltip ? ' content-tooltip' : '';
      return '<div class="' + classes + '">' + xssUtils.unescapeHTML(formatted) + '</div>';
    },


    // Expand / Collapse Button
    Expander: function Expander(row, cell, value) {
      var button = '<button type="button" aria-label="' + Locale.translate('ExpandCollapse') + '" class="btn-icon datagrid-expand-btn" tabindex="-1">\n      <span class="icon plus-minus"></span>\n      </button>' + (value ? '<span> ' + value + '</span>' : '');

      return button;
    },


    // Datagrid Group Row
    GroupRow: function GroupRow(row, cell, value, col, item, api) {
      var groupSettings = api.settings.groupable;
      var rowHtml = { left: '', center: '', right: '' };
      var groups = '';
      var isOpen = groupSettings.expanded === undefined ? true : groupSettings.expanded;

      if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
        isOpen = groupSettings.expanded(row, cell, value, col, item, api);
      }

      for (var i = 0; i < groupSettings.fields.length; i++) {
        groups += item[groupSettings.fields[i]] + (i === 0 ? '' : ',');
      }

      if (groupSettings.groupRowFormatter) {
        groups = groupSettings.groupRowFormatter(row, cell, value, col, item, api);
      }

      var button = '<button type="button" class="btn-icon datagrid-expand-btn' + (isOpen ? ' is-expanded' : '') + '" tabindex="-1">\n    <span class="icon plus-minus' + (isOpen ? ' active' : '') + '"></span>\n    <span class="audible">' + Locale.translate('ExpandCollapse') + '</span>\n    </button><span> ' + groups + '</span>';

      // Take the first
      var container = api.getContainer(groupSettings.fields ? groupSettings.fields[0] : '');
      rowHtml[container] = button;
      return rowHtml;
    },
    GroupFooterRow: function GroupFooterRow(row, cell, value, col, item, api) {
      var groupSettings = api.settings.groupable;
      var rowHtml = { left: '', center: '', right: '' };
      var visibleColumnsLeft = api.settings.frozenColumns.left.length;
      var visibleColumnsRight = api.settings.frozenColumns.right.length;
      var idx = api.columnIdxById(groupSettings.aggregate);
      var container = api.getContainer(groupSettings.aggregate);
      rowHtml.left = '<td role="gridcell" colspan="' + visibleColumnsLeft + '"><div class="datagrid-cell-wrapper"></div></td><td role="gridcell"><div class="datagrid-cell-wrapper">' + (container === 'left' ? item.sum : '<span>&nbsp;</span>') + '</div></td>';
      rowHtml.center = '<td role="gridcell" colspan="' + (idx - visibleColumnsLeft - visibleColumnsRight) + '"><div class="datagrid-cell-wrapper"></div></td><td role="gridcell"><div class="datagrid-cell-wrapper">' + (container === 'center' ? item.sum : '<span>&nbsp;</span>') + '</div></td>';
      rowHtml.right = '<td role="gridcell" colspan="' + visibleColumnsRight + '"><div class="datagrid-cell-wrapper"></div></td><td role="gridcell"><div class="datagrid-cell-wrapper">' + (container === 'right' ? item.sum : '<span>&nbsp;</span>') + '</div></td>';

      if (groupSettings.groupFooterRowFormatter) {
        rowHtml[container] = groupSettings.groupFooterRowFormatter(idx, row, cell, value, col, item, api);
      }

      return rowHtml;
    },
    SummaryRow: function SummaryRow(row, cell, value, col) {
      var afterText = '';
      var beforeText = col.summaryText || '';

      if (col.summaryTextPlacement === 'after') {
        afterText = beforeText;
        beforeText = '';
      }

      if (typeof Locale !== 'undefined' && col.numberFormat && value !== null && value !== undefined && value !== '') {
        value = Locale.formatNumber(+value, col.numberFormat);
      }

      return beforeText + (value === null || value === undefined || value === '' ? '' : value.toString()) + afterText;
    },


    // Tree Expand / Collapse Button and Paddings
    Tree: function Tree(row, cell, value, col, item, api) {
      var isOpen = item ? item.expanded : true;
      var depth = api && api.settings.treeDepth && api.settings.treeDepth[row] ? api.settings.treeDepth[row].depth : 0;

      // When use filter then
      // If (settings.allowChildExpandOnMatch === false) and only parent node got match
      // then make expand/collapse button to be collapsed and disabled
      var isExpandedBtnDisabled = item && item.isAllChildrenFiltered;
      var expandedBtnDisabledHtml = isExpandedBtnDisabled ? ' disabled' : '';
      if (isOpen && isExpandedBtnDisabled) {
        isOpen = false;
      }
      if (item && typeof item.isAllChildrenFiltered !== 'undefined') {
        // Remove key after use to reset
        delete item.isAllChildrenFiltered;
      }

      var button = '<button type="button" class="btn-icon datagrid-expand-btn' + (isOpen ? ' is-expanded' : '') + '" tabindex="-1"' + (depth ? ' style="margin-left: ' + (depth ? 30 * (depth - 1) + 'px' : '') + '"' : '') + expandedBtnDisabledHtml + '>\n      <span class="icon plus-minus ' + (isOpen ? ' active' : '') + '"></span>\n      <span class="audible">' + Locale.translate('ExpandCollapse') + '</span>\n      </button>' + (value ? ' <span>' + value + '</span>' : '');
      var node = ' <span class="datagrid-tree-node"' + (depth ? ' style="margin-left: ' + (depth ? 30 * depth + 'px' : '') + '"' : '') + '>' + value + '</span>';

      return item && item[col.children ? col.children : 'children'] ? button : node;
    },


    // Badge / Tags and Visual Indictors
    ClassRange: function ClassRange(row, cell, value, col) {
      var ranges = col.ranges;
      var classes = '';
      var text = '';

      if (!ranges) {
        return {};
      }

      for (var i = 0; i < ranges.length; i++) {
        if (value >= ranges[i].min && value <= ranges[i].max) {
          classes = ranges[i].classes;
          text = ranges[i].text ? ranges[i].text : classes.split(' ')[0];
        }

        if (value === ranges[i].value) {
          classes = ranges[i].classes;
          text = ranges[i].text ? ranges[i].text : value;
        }
      }

      return { classes: classes, text: text };
    },


    // Badge (Visual Indictors)
    Badge: function Badge(row, cell, value, col) {
      var colorClasses = col.color;
      var text = col.name;

      if (col.ranges) {
        var ranges = formatters.ClassRange(row, cell, value, col);
        colorClasses = ranges.classes;
        text = ranges.text;
      }
      return '<span class="badge ' + colorClasses + '">' + value + ' <span class="audible">' + text + '</span></span>';
    },
    Tag: function Tag(row, cell, value, col) {
      var ranges = formatters.ClassRange(row, cell, value, col);
      return '<span class="tag ' + ranges.classes + '">' + value + '</span>';
    },
    Alert: function Alert(row, cell, value, col) {
      var ranges = formatters.ClassRange(row, cell, value, col);
      var icon = $.createIcon({
        icon: ranges.classes,
        classes: ['icon', 'datagrid-alert-icon', 'icon-' + ranges.classes]
      });
      return icon + '<span class="datagrid-alert-text">' + (ranges.text === 'value' ? value : ranges.text) + '</span>';
    },
    Image: function Image(row, cell, value, col) {
      return '<img class="datagrid-img" src="' + value + '" alt="' + (col.alt ? col.alt : Locale.translate('Image')) + '"' + (col.dimensions ? ' style="height:' + col.dimensions.height + ';width:' + col.dimensions.height + '"' : '') + '/>';
    },
    Color: function Color(row, cell, value, col) {
      var ranges = formatters.ClassRange(row, cell, value, col);
      var text = value === null || value === undefined || value === '' ? '' : value.toString();

      return '<span class="' + ranges.classes + '">' + text + '</span>';
    },
    Colorpicker: function Colorpicker(row, cell, value, col) {
      var html = value === null || value === undefined || value === '' ? '' : value.toString();
      if (col.inlineEditor) {
        return html;
      }
      var classList = 'swatch' + (value === '' ? ' is-empty' : '');
      html = '<span class="colorpicker-container trigger dropdown-trigger"><span class="' + classList + '" style="background-color: ' + value + '"></span><input class="colorpicker" id="colorpicker-' + cell + '" name="colorpicker-' + cell + '" type="text" role="combobox" aria-autocomplete="list" value="' + value + '" aria-describedby="">';
      html += '<span class="trigger">' + $.createIcon({ icon: 'dropdown' }) + '</span></span>';

      return html;
    },
    Button: function Button(row, cell, value, col, item, api) {
      var text = void 0;
      if (col.text) {
        text = col.text;
      } else {
        text = value === null || value === undefined || value === '' ? '' : value.toString();
      }
      var markup = '<button type="button" class="' + (col.icon ? 'btn-icon' : 'btn-secondary') + ' row-btn ' + (col.cssClass ? col.cssClass : '') + '"' + (!api.settings.rowNavigation ? '' : ' tabindex="-1"') + ' >';

      if (col.icon) {
        markup += $.createIcon({ icon: col.icon, file: col.iconFile });
      }
      markup += '<span>' + text + '</span></button>';

      return markup;
    },
    Dropdown: function Dropdown(row, cell, value, col) {
      var formattedValue = value;
      var compareValue = void 0;
      var option = void 0;
      var optionValue = void 0;

      if (col.options && value !== undefined) {
        compareValue = col.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;

        for (var i = 0, l = col.options.length; i < l; i++) {
          option = col.options[i];
          optionValue = col.caseInsensitive && typeof option.value === 'string' ? option.value.toLowerCase() : option.value;

          if (optionValue === compareValue) {
            formattedValue = option.label;
            break;
          }
        }
      }

      var html = '<span class="trigger dropdown-trigger">' + formattedValue + '</span>' + $.createIcon({ icon: 'dropdown' });

      if (col.inlineEditor) {
        html = '<label for="full-dropdown" class="audible">' + col.name + '</label><select id="datagrid-dropdown' + row + '" class="dropdown">';

        for (var _i = 0, _l = col.options.length; _i < _l; _i++) {
          var opt = col.options[_i];
          var labelOrValue = void 0;
          if (opt.label !== undefined) {
            labelOrValue = opt.label;
          } else {
            labelOrValue = opt.value !== undefined ? opt.value : '';
          }
          html += '<option' + (opt.id === undefined ? '' : ' id="' + opt.id + '"') + '  value="' + opt.value + '"' + (opt.selected || opt.value === compareValue ? ' selected ' : '') + '>' + labelOrValue + '</option>';
        }

        html += '</select>\n      <div class="dropdown-wrapper is-inline">\n        <div class="dropdown"><span>' + formattedValue + '</span></div>\n        <svg class="icon" focusable="false" aria-hidden="true" role="presentation">\n          <use xlink:href="#icon-dropdown"></use>\n        </svg>\n      </div>';
      }

      return html;
    },
    Fileupload: function Fileupload(row, cell, value, col) {
      var html = value === null || value === undefined || value === '' ? '' : value.toString();

      if (!col.inlineEditor) {
        if ($.trim(html) === '') {
          html = '<span class="trigger">' + html + '</span>' + $.createIcon({ icon: 'folder', classes: ['icon-fileupload'] });
        } else {
          html = '<span class="trigger is-clearable">' + html + '</span>' + $.createIcon({ icon: 'close', classes: ['icon-close'] }) + $.createIcon({ icon: 'folder', classes: ['icon-fileupload'] });
        }
      }

      return html;
    },
    Spinbox: function Spinbox(row, cell, value, col) {
      var html = value === null || value === undefined || value === '' ? '' : value.toString();

      if (col.inlineEditor) {
        html = '<label for="spinbox-' + cell + '" class="audible">Quantity</label>\n        <span class="spinbox-wrapper"><span class="spinbox-control down">-</span>\n        <input id="spinbox-' + cell + '" name="spinbox-' + cell + '" type="text" class="spinbox" value="' + value + '">\n        <span class="spinbox-control up">+</span></span>';
      }

      return html;
    },
    Favorite: function Favorite(row, cell, value, col, item, api) {
      var isChecked = void 0;

      // Use isChecked function if exists
      if (col.isChecked) {
        isChecked = col.isChecked(value);
      } else {
        isChecked = value === undefined ? false : value === true;
      }

      var isEditable = col.editor && api.settings.editable;

      if (isChecked) {
        return '<span aria-label="' + Locale.translate('Favorite') + '" class="icon-favorite' + (isEditable ? ' is-editable' : '') + '">' + $.createIcon({ icon: 'star-filled' }) + '</span>';
      }
      return col.showEmpty ? '<span aria-label="' + Locale.translate('Favorite') + '" class="icon-favorite' + (isEditable ? ' is-editable' : '') + '">' + $.createIcon({ icon: 'star-outlined' }) + '</span>' : '';
    },
    Status: function Status(row, cell, value, col, item) {
      if (!item || !item.rowStatus) {
        return '<span></span>';
      }

      return $.createIcon({ icon: item.rowStatus.icon, classes: ['icon', 'icon-' + item.rowStatus.icon] }) + '<span class="audible">' + item.rowStatus.text + '</span>';
    },
    TargetedAchievement: function TargetedAchievement(row, cell, value, col) {
      var perc = 100 * value;
      var text = perc + '%';
      var ranges = formatters.ClassRange(row, cell, perc, col);
      var target = col.target;
      var isWhite = perc > 60;

      if (col.text) {
        text = col.text;
        text = text.replace('{{value}}', value);
        text = text.replace('<% value %>', value);
        text = text.replace('<%value%>', value);

        text = text.replace('{{percent}}', perc);
        text = text.replace('<% percent %>', perc);
        text = text.replace('<%percent%>', perc);

        col.showPercentText = true;
        isWhite = perc > 75;
      }

      var barClass = col.ranges && ranges.classes ? ranges.classes : 'primary';
      return '<div class="total bar chart-completion-target chart-targeted-achievement">\n              <div class="target remaining bar" style="width: ' + (target || 0) + '%;"></div>\n              <div class="completed bar ' + barClass + '" style="width: ' + perc + '%;"></div>\n              ' + (col.showPercentText ? '<div class="chart-targeted-text l-center" ' + (isWhite ? 'style="color: white"' : '') + '>' + text + '</div>\n            </div>' : '');
    }

    // TODO Possible future Formatters
    // Multi Select
    // Sparkline
    // Progress Indicator (n of 100%)
    // Process Indicator
    // File Upload (Simple)
    // Menu Button
    // Color Picker (Low)
    // Radio

  };

  // Adds all the basic input features to any Datagrid Editor.
  function addStandardInputFeatures(input, row, cell, value, container, column, e, api, item) {
    if (column.align) {
      input.addClass('l-' + column.align + '-text');
    }

    if (column.maxLength) {
      input.attr('maxlength', column.maxLength);
    }

    if (column.uppercase) {
      input.addClass('uppercase-text');
    }

    if (column.mask && typeof column.mask === 'function') {
      var mask = column.mask(row, cell, value, column, item);
      input.mask({ pattern: mask, mode: column.maskMode });
    } else if (column.maskOptions && typeof column.maskOptions === 'function') {
      var maskOptions = column.maskOptions(row, cell, value, column, item);
      input.mask(maskOptions);
    } else if (column.mask) {
      input.mask({ pattern: column.mask, mode: column.maskMode });
    }

    var defaults = {
      patternOptions: {
        allowNegative: true,
        allowDecimal: true,
        integerLimit: 4,
        decimalLimit: 2,
        symbols: {
          thousands: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',',
          decimal: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.decimal : '.',
          negative: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.minusSign : '-'
        }
      },
      process: 'number'
    };

    var useMask = false;

    if (column.maskOptions) {
      useMask = true;
    }

    if (column.numberFormat) {
      useMask = true;
      defaults = { patternOptions: { decimalLimit: column.numberFormat.maximumFractionDigits } };
    }

    if (column.maskOptions && typeof column.maskOptions === 'function') {
      useMask = false;
    }

    if (useMask) {
      column.maskOptions = utils.extend(true, {}, defaults, column.maskOptions);
      input.mask(column.maskOptions);
    }

    if (!column.align || column.align !== 'right') {
      input.removeClass('is-number-mask');
    }
  }

  /**
  *  A object containing all the supported Editors
  * @private
  */
  var editors = {

    // Supports, Text, Numeric, Integer via mask
    Input: function Input(row, cell, value, container, column, e, api, item) {
      this.name = 'input';
      this.originalValue = value;
      this.useValue = !!column.inlineEditor;

      this.init = function () {
        if (column.inlineEditor) {
          this.input = container.find('input');
        } else {
          this.input = $('<input type="' + (column.inputType || 'text') + '"/>').appendTo(container);
        }

        addStandardInputFeatures(this.input, row, cell, value, container, column, e, api, item);
      };

      this.val = function (v) {
        var thisValue = void 0;
        if (v) {
          this.input.val(v);
        }
        if (column && column.numberFormat && column.numberFormat.style === 'percent') {
          thisValue = this.input.val().trim().replace(/(\s%?|%)$/g, '');
          return Locale.parseNumber(thisValue) / 100;
        }
        return this.input.val();
      };

      this.focus = function () {
        this.input.focus().select();
      };

      this.destroy = function () {
        var _this = this;

        if (column.inlineEditor) {
          return;
        }

        setTimeout(function () {
          _this.input.remove();
        }, 0);
      };

      this.init();
    },
    Textarea: function Textarea(row, cell, value, container, column) {
      this.name = 'textarea';
      this.originalValue = value;

      this.init = function () {
        this.input = $('<textarea class="textarea"></textarea>').appendTo(container);

        if (column.maxLength) {
          this.input.attr('maxlength', column.maxLength);
        }

        if (column.uppercase) {
          this.input.addClass('uppercase-text');
        }
      };

      this.val = function (v) {
        if (v) {
          // note that focus will help move text to end of input.
          this.input.focus().val(v);
        }
        return this.input.val();
      };

      this.focus = function () {
        this.input.focus();
      };

      this.destroy = function () {
        var _this2 = this;

        setTimeout(function () {
          _this2.input.remove();
        }, 0);
      };

      this.init();
    },


    // Rich Text Editor
    Editor: function Editor(row, cell, value, container, column, e, api) {
      this.name = 'editor';
      this.originalValue = value;

      this.init = function () {
        var self = this;
        // Editor options
        var editorOptions = $.extend({}, {
          buttons: { editor: ['bold', 'italic', 'underline', 'strikethrough', 'separator', 'foreColor'], source: [] },
          excludeButtons: { editor: [] }
        }, column.editorOptions);

        // Editor width
        this.editorWidth = api.setUnit(editorOptions.width || container.outerWidth());
        delete editorOptions.width;

        container[0].innerHTML = '<div class="editor-wrapper" style="width: ' + this.editorWidth + ';">\n          <div class="editor" data-init="false">' + xssUtils.unescapeHTML(value) + '</div>\n        </div>';
        this.td = container.closest('td');
        this.input = $('.editor', container);

        this.input.popover({
          content: $('.editor-wrapper', container),
          placementOpts: {
            x: 0,
            y: '-' + (parseInt(container[0].style.height, 10) + 35),
            parent: this.td,
            parentXAlignment: Locale.isRTL() ? 'right' : 'left',
            strategies: ['flip', 'nudge', 'shrink']
          },
          placement: 'bottom',
          popover: true,
          trigger: 'immediate',
          tooltipElement: '#editor-popup',
          extraClass: 'editor-popup'
        }).editor(editorOptions).on('hide.editor', function () {
          api.commitCellEdit(self.input);
        }).on('keydown.editor', function (event) {
          var key = event.which || event.keyCode || event.charCode || 0;
          // Ctrl + Enter (Some browser return keyCode: 10, not 13)
          if ((event.ctrlKey || event.metaKey) && (key === 13 || key === 10)) {
            var apiPopover = self.input.data('tooltip');
            if (apiPopover) {
              apiPopover.hide();
              api.setNextActiveCell(event);
            }
          }
        });
        utils.fixSVGIcons($('#editor-popup'));
      };

      this.val = function () {
        return this.input.html();
      };

      this.focus = function () {
        var _this3 = this;

        setTimeout(function () {
          _this3.input.focus();
        }, 0);
      };

      this.destroy = function () {
        var self = this;
        container.removeAttr('style');
        api.quickEditMode = false;
        self.input.off('hide.editor keydown.editor');
        setTimeout(function () {
          self.input.remove();
        }, 0);
      };

      this.init();
    },
    Checkbox: function Checkbox(row, cell, value, container, column, event, grid) {
      this.name = 'checkbox';
      this.originalValue = value;
      this.useValue = true; // use the data set value not cell value
      this.container = container;

      this.init = function () {
        this.input = $('<input type="checkbox" class="checkbox"/>').appendTo(container);
        this.input.after('<label class="checkbox-label"></label>');

        if (column.align) {
          this.input.addClass('l-' + column.align + '-text');
        }
      };

      this.val = function (v) {
        // eslint-disable-line
        var isChecked = void 0;

        if (v === undefined) {
          return this.input.prop('checked');
        }

        // Use isChecked function if exists
        if (column.isChecked) {
          isChecked = column.isChecked(v);
        } else {
          isChecked = v;
        }

        // just toggle it if we click right on it
        if ((event.type === 'click' || event.type === 'keydown' && event.keyCode === 32) && !$(event.target).is('.datagrid-checkbox-wrapper, .datagrid-cell-wrapper')) {
          isChecked = !isChecked;
          grid.setNextActiveCell(event);
        }

        this.input.prop('checked', isChecked);
      };

      this.focus = function () {
        this.input.trigger('focusout');
        this.container.parent().focus();
      };

      this.destroy = function () {
        var _this4 = this;

        setTimeout(function () {
          _this4.input.next('.checkbox-label').remove();
          _this4.input.remove();
        }, 0);
      };

      this.init();
    },
    Colorpicker: function Colorpicker(row, cell, value, container, column, event, grid) {
      this.name = 'colorpicker';
      this.originalValue = value;
      this.useValue = true; // use the data set value not cell value
      value = xssUtils.stripTags(value);

      this.init = function () {
        this.input = $('<input id="colorpicker-' + cell + '" name="colorpicker-' + cell + '" class="colorpicker" value="' + value + '" type="text" />').appendTo(container);
        this.input.colorpicker(column.editorOptions);
      };

      this.val = function (v) {
        return v ? this.input.val(v) : this.input.val();
      };

      this.focus = function () {
        var self = this;

        this.input.trigger('openlist');
        var rowNodes = grid.rowNodes(row);
        rowNodes.removeClass('is-hover-row');
        this.input.focus().select();

        this.input.off('listclosed').on('listclosed', function () {
          grid.commitCellEdit(self.input);

          container.parent('td').focus();
          return; // eslint-disable-line
        });
      };

      this.destroy = function () {
        // We dont need to destroy since it will when the list is closed
      };

      this.init();
    },
    Dropdown: function Dropdown(row, cell, value, container, column, event, grid, rowData) {
      this.name = 'dropdown';
      this.originalValue = value;
      this.useValue = true; // use the data set value not cell value
      this.cell = grid.activeCell;

      this.init = function () {
        var _this5 = this;

        if (column.inlineEditor) {
          this.input = container.find('select');
          return;
        }

        this.input = $('<select class="dropdown"></select>').appendTo(container);

        if (column.options) {
          var html = void 0;
          var opt = void 0;
          var optionValue = void 0;
          value = grid.fieldValue(rowData, column.field);

          var compareValue = column.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;

          for (var i = 0; i < column.options.length; i++) {
            html = $('<option></option>');
            opt = column.options[i];
            optionValue = column.caseInsensitive && typeof opt.value === 'string' ? opt.value.toLowerCase() : opt.value;

            if (opt.selected || compareValue === optionValue) {
              html.attr('selected', 'true');
              this.originalValue = optionValue;
            }

            html.attr('value', opt.value).attr('id', opt.id).attr('data-type', _typeof(opt.value));
            html.text(opt.label);
            this.input.append(html);
          }
        }

        var editorOptions = column.editorOptions || {};

        function hasEditingClass() {
          return editorOptions.cssClass && /is-editing/g.test(editorOptions.cssClass);
        }
        // Add the class to both the options being passed, as well as the column's original options
        if (!hasEditingClass()) {
          editorOptions.cssClass = editorOptions.cssClass || '';
          editorOptions.cssClass += ' is-editing';
        }

        this.input.dropdown(editorOptions);
        this.input.on('requestend', function () {
          _this5.val(_this5.datasetValue);
        });

        // Append the Dropdown's sourceArguments with some row/col meta-data
        var api = this.input.data('dropdown');
        api.settings.sourceArguments = {
          column: column,
          container: container,
          grid: grid,
          cell: cell,
          event: event,
          row: row,
          rowData: rowData,
          value: value
        };
      };

      this.val = function (v) {
        this.datasetValue = v;

        if (v !== undefined) {
          var compareValue = column.caseInsensitive && typeof v === 'string' ? v.toLowerCase() : v;
          this.input.val(v);

          this.input.find('option').each(function () {
            var opt = $(this);
            var valueAttr = opt.attr('value');
            var type = opt.attr('data-type');
            var optionValue = valueAttr;

            // Get option value in proper type before checking equality
            if (type === 'number') {
              optionValue = parseFloat(valueAttr);
            } else if (type === 'boolean') {
              optionValue = valueAttr === 'true';
            } else if (type === 'string' && column.caseInsensitive) {
              optionValue = valueAttr.toLowerCase();
            }

            if (optionValue === compareValue) {
              opt.attr('selected', 'true');
            }
          });
        }

        var selected = this.input.find(':selected');
        var val = selected.attr('value');
        var dataType = selected.attr('data-type');

        // For non-string option values (number, boolean, etc.),
        // convert string attr value to proper type
        if (dataType === 'number') {
          val = parseFloat(val);
        } else if (dataType === 'boolean') {
          val = val === 'true';
        }

        if (val === undefined) {
          val = selected.text();
        }

        return val;
      };

      this.focus = function () {
        var self = this;

        // Check if isClick or cell touch and just open the list
        if (event.type === 'click') {
          this.input.trigger('openlist');
          var rowNodes = grid.rowNodes(row);
          rowNodes.removeClass('is-hover-row');
          $('#dropdown-list input').focus();
        } else {
          this.input[0].parentNode.querySelector('div.dropdown').focus();
        }

        this.input.off('listclosed').on('listclosed', function (e, type) {
          grid.commitCellEdit(self.input);

          if (type === 'select') {
            container.parent('td').focus();
            return;
          }

          if (type === 'tab') {
            setTimeout(function () {
              container.parent('td').focus();
            }, 100);
          }
        });
      };

      this.destroy = function () {
        // We dont need to destroy since it will when the list is closed
      };

      this.init();
    },
    Date: function Date(row, cell, value, container, column, event, grid) {
      this.name = 'date';
      this.originalValue = value;

      this.init = function () {
        this.input = $('<input class="datepicker"/>').appendTo(container);
        this.input.datepicker(column.editorOptions || { dateFormat: column.dateFormat });
      };

      this.val = function (v) {
        if (v === '0000' || v === '000000' || v === '00000000') {
          // Means no date in some applications
          v = '';
        }
        if (v) {
          // Note that the value should be formatted from the formatter.
          this.input.val(v);
        }
        return formatters.Date(row, cell, this.input.val(), column, true);
      };

      this.focus = function () {
        var self = this;

        this.input.select().focus();

        // Check if isClick or cell touch and just open the list
        if (event.type === 'click' && $(event.target).is('.icon')) {
          this.input.parent().find('.icon').trigger('click');
          this.input.closest('td').addClass('is-focused');
        }

        this.input.on('listclosed', function () {
          self.input.closest('td').removeClass('is-focused');

          setTimeout(function () {
            self.input.trigger('focusout');
            container.parent().focus();
            grid.setNextActiveCell(event);
          }, 1);
        });
      };

      this.destroy = function () {
        var _this6 = this;

        setTimeout(function () {
          grid.quickEditMode = false;
          _this6.input.remove();
        }, 0);
      };

      this.init();
    },
    Fileupload: function Fileupload(row, cell, value, container, column, event, grid) {
      var _this7 = this;

      var s = utils.mergeSettings(undefined, column.editorOptions, {
        allowedTypes: '*' // restrict file types(ie. 'jpg|png|gif') ['*' all types]
      });
      var fileExtensions = s.allowedTypes.split(/[\s|]+/g);
      var id = utils.uniqueId(this, 'fileupload-' + row + '-' + cell + '-');

      var multiple = s.useMultiple ? ' multiple' : '';
      var disabled = s.isDisabled ? ' disabled' : '';
      var types = '';

      if (fileExtensions.length === 1) {
        if (fileExtensions[0] !== '*') {
          types = '.' + xssUtils.ensureAlphaNumeric(fileExtensions[0]);
        }
      } else {
        for (var i = 0, l = fileExtensions.length; i < l; i++) {
          types += '.' + (xssUtils.ensureAlphaNumeric(fileExtensions[i]) + (i !== l - 1 ? ',' : ''));
        }
      }
      if (types !== '') {
        types = ' accept="' + types + '"';
      }

      this.name = 'fileupload';
      this.originalValue = value;
      this.status = 'init';
      this.useValue = true; // use the data set value not cell value

      this.init = function () {
        id = xssUtils.ensureAlphaNumeric(id);
        multiple = xssUtils.ensureAlphaNumeric(multiple);
        disabled = xssUtils.ensureAlphaNumeric(disabled);

        this.input = $('<input id="' + id + '" name="' + id + '" class="fileupload" type="file" ' + types + multiple + disabled + ' />');
        container.append('<label>' + this.input[0].outerHTML + '</label>');
        this.api = this.input.fileupload(column.editorOptions).data('fileupload');
        this.input.closest('td').addClass('is-fileupload').find('label:eq(1)').addClass('audible');
      };

      this.val = function (v) {
        if (v) {
          v = xssUtils.stripTags(v);
          this.input.attr('value', v);
          return v;
        }
        return this.input.val();
      };

      this.focus = function () {
        /**
         * Handle cancel on file-input
         * Bind body to listen one time only, right after file chooser window popup open
         * Listen on body `focusin`(on close popup window),
         * if no `change` event triggered means it canceled
         * @private
         * @returns {void}
         */
        var handleCancel = function handleCancel() {
          $('body').one('focusin.fileuploadeditor', function () {
            setTimeout(function () {
              if (_this7.status !== 'change') {
                _this7.status = 'cancel';
                grid.commitCellEdit(_this7.input);
              }
            }, 100);
          });
        };

        /**
         * Handle clear the value on file-input
         * @private
         * @returns {void}
         */
        var handleClear = function handleClear() {
          if (_this7.originalValue !== '') {
            _this7.status = 'clear';
          }
          grid.commitCellEdit(_this7.input);
        };

        /**
         * Open file chooser popup window for file-input
         * @private
         * @returns {void}
         */
        var openFileChooserWindow = function openFileChooserWindow() {
          if (_this7.api) {
            handleCancel();
            _this7.api.fileInput.trigger('click');
          }
        };

        // Handle change for file-input
        _this7.input.on('change.fileuploadeditor', function () {
          _this7.status = 'change';
          grid.commitCellEdit(_this7.input);
        });

        // Using keyboard
        if (event.type === 'keydown') {
          var key = event.which || event.keyCode || event.charCode || 0;

          if (key === 8 || key === 46) {
            // Backspace: 8, Delete: 46
            handleClear();
          } else if (key === 13 || key === 10) {
            // Enter (Some browser return keyCode: 10, not 13)
            openFileChooserWindow();
          } else {
            grid.commitCellEdit(_this7.input);
          }
        }

        // Check if isClick or cell touch
        if (event.type === 'click') {
          var target = $(event.target);
          if (target.is('.icon-close')) {
            handleClear();
          } else if (target.is('.icon-fileupload')) {
            openFileChooserWindow();
          } else {
            grid.commitCellEdit(_this7.input);
          }
        }
      };

      this.destroy = function () {
        _this7.input.off('change.fileuploadeditor');
        grid.quickEditMode = false;
        if (_this7.api) {
          _this7.api.destroy();
        }
      };

      this.init();
    },
    Time: function Time(row, cell, value, container, column, event, grid) {
      this.name = 'time';
      this.originalValue = value;

      this.init = function () {
        this.input = $('<input class="timepicker"/>').appendTo(container);
        this.api = this.input.timepicker(column.editorOptions || '').data('timepicker');
      };

      this.val = function (v) {
        if (v) {
          // Note that the value should be formatted from the formatter.
          this.input.val(v);
        }

        return this.input.val();
      };

      this.focus = function () {
        var self = this;

        this.input.select().focus();

        // Check if isClick or cell touch and just open the list
        if (event.type === 'click' && $(event.target).is('.icon')) {
          this.input.parent().find('.icon').trigger('click');
          this.input.closest('td').addClass('is-focused');
        }

        this.api.trigger.on('hide.editortime', function () {
          self.input.closest('td').removeClass('is-focused');

          setTimeout(function () {
            self.input.trigger('focusout');
            container.parent().focus();
            grid.setNextActiveCell(event);
          }, 1);
        });
      };

      this.destroy = function () {
        var self = this;
        if (self.api && self.api.trigger) {
          self.api.trigger.off('hide.editortime');
        }

        setTimeout(function () {
          grid.quickEditMode = false;
          self.input.remove();
        }, 0);
      };

      this.init();
    },
    Lookup: function Lookup(row, cell, value, container, column, event, grid, rowData) {
      this.name = 'lookup';
      this.originalValue = value;

      this.init = function () {
        this.input = $('<input class="lookup ' + (column.align === 'right' ? 'align-text-right' : '') + '" data-init="false" />').appendTo(container);

        addStandardInputFeatures(this.input, row, cell, value, container, column, event, grid, rowData);

        this.input.lookup(column.editorOptions);

        // Append the Lookup's clickArguments with some row/col meta-data
        var api = this.input.data('lookup');
        api.settings.clickArguments = {
          column: column,
          container: container,
          grid: grid,
          cell: cell,
          event: event,
          row: row,
          rowData: rowData,
          value: value
        };
      };

      this.val = function (v) {
        var fieldValue = this.input.val();
        if (fieldValue && fieldValue.indexOf('|') > -1) {
          fieldValue = fieldValue.substr(0, fieldValue.indexOf('|'));
        }
        return v ? this.input.val(v) : fieldValue;
      };

      this.focus = function () {
        var self = this;
        var api = self.input.data('lookup');
        var td = self.input.closest('td');

        // Using keyboard
        if (event.type === 'keydown') {
          self.input.select().focus();
          td.on('keydown.editorlookup', function (e) {
            if (e.keyCode === 40 && grid.quickEditMode) {
              e.preventDefault();
              e.stopPropagation();
            }
          });
        }

        // Check if isClick or cell touch and just open the list
        if (event.type === 'click') {
          if ($(event.target).is('svg')) {
            api.openDialog(event);
          } else {
            self.input.select().focus();
            td.on('touchcancel.editorlookup touchend.editorlookup', '.trigger', function () {
              api.openDialog();
            });
          }
        }

        // Update on change from lookup
        self.input.on('change', function () {
          setTimeout(function () {
            container.parent().focus();
            grid.setNextActiveCell(event);
            grid.quickEditMode = false;
          }, 1);
        });
      };

      this.destroy = function () {
        var self = this;
        var td = this.input.closest('td');
        setTimeout(function () {
          grid.quickEditMode = false;
          td.off('keydown.editorlookup').find('.trigger').off('touchcancel.editorlookup touchend.editorlookup');
          self.input.remove();
        }, 0);
      };

      this.init();
    },
    Autocomplete: function Autocomplete(ow, cell, value, container, column, event, grid) {
      this.name = 'autocomplete';
      this.originalValue = value;

      this.init = function () {
        this.input = $('<input class="autocomplete datagrid-autocomplete" />').appendTo(container);

        if (!column.editorOptions) {
          column.editorOptions = {};
        }
        column.editorOptions.width = container.parent().width();
        column.editorOptions.offset = { left: -1, top: grid.settings.rowHeight === 'medium' ? 1 : 5 };

        if (column.maxLength) {
          this.input.attr('maxlength', column.maxLength);
        }

        if (column.uppercase) {
          this.input.addClass('uppercase-text');
        }

        this.input.autocomplete(column.editorOptions);
      };

      this.val = function (v) {
        return v ? this.input.val(v) : this.input.val();
      };

      this.focus = function () {
        grid.quickEditMode = true;
        this.input.select().focus();
      };

      this.destroy = function () {
        var _this8 = this;

        setTimeout(function () {
          grid.quickEditMode = false;
          _this8.input.remove();
        }, 0);
      };

      this.init();
    },
    Spinbox: function Spinbox(ow, cell, value, container, column, event, grid) {
      this.name = 'spinbox';
      this.originalValue = value;
      this.useValue = true; // use the data set value not cell value

      this.init = function () {
        if (column.inlineEditor) {
          this.input = container.find('input');
          return;
        }

        var markup = '<label for="spinbox-' + cell + '" class="audible">Quantity</label>\n        <span class="spinbox-wrapper"><span class="spinbox-control down">-</span>\n        <input id="spinbox-' + cell + '" name="spinbox-' + cell + '" type="text" class="spinbox" value="\'+ ' + value + ' +\'">\n        <span class="spinbox-control up">+</span></span>';

        DOM.append(container, markup, '<label><span><input>');
        this.input = container.find('input');

        if (!column.editorOptions) {
          column.editorOptions = {};
        }

        this.input.spinbox(column.editorOptions);
      };

      this.val = function (v) {
        return v ? parseInt(this.input.val(v), 10) : parseInt(this.input.val(), 10);
      };

      this.focus = function () {
        grid.quickEditMode = true;
        this.input.select().focus();
      };

      this.destroy = function () {
        var _this9 = this;

        if (column.inlineEditor) {
          return;
        }

        setTimeout(function () {
          grid.quickEditMode = false;
          _this9.input.remove();
        }, 0);
      };

      this.init();
    },
    Favorite: function Favorite(row, cell, value, container, column, event, grid) {
      this.name = 'favorite';
      this.useValue = true;
      this.originalValue = value;

      this.init = function () {
        this.input = $('<span class="icon-favorite">' + $.createIcon({ icon: value ? 'star-filled' : 'star-outlined' }) + '<input type="checkbox"></span>').appendTo(container);

        this.input = this.input.find('input');
      };

      this.val = function (v) {
        // eslint-disable-line
        var isChecked = void 0;

        if (v === undefined) {
          return this.input.prop('checked');
        }

        // Use isChecked function if exists
        if (column.isChecked) {
          isChecked = column.isChecked(v);
        } else {
          isChecked = v;
        }

        // just toggle it when clicked
        if ((event.type === 'click' || event.type === 'keydown' && event.keyCode === 32) && !$(event.target).is('.datagrid-cell-wrapper')) {
          isChecked = !isChecked;
          grid.setNextActiveCell(event);
        }

        this.input.prop('checked', isChecked);
        this.input.find('use').attr('xlink:href', isChecked ? '#icon-star-filled' : '#icon-star-outlined');
      };

      this.focus = function () {
        this.input.trigger('focusout').focus();
      };

      this.destroy = function () {
        var _this10 = this;

        setTimeout(function () {
          _this10.input.parent().remove();
        }, 0);
      };

      this.init();
    }
  };

  /* eslint-disable import/prefer-default-export */
  var excel = {};

  /**
   * Remove Hidden Columns and Non Exportable Columns.
   * @private
   * @param {string} customDs An optional customized version of the data to use.
   * @param {string} self The grid api to use (if customDs is not used)
   * @returns {object} an table element cleaned extra stuff
   */
  excel.cleanExtra = function (customDs, self) {
    var clean = function clean(table) {
      var removeNode = function removeNode(node) {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      };
      var nonExportables = [];
      var elements = [].slice.call(table[0].querySelectorAll('tr, th, td, div, span'));
      elements.forEach(function (el) {
        if (el.classList.contains('is-hidden') || el.classList.contains('datagrid-expandable-row')) {
          removeNode(el);
          return;
        }

        // THEAD
        var attrExportable = el.getAttribute('data-exportable');
        if (attrExportable && attrExportable === 'no') {
          var index = Array.prototype.slice.call(el.parentElement.children).indexOf(el);
          nonExportables.push(index + 1);
          removeNode(el);
          return;
        }

        // TBODY
        var attrAriaColindex = el.getAttribute('aria-colindex');
        if (el.tagName.toLowerCase() === 'td' && attrAriaColindex) {
          if (nonExportables.indexOf(parseInt(attrAriaColindex, 10)) !== -1) {
            removeNode(el);
            return;
          }
        }

        var innerElements = [].slice.call(table[0].querySelectorAll('.is-hidden, .datagrid-expand-btn, .is-draggable-target, .handle, .sort-indicator, .datagrid-filter-wrapper'));
        innerElements.forEach(function (innerEl) {
          return removeNode(innerEl);
        });

        while (el.attributes.length > 0) {
          el.removeAttribute(el.attributes[0].name);
        }

        // White Hat Security Violation. Remove Excel formulas
        // Excel Formulas Start with =SOMETHING
        var text = el.textContent;
        if (text.substr(0, 1) === '=' && text.substr(1, 1) !== '') {
          el.textContent = '\'' + text + '\'';
        }
      });
      return table;
    };

    var table = [];
    if (!self && customDs) {
      table = excel.datasetToHtml(customDs);
    } else {
      table = excel.appendRows(self.settings.dataset, self.table[0].cloneNode(true), self);
    }

    // Create the header row
    if (!customDs && !table[0].querySelector('thead')) {
      var tbody = table[0].querySelector('tbody');
      var header = table[0].createTHead();
      var row = table[0].insertRow(0);
      var allHeaderNodes = self.headerNodes();

      for (var i = 0; i < allHeaderNodes.length; i++) {
        var headerNode = allHeaderNodes[i];
        var cell = row.insertCell(i);
        cell.innerHTML = headerNode.querySelector('.datagrid-header-text').textContent.trim();
        cell.classList = headerNode.classList;
        cell.setAttribute('id', headerNode.getAttribute('id'));
        if (headerNode.getAttribute('data-exportable')) {
          cell.setAttribute('data-exportable', headerNode.getAttribute('data-exportable'));
        }
      }
      tbody.parentNode.insertBefore(header, tbody);
    }

    table = clean(table);

    // Exporting data with trailing negative signs moved in front
    if (self && self.settings.exportConvertNegative) {
      var cells = [].slice.call(table[0].querySelectorAll('td'));
      cells.forEach(function (td) {
        td.textContent = td.textContent.replace(/^(.+)(-$)/, '$2$1');
      });
    }
    return table;
  };

  /**
   * Save file to download `.xls or .csv`.
   * @private
   * @param {string} content The content for the file in the download.
   * @param {string} fileName The desired export filename in the download.
   * @returns {void}
   */
  excel.save = function (content, fileName) {
    var ext = (fileName.match(/\.([^.]*?)(?=\?|#|$)/) || [])[1];
    var isTypeExcel = typeof ext === 'string' && /\b(xlsx|xls)\b/g.test(ext);

    if (Environment.browser.name === 'ie' || Environment.browser.name === 'edge') {
      if (window.navigator.msSaveBlob) {
        var blob = new Blob([content], {
          type: 'application/csv;charset=utf-8;'
        });
        navigator.msSaveBlob(blob, fileName);
      }
    } else if (window.URL.createObjectURL) {
      // createObjectURL api allows downloading larger files
      var _blob = new Blob([content], {
        type: 'application/' + (isTypeExcel ? 'vnd.ms-excel' : 'csv') + ';charset=utf-8;'
      });
      var objectUrl = URL.createObjectURL(_blob);
      var link = document.createElement('a');
      link.href = objectUrl;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(objectUrl);
    } else {
      var _link = document.createElement('a');
      _link.href = this.base64(content);
      _link.download = fileName;
      document.body.appendChild(_link);
      _link.click();
      document.body.removeChild(_link);
    }
  };

  /**
  * Convert a dataset to a html table for conversion to excel.
  * @private
  * @param {string} dataset The array of objects to convert
  * @returns {string} an html table as a string
  */
  excel.datasetToHtml = function (dataset) {
    var tableHtml = '<tbody>';

    var _loop = function _loop(i) {
      tableHtml += '<tr>';
      Object.keys(dataset[i]).forEach(function (key, index) {
        //eslint-disable-line
        if (dataset[i] && Object.prototype.hasOwnProperty.call(dataset[i], key)) {
          tableHtml += '<td>' + dataset[i][key] + '</td>';
        }
      });
      tableHtml += '</tr>';
    };

    for (var i = 0; i < dataset.length; i++) {
      _loop(i);
    }

    tableHtml += '</tbody>';
    return $('<table></table>').append(tableHtml);
  };

  /**
  * Convert a dataset to a html table for conversion to excel.
  * @private
  * @param {array} dataset The array of objects to convert.
  * @param {object} table The table object.
  * @param {object} self The grid API.
  * @returns {object} The table with rows appended.
  */
  excel.appendRows = function (dataset, table, self) {
    var isjQuery = function isjQuery(obj) {
      return obj && (obj instanceof jQuery || obj.constructor.prototype.jquery);
    };
    var tableJq = isjQuery(table) ? table : $(table);
    table = tableJq[0];

    var tableHtml = '';
    var body = table.querySelector('tbody');
    body.innerHTML = '';
    var appendRow = function appendRow(d, i) {
      if (!d.isFiltered) {
        var rowHtml = self.rowHtml(d, i, i, false, false, i, true);
        var tr = document.createElement('tr');
        tr.innerHTML = rowHtml.left + rowHtml.center + rowHtml.right;
        tableHtml += tr.outerHTML;

        // Add tree rows
        if (d.children) {
          for (var j = 0, l = d.children.length; j < l; j++) {
            appendRow(d.children[j], j);
          }
        }
      }
    };

    dataset.forEach(function (d, i) {
      appendRow(d, i);
    });

    body.insertAdjacentHTML('beforeend', tableHtml);
    return tableJq;
  };

  /**
   * Convert a excel string to base64 format for download.
   * @private
   * @param {string} s The string containing the document.
   * @returns {string} The excel doc as a base64 string.
   */
  excel.base64 = function (s) {
    if (window.btoa) {
      return 'data:application/vnd.ms-excel;base64,' + window.btoa(unescape(encodeURIComponent(s)));
    }
    return 'data:application/vnd.ms-excel;,' + unescape(encodeURIComponent(s));
  };

  /**
   * Copy pasted data into the dataset to facilitate copy from excel.
   * @param {object} pastedData The paste data from the paste event.
   * @param {[type]} rowCount The number of rows.
   * @param {[type]} colIndex The column index we started on.
   * @param {[type]} dataSet The dataset.
   * @param {[type]} self The datagrid API.
   * @returns {void}
   */
  excel.copyToDataSet = function (pastedData, rowCount, colIndex, dataSet, self) {
    var validateFields = function validateFields(values, settings, rowData, idx) {
      for (var j = 0; j < values.length; j++) {
        var col = settings.columns[idx];

        if (col.formatter !== formatters.Readonly) {
          switch (col.editor.name) {
            case editors.Input.name:
              if (col.filterType === 'integer' || col.filterType === 'decimal' || col.filterType === 'number') {
                // Number Values

                // Validates if input is number. If true, will overwrite the data in cell otherwise nothing will happen.
                if (!isNaN(values[j].trim())) {
                  rowData[col.field] = values[j];
                }
              } else {
                // String Values
                // Just overwrite the data in the cell
                rowData[col.field] = values[j];
              }
              break;
            case editors.Date.name:
              // Validates if input is date. If true, will overwrite the data in cell otherwise nothing will happen.
              if (!isNaN(Date.parse(values[j]))) {
                rowData[col.field] = new Date(values[j]);
              }
              break;
            default:
              break;
          }
        }

        idx++;
      }
    };

    for (var i = 0; i < pastedData.length; i++) {
      var rawVal = pastedData[i].split('\t');
      var startColIndex = colIndex;

      if (rowCount < dataSet.length) {
        var currentRowData = dataSet[rowCount];
        validateFields(rawVal, self.settings, currentRowData, startColIndex);
      } else {
        var newRowData = {};
        for (var k = 0; k < self.settings.columns.length; k++) {
          newRowData[self.settings.columns[k].field] = '';
        }
        validateFields(rawVal, self.settings, newRowData, startColIndex);
        dataSet.push(newRowData);
      }
      rowCount++;
    }

    self.renderRows();
    self.syncSelectedUI();
    self.pagerRefresh('bottom');
  };

  /**
   * Export the grid contents to xls format. This may give a warning when opening the file.
   * exportToCsv may be prefered.
   * @param {string} fileName The desired export filename in the download.
   * @param {string} worksheetName A name to give the excel worksheet tab.
   * @param {string} customDs An optional customized version of the data to use.
   * @param {object} self The grid api if customDS is not used
   * @returns {void}
   */
  excel.exportToExcel = function (fileName, worksheetName, customDs, self) {
    var template = '' + '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">' + '<head>' + '<!--[if gte mso 9]>' + '<xml>' + '<x:ExcelWorkbook>' + '<x:ExcelWorksheets>' + '<x:ExcelWorksheet>' + '<x:Name>{worksheet}</x:Name>' + '<x:WorksheetOptions>' + '<x:Panes></x:Panes>' + '<x:DisplayGridlines></x:DisplayGridlines>' + '</x:WorksheetOptions>' + '</x:ExcelWorksheet>' + '</x:ExcelWorksheets>' + '</x:ExcelWorkbook>' + '</xml>' + '<![endif]-->' + '<meta http-equiv="content-type" content="text/plain; charset=UTF-8"/>' + '</head>' + '<body>' + '<table border="1px solid #999999">{table}</table>' + '</body>' + '</html>';

    var formatExcel = function formatExcel(s, c) {
      return s.replace(/{(\w+)}/g, function (m, p) {
        return c[p];
      });
    };

    var table = excel.cleanExtra(customDs, self);
    var ctx = { worksheet: worksheetName || 'Worksheet', table: table[0].innerHTML };

    fileName = (fileName || self.element[0].id || 'Export') + '.xls';
    excel.save(formatExcel(template, ctx), fileName);
  };

  /**
   * Export the grid contents to csv
   * @param {string} fileName The desired export filename in the download.
   * @param {string} customDs An optional customized version of the data to use.
   * @param {string} separator (optional) If user's machine is configured for a locale with alternate default seperator.
   * @param {string} self The grid api to use (if customDs is not used)
   * @returns {void}
   */
  excel.exportToCsv = function (fileName, customDs) {
    var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sep=,';
    var self = arguments[3];

    var formatCsv = function formatCsv(table) {
      var csv = [];
      var rows = [].slice.call(table[0].querySelectorAll('tr'));
      rows.forEach(function (row) {
        var rowContent = [];
        var cols = [].slice.call(row.querySelectorAll('td, th'));
        cols.forEach(function (col) {
          return rowContent.push(col.textContent.replace(/\r?\n|\r/g, '').replace(/"/g, '""').trim());
        });
        csv.push(rowContent.join('","'));
      });
      csv.unshift(['' + separator]);
      return '"' + csv.join('"\n"') + '"';
    };

    var table = excel.cleanExtra(customDs, self);

    fileName = (fileName || self.element[0].id || 'Export') + '.csv';
    excel.save(formatCsv(table), fileName);
  };

  /* eslint-enable import/prefer-default-export */

  /**
  * An api for grouping data by a given field (s)
  * @private
  */
  var groupBy = function () {
    // Can also use in isEquivalent: function(obj1, obj2)  in datagrid.js
    var equals = utils.equals;

    // See if the object has these proprties or not
    var has = function has(obj, target) {
      return obj.some(function (value) {
        return equals(value, target);
      });
    };

    // Return just the object properties matching the names
    var pick = function pick(obj, names) {
      var chosen = {};
      for (var i = 0, l = names.length; i < l; i++) {
        chosen[names[i]] = obj[names[i]];
      }
      return chosen;
    };

    // Return the specific keys from the object
    var keys = function keys(data, names) {
      return data.reduce(function (memo, item) {
        var key = pick(item, names);

        if (!has(memo, key)) {
          memo.push(key);
        }
        return memo;
      }, []);
    };

    // Look through each value in the list and return an array of all the values
    // that contain all of the key-value pairs listed in properties.
    var where = function where(data, names) {
      var chosen = [];

      /* eslint-disable */
      data.map(function (item) {
        for (var prop in names) {
          if (names[prop] !== item[prop]) {
            return;
          }
        }
        chosen.push(item);
        return;
      });
      /* eslint-enable */

      return chosen;
    };

    // Grouping Function with Plugins/Aggregator
    var group = function group(data, names) {
      var stems = keys(data, names);

      return stems.map(function (stem) {
        return {
          key: stem,
          values: where(data, stem).map(function (item) {
            return item;
          })
        };
      });
    };

    // Register an aggregator
    group.register = function (name, converter) {
      group[name] = function (data, names, extra) {
        var that = this;
        that.extra = extra;
        return group(data, names).map(converter, that);
      };
      return group[name];
    };

    return group;
  }();

  /**
  * Register built in aggregators
  * @private
  */
  groupBy.register('none', function (item) {
    return $.extend({}, item.key, { values: item.values });
  });

  groupBy.register('sum', function (item) {
    var extra = this.extra;
    return $.extend({}, item.key, { values: item.values }, { sum: item.values.reduce(function (memo, node) {
        return memo + Number(node[extra]);
      }, 0) });
  });

  groupBy.register('max', function (item) {
    var extra = this.extra;
    return $.extend({}, item.key, { values: item.values }, // eslint-disable-next-line
    { max: item.values.reduce(function (memo, node) {
        return Math.max(memo, Number(node[extra]));
      }, Number.NEGATIVE_INFINITY) });
  });

  groupBy.register('list', function (item) {
    var extra = this.extra;

    return $.extend({}, item.key, { values: item.values }, {
      list: item.values.map(function (thisItem) {
        var list = [];

        for (var i = 0, l = extra.list.length; i < l; i++) {
          var exclude = extra.exclude ? thisItem[extra.exclude] : false;
          if (thisItem[extra.list[i]] && !exclude) {
            list.push({ value: thisItem[extra.list[i]], key: extra.list[i] });
          }
        }
        return list;
      })
    });
  });

  /**
  * Simple Summary Row Accumlator
  * @private
  */
  var aggregators = {};
  aggregators.aggregate = function (items, columns) {
    var totals = {};
    var self = this;

    for (var i = 0, l = columns.length; i < l; i++) {
      if (columns[i].aggregator) {
        (function () {
          var field = columns[i].field;

          self.sum = function (sum, node) {
            if (node.isFiltered) {
              // If excluded / filtered out.
              return sum;
            }

            var value = void 0;

            if (field.indexOf('.') > -1) {
              value = field.split('.').reduce(function (o, x) {
                return o ? o[x] : '';
              }, node);
            } else {
              value = node[field];
            }
            return sum + Number(value);
          };

          var total = items.reduce(self[columns[i].aggregator], 0);

          if (field.indexOf('.') > -1) {
            var currentObj = totals;
            for (var j = 0, k = field.split('.').length; j < k; j++) {
              if (j === field.split('.').length - 1) {
                currentObj[field.split('.')[j]] = total;
              } else {
                if (!(field.split('.')[j] in currentObj)) {
                  currentObj[field.split('.')[j]] = {};
                }

                currentObj = currentObj[field.split('.')[j]];
              }
            }
          } else {
            totals[field] = total;
          }
        })();
      }
    }

    return totals;
  };

  /* eslint-disable no-underscore-dangle, no-continue, no-nested-ternary */

  // The name of this component.
  var COMPONENT_NAME$18 = 'datagrid';

  /**
   * The Datagrid Component displays and process data in tabular format.
   * @class Datagrid
   * @constructor
   *
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object}   [settings] The component settings.
   * @param {boolean}  [settings.actionableMode=false] If actionableMode is "true, tab and shift tab behave like left and right arrow key, if the cell is editable it goes in and out of edit mode. F2 - toggles actionableMode "true" and "false"
   * @param {boolean}  [settings.cellNavigation=true] If cellNavigation is "false, will show border around whole row on focus
   * @param {boolean}  [settings.rowNavigation=true] If rowNavigation is "false, will NOT show border around the row
   * @param {boolean}  [settings.showHoverState=true] If false there will be no hover effect.
   * @param {boolean}  [settings.alternateRowShading=false] Sets shading for readonly grids
   * @param {array}    [settings.columns=[]] An array of columns (see column options)
   * @param {array}    [settings.frozenColumns={ left: [], right: [] }] An object with two arrays of column id's. One for freezing columns to the left side, and one for freezing columns to the right side.
   * @param {array}    [settings.dataset=[]] An array of data objects
   * @param {boolean}  [settings.columnReorder=false] Allow Column reorder
   * @param {boolean}  [settings.saveColumns=false] Save Column Reorder and resize, this is deprecated, use saveUserSettings
   * @param {object}   [settings.saveUserSettings]
   * @param {object}   [settings.saveUserSettings.columns=true]
   * @param {object}   [settings.saveUserSettings.rowHeight=true]
   * @param {object}   [settings.saveUserSettings.sortOrdertrue]
   * @param {object}   [settings.saveUserSettings.pageSize=true]
   * @param {object}   [settings.saveUserSettings.activePage=true]
   * @param {object}   [settings.saveUserSettings.filter=true]
   * @param {boolean}  [settings.focusAfterSort=false] If true will focus the active cell after sorting.
   * @param {boolean}  [settings.editable=false] Enable editing in the grid, requires column editors.
   * @param {boolean}  [settings.isList=false] Makes the grid have readonly "list" styling
   * @param {string}   [settings.menuId=null]  ID of the menu to use for a row level right click context menu
   * @param {string}   [settings.menuSelected=null] Callback for the grid level context menu
   * @param {string}   [settings.menuBeforeOpen=null] Callback for the grid level beforeopen menu event
   * @param {string}   [settings.headerMenuId=null] Id of the menu to use for a header right click context menu
   * @param {string}   [settings.headerMenuSelected=false] Callback for the header level context menu
   * @param {string}   [settings.headerMenuBeforeOpen=false] Callback for the header level beforeopen menu event
   * @param {string}   [settings.uniqueId=null] Unique DOM ID to use as local storage reference and internal variable names
   * @param {string}   [settings.rowHeight=normal] Controls the height of the rows / number visible rows. May be (short, medium or normal)
   * @param {string}   [settings.selectable=false] Controls the selection Mode this may be: false, 'single' or 'multiple' or 'mixed' or 'siblings'
   * @param {object}   [settings.groupable=null]  Controls fields to use for data grouping Use Data grouping, e.g. `{fields: ['incidentId'], supressRow: true, aggregator: 'list', aggregatorOptions: ['unitName1']}`
   * @param {boolean}  [settings.spacerColumn=false] if true and the grid is not wide enough to fit the last column will get filled with an empty spacer column.
   * @param {boolean}  [settings.showNewRowIndicator=true] If true, the new row indicator will display after adding a row.
   * @param {boolean}  [settings.stretchColumn='last'] If 'last' the last column will stretch using 100% css and work on resize.
   * @param {boolean}  [settings.clickToSelect=true] Controls if using a selection mode if you can click the rows to select
   * @param {object}   [settings.toolbar=false]  Toggles and appends various toolbar features for example `{title: 'Data Grid Header Title', results: true, keywordFilter: true, filter: true, rowHeight: true, views: true}`
   * @param {boolean}  [settings.selectChildren=true] Will prevent selecting of all child nodes on a multiselect tree.
   * @param {boolean}  [settings.allowSelectAcrossPages=null] Makes it possible to save selections when changing pages on server side paging. You may want to also use showSelectAllCheckBox: false
   * @param {boolean}  [settings.initializeToolbar=true] Set to false if you will initialize the toolbar yourself
   * @param {boolean}  [settings.paging=false] Enable paging mode
   * @param {number}   [settings.pagesize=25] Number of rows per page
   * @param {array}    [settings.pagesizes=[10, 25, 50, 75]] Array of page sizes to show in the page size dropdown.
   * @param {boolean}  [settings.indeterminate=false] Disable the ability to go to a specific page when paging.
   * @param {Function} [settings.source=false]  Callback function for paging
   * @param {boolean}  [settings.hidePagerOnOnePage=false]  If true, hides the pager if there's only one page worth of results.
   * @param {boolean}  [settings.filterable=false] Enable Column Filtering, This will require column filterTypes as well.
   * @param {boolean}  [settings.filterWhenTyping=true] Enable Column Filtering as you stop typing in inputs
   * @param {boolean}  [settings.disableClientFilter=false] Disable Filter Logic client side and let your server do it
   * @param {boolean}  [settings.disableClientSort=false] Disable Sort Logic client side and let your server do it
   * @param {string}   [settings.resultsText=null] Can provide a custom function to adjust results text on the toolbar
   * @param {boolean}  [settings.showFilterTotal=true] Paging results display filter count, change to false to not show filtered count
   * @param {boolean}  [settings.rowReorder=false] If set you can reorder rows. Requires rowReorder formatter
   * @param {boolean}  [settings.showDirty=false]  If true the dirty indicator will be shown on the rows
   * @param {boolean}  [settings.showSelectAllCheckBox=true] Allow to hide the checkbox header (true to show, false to hide)
   * @param {boolean}  [settings.allowOneExpandedRow=true] Controls if you cna expand more than one expandable row.
   * @param {boolean}  [settings.enableTooltips=false] Process tooltip logic at a cost of performance
   * @param {boolean}  [settings.disableRowDeactivation=false] if a row is activated the user should not be able to deactivate it by clicking on the activated row
   * @param {boolean}  [settings.sizeColumnsEqually=false] If true make all the columns equal width
   * @param {boolean}  [settings.expandableRow=false] If true we append an expandable row area without the rowTemplate feature being needed.
   * @param {boolean}  [settings.exportConvertNegative=false] If set to true export data with trailing negative signs moved in front.
   * @param {array}    [settings.columnGroups=null] An array of columns to use for grouped column headers.
   * @param {boolean}  [settings.treeGrid=false] If true a tree grid is expected so addition calculations will be used to calculate of the row children
   * @param {Function} [settings.onPostRenderCell=null] A call back function that will fire and send you the cell container and related information for any cells cells with a component attribute in the column definition.
   * @param {Function} [settings.onDestroyCell=null] A call back that goes along with onPostRenderCel and will fire when this cell is destroyed and you need noification of that.
   * @param {Function} [settings.onEditCell=null] A callback that fires when a cell is edited, the editor object is passed in to the function
   * @param {Function} [settings.onExpandRow=null] A callback function that fires when expanding rows. To be used. when expandableRow is true. The function gets eventData about the row and grid and a response function callback. Call the response function with markup to append and delay opening the row.
   * @param {boolean}  [settings.searchExpandableRow=true] If true keywordSearch will search in expandable rows (default). If false it will not search expandable rows.
   * @param {object}   [settings.emptyMessage]
   * @param {object}   [settings.emptyMessage.title='No Data Available']
   * @param {object}   [settings.emptyMessage.info='']
   * @param {object}   [settings.emptyMessage.icon='icon-empty-no-data']
   * An empty message will be displayed when there is no rows in the grid. This accepts an object of the form
   * emptyMessage: {title: 'No Data Available', info: 'Make a selection on the list above to see results',
   * icon: 'icon-empty-no-data', button: {text: 'xxx', click: <function>}} set this to null for no message
   * or will default to 'No Data Found with an icon.'
   * @param {boolean}  [settings.allowChildExpandOnMatch=false] use  with filter
   * if true:
   * and if only parent has a match then add all children nodes too
   * or if one or more child node got match then add parent node and all the children nodes
   * if false:
   * and if only parent has a match then make expand/collapse button to be collapsed, disabled
   * and do not add any children nodes
   * or if one or more child node got match then add parent node and only matching children nodes
   */
  var DATAGRID_DEFAULTS = {
    // F2 - toggles actionableMode "true" and "false"
    // If actionableMode is "true, tab and shift tab behave like left and right arrow key,
    // if the cell is editable it goes in and out of edit mode
    actionableMode: false,
    cellNavigation: true, // If cellNavigation is "false, will show border around whole row on focus
    rowNavigation: true, // If rowNavigation is "false, will NOT show border around the row
    showHoverState: true,
    alternateRowShading: false,
    columns: [],
    frozenColumns: {
      left: [],
      right: []
    },
    dataset: [],
    columnReorder: false, // Allow Column reorder
    saveColumns: false, // Save Column Reorder and resize
    saveUserSettings: {},
    focusAfterSort: false, // If true will focus the active cell after sorting.
    editable: false,
    isList: false, // Makes a readonly "list"
    menuId: null, // Id to the right click context menu
    headerMenuId: null, // Id to the right click context menu to use for the header
    menuSelected: null, // Callback for the grid level right click menu
    menuBeforeOpen: null, // Call back for the grid level before open menu event
    headerMenuSelected: null, // Callback for the header level right click menu
    headerMenuBeforeOpen: null, // Call back for the header level before open menu event
    uniqueId: null, // Unique ID for local storage reference and variable names
    rowHeight: 'normal', // (short, medium or normal)
    selectable: false, // false, 'single' or 'multiple' or 'siblings'
    selectChildren: true, // can prevent selecting of all child nodes on multiselect
    allowSelectAcrossPages: null,
    groupable: null,
    spacerColumn: false,
    showNewRowIndicator: true,
    stretchColumn: 'last',
    twoLineHeader: false,
    clickToSelect: true,
    toolbar: false,
    initializeToolbar: true, // can set to false if you will initialize the toolbar yourself
    // Paging settings
    paging: false,
    pagesize: 25,
    pagesizes: [10, 25, 50, 75],
    showPageSizeSelector: true, // Will show page size selector
    indeterminate: false, // removed ability to go to a specific page.
    source: null, // callback for paging
    hidePagerOnOnePage: false, // If true, hides the pager if there's only one page worth of results.
    // Filtering settings
    filterable: false,
    filterWhenTyping: true,
    disableClientFilter: false, // Disable Filter Logic client side and let your server do it
    disableClientSort: false, // Disable Sort Logic client side and let your server do it
    resultsText: null, // Can provide a custom function to adjust results text
    showFilterTotal: true, // Paging results show filtered count, false to not show.
    virtualized: false, // Prevent Unused rows from being added to the DOM
    virtualRowBuffer: 10, // how many extra rows top and bottom to allow as a buffer
    rowReorder: false, // Allows you to reorder rows. Requires rowReorder formatter
    showDirty: false,
    showSelectAllCheckBox: true, // Allow to hide the checkbox header (true to show, false to hide)
    allowOneExpandedRow: true, // Only allows one expandable row at a time
    enableTooltips: false, // Process tooltip logic at a cost of performance
    disableRowDeactivation: false,
    sizeColumnsEqually: false, // If true make all the columns equal width
    expandableRow: false, // Supply an empty expandable row template
    exportConvertNegative: false, // Export data with trailing negative signs moved in front
    columnGroups: null, // The columns to use for grouped column headings
    treeGrid: false,
    onPostRenderCell: null,
    onDestroyCell: null,
    onEditCell: null,
    onExpandRow: null,
    emptyMessage: { title: Locale ? Locale.translate('NoData') : 'No Data Available', info: '', icon: 'icon-empty-no-data' },
    searchExpandableRow: true,
    allowChildExpandOnMatch: false
  };

  function Datagrid(element, settings) {
    this.settings = utils.mergeSettings(element, settings, DATAGRID_DEFAULTS);
    this.element = $(element);
    if (settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.init();
  }

  /**
  * Actual Datagrid prototype
  * @private
  */
  Datagrid.prototype = {

    /**
     * @returns {Pager} IDS Pager component API.
     */
    get pagerAPI() {
      var api = void 0;
      if (this.tableBody && this.tableBody.length) {
        api = this.tableBody.data('pager');
      }
      return api;
    },

    /**
     * Reference to the pager API, if applicable.
     * This method is slated to be removed in a future v4.22.0 or v5.0.0.
     * @deprecated as of v4.16.0. Please use `pagerAPI` property instead.
     * @returns {Pager} IDS Pager component API.
     */
    get pager() {
      warnAboutDeprecation('pagerAPI', 'pager');
      return this.pagerAPI;
    },

    /**
    * Init the datagrid from its uninitialized state.
    * @private
    * @returns {void}
    */
    init: function init() {
      var html = $('html');

      this.isTouch = Environment.features.touch;
      this.isSafari = html.is('.is-safari');
      this.isWindows = navigator.userAgent.indexOf('Windows') !== -1;
      this.appendTooltip();
      this.initSettings();
      this.originalColumns = this.columnsFromString(JSON.stringify(this.settings.columns));
      this.removeToolbarOnDestroy = false;
      this.nonVisibleCellErrors = [];
      this.recordCount = 0;
      this.canvas = null;
      this.totalWidths = { left: 0, center: 0, right: 0 };
      this.totalMinWidths = { left: 0, center: 0, right: 0 };
      this.editor = null; // Current Cell Editor thats in Use
      this.activeCell = { node: null, cell: null, row: null }; // Current Active Cell
      this.dontSyncUi = false;
      this.widthPercent = false;
      this.rowSpans = [];
      this.headerWidths = []; // Cache
      this.filterRowRendered = false; // Flag used to determine if the header is rendered or not.
      this.scrollLeft = 0;
      this.scrollTop = 0;
      this._selectedRows = [];
      this.restoreColumns();
      this.restoreUserSettings();
      this.appendToolbar();
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();
      this.firstRender();
      this.handleEvents();
      this.handleKeys();

      /**
       * Fires after the grid is rendered.
      * @event rendered
      * @memberof Datagrid
      * @property {object} event - The jquery event object
      * @property {array} ui - An array with references to the domElement, header and pagerBar
      */
      this.element.trigger('rendered', [this.element, this.headerContainer.find('thead'), this.pagerBar]);
    },


    /**
    * Initialize internal variables and states.
    * @private
    */
    initSettings: function initSettings() {
      this.ignoredColumnById('rowStatus');
      this.sortColumn = { sortField: null, sortAsc: true };
      this.gridCount = $('.datagrid').length + 1;
      this.lastSelectedRow = 0; // Remember index to use shift key

      this.contextualToolbar = this.element.prev('.contextual-toolbar');
      this.contextualToolbar.addClass('datagrid-contextual-toolbar');
    },


    /**
    * Ignore given Column from settings.
    * @private
    * @param {string} columnId for column to be ignored
    * @returns {void}
    */
    ignoredColumnById: function ignoredColumnById(columnId) {
      var s = this.settings;
      if (!columnId || !s.columns || s.columns && !s.columns.length) {
        return;
      }
      var column = { index: -1 };
      for (var i = 0, l = s.columns.length; i < l; i++) {
        if (s.columns[i].id === columnId) {
          column.index = i;
        }
      }
      if (column.index > -1) {
        s.columns.splice(column.index, 1);
      }
    },


    /**
     * Render or render both the header and row area.
     * @param {string} isToggleFilter Check if filterrow type should be passed to the data source request
     * @param {object} pagingInfo information about the pager state
     * @returns {void}
     */
    render: function render(isToggleFilter, pagingInfo) {
      if (!pagingInfo) {
        pagingInfo = {};
      }

      if (isToggleFilter) {
        pagingInfo.type = 'filterrow';
      }

      if (this.settings.source) {
        pagingInfo.preserveSelected = true;
        this.triggerSource(pagingInfo);
        return;
      }

      this.loadData(this.settings.dataset, pagingInfo);
    },


    /**
    * Run the initial render on the Header and Rows.
    * @private
    */
    firstRender: function firstRender() {
      var self = this;
      this.hasLeftPane = this.settings.frozenColumns.left.length > 0;
      this.hasRightPane = this.settings.frozenColumns.right.length > 0;
      self.bodyContainer = $('<div class="datagrid-body-container"></div>');

      if (this.hasLeftPane) {
        self.bodyWrapperLeft = $('<div class="datagrid-body left"></div>');
        self.tableLeft = $('<table></table>').addClass('datagrid').attr('role', this.settings.treeGrid ? 'treegrid' : 'grid').appendTo(self.bodyWrapperLeft);
        self.bodyContainer.append(self.bodyWrapperLeft);
      }

      self.bodyWrapperCenter = $('<div class="datagrid-body center scroll-x' + (!this.hasRightPane ? ' scroll-y' : '') + '"></div>');
      self.table = $('<table></table>').addClass('datagrid').attr('role', this.settings.treeGrid ? 'treegrid' : 'grid').appendTo(self.bodyWrapperCenter);
      self.bodyContainer.append(self.bodyWrapperCenter);

      if (this.hasRightPane) {
        self.bodyWrapperRight = $('<div class="datagrid-body right scroll-y"></div>');
        self.tableRight = $('<table></table>').addClass('datagrid').attr('role', this.settings.treeGrid ? 'treegrid' : 'grid').appendTo(self.bodyWrapperRight);
        self.bodyContainer.append(self.bodyWrapperRight);
      }

      this.element.addClass('datagrid-container').attr('x-ms-format-detection', 'none');

      if (this.isWindows) {
        this.element.addClass('is-windows'); // need since scrollbars are visible
      }

      // initialize row height by a setting
      if (this.settings.rowHeight !== 'normal') {
        if (this.hasLeftPane) {
          self.tableLeft.addClass(this.settings.rowHeight + '-rowheight');
        }
        self.table.addClass(this.settings.rowHeight + '-rowheight');
        if (this.hasRightPane) {
          self.tableRight.addClass(this.settings.rowHeight + '-rowheight');
        }
        this.element.addClass(this.settings.rowHeight + '-rowheight');
      }

      if (this.settings.isList) {
        $(this.element).addClass('is-gridlist');
      } else {
        $(this.element).removeClass('is-gridlist');
      }

      this.isInitialRender = true;
      self.table.empty();
      self.clearHeaderCache();
      self.renderRows();
      self.element.append(this.bodyContainer);
      self.renderHeader();
      self.container = self.element.closest('.datagrid-container');

      if (this.settings.emptyMessage) {
        self.setEmptyMessage(this.settings.emptyMessage);
        self.checkEmptyMessage();
      }

      self.buttonSelector = '.btn, .btn-secondary, .btn-primary, .btn-modal-primary, .btn-tertiary, .btn-icon, .btn-actions, .btn-menu, .btn-split';
      $(self.buttonSelector, self.table).button();

      this.handlePaging();
      this.triggerSource('initial');
    },


    /**
    * If the datagrid is a html table, convert that table to an internal dataset to use.
    * @private
    * @returns {void}
    */
    htmlToDataset: function htmlToDataset() {
      var rows = $(this.element).find('tbody tr');
      var self = this;
      var specifiedCols = self.settings.columns.length > 0;
      var dataset = [];

      // Geneate the columns if not supplier
      if (!specifiedCols) {
        var headers = $(this.element).find('thead th');
        var firstRow = self.element.find('tbody tr:first()');

        headers.each(function (i, col) {
          var colSpecs = {};
          var column = $(col);
          var colName = 'column' + i;

          colSpecs.id = column.text().toLowerCase();
          colSpecs.name = column.text();
          colSpecs.field = colName;

          var link = firstRow.find('td').eq(i).find('a');
          if (link.length > 0) {
            colSpecs.formatter = formatters.Hyperlink;
            colSpecs.href = link.attr('href');
          }

          self.settings.columns.push(colSpecs);
        });
      }

      rows.each(function () {
        var cols = $(this).find('td');
        var newRow = {};

        cols.each(function (i, col) {
          var column = $(col);
          var colName = 'column' + i;

          if (self.settings.columns[i].formatter) {
            newRow[colName] = column.text();
          } else {
            newRow[colName] = column.html();
          }

          if (specifiedCols) {
            self.settings.columns[i].field = colName;
          }
        });

        dataset.push(newRow);
      });

      return dataset;
    },


    /**
    * Add a row of data to the grid and dataset.
    * @param {object} data An data row object
    * @param {string} location Where to add the row. This can be 'bottom' or 'top', default is top.
    */
    addRow: function addRow(data, location) {
      var self = this;
      var isTop = false;
      var row = 0;
      var cell = 0;
      var args = void 0;
      var rowNode = void 0;

      if (!location || location === 'top') {
        location = 'top';
        isTop = true;
      }
      // Add row status
      data.rowStatus = { icon: 'new', text: Locale.translate('New'), tooltip: Locale.translate('New') };

      // Add to array
      if (typeof location === 'string') {
        self.settings.dataset[isTop ? 'unshift' : 'push'](data);
      } else {
        self.settings.dataset.splice(location, 0, data);
      }

      // Add to ui
      self.renderRows();

      // Sync with others
      self.syncSelectedUI();

      // Set active and fire handler
      setTimeout(function () {
        row = isTop ? row : self.settings.dataset.length - 1;
        self.setActiveCell(row, cell);

        rowNode = self.tableBody.find('tr[aria-rowindex="' + (row + 1) + '"]');
        args = { row: row, cell: cell, target: rowNode, value: data, oldValue: {} };

        self.pagerRefresh(location);

        /**
         * Fires after a row is added via the api.
        * @event addrow
        * @memberof Datagrid
        * @property {object} event The jquery event object
        * @property {number} args.row The row index
        * @property {number} args.cell The cell index
        * @property {HTMLElement} args.target The html element.
        * @property {object} args.value - An object all the row data.
        * @property {object} args.oldValue - Always an empty object added for consistent api.
        */
        self.element.triggerHandler('addrow', args);
      }, 100);
    },


    /**
    * Refresh the pager based on the current page and dataset.
    * @private
    * @param {object} location Deprecated - Can be set to 'top' or left off for bottom pager.
    */
    pagerRefresh: function pagerRefresh(location) {
      if (!this.pagerAPI) {
        return;
      }

      var pagingInfo = {};

      if (typeof location === 'string') {
        pagingInfo.activePage = location === 'top' ? 1 : this.pagerAPI._pageCount;
      } else if (typeof location === 'number') {
        pagingInfo.activePage = Math.floor(location / (this.pagerAPI.settings.pagesize + 1));
      }

      if (!this.settings.source) {
        pagingInfo.total = this.settings.dataset.length;
        pagingInfo.pagesize = this.settings.pagesize;
      }
      this.renderPager(pagingInfo, true);
    },


    /**
    * Remove a row of data to the grid and dataset.
    * @param {number} row The row index
    * @param {boolean} nosync Dont sync the selected rows.
    */
    removeRow: function removeRow(row, nosync) {
      var rowNode = this.tableBody.find('tr[aria-rowindex="' + (row + 1) + '"]');
      var rowData = this.settings.dataset[row];

      this.unselectRow(row, nosync);
      this.settings.dataset.splice(row, 1);
      this.renderRows();

      /**
      *  Fires after a row is removed via the api
      * @event rowremove
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Object with the arguments
      * @property {number} args.row The row index
      * @property {number} args.cell The cell index
      * @property {HTMLElement} args.target The row node that is being dragged.
      * @property {HTMLElement} args.item The dragged rows data.
      */
      this.element.trigger('rowremove', { row: row, cell: null, target: rowNode, item: rowData, oldValue: rowData });
    },


    /**
    * Remove all selected rows from the grid and dataset.
    */
    removeSelected: function removeSelected() {
      this._selectedRows.sort(function (a, b) {
        return a.idx < b.idx ? -1 : a.idx > b.idx ? 1 : 0;
      });

      for (var i = this._selectedRows.length - 1; i >= 0; i--) {
        this.removeRow(this._selectedRows[i].idx, true);
      }
      this.pagerRefresh();
      this.syncSelectedUI();
    },


    /**
    * Send in a new data set to display in the datagrid.
    * @param {object} dataset The array of objects to show in the grid. Should match
    * the column definitions.
    * @param {object} pagerInfo The pager info object with information like activePage ect.
    */
    updateDataset: function updateDataset(dataset, pagerInfo) {
      if (this.settings.toolbar && this.settings.toolbar.keywordFilter) {
        var searchField = this.element.parent().find('.toolbar').find('.searchfield');
        searchField.val('');
        searchField.parent().removeClass('has-text');

        this.clearFilter();
      }

      this.loadData(dataset, pagerInfo);
    },


    /**
    * Trigger the source method to call to the backend on demand.
    * @param {object|string} [pagerType=undefined] The pager info object with information like activePage ect.
    * @param {function} callback The call back functions
    * @param {string} [op=undefined] an optional info string that can be applied to identify which operation cause the source call
    */
    triggerSource: function triggerSource(pagerType, callback, op) {
      if (!this.settings.source) {
        return;
      }

      var self = this;
      var pagingInfo = {};
      if (this.pagerAPI) {
        pagingInfo = this.pagerAPI.state;
      }

      if (typeof pagerType === 'string') {
        pagingInfo.type = pagerType;
        pagingInfo.trigger = op;
      } else if (pagerType) {
        pagingInfo = utils.extend({}, pagingInfo, pagerType);
      }

      if (callback && typeof callback !== 'function') {
        if (typeof callback.type === 'string') {
          pagingInfo.type = callback.type;
        }
      }

      /**
      * Fires just before changing page. Returning false from the request function will cancel paging.
      * @event beforepaging
      * @memberof Pager
      * @property {object} event - The jquery event object
      * @property {function} request - The paging request info
      */
      var doPaging = this.element.triggerHandler('beforepaging', pagingInfo);
      if (doPaging === false) {
        return;
      }

      function response(data, updatedPagingInfo) {
        if (updatedPagingInfo.activePage > -1) {
          self.activePage = updatedPagingInfo.activePage;
        }

        if (updatedPagingInfo.grandTotal) {
          self.grandTotal = updatedPagingInfo.grandTotal;
        }

        // Set the remote dataset on the grid
        self.loadData(data, updatedPagingInfo);

        if (callback && typeof callback === 'function') {
          callback(true);
        }

        /**
        * Fires after changing paging has completed.
        * @event afterpaging
        * @memberof Pager
        * @property {object} event - The jquery event object
        * @property {object} pagingInfo - The paging info object
        */
        self.element.trigger('afterpaging', pagingInfo);
      }

      if (this.sortColumn && this.sortColumn.sortId) {
        pagingInfo.sortAsc = this.sortColumn.sortAsc;
        pagingInfo.sortField = this.sortColumn.sortField;
        pagingInfo.sortId = this.sortColumn.sortId;
      }

      if (this.filterExpr && this.filterExpr.length) {
        pagingInfo.filterExpr = this.filterExpr;
      }

      /**
       * Fires when change page.
       * @event paging
       * @memberof Pager
       * @property {object} event The jquery event object
       * @property {object} request The paging request object
       */
      this.element.trigger('paging', pagingInfo);

      this.settings.source(pagingInfo, response);
    },


    /**
    * Send in a new data set to display in the datagrid. Use better named updateDataset
    * @private
    * @param {object} dataset The array of objects to show in the grid.
    * Should match the column definitions.
    * @param {object} pagerInfo The pager info object with information like activePage ect.
    */
    loadData: function loadData(dataset, pagerInfo) {
      this.settings.dataset = dataset;

      if (!pagerInfo) {
        pagerInfo = {};
      }

      if (pagerInfo.type === 'filterrow') {
        pagerInfo.activePage = this.pagerAPI && this.pagerAPI.activePage || 1;
        pagerInfo.pagesize = this.settings.pagesize;
        pagerInfo.total = pagerInfo.total || -1;
        pagerInfo.type = 'filterrow';
      }

      if (!pagerInfo.activePage) {
        pagerInfo.activePage = 1;
        pagerInfo.pagesize = this.settings.pagesize;
        pagerInfo.total = -1;
        pagerInfo.type = 'initial';
        if (this.settings.treeGrid) {
          pagerInfo.preserveSelected = true;
        }
      }

      if (this.settings.source && pagerInfo.grandTotal) {
        this.grandTotal = pagerInfo.grandTotal;
      } else {
        this.grandTotal = null;
      }

      if (this.pagerAPI) {
        if (this.settings.showDirty && this.settings.source && /first|last|next|prev|sorted/.test(pagerInfo.type)) {
          this.dirtyArray = undefined;
        }
      }

      // Update Paging and Clear Rows
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();

      // Figure out whether or not to preserve previously selected rows
      if (pagerInfo.preserveSelected === undefined) {
        if (this.settings.source) {
          this._selectedRows = [];
        } else if (pagerInfo.type === 'initial') {
          this.unSelectAllRows();
        }
      } else if (pagerInfo.preserveSelected === false) {
        if (this.settings.source) {
          this._selectedRows = [];
        } else {
          this.unSelectAllRows();
        }
      }

      if (this.settings.disableClientFilter) {
        this.restoreFilter = true;
        this.restoreSortOrder = true;
        this.savedFilter = this.filterConditions();
        this.restoreFilterClientSide = true;
      }

      // Resize and re-render if have a new dataset
      // (since automatic column sizing depends on the dataset)
      if (pagerInfo.type === 'initial') {
        this.clearHeaderCache();
        this.restoreUserSettings();
        this.renderRows();
        this.renderHeader();
      } else {
        this.renderRows();
      }

      // Setup focus on the first cell
      this.cellNode(0, 0, true).attr('tabindex', '0');
      this.renderPager(pagerInfo, true);
      this.syncSelectedUI();
      this.displayCounts();
    },


    /**
    * Generate a unique id based on the page and grid count. Add a suffix.
    * @private
    * @param {object} suffix Add this string to make the id more unique
    * @returns {string} The unique id.
    */
    uniqueId: function uniqueId(suffix) {
      suffix = suffix === undefined || suffix === null ? '' : suffix;
      var uniqueid = this.settings.uniqueId ? this.settings.uniqueId + '-' + suffix : window.location.pathname.split('/').pop().replace(/\.xhtml|\.shtml|\.html|\.htm|\.aspx|\.asp|\.jspx|\.jsp|\.php/g, '').replace(/[^-\w]+/g, '').replace(/\./g, '-').replace(/ /g, '-').replace(/%20/g, '-') + '-' + (this.element.attr('id') || 'datagrid') + '-' + (this.gridCount || 0) + suffix;

      return uniqueid.replace(/--/g, '-');
    },


    /**
    * Returns an array with all visible columns.
    * @param {boolean} skipBuiltIn If true then built in columns like selectionCheckbox are skipped.
    * @returns {array} An array with the visible columns.
    */
    visibleColumns: function visibleColumns(skipBuiltIn) {
      var visible = [];
      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = this.settings.columns[j];

        if (column.hidden) {
          continue;
        }

        if (skipBuiltIn && column.id === 'selectionCheckbox') {
          continue;
        }
        visible.push(column);
      }
      return visible;
    },


    /**
    * Returns the index of the last column.
    * @private
    * @returns {number} The last columns index.
    */
    lastColumnIdx: function lastColumnIdx() {
      var last = 0;

      if (this.lastColumn) {
        return this.lastColumn;
      }

      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = this.settings.columns[j];

        if (column.hidden) {
          continue;
        }

        last = j;
      }

      this.lastColumn = last;
      return last;
    },


    /**
    * Gets an if for the column group used for grouped headers.
    * @private
    * @param {object} idx The index of the column group
    * @returns {string} The name of the column group
    */
    getColumnGroup: function getColumnGroup(idx) {
      var total = 0;
      var colGroups = this.settings.columnGroups;

      for (var l = 0; l < colGroups.length; l++) {
        if (colGroups[l].hidden) {
          continue;
        }
        total += colGroups[l].colspan;

        if (total >= idx) {
          return this.uniqueId('-header-group-' + l);
        }
      }

      return '';
    },


    /**
    * Gets an if for the column group used for grouped headers.
    * @private
    * @param {number} idx The index of the column group
    * @param {boolean} show Did we show or hide the col.
    */
    updateColumnGroup: function updateColumnGroup() {
      var colGroups = this.settings.columnGroups;
      if (!this.originalColGroups) {
        this.originalColGroups = JSON.parse(JSON.stringify(colGroups));
      }

      if (this.settings.groupable) {
        // need to rerender here to get the colspans correct.
        var groupHeaders = this.tableBody.find('.datagrid-rowgroup-header');
        var newColspan = this.visibleColumns().length;

        for (var _i = 0; _i < groupHeaders.length; _i++) {
          groupHeaders[_i].children[0].setAttribute('colspan', newColspan);
        }
        return;
      }

      if (!colGroups) {
        return;
      }

      // Update the dom
      if (!this.colGroups) {
        return;
      }

      var headGroups = [].slice.call(this.colGroups[0].querySelectorAll('th'));
      var columns = this.settings.columns;
      var columnsLen = columns.length;
      var visibleColumnsLen = this.visibleColumns().length;
      var groups = colGroups.map(function (group) {
        return parseInt(group.colspan, 10);
      });
      var getGroupsTotal = function getGroupsTotal() {
        return groups.reduce(function (a, b) {
          return a + b;
        }, 0);
      };
      var getDiff = function getDiff() {
        var groupsTotal = getGroupsTotal();
        return groupsTotal > columnsLen ? groupsTotal - columnsLen : columnsLen - groupsTotal;
      };

      var groupsTotal = getGroupsTotal();
      var diff = void 0;
      if (groupsTotal > columnsLen) {
        var move = true;
        for (var _i2 = groups.length - 1; _i2 >= 0 && move; _i2--) {
          diff = getDiff();
          if (groups[_i2] >= diff) {
            groups[_i2] -= diff;
            move = false;
          } else {
            groups[_i2] = 0;
          }
        }
      }

      var i = 0;
      var total = 0;
      groups.forEach(function (groupColspan, k) {
        var colspan = groupColspan;
        for (var l = i + groupColspan; i < l; i++) {
          if (i < columnsLen && columns[i].hidden) {
            colspan--;
          }
        }

        if (colspan > 0) {
          total += colspan;
        }

        var groupHeaderEl = headGroups[k];
        groupHeaderEl.setAttribute('colspan', colspan > 0 ? colspan : 1);

        if (colGroups[k].hidden || colspan < 1) {
          groupHeaderEl.classList.add('hidden');
        } else {
          groupHeaderEl.classList.remove('hidden');
        }
      });

      if (total < visibleColumnsLen) {
        var groupHeaderEl = headGroups[headGroups.length - 1];
        diff = visibleColumnsLen - total;
        groupHeaderEl.setAttribute('colspan', diff > 0 ? diff : 1);
      }
    },


    /**
    * Update group headers after column reorder/dragged.
    * @private
    * @param {number} indexFrom The column index dragged from.
    * @param {number} indexTo The column index dragged to.
    * @returns {void}
    */
    updateGroupHeadersAfterColumnReorder: function updateGroupHeadersAfterColumnReorder(indexFrom, indexTo) {
      var colGroups = this.settings.columnGroups;
      if (!colGroups) {
        return;
      }

      if (!this.originalColGroups) {
        this.originalColGroups = JSON.parse(JSON.stringify(colGroups));
      }

      var groups = colGroups.map(function (group) {
        return parseInt(group.colspan, 10);
      });
      var changed = { from: null, to: null, total: 0 };

      groups.forEach(function (colspan, i) {
        changed.total += colspan;

        if (changed.total > indexFrom && changed.from === null) {
          changed.from = i;
        }
        if (changed.total > indexTo && changed.to === null) {
          changed.to = i;
        }
      });

      if (changed.from !== changed.to) {
        colGroups[changed.from].colspan -= 1;
        colGroups[changed.to].colspan += 1;
      }
    },


    /**
    * Returns the text for a header adding built in defaults
    * @private
    * @param {object} col The column id.
    * @returns {string} The current header text
    */
    headerText: function headerText(col) {
      var text = col.name ? col.name : '';

      if (!text && col.id === 'drilldown') {
        text = Locale.translate('Drilldown');
        return '<span class="audible">' + text + '</span>';
      }

      return text;
    },


    /**
     * Get the name of the container (left, right, center) that this column will appear in.
     * @private
     * @param  {string} id The column id to check using the id property.
     * @returns {string} The container that the column appears in.
     */
    getContainer: function getContainer(id) {
      if (this.settings.frozenColumns.left && this.settings.frozenColumns.left.indexOf(id) > -1) {
        return 'left';
      }
      if (this.settings.frozenColumns.right && this.settings.frozenColumns.right.indexOf(id) > -1) {
        return 'right';
      }
      return 'center';
    },


    /**
    * Render the header area.
    * @private
    */
    renderHeader: function renderHeader() {
      var self = this;
      var headerRows = { left: '', center: '', right: '' };
      var headerColGroups = { left: '<colgroup>', center: '<colgroup>', right: '<colgroup>' };
      var headerColGroupCols = { left: '', center: '', right: '' };
      var uniqueId = void 0;

      // Handle Nested Headers
      var colGroups = this.settings.columnGroups;
      if (colGroups) {
        this.element.addClass('has-group-headers');

        var columns = this.settings.columns;
        var columnsLen = columns.length;
        var visibleColumnsLen = this.visibleColumns().length;
        var groups = colGroups.map(function (group) {
          return parseInt(group.colspan, 10);
        });
        var getGroupsTotal = function getGroupsTotal() {
          return groups.reduce(function (a, b) {
            return a + b;
          }, 0);
        };
        var getDiff = function getDiff() {
          var groupsTotal = getGroupsTotal();
          return groupsTotal > columnsLen ? groupsTotal - columnsLen : columnsLen - groupsTotal;
        };

        headerRows.left += '<tr role="row" class="datagrid-header-groups">';
        headerRows.center += '<tr role="row" class="datagrid-header-groups">';
        headerRows.right += '<tr role="row" class="datagrid-header-groups">';

        var groupsTotal = getGroupsTotal();
        var diff = void 0;
        if (groupsTotal > columnsLen) {
          var move = true;
          for (var _i3 = groups.length - 1; _i3 >= 0 && move; _i3--) {
            diff = getDiff();
            if (groups[_i3] >= diff) {
              groups[_i3] -= diff;
              move = false;
            } else {
              groups[_i3] = 0;
            }
          }
        }

        var i = 0;
        var total = 0;
        groups.forEach(function (groupColspan, k) {
          var colspan = groupColspan;
          for (var l = i + groupColspan; i < l; i++) {
            if (i < columnsLen && columns[i].hidden) {
              colspan--;
            }
          }
          var hiddenStr = colGroups[k].hidden || colspan < 1 ? ' class="hidden"' : '';
          var colspanStr = ' colspan="' + (colspan > 0 ? colspan : 1) + '"';
          var groupedHeaderAlignmentClass = colGroups[k].align ? 'l-' + colGroups[k].align + '-text' : '';
          uniqueId = self.uniqueId('-header-group-' + k);
          if (colspan > 0) {
            total += colspan;
          }

          headerRows.center += '<th' + hiddenStr + colspanStr + ' id="' + uniqueId + '" class="' + groupedHeaderAlignmentClass + '"><div class="datagrid-column-wrapper"><span class="datagrid-header-text">' + colGroups[k].name + '</span></div></th>';
        });

        if (total < visibleColumnsLen) {
          diff = visibleColumnsLen - total;
          var colspanStr = ' colspan="' + (diff > 0 ? diff : 1) + '"';
          headerRows.center += '<th' + colspanStr + '></th>';
        }
        headerRows.center += '</tr><tr>';
      } else {
        headerRows.left += '<tr role="row">';
        headerRows.center += '<tr role="row">';
        headerRows.right += '<tr role="row">';
      }

      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = self.settings.columns[j];
        var container = self.getContainer(column.id);
        var id = self.uniqueId('-header-' + j);
        var isSortable = column.sortable === undefined ? true : column.sortable;
        var isResizable = column.resizable === undefined ? true : column.resizable;
        var isExportable = column.exportable === undefined ? true : column.exportable;
        var isSelection = column.id === 'selectionCheckbox';
        var headerAlignmentClass = '';

        // Make frozen columns hideable: false
        if ((self.hasLeftPane || self.hasRightPane) && (self.settings.frozenColumns.left && self.settings.frozenColumns.left.indexOf(column.id) > -1 || self.settings.frozenColumns.right && self.settings.frozenColumns.right.indexOf(column.id) > -1)) {
          column.hideable = false;
        }

        // note there is a space at the front of the classname
        if (column.headerAlign === undefined) {
          headerAlignmentClass = column.align ? ' l-' + column.align + '-text' : '';
        } else {
          headerAlignmentClass = ' l-' + column.headerAlign + '-text';
        }

        // Assign css classes
        var cssClass = '';
        cssClass += isSortable ? ' is-sortable' : '';
        cssClass += isResizable ? ' is-resizable' : '';
        cssClass += column.hidden ? ' is-hidden' : '';
        cssClass += column.filterType ? ' is-filterable' : '';
        cssClass += column.textOverflow === 'ellipsis' ? ' text-ellipsis' : '';
        cssClass += headerAlignmentClass !== '' ? headerAlignmentClass : '';

        // Apply css classes
        cssClass = cssClass !== '' ? ' class="' + cssClass.substr(1) + '"' : '';

        headerRows[container] += '<th scope="col" role="columnheader" id="' + id + '" data-column-id="' + column.id + '"' + (column.field ? ' data-field="' + column.field + '"' : '') + (column.headerTooltip ? ' title="' + column.headerTooltip + '"' : '') + (column.reorderable === false ? ' data-reorder="false"' : '') + (colGroups ? ' headers="' + self.getColumnGroup(j) + '"' : '') + ' data-exportable="' + (isExportable ? 'yes' : 'no') + '"' + cssClass + '>';

        var sortIndicator = '';
        if (isSortable) {
          sortIndicator = '' + ('<div class="sort-indicator">' + '<span class="sort-asc">') + $.createIcon({ icon: 'dropdown' }) + '</span>' + ('<span class="sort-desc">' + $.createIcon({ icon: 'dropdown' }) + '</div>');
        }

        // If header text is center aligned, for proper styling,
        // place the sortIndicator as a child of datagrid-header-text.
        headerRows[container] += '<div class="' + (isSelection ? 'datagrid-checkbox-wrapper ' : 'datagrid-column-wrapper') + headerAlignmentClass + '">\n      <span class="datagrid-header-text' + (column.required ? ' required' : '') + '">' + self.headerText(this.settings.columns[j]) + (headerAlignmentClass === ' l-center-text' ? sortIndicator : '') + '</span>';
        headerColGroupCols[container] += '<col' + this.columnWidth(column, j) + (column.hidden ? ' class="is-hidden"' : '') + '>';

        if (isSelection) {
          if (self.settings.showSelectAllCheckBox) {
            headerRows[container] += '<span aria-checked="false" class="datagrid-checkbox" aria-label="Selection" role="checkbox"></span>';
          } else {
            headerRows[container] += '<span aria-checked="false" class="datagrid-checkbox" aria-label="Selection" role="checkbox" style="display:none"></span>';
          }
        }

        // Note the space in classname.
        // Place sortIndicator via concatenation if
        // header text is not center aligned.
        if (isSortable && headerAlignmentClass !== ' l-center-text') {
          headerRows[container] += sortIndicator;
        }

        headerRows[container] += '</div>' + self.filterRowHtml(column, j) + '</th>';
      }
      headerRows.left += '</tr>';
      headerRows.center += '</tr>';
      headerRows.right += '</tr>';

      headerColGroups.left += headerColGroupCols.left + '</colgroup>';
      headerColGroups.center += headerColGroupCols.center + '</colgroup>';
      headerColGroups.right += headerColGroupCols.right + '</colgroup>';

      // Set Up Header Panes
      if (self.headerRow === undefined) {
        self.headerContainer = $('<div class="datagrid-header-container"></div>').prependTo(self.element);
        var headerHtml = '<div class="datagrid-header"><table role="grid"></table></div>';

        if (self.hasLeftPane) {
          self.headerContainerLeft = $(headerHtml).addClass('left');
          self.headerContainer.append(self.headerContainerLeft);
          self.headerTableLeft = self.headerContainerLeft.find('table');
          self.headerTableLeft.width(this.headerTableWidth('left'));
          self.headerTableLeft.css('min-width', this.headerTableMinWidth('left'));
          self.headerColGroupLeft = $(headerColGroups.left).appendTo(self.headerTableLeft);
          DOM.append(self.headerContainerLeft.find('table'), '<thead>' + headerRows.left + '</thead>', '*');
          self.headerRowLeft = self.headerContainerLeft.find('thead');
        }

        self.headerContainerCenter = $(headerHtml).addClass('center');
        self.headerContainer.append(self.headerContainerCenter);
        self.headerTable = self.headerContainerCenter.find('table');
        self.headerTable.width(this.headerTableWidth('center'));
        self.headerTable.css('min-width', this.headerTableMinWidth('center'));
        self.headerColGroup = $(headerColGroups.center).appendTo(self.headerTable);
        DOM.append(self.headerContainerCenter.find('table'), '<thead>' + headerRows.center + '</thead>', '*');
        self.headerRow = self.headerContainerCenter.find('thead');

        if (self.hasRightPane) {
          self.headerContainerRight = $(headerHtml).addClass('right');
          self.headerContainer.append(self.headerContainerRight);
          self.headerTableRight = self.headerContainerRight.find('table');
          self.headerTableRight.width(this.headerTableWidth('right'));
          self.headerTableRight.css('min-width', this.headerTableMinWidth('right'));
          self.headerColGroupRight = self.hasRightPane ? $(headerColGroups.right).appendTo(self.headerTableRight) : '';
          DOM.append(self.headerContainerRight.find('table'), '<thead>' + headerRows.right + '</thead>', '*');
          self.headerRowRight = self.headerContainerRight.find('thead');
        }
      } else {
        if (self.hasLeftPane) {
          self.headerTableLeft.width(this.headerTableWidth('left'));
          self.headerTableLeft.css('min-width', this.headerTableMinWidth('left'));
          DOM.html(self.headerRowLeft, headerRows.left, '*');
          self.headerColGroupLeft.html(headerColGroupCols.left);
        }

        self.headerTable.width(this.headerTableWidth('center'));
        self.headerTable.css('min-width', this.headerTableMinWidth('center'));
        DOM.html(self.headerRow, headerRows.center, '*');
        self.headerColGroup.html(headerColGroupCols.center);

        if (self.hasRightPane) {
          self.headerTableRight.width(this.headerTableWidth('right'));
          self.headerTableRight.css('min-width', this.headerTableMinWidth('right'));
          DOM.html(self.headerRowRight, headerRows.right, '*');
          self.headerColGroupRight.html(headerColGroupCols.right);
        }
      }

      if (colGroups && self.headerRow) {
        self.colGroups = self.headerRow.find('.datagrid-header-groups');
      }

      self.syncHeaderCheckbox(this.settings.dataset);
      self.setScrollClass();

      if (self.settings.columnReorder) {
        self.createDraggableColumns();
      }

      this.attachFilterRowEvents();

      if (this.restoreSortOrder) {
        this.setSortIndicator(this.sortColumn.sortId, this.sortColumn.sortAsc);
        this.restoreSortOrder = false;
      }

      if (this.restoreFilter) {
        this.applyFilter(this.savedFilter, 'render');
        this.restoreFilter = false;
        this.savedFilter = null;
      }

      this.activeEllipsisHeaderAll();
    },


    /**
    * Set filter datepicker with range/single date.
    * @private
    * @param {object} input element to target datepicker.
    * @param {string} operator filter type.
    * @param {object} options pass in to datepicker.
    * @returns {void}
    */
    filterSetDatepicker: function filterSetDatepicker(input, operator, options) {
      var datepickerApi = input.data('datepicker');
      var isRange = input.data('is-range');
      options = options || {};

      // Init datepicker
      var initDatepicker = function initDatepicker() {
        if (datepickerApi && typeof datepickerApi.destroy === 'function') {
          datepickerApi.destroy();
        }
        input.datepicker(options);
      };

      // invoke datepicker
      if ((!datepickerApi || !isRange) && operator === 'in-range') {
        input.data('is-range', true);
        options.range = { useRange: true };
        initDatepicker();
      } else if ((!datepickerApi || isRange) && operator !== 'in-range') {
        options.range = { useRange: false };
        input.removeData('is-range');
        initDatepicker();
      }
    },


    /**
    * Returns the markup for a specific filter row area.
    * @private
    * @param {object} columnDef The column object for the header
    * @param {object} idx The column idx for the header
    * @returns {string} The filter html to use
    */
    filterRowHtml: function filterRowHtml(columnDef, idx) {
      var self = this;
      var filterMarkup = '';

      // Generate the markup for the various Types
      // Supported Filter Types: text, integer, date, select, decimal,
      // lookup, percent, checkbox, contents
      if (columnDef.filterType) {
        var col = columnDef;
        var filterId = self.uniqueId('-header-filter-' + idx);
        var integerDefaults = void 0;

        filterMarkup = '<div class="datagrid-filter-wrapper" ' + (!self.settings.filterable ? ' style="display:none"' : '') + '>' + self.filterButtonHtml(col) + '<label class="audible" for="' + filterId + '">' + col.name + '</label>';

        switch (col.filterType) {
          case 'checkbox':
            // just the button
            break;
          case 'date':
            filterMarkup += '<input ' + (col.filterDisabled ? ' disabled' : '') + ' type="text" class="datepicker" id="' + filterId + '"/>';
            break;
          case 'integer':
            {
              integerDefaults = {
                patternOptions: {
                  allowNegative: true,
                  allowThousandsSeparator: false,
                  allowDecimal: false,
                  symbols: {
                    thousands: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',',
                    decimal: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.decimal : '.',
                    negative: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.minusSign : '-'
                  }
                },
                process: 'number'
              };

              col.maskOptions = utils.extend(true, {}, integerDefaults, col.maskOptions);
              filterMarkup += '<input' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="' + filterId + '" />';
              break;
            }
          case 'percent':
          case 'decimal':
            {
              var decimalDefaults = {
                patternOptions: {
                  allowNegative: true,
                  allowDecimal: true,
                  symbols: {
                    thousands: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',',
                    decimal: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.decimal : '.',
                    negative: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.minusSign : '-'
                  }
                },
                process: 'number'
              };

              if (col.numberFormat) {
                integerDefaults = {
                  patternOptions: { decimalLimit: col.numberFormat.maximumFractionDigits }
                };

                col.maskOptions = utils.extend(true, {}, integerDefaults, decimalDefaults, col.maskOptions);
              } else {
                col.maskOptions = utils.extend(true, {}, decimalDefaults, col.maskOptions);
              }

              filterMarkup += '<input' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="' + filterId + '" />';
              break;
            }
          case 'contents':
          case 'select':

            filterMarkup += '<select ' + (col.filterDisabled ? ' disabled' : '') + (col.filterType === 'select' ? ' class="dropdown"' : ' multiple class="multiselect"') + 'id="' + filterId + '">';
            if (col.options) {
              if (col.filterType === 'select') {
                filterMarkup += '<option></option>';
              }

              for (var i = 0; i < col.options.length; i++) {
                var option = col.options[i];
                var optionValue = col.caseInsensitive && typeof option.value === 'string' ? option.value.toLowerCase() : option.value;
                if (option && optionValue !== '') {
                  filterMarkup += '<option value = "' + optionValue + '">' + option.label + '</option>';
                }
              }
            }
            filterMarkup += '</select><div class="dropdown-wrapper"><div class="dropdown"><span></span></div><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-dropdown"></use></svg></div>';

            break;
          case 'multiselect':
            filterMarkup += '<select ' + (col.filterDisabled ? ' disabled' : '') + (col.filterType === 'select' ? ' class="dropdown"' : ' multiple class="multiselect"') + 'id="' + filterId + '">';
            if (col.options) {
              for (var _i4 = 0; _i4 < col.options.length; _i4++) {
                var _option = col.options[_i4];
                var _optionValue = col.caseInsensitive && typeof _option.value === 'string' ? _option.value.toLowerCase() : _option.value;
                if (_option && _option.label) {
                  filterMarkup += '<option value = "' + _optionValue + '">' + _option.label + '</option>';
                }
              }
            }
            filterMarkup += '</select><div class="dropdown-wrapper"><div class="dropdown"><span></span></div><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-dropdown"></use></svg></div>';

            break;
          case 'time':
            filterMarkup += '<input ' + (col.filterDisabled ? ' disabled' : '') + ' type="text" class="timepicker" id="' + filterId + '"/>';
            break;
          case 'lookup':
            filterMarkup += '<input ' + (col.filterDisabled ? ' disabled' : '') + ' type="text" class="lookup" id="' + filterId + '" >';
            break;
          default:
            filterMarkup += '<input' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="' + filterId + '"/>';
            break;
        }

        filterMarkup += '</div>';
      }

      if (!columnDef.filterType) {
        filterMarkup = '<div class="datagrid-filter-wrapper"></div>';
      }
      return filterMarkup;
    },


    /**
    * Attach Events and initialize plugins for the filter row.
    * @private
    */
    attachFilterRowEvents: function attachFilterRowEvents() {
      var _this = this;

      var self = this;

      if (!this.settings.filterable) {
        return;
      }

      this.element.addClass('has-filterable-columns');

      if (this.settings.twoLineHeader) {
        this.element.addClass('has-two-line-header');
      }

      // Attach Keyboard support
      this.headerContainer.off('click.datagrid-filter').on('click.datagrid-filter', '.btn-filter', function () {
        var popupOpts = { trigger: 'immediate', offset: { y: 15 }, placementOpts: { strategies: ['flip', 'nudge'] } };
        var popupmenu = $(this).data('popupmenu');

        if (popupmenu) {
          popupmenu.close(true, true);
        } else {
          $(this).off('beforeopen.datagrid-filter').on('beforeopen.datagrid-filter', function () {
            var menu = $(this).next('.popupmenu-wrapper');
            utils.fixSVGIcons(menu);
            self.hideTooltip();
          }).popupmenu(popupOpts).off('selected.datagrid-filter').on('selected.datagrid-filter', function (e, anchor) {
            var rowElem = anchor.closest('th[role="columnheader"]');
            var col = self.columnById(rowElem.attr('data-column-id'))[0];

            // Set datepicker with range/single date
            if (col && col.filterType === 'date') {
              var input = rowElem.find('input');
              var svg = rowElem.find('.btn-filter .icon-dropdown:first');
              var operator = svg.getIconName().replace('filter-', '');
              self.filterSetDatepicker(input, operator, col.editorOptions);
            }
            self.applyFilter(null, 'selected');
          }).off('close.datagrid-filter').on('close.datagrid-filter', function () {
            var data = $(this).data('popupmenu');
            if (data) {
              data.destroy();
            }
          });
        }
        return false;
      });

      var typingTimer = void 0;
      this.headerContainer.off('keydown.datagrid').on('keydown.datagrid', '.datagrid-filter-wrapper input', function (e) {
        clearTimeout(typingTimer);
        e.stopPropagation();

        if (e.which === 13) {
          self.applyFilter(null, 'enter');
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        return true;
      });

      if (this.settings.filterWhenTyping) {
        this.headerContainer.off('keyup.datagrid').on('keyup.datagrid', '.datagrid-filter-wrapper input', function (e) {
          if (e.which === 13) {
            return;
          }

          if (_this.activeCell && _this.activeCell.isFocused) {
            _this.activeCell.isFocused = false;
          }

          clearTimeout(typingTimer);
          typingTimer = setTimeout(function () {
            self.applyFilter(null, 'keyup');
          }, 400);
        });
      }

      this.headerContainer.find('tr:last th').each(function () {
        var col = self.columnById($(this).attr('data-column-id'))[0];
        var elem = $(this);

        if (!col) {
          // No ID found
          return true;
        }

        elem.find('select.dropdown').each(function () {
          var dropdown = $(this);
          dropdown.dropdown(col.editorOptions).on('selected.datagrid', function () {
            self.applyFilter(null, 'selected');
          }).on('listopened.datagrid', function () {
            var api = dropdown.data('dropdown');
            if (api) {
              if (!self.isInViewport(api.list[0])) {
                self.adjustPosLeft(api.list[0]);
              }
            }
          });

          // Append the Dropdown's sourceArguments with some row/col meta-data
          var api = dropdown.data('dropdown');
          api.settings.sourceArguments = {
            column: col,
            container: elem,
            grid: self,
            cell: col,
            event: undefined,
            row: -1,
            rowData: {},
            value: undefined
          };
        });

        elem.find('select.multiselect').each(function () {
          var multiselect = $(this);
          multiselect.multiselect(col.editorOptions).on('selected.datagrid', function () {
            self.applyFilter(null, 'selected');
          });

          // Append the Dropdown's sourceArguments with some row/col meta-data
          var api = multiselect.data('dropdown');
          api.settings.sourceArguments = {
            column: col,
            container: elem,
            grid: self,
            cell: col,
            event: undefined,
            row: -1,
            rowData: {},
            value: undefined
          };
        });

        if (col.maskOptions) {
          elem.find('input').mask(col.maskOptions);
        }

        if (col.mask) {
          elem.find('input').mask(col.mask);
        }

        var datepickerEl = elem.find('.datepicker');
        if (datepickerEl.length && typeof $().datepicker === 'function') {
          datepickerEl.datepicker(col.editorOptions || { dateFormat: col.dateFormat }).on('listclosed.datepicker', function () {
            self.applyFilter(null, 'selected');
          });
        }

        var lookupEl = elem.find('.lookup');
        if (lookupEl.length && typeof $().lookup === 'function') {
          if (col.editorOptions) {
            if (col.editorOptions.clickArguments) {
              col.editorOptions.clickArguments.grid = self;
            } else {
              col.editorOptions.clickArguments = {
                grid: self
              };
            }
          }

          lookupEl.lookup(col.editorOptions || {}).on('change', function () {
            self.applyFilter(null, 'selected');
          });
        }

        var timepickerEl = elem.find('.timepicker');
        if (timepickerEl.length && typeof $().timepicker === 'function') {
          timepickerEl.timepicker(col.editorOptions || { timeFormat: col.timeFormat });
        }

        // Attach Mask
        if (col.mask) {
          elem.find('input').mask({ pattern: col.mask, mode: col.maskMode });
        }

        return null;
      });

      self.filterRowRendered = true;
    },


    /**
    * Render one filter item as used in renderFilterButton
    * @private
    * @param {object} icon The icon for the menu item
    * @param {object} text The text for the menu item
    * @param {object} checked If the menu item is selected
    * @returns {string} The html for the filter item.
    */
    filterItemHtml: function filterItemHtml(icon, text, checked) {
      var iconMarkup = $.createIcon({ classes: 'icon icon-filter', icon: 'filter-' + icon });
      return '<li ' + (checked ? 'class="is-checked"' : '') + '><a href="#">' + iconMarkup + '<span>' + Locale.translate(text) + '</span></a></li>';
    },


    /**
    * Render the Filter Button and Menu based on filterType - which determines the options
    * @private
    * @param {object} col The column object
    * @returns {string} The html for the filter button.
    */
    filterButtonHtml: function filterButtonHtml(col) {
      if (!col.filterType) {
        return '';
      }

      var self = this;
      var isDisabled = col.filterDisabled;
      var filterConditions = $.isArray(col.filterConditions) ? col.filterConditions : [];
      var inArray = function inArray(s, array) {
        array = array || filterConditions;
        return $.inArray(s, array) > -1;
      };
      var render = function render(icon, text, checked) {
        return filterConditions.length && !inArray(icon) ? '' : self.filterItemHtml(icon, text, checked);
      };
      var renderButton = function renderButton(defaultValue) {
        return '<button type="button" class="btn-menu btn-filter" data-init="false" ' + (isDisabled ? ' disabled' : '') + (defaultValue ? ' data-default="' + defaultValue + '"' : '') + ' type="button"><span class="audible">Filter</span>' + ('<svg class="icon-dropdown icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-filter-{{icon}}"></use></svg>' + $.createIcon({ icon: 'dropdown', classes: 'icon-dropdown' }) + '</button><ul class="popupmenu has-icons is-translatable is-selectable">');
      };
      var btnMarkup = '';

      // Just the dropdown
      if (col.filterType === 'contents' || col.filterType === 'select' || col.filterType === 'multiselect') {
        return '';
      }

      if (col.filterType === 'text') {
        btnMarkup = renderButton('contains') + render('contains', 'Contains', true) + render('does-not-contain', 'DoesNotContain') + render('equals', 'Equals') + render('does-not-equal', 'DoesNotEqual') + render('is-empty', 'IsEmpty') + render('is-not-empty', 'IsNotEmpty');
        btnMarkup = btnMarkup.replace('{{icon}}', 'contains');
      }

      if (col.filterType === 'checkbox') {
        btnMarkup += renderButton('selected-notselected') + render('selected-notselected', 'All', true) + render('selected', 'Selected') + render('not-selected', 'NotSelected');
        btnMarkup = btnMarkup.replace('{{icon}}', 'selected-notselected');
      }

      if (col.filterType !== 'checkbox' && col.filterType !== 'text') {
        btnMarkup += renderButton('equals') + render('equals', 'Equals', col.filterType === 'lookup' || col.filterType === 'integer' || col.filterType === 'decimal' || col.filterType === 'date' || col.filterType === 'time') + render('does-not-equal', 'DoesNotEqual') + render('is-empty', 'IsEmpty') + render('is-not-empty', 'IsNotEmpty');
        btnMarkup = btnMarkup.replace('{{icon}}', 'equals');
      }

      if (col.filterType === 'date') {
        btnMarkup += render('in-range', 'InRange');
      }

      if (/\b(integer|decimal|date|time|percent)\b/g.test(col.filterType)) {
        btnMarkup += '' + render('less-than', 'LessThan') + render('less-equals', 'LessOrEquals') + render('greater-than', 'GreaterThan') + render('greater-equals', 'GreaterOrEquals');
        btnMarkup = btnMarkup.replace('{{icon}}', 'less-than');
      }

      if (col.filterType === 'text') {
        btnMarkup += '' + render('end-with', 'EndsWith') + render('does-not-end-with', 'DoesNotEndWith') + render('start-with', 'StartsWith') + render('does-not-start-with', 'DoesNotStartWith');
        btnMarkup = btnMarkup.replace('{{icon}}', 'end-with');
      }

      btnMarkup += '</ul>';
      return btnMarkup;
    },


    /**
    * Toggle the visibility of the filter row.
    */
    toggleFilterRow: function toggleFilterRow() {
      if (this.settings.filterable) {
        this.headerContainer.find('thead').removeClass('is-filterable');
        this.headerContainer.find('.is-filterable').removeClass('is-filterable');
        this.headerContainer.find('.datagrid-filter-wrapper').hide();
        this.settings.filterable = false;
        this.filterRowRendered = false;
        this.element.removeClass('has-filterable-columns');
        this.element.removeClass('has-two-line-header');
        /**
        *  Fires after the filter row is closed by the user.
        * @event closefilterrow
        * @memberof Datagrid
        * @property {object} event The jquery event object
        */
        this.element.triggerHandler('closefilterrow');
      } else {
        this.settings.filterable = true;
        this.filterRowRendered = true;

        this.element.addClass('has-filterable-columns');

        if (this.settings.twoLineHeader) {
          this.element.addClass('has-two-line-header');
        }

        this.headerContainer.find('thead').addClass('is-filterable');
        this.headerContainer.find('.is-filterable').addClass('is-filterable');
        this.headerContainer.find('.datagrid-filter-wrapper').show();

        /**
        * Fires after the filter row is opened by the user.
        * @event openfilterrow
        * @memberof Datagrid
        * @property {object} event The jquery event object
        */
        this.element.triggerHandler('openfilterrow');
        this.attachFilterRowEvents();
      }
      this.setupTooltips();
    },


    /**
    * Apply the Filter with the currently selected conditions, or the ones passed in.
    * @param {object} conditions An array of objects with the filter conditions.
    * @param {string} [trigger] A string to identify the triggering action.
    */
    applyFilter: function applyFilter(conditions, trigger) {
      var self = this;

      if (conditions) {
        this.setFilterConditions(conditions);
      } else {
        conditions = this.filterConditions();
      }

      var checkRow = function checkRow(rowData) {
        var isMatch = true;

        var _loop = function _loop(i) {
          var columnDef = self.columnById(conditions[i].columnId)[0];

          var rowValue = rowData && rowData[columnDef.field] !== undefined ? rowData[columnDef.field] : self.fieldValue(rowData, columnDef.field);
          var rowValueStr = rowValue === null || rowValue === undefined ? '' : rowValue.toString().toLowerCase();
          var conditionValue = conditions[i].value.toString().toLowerCase();
          var rangeData = null;

          // Percent filter type
          if (columnDef.filterType === 'percent') {
            conditionValue = (conditionValue / 100).toString();
            if (('' + columnDef.name).toLowerCase() === 'decimal') {
              rowValue = formatters.Decimal(false, false, rowValue, columnDef);
              conditionValue = formatters.Decimal(false, false, conditionValue, columnDef);
            } else if (('' + columnDef.name).toLowerCase() === 'integer') {
              rowValue = formatters.Integer(false, false, rowValue, columnDef);
              conditionValue = formatters.Integer(false, false, conditionValue, columnDef);
            }
          }

          // Run Data over the formatter
          if (columnDef.filterType === 'text') {
            var fmt = columnDef.formatter;
            var id = conditions[i].columnId;
            rowValue = self.formatValue(fmt, i, id, rowValue, columnDef, rowData, self);

            // Strip any html markup that might be in the formatters
            var rex = /(<([^>]+)>)|(amp;)|(&lt;([^>]+)&gt;)/ig;
            rowValue = rowValue.replace(rex, '').trim().toLowerCase();

            rowValueStr = rowValue === null || rowValue === undefined ? '' : rowValue.toString().toLowerCase();
          }

          if (columnDef.filterType === 'contents' || columnDef.filterType === 'select' || columnDef.filterType === 'multiselect') {
            rowValue = rowValue === null || rowValue === undefined ? '' : rowValue.toString().toLowerCase();
          }

          if ((typeof rowValue === 'number' || !isNaN(rowValue) && rowValue !== '') && columnDef.filterType !== 'date' && columnDef.filterType !== 'time') {
            rowValue = parseFloat(rowValue);
            conditionValue = Locale.parseNumber(conditionValue);
          }

          if (columnDef.filterType === 'date' || columnDef.filterType === 'time') {
            if (columnDef.filterType === 'date' && typeof rowValue === 'string') {
              rowValue = columnDef.formatter(false, false, rowValue, columnDef, true);
            }
            var getValues = function getValues(rValue, cValue) {
              cValue = Locale.parseDate(cValue, conditions[i].format);
              if (cValue) {
                if (columnDef.filterType === 'time') {
                  // drop the day, month and year
                  cValue.setDate(1);
                  cValue.setMonth(0);
                  cValue.setYear(0);
                }

                cValue = cValue.getTime();
              }

              if (rValue instanceof Date) {
                // Copy date
                rValue = new Date(rValue.getTime());
                if (columnDef.filterType === 'time') {
                  // drop the day, month and year
                  rValue.setDate(1);
                  rValue.setMonth(0);
                  rValue.setYear(0);
                } else if (!(columnDef.editorOptions && columnDef.editorOptions.showTime)) {
                  // Drop any time component of the row data for the filter as it is a date only field
                  rValue.setHours(0);
                  rValue.setMinutes(0);
                  rValue.setSeconds(0);
                  rValue.setMilliseconds(0);
                }
                rValue = rValue.getTime();
              } else if (typeof rValue === 'string' && rValue) {
                if (!columnDef.sourceFormat) {
                  rValue = Locale.parseDate(rValue, { pattern: conditions[i].format });
                } else {
                  rValue = Locale.parseDate(rValue, typeof columnDef.sourceFormat === 'string' ? { pattern: columnDef.sourceFormat } : columnDef.sourceFormat);
                }

                if (rValue) {
                  if (columnDef.filterType === 'time') {
                    // drop the day, month and year
                    rValue.setDate(1);
                    rValue.setMonth(0);
                    rValue.setYear(0);
                  } else if (!(columnDef.editorOptions && columnDef.editorOptions.showTime)) {
                    // Drop any time component of the row data for the filter
                    // as it is a date only field
                    rValue.setHours(0);
                    rValue.setMinutes(0);
                    rValue.setSeconds(0);
                    rValue.setMilliseconds(0);
                  }
                  rValue = rValue.getTime();
                }
              }
              return { rValue: rValue, cValue: cValue };
            };

            var values = null;
            if (conditions[i].operator === 'in-range') {
              var cell = self.settings.columns.indexOf(columnDef);
              var input = self.headerContainer.find('th:eq(' + cell + ') .datagrid-filter-wrapper input');
              var datepickerApi = input.data('datepicker');
              if (datepickerApi) {
                rangeData = datepickerApi.settings.range.data;
                if (rangeData && rangeData.start) {
                  values = getValues(rowValue, rangeData.start);
                }
              }
            } else {
              values = getValues(rowValue, conditions[i].value);
            }
            rowValue = values ? values.rValue : rowValue;
            conditionValue = values ? values.cValue : conditionValue;
          }

          switch (conditions[i].operator) {
            case 'equals':

              // This case is multiselect
              if (conditions[i].value instanceof Array) {
                isMatch = false;

                for (var k = 0; k < conditions[i].value.length; k++) {
                  var match = conditions[i].value[k].toLowerCase() === rowValue && (rowValue.toString() !== '' || conditions[i].value[k] === '');
                  if (match) {
                    isMatch = true;
                  }
                }
              } else {
                isMatch = rowValue === conditionValue && rowValue !== '';
              }

              break;
            case 'does-not-equal':
              isMatch = rowValue !== conditionValue;
              break;
            case 'contains':
              isMatch = rowValueStr.indexOf(conditionValue) > -1 && rowValue.toString() !== '';
              break;
            case 'does-not-contain':
              isMatch = rowValueStr.indexOf(conditionValue) === -1;
              break;
            case 'end-with':
              isMatch = rowValueStr.lastIndexOf(conditionValue) === rowValueStr.length - conditionValue.toString().length && rowValueStr !== '' && rowValueStr.length >= conditionValue.toString().length;
              break;
            case 'start-with':
              isMatch = rowValueStr.indexOf(conditionValue) === 0 && rowValueStr !== '';
              break;
            case 'does-not-end-with':
              isMatch = rowValueStr.lastIndexOf(conditionValue) === rowValueStr.length - conditionValue.toString().length && rowValueStr !== '' && rowValueStr.length >= conditionValue.toString().length;
              isMatch = !isMatch;
              break;
            case 'does-not-start-with':
              isMatch = !(rowValueStr.indexOf(conditionValue) === 0 && rowValueStr !== '');
              break;
            case 'is-empty':
              isMatch = rowValueStr === '';
              break;
            case 'is-not-empty':
              if (rowValue === '') {
                isMatch = rowValue !== '';
                break;
              }
              isMatch = !(rowValue === null);
              break;
            case 'in-range':
              isMatch = false;
              if (rangeData && rangeData.startDate && rangeData.endDate) {
                var d1 = rangeData.startDate.getTime();
                var d2 = rangeData.endDate.getTime();
                isMatch = rowValue >= d1 && rowValue <= d2;
              }
              break;
            case 'less-than':
              isMatch = rowValue < conditionValue && rowValue !== '';
              break;
            case 'less-equals':
              isMatch = rowValue <= conditionValue && rowValue !== '';
              break;
            case 'greater-than':
              isMatch = rowValue > conditionValue && rowValue !== '';
              break;
            case 'greater-equals':
              isMatch = rowValue >= conditionValue && rowValue !== '';
              break;
            case 'selected':
              if (columnDef && columnDef.isChecked) {
                isMatch = columnDef.isChecked(rowValue);
                break;
              }
              isMatch = (rowValueStr === '1' || rowValueStr === 'true' || rowValue === true || rowValue === 1) && rowValueStr !== '';
              break;
            case 'not-selected':
              if (columnDef && columnDef.isChecked) {
                isMatch = !columnDef.isChecked(rowValue);
                break;
              }
              isMatch = rowValueStr === '0' || rowValueStr === 'false' || rowValue === false || rowValue === 0 || rowValueStr === '';
              break;
            case 'selected-notselected':
              isMatch = true;
              break;
            default:
          }

          if (!isMatch) {
            return {
              v: false
            };
          }
        };

        for (var i = 0; i < conditions.length; i++) {
          var _ret = _loop(i);

          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
        }
        return isMatch;
      };

      if (!this.settings.disableClientFilter) {
        var dataset = void 0;
        var isFiltered = void 0;
        var i = void 0;
        var i2 = void 0;
        var len = void 0;
        var dataSetLen = void 0;

        if (this.settings.treeGrid) {
          dataset = this.settings.dataset;

          var checkChildNodes = function checkChildNodes(nodeData, parentNode) {
            for (var j = 0; j < nodeData.length; j++) {
              var childNode = nodeData[j];

              if (isFiltered) {
                isFiltered = !checkRow(childNode);
              }

              childNode.isFiltered = !checkRow(childNode);

              if (parentNode && !childNode.isFiltered) {
                parentNode.isFiltered = false;
              }

              if (childNode.children && childNode.children.length) {
                checkChildNodes(childNode.children, childNode);
              }
            }
          };

          for (i = 0, len = dataset.length; i < len; i++) {
            isFiltered = !checkRow(dataset[i]);

            if (dataset[i].children && dataset[i].children.length) {
              checkChildNodes(dataset[i].children);
            }

            dataset[i].isFiltered = isFiltered;
          }
        } else if (this.settings.groupable) {
          for (i = 0, len = this.settings.dataset.length; i < len; i++) {
            var isGroupFiltered = true;
            for (i2 = 0, dataSetLen = this.settings.dataset[i].values.length; i2 < dataSetLen; i2++) {
              isFiltered = !checkRow(this.settings.dataset[i].values[i2]);
              this.settings.dataset[i].values[i2].isFiltered = isFiltered;

              if (!isFiltered) {
                isGroupFiltered = false;
              }
            }

            this.settings.dataset[i].isFiltered = isGroupFiltered;
          }
        } else {
          for (i = 0, len = this.settings.dataset.length; i < len; i++) {
            isFiltered = !checkRow(this.settings.dataset[i]);
            this.settings.dataset[i].isFiltered = isFiltered;
          }
        }
      }

      this.setChildExpandOnMatch();

      if (!this.settings.source) {
        this.renderRows();
      }

      if (this.restoreFilterClientSide) {
        this.restoreFilterClientSide = false;
      } else {
        /**
        * Fires after a filter action ocurs
        * @event filtered
        * @memberof Datagrid
        * @property {object} event The jquery event object
        * @property {object} args Object with the arguments
        * @property {number} args.op The filter operation, this can be 'apply', 'clear'
        * @property {object} args.conditions An object with all the condition data.
        * @property {string} args.trigger Info on what was the triggering action. May be render, select or key
        */
        this.element.trigger('filtered', { op: 'apply', conditions: conditions, trigger: trigger });
      }

      this.setSearchActivePage({
        trigger: trigger,
        type: 'filtered'
      });
      this.saveUserSettings();
    },


    /**
     * Adjust the left positon for given element to be in viewport
     * @private
     * @param {object} el The element
     * @returns {void}
     */
    adjustPosLeft: function adjustPosLeft(el) {
      var padding = 20;
      var b = el.getBoundingClientRect();
      var w = window.innerWidth || document.documentElement.clientWidth;
      if (b.left < 0 && b.right <= w) {
        el.style.left = padding + 'px'; // Left side
      } else if (b.left >= 0 && !(b.right <= w)) {
        el.style.left = w - b.width - padding + 'px'; // Right side
      }
    },


    /**
     * Check if given element is in the viewport
     * @private
     * @param {object} el The element to check
     * @returns {boolean} true if is in the viewport
     */
    isInViewport: function isInViewport(el) {
      var b = el.getBoundingClientRect();
      return b.top >= 0 && b.left >= 0 && b.bottom <= (window.innerHeight || document.documentElement.clientHeight) && b.right <= (window.innerWidth || document.documentElement.clientWidth);
    },


    /**
     * Set child nodes when use filter as
     * settings.allowChildExpandOnMatch === true
     * and if only parent got match then add all children nodes too
     * or if one or more child node got match then add parent node and all the children nodes
     * settings.allowChildExpandOnMatch === false
     * and if only parent got match then make expand/collapse button to be collapsed, disabled
     * and do not add any children nodes
     * or if one or more child node got match then add parent node and only matching children nodes
     * @private
     * @returns {void}
     */
    setChildExpandOnMatch: function setChildExpandOnMatch() {
      var s = this.settings;
      if (s.treeGrid) {
        var checkNodes = function checkNodes(nodeData, depth) {
          for (var i = 0, l = nodeData.length; i < l; i++) {
            var node = nodeData[i];
            var children = node.children;
            var childrenLen = children ? children.length : 0;

            if (childrenLen) {
              if (!node.isFiltered) {
                if (s.allowChildExpandOnMatch) {
                  for (var i2 = 0; i2 < childrenLen; i2++) {
                    children[i2].isFiltered = false;
                  }
                } else {
                  var isAllChildrenFiltered = true;
                  for (var _i5 = 0; _i5 < childrenLen; _i5++) {
                    if (!children[_i5].isFiltered) {
                      isAllChildrenFiltered = false;
                    }
                  }
                  node.isAllChildrenFiltered = isAllChildrenFiltered;
                }
              }
              checkNodes(children, node, depth++);
            }
          }
        };
        checkNodes(s.dataset, 0);
      }
    },


    /**
    * Clear the Filter row Conditions and Reset the Data.
    */
    clearFilter: function clearFilter() {
      if (!this.settings.filterable) {
        return;
      }

      this.headerContainer.find('input, select').val('').trigger('updated');
      // reset all the filters to first item
      this.headerContainer.find('.btn-filter').each(function () {
        var btn = $(this);
        var ul = btn.next();
        var first = ul.find('li:first');

        btn.find('svg:first > use').attr('xlink:href', '#icon-filter-' + btn.attr('data-default'));
        ul.find('.is-checked').removeClass('is-checked');
        first.addClass('is-checked');
      });

      this.applyFilter();
      this.element.trigger('filtered', { op: 'clear', conditions: [] });
    },


    /**
    * Set the Filter Conditions on the UI Only.
    * @param {object} conditions An array of objects with the filter conditions.
    */
    setFilterConditions: function setFilterConditions(conditions) {
      for (var i = 0; i < conditions.length; i++) {
        // Find the filter row
        var rowElem = this.headerContainer.find('th[data-column-id="' + conditions[i].columnId + '"]');
        var input = rowElem.find('input, select');
        var btn = rowElem.find('.btn-filter');

        if (conditions[i].value === undefined) {
          conditions[i].value = '';
        }

        input.val(conditions[i].value);

        if (input.is('select')) {
          if (conditions[i].value instanceof Array) {
            for (var j = 0; j < conditions[i].value.length; j++) {
              input.find('option[value="' + conditions[i].value[j] + '"]').prop('selected', true);
            }
          } else {
            input.find('option[value="' + conditions[i].value + '"]').prop('selected', true);
          }
          input.trigger('updated');
        }

        btn.find('svg:first > use').attr('xlink:href', '#icon-filter-' + conditions[i].operator);
      }
    },


    /**
    * Get filter conditions in array from whats set in the UI.
    * @returns {array} An array with the currently showing filter conditions.
    */
    filterConditions: function filterConditions() {
      // Do not modify keyword search filter expr
      if (this.filterExpr && this.filterExpr.length === 1 && this.filterExpr[0].keywordSearch) {
        delete this.filterExpr[0].keywordSearch;
        return this.filterExpr;
      }

      var self = this;
      this.filterExpr = [];

      // Create an array of objects with: field, id, filterType, operator, value
      this.headerContainer.find('th').each(function () {
        var rowElem = $(this);
        var btn = rowElem.find('.btn-filter');
        var input = rowElem.find('input, select');
        var isDropdown = input.is('select');
        var svg = btn.find('.icon-dropdown:first');
        var op = null;
        var format = null;

        if (!btn.length && !isDropdown) {
          return;
        }

        op = isDropdown ? 'equals' : svg.getIconName().replace('filter-', '');

        if (op === 'selected-notselected') {
          return;
        }

        if (input.val() === '' && ['is-not-empty', 'is-empty', 'selected', 'not-selected'].indexOf(op) === -1) {
          return;
        }

        if (input.val() instanceof Array && input.val().length === 0) {
          return;
        }

        var value = input.val() ? input.val() : '';
        if (input.attr('data-mask-mode') && input.attr('data-mask-mode') === 'number') {
          value = Locale.parseNumber(value);
        }

        var condition = {
          columnId: rowElem.attr('data-column-id'),
          operator: op,
          value: value
        };

        if (input.data('datepicker')) {
          format = input.data('datepicker').settings.dateFormat;
          if (format === 'locale') {
            format = Locale.calendar().dateFormat.short;
          }
          condition.format = format;
        }

        if (input.data('timepicker')) {
          format = input.data('timepicker').settings.timeFormat;
          condition.format = format;
        }

        self.filterExpr.push(condition);
      });

      return self.filterExpr;
    },


    /**
    * Get extra top position for current target in header
    * @private
    * @returns {number} the extra top position of the rows depending on rowHeight setting.
    */
    getExtraTop: function getExtraTop() {
      var s = this.settings;
      var topPositions = {
        default: { short: 0, medium: 0, normal: 0 },
        filterable: { short: 0, medium: 0, normal: 0 },
        group: { short: -25, medium: -30, normal: -39 },
        groupFilterable: { short: -29, medium: -30, normal: -41 }
      };
      var extraTop = 0;
      if (s.columnGroups) {
        extraTop = s.filterable ? topPositions.groupFilterable[s.rowHeight] : topPositions.group[s.rowHeight];
      } else {
        extraTop = s.filterable ? topPositions.filterable[s.rowHeight] : topPositions.default[s.rowHeight];
      }
      return extraTop;
    },


    /**
    * Get height for current target in header
    * @private
    * @returns {number} the height of the rows depending on rowHeight setting.
    */
    getTargetHeight: function getTargetHeight() {
      var s = this.settings;
      var heights = {
        default: { short: 20, medium: 28, normal: 35 },
        filterable: { short: 48, medium: 51, normal: 56 },
        group: { short: 46, medium: 56, normal: 74 },
        groupFilterable: { short: 78, medium: 84, normal: 99 }
      };
      var height = 0;
      if (s.columnGroups) {
        height = s.filterable ? heights.groupFilterable[s.rowHeight] : heights.group[s.rowHeight];
      } else {
        height = s.filterable ? heights.filterable[s.rowHeight] : heights.default[s.rowHeight];
      }
      return height;
    },


    /**
    * Create draggable columns
    * @private
    */
    createDraggableColumns: function createDraggableColumns() {
      var self = this;
      var headers = self.headerNodes().not('[data-column-id="selectionCheckbox"]');
      var showTarget = $('.drag-target-arrows', self.element);

      if (!showTarget.length) {
        self.element.prepend('<span class="drag-target-arrows" style="height: ' + self.getTargetHeight() + 'px;"></span>');
        showTarget = $('.drag-target-arrows', self.element);
      }

      headers.not('[data-reorder="false"]').prepend('</span><span class="handle">&#8286;</span>');
      headers.prepend('<span class="is-draggable-target"></span>');
      headers.last().append('<span class="is-draggable-target last"></span>');
      self.element.addClass('has-draggable-columns');

      // Initialize Drag api
      $('.handle', headers).each(function () {
        var clone = null;
        var headerPos = null;
        var offPos = null;
        var extraTopPos = 0;
        var handle = $(this);
        var header = handle.parent();

        handle.on('mousedown.datagrid', function (e) {
          e.preventDefault();

          header.drag({
            clone: true, cloneAppendTo: headers.first().parent().parent(), clonePosIsFixed: true
          }).on('dragstart.datagrid', function (dragStartEvent, pos, thisClone) {
            clone = thisClone;

            clone.removeAttr('id').addClass('is-dragging-clone').css({ left: pos.left, top: pos.top, height: header.height(), border: 0 });

            $('.is-draggable-target', clone).remove();

            self.setDraggableColumnTargets();

            extraTopPos = self.getExtraTop();
            headerPos = header.position();
            offPos = { top: pos.top - headerPos.top, left: pos.left - headerPos.left };

            var index = self.targetColumn(headerPos);
            self.draggableStatus.startIndex = index;
            e.stopImmediatePropagation();
          }).on('drag.datagrid', function (dragEvent, pos) {
            clone[0].style.left = parseInt(pos.left, 10) + 'px';
            clone[0].style.top = parseInt(pos.top, 10) + 'px';
            headerPos = { top: pos.top - offPos.top, left: pos.left - offPos.left };

            var n = 0;
            var target = null;
            var rect = null;
            var index = self.targetColumn(headerPos);

            $('.is-draggable-target', headers).add(showTarget).removeClass('is-over');

            if (index !== -1) {
              for (var i = 0, l = self.draggableColumnTargets.length; i < l; i++) {
                target = self.draggableColumnTargets[i];
                n = i + 1;

                if (target.index === index && target.index !== self.draggableStatus.startIndex) {
                  if (target.index > self.draggableStatus.startIndex && n < l) {
                    target = self.draggableColumnTargets[n];
                  }

                  target.el.addClass('is-over');
                  showTarget.addClass('is-over');
                  rect = target.el[0].getBoundingClientRect();
                  showTarget[0].style.left = parseInt(rect.left, 10) + 'px';
                  showTarget[0].style.top = parseInt(rect.top, 10) + 1 + extraTopPos + 'px';
                }
              }
            }

            e.stopImmediatePropagation();
          }).on('dragend.datagrid', function (dragendEvent, pos) {
            clone[0].style.left = parseInt(pos.left, 10) + 'px';
            clone[0].style.top = parseInt(pos.top, 10) + 'px';

            headerPos = { top: pos.top - offPos.top, left: pos.left - offPos.left };

            var index = self.targetColumn(headerPos);
            var dragApi = header.data('drag');
            var tempArray = [];
            var i = void 0;
            var l = void 0;
            var indexFrom = void 0;
            var indexTo = void 0;

            // Unbind drag from header
            if (dragApi && dragApi.destroy) {
              dragApi.destroy();
            }

            self.draggableStatus.endIndex = index;
            $('.is-draggable-target', headers).add(showTarget).removeClass('is-over');

            if (self.draggableStatus.endIndex !== -1) {
              if (self.draggableStatus.startIndex !== self.draggableStatus.endIndex) {
                // Swap columns
                for (i = 0, l = self.settings.columns.length; i < l; i++) {
                  if (!self.settings.columns[i].hidden && self.settings.columns[i].id !== 'selectionCheckbox') {
                    tempArray.push(i);
                  }
                }

                indexFrom = tempArray[self.draggableStatus.startIndex] || 0;
                indexTo = tempArray[self.draggableStatus.endIndex] || 0;

                self.updateGroupHeadersAfterColumnReorder(indexFrom, indexTo);
                self.arrayIndexMove(self.settings.columns, indexFrom, indexTo);
                self.updateColumns(self.settings.columns);
              }
            }
          });
        });
      });
    },


    /**
    * Set draggable columns target elements
    * @private
    */
    setDraggableColumnTargets: function setDraggableColumnTargets() {
      var self = this;
      var headers = self.headerNodes().not('.is-hidden').not('[data-column-id="selectionCheckbox"]');
      var target = void 0;
      var pos = void 0;
      var extra = void 0;

      self.draggableColumnTargets = [];
      self.draggableStatus = {};

      // Move last target if not found in last header
      if (!$('.is-draggable-target.last', headers.last()).length) {
        headers.last().append($('.is-draggable-target.last', self.headerNodes()));
      }

      $('.is-draggable-target', headers).each(function (index) {
        var idx = $(this).is('.last') ? index - 1 : index; // Extra target for last header th
        target = headers.eq(idx);
        pos = target.position();
        // Extra space around, if dropped item bit off from drop area
        extra = 20;

        self.draggableColumnTargets.push({
          el: $(this),
          index: idx,
          pos: pos,
          width: target.outerWidth(),
          height: target.outerHeight(),
          dropArea: {
            x1: pos.left - extra,
            x2: pos.left + target.outerWidth() + extra,
            y1: pos.top - extra + self.getExtraTop(),
            y2: pos.top + target.outerHeight() + extra
          }
        });
      });
    },


    /**
    * Get column index for dragging columns
    * @private
    * @param {object} pos The position index
    * @returns {number} The column array index
    */
    targetColumn: function targetColumn(pos) {
      var self = this;
      var idx = -1;
      var target = void 0;
      var i = void 0;
      var l = void 0;

      for (i = 0, l = self.draggableColumnTargets.length - 1; i < l; i++) {
        target = self.draggableColumnTargets[i];
        if (pos.left > target.dropArea.x1 && pos.left < target.dropArea.x2 && pos.top > target.dropArea.y1 && pos.top < target.dropArea.y2) {
          idx = target.index;
        }
      }
      return idx;
    },


    /**
    * Move an array element to a different position. May be dups of this function.
    * @private
    * @param {array} arr The array
    * @param {array} from The from position
    * @param {array} to The to position
    */
    arrayIndexMove: function arrayIndexMove(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },


    /**
    * Attach Drag Events to Rows
    * @private
    */
    createDraggableRows: function createDraggableRows() {
      var self = this;

      if (!this.settings.rowReorder) {
        return;
      }

      this.tableBody.children().filter(function () {
        return $(this).find('.datagrid-reorder-icon').length < 1;
      }).attr('data-arrange-exclude', true);

      // Attach the Drag API
      this.tableBody.arrange({
        placeholder: '<tr class="datagrid-reorder-placeholder"><td colspan="' + this.visibleColumns().length + '"></td></tr>',
        handle: '.datagrid-reorder-icon',
        isVisualItems: true
      }).off('beforearrange.datagrid').on('beforearrange.datagrid', function (e, status) {
        if (self.isSafari) {
          status.start.css({ display: 'inline-block' });
        }
      }).off('arrangeupdate.datagrid').on('arrangeupdate.datagrid', function (e, status) {
        if (self.isSafari) {
          status.end.css({ display: '' });
        }

        self.reorderRow(status.startIndex, status.endIndex, status);
      });
    },


    /**
     * Move a row from one position to another.
     * @param {number} startIndex The row to move.
     * @param {boolean} endIndex The end index.
     * @param {object} status The drag event object.
     */
    reorderRow: function reorderRow(startIndex, endIndex, status) {
      var moveDown = endIndex > startIndex;
      var startRow = this.tableBody.find('tr').eq(startIndex);
      var endRow = this.tableBody.find('tr').eq(endIndex);

      // Move the elem in the data set
      var startRowIdx = this.settings.dataset.splice(startIndex, 1)[0];
      this.settings.dataset.splice(endIndex, 0, startRowIdx);

      // move in the ui
      if (!status && moveDown) {
        startRow.insertAfter(endRow);
      }

      if (!status && !moveDown) {
        startRow.insertBefore(endRow);
      }

      // If using expandable rows move the expandable row with it
      if ((this.settings.rowTemplate || this.settings.expandableRow) && moveDown) {
        this.tableBody.find('tr').eq(startIndex * 2).insertAfter(status.end);
        status.end.next().next().insertAfter(status.over);
      }

      if ((this.settings.rowTemplate || this.settings.expandableRow) && !moveDown) {
        this.tableBody.find('tr').eq(startIndex * 2).next().insertAfter(status.end);
      }

      // Resequence the rows
      var allRows = this.tableBody.find('tr:not(.datagrid-expandable-row)');
      for (var i = 0; i < allRows.length; i++) {
        allRows[i].setAttribute('data-index', i);
        allRows[i].setAttribute('aria-rowindex', i + 1);
      }

      /**
      * Fires after a row is moved via the rowReorder option.
      * @event rowremove
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} status Object with row reorder info
      * @property {number} status.endIndex The ending row index
      * @property {number} status.startIndex The starting row index
      * @property {HTMLElement} status.over The row object that was dragged over.
      * @property {HTMLElement} status.start The starting row object.
      */
      this.element.trigger('rowreorder', [{
        endIndex: endIndex,
        startIndex: startIndex,
        over: endRow,
        start: startRow
      }]);
      this.syncSelectedRowsIdx();
    },


    /**
    * Return the value in a field, taking into account nested objects. Fx obj.field.id
    * @private
    * @param {object} obj The object to use
    * @param {string} field The field as a string fx 'field' or 'obj.field.id'
    * @returns {any} The current value in the field.
    */
    fieldValue: function fieldValue(obj, field) {
      if (!field || !obj) {
        return '';
      }

      if (field.indexOf('.') > -1) {
        return field.split('.').reduce(function (o, x) {
          return o ? o[x] : '';
        }, obj);
      }

      var rawValue = obj[field];
      var value = rawValue || rawValue === 0 || rawValue === false ? rawValue : '';

      value = xssUtils.escapeHTML(value);
      return value;
    },


    /**
    * Setup internal tree root nodes array.
    * @private
    */
    setTreeRootNodes: function setTreeRootNodes() {
      if (!this.settings.treeGrid) {
        return;
      }
      this.settings.treeRootNodes = this.settings.treeDepth.filter(function (node) {
        return node.depth === 1;
      });
    },


    /**
     * Setup internal tree depth array.
     * @private
     * @param {array} dataset The json array to use for calculating tree depth.
     */
    setTreeDepth: function setTreeDepth(dataset) {
      if (!this.settings.treeGrid) {
        return;
      }
      var self = this;
      var idx = 0;
      var iterate = function iterate(node, depth) {
        idx++;
        self.settings.treeDepth.push({ idx: idx, depth: depth, node: node });
        var children = node.children || [];
        for (var i = 0, len = children.length; i < len; i++) {
          iterate(children[i], depth + 1);
        }
      };

      dataset = dataset || this.settings.dataset;
      self.settings.treeDepth = [];

      for (var i = 0, len = dataset.length; i < len; i++) {
        iterate(dataset[i], 1);
      }
    },


    /**
    * Setup internal row grouping
    * @private
    */
    setRowGrouping: function setRowGrouping() {
      var groupSettings = this.settings.groupable;
      if (!groupSettings) {
        return;
      }

      this.originalDataset = this.settings.dataset.slice();

      if (!groupSettings.aggregator || groupSettings.aggregator === 'none') {
        this.settings.dataset = groupBy.none(this.settings.dataset, groupSettings.fields);
        return;
      }

      if (groupSettings.aggregator === 'sum') {
        this.settings.dataset = groupBy.sum(this.settings.dataset, groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'max') {
        this.settings.dataset = groupBy.max(this.settings.dataset, groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'list') {
        this.settings.dataset = groupBy.list(this.settings.dataset, groupSettings.fields, groupSettings.aggregatorOptions);
        return;
      }

      this.settings.dataset = groupBy(this.settings.dataset, groupSettings.fields);
    },


    /**
    * Clear the table body and rows.
    * @private
    */
    renderRows: function renderRows() {
      var tableHtml = '';
      var tableHtmlLeft = '';
      var tableHtmlRight = '';
      var self = this;
      var s = self.settings;
      var body = self.table.find('tbody');
      var activePage = 1;
      if (self.pagerAPI) {
        var pagerState = self.pagerAPI.state;
        if (pagerState.filteredActivePage) {
          activePage = pagerState.filteredActivePage;
        } else {
          activePage = pagerState.activePage;
        }
      }

      self.bodyColGroupHtmlLeft = '<colgroup>';
      self.bodyColGroupHtml = '<colgroup>';
      self.bodyColGroupHtmlRight = '<colgroup>';
      self.triggerDestroyCell(); // Trigger Destroy on previous cells

      // Prevent flashing message area on filter / reload
      if (self.emptyMessageContainer) {
        self.emptyMessageContainer.hide();
      }

      if (body.length === 0) {
        if (self.hasLeftPane) {
          self.tableBodyLeft = $('<tbody></tbody>');
          self.tableLeft.append(self.tableBodyLeft);
        }
        self.tableBody = $('<tbody></tbody>');
        self.table.append(self.tableBody);
        if (self.hasRightPane) {
          self.tableBodyRight = $('<tbody></tbody>');
          self.tableRight.append(self.tableBodyRight);
        }
      }

      self.groupArray = [];

      self.recordCount = 0;
      self.filteredCount = 0;

      // Reset recordCount for paging
      if (s.treeGrid && s.paging && !s.source && activePage > 1) {
        self.recordCount = s.treeRootNodes[s.pagesize * activePage - s.pagesize].idx - 1;
      }

      if (this.restoreSortOrder) {
        this.sortDataset();
      }

      var rowStatusTooltip = false;
      for (var i = 0; i < s.dataset.length; i++) {
        // For better performance dont render out of page
        if (s.paging && !s.source) {
          if (activePage === 1 && i - this.filteredCount >= s.pagesize) {
            if (!s.dataset[i].isFiltered) {
              this.recordCount++;
            } else {
              this.filteredCount++;
            }
            continue; //eslint-disable-line
          }

          if (activePage > 1 && !(i - this.filteredCount >= s.pagesize * (activePage - 1) && i - this.filteredCount < s.pagesize * activePage)) {
            if (!s.dataset[i].isFiltered) {
              if (this.filteredCount) {
                this.recordCount++;
              }
            } else {
              this.filteredCount++;
            }
            continue; //eslint-disable-line
          }
        }

        if (s.virtualized) {
          if (!this.isRowVisible(this.recordCount)) {
            this.recordCount++;
            continue; //eslint-disable-line
          }
        }

        // Exclude Filtered Rows
        if ((!s.treeGrid && s.dataset[i]).isFiltered) {
          this.filteredCount++;
          continue; //eslint-disable-line
        }

        // Handle Grouping
        if (this.settings.groupable) {
          // First push group row
          if (!this.settings.groupable.suppressGroupRow) {
            // Show the grouping row
            var groupHtml = self.rowHtml(s.dataset[i], this.recordCount, i, true);
            if (this.hasLeftPane && groupHtml.left) {
              tableHtmlLeft += groupHtml.left;
            }
            if (groupHtml.center) {
              tableHtml += groupHtml.center;
            }
            if (this.hasRightPane && groupHtml.right) {
              tableHtmlRight += groupHtml.right;
            }
          }

          if (this.settings.groupable.showOnlyGroupRow && s.dataset[i].values[0]) {
            var rowData = s.dataset[i].values[0];

            if (s.dataset[i].list) {
              rowData.list = s.dataset[i].list;
            }

            rowData.values = s.dataset[i].values;
            var _groupHtml = self.rowHtml(rowData, this.recordCount, i);
            if (this.hasLeftPane && _groupHtml.left) {
              tableHtmlLeft += _groupHtml.left;
            }
            if (_groupHtml.center) {
              tableHtml += _groupHtml.center;
            }
            if (this.hasRightPane && _groupHtml.right) {
              tableHtmlRight += _groupHtml.right;
            }

            this.recordCount++;
            self.groupArray.push({ group: i, node: 0 });
            continue; //eslint-disable-line
          }

          // Now Push Groups
          for (var k = 0; k < s.dataset[i].values.length; k++) {
            if (!s.dataset[i].values[k].isFiltered) {
              var _rowHtml = self.rowHtml(s.dataset[i].values[k], this.recordCount, i);
              if (self.hasLeftPane && _rowHtml.left) {
                tableHtmlLeft += _rowHtml.left;
              }
              if (_rowHtml.center) {
                tableHtml += _rowHtml.center;
              }
              if (self.hasRightPane && _rowHtml.right) {
                tableHtmlRight += _rowHtml.right;
              }
              this.recordCount++;
              self.groupArray.push({ group: i, node: k });
            }
          }

          // Now Push summary rowHtml
          if (this.settings.groupable.groupFooterRow) {
            var _rowHtml2 = self.rowHtml(s.dataset[i], this.recordCount, i, true, true);
            if (self.hasLeftPane && _rowHtml2.left) {
              tableHtmlLeft += _rowHtml2.left;
            }
            if (_rowHtml2.center) {
              tableHtml += _rowHtml2.center;
            }
            if (self.hasRightPane && _rowHtml2.right) {
              tableHtmlRight += _rowHtml2.right;
            }
          }

          continue; //eslint-disable-line
        }

        var currentCount = i;
        if (s.treeGrid) {
          currentCount = this.recordCount;
        }

        var rowHtml = self.rowHtml(s.dataset[i], currentCount, i);
        if (self.hasLeftPane && rowHtml.left) {
          tableHtmlLeft += rowHtml.left;
        }
        if (rowHtml.center) {
          tableHtml += rowHtml.center;
        }
        if (self.hasRightPane && rowHtml.right) {
          tableHtmlRight += rowHtml.right;
        }
        this.recordCount++;

        if (s.dataset[i].rowStatus) {
          rowStatusTooltip = true;
        }
      }

      // Append a Summary Row
      if (this.settings.summaryRow) {
        var totals = self.calculateTotals();
        var summaryRowHtml = self.rowHtml(totals, this.recordCount, null, false, true);
        if (self.hasLeftPane && summaryRowHtml.left) {
          tableHtmlLeft += summaryRowHtml.left;
        }
        if (summaryRowHtml.center) {
          tableHtml += summaryRowHtml.center;
        }
        if (self.hasRightPane && summaryRowHtml.right) {
          tableHtmlRight += summaryRowHtml.right;
        }
      }

      if (self.bodyColGroupHtml !== '<colgroup>') {
        self.bodyColGroupHtmlLeft += '</colgroup>';
        self.bodyColGroupHtml += '</colgroup>';
        self.bodyColGroupHtmlRight += '</colgroup>';

        if (self.bodyColGroupLeft) {
          self.bodyColGroupLeft.remove();
        }

        if (self.bodyColGroup) {
          self.bodyColGroup.remove();
        }

        if (self.bodyColGroupRight) {
          self.bodyColGroupRight.remove();
        }

        if (self.hasLeftPane) {
          self.bodyColGroupLeft = $(self.bodyColGroupHtmlLeft);
          self.tableBodyLeft.before(self.bodyColGroupLeft);
        }

        self.bodyColGroup = $(self.bodyColGroupHtml);
        self.tableBody.before(self.bodyColGroup);

        if (self.hasRightPane) {
          self.bodyColGroupRight = $(self.bodyColGroupHtmlRight);
          self.tableBodyRight.before(self.bodyColGroupRight);
        }
      }

      if (self.hasLeftPane) {
        DOM.html(self.tableBodyLeft, tableHtmlLeft, '*');
      }

      DOM.html(self.tableBody, tableHtml, '*');

      if (self.hasRightPane) {
        DOM.html(self.tableBodyRight, tableHtmlRight, '*');
      }
      self.setVirtualHeight();
      self.setScrollClass();
      self.setupTooltips(rowStatusTooltip);
      self.afterRender();
    },


    /**
    * Fire events and do steps needed after a full render.
    * @private
    */
    afterRender: function afterRender() {
      var _this2 = this;

      var self = this;

      // Column column postRender functions
      if (this.settings.onPostRenderCell) {
        var _loop2 = function _loop2(i) {
          var col = self.settings.columns[i];

          if (col.component) {
            self.tableBody.find('tr').each(function () {
              var row = $(this);
              var rowIdx = row.attr('data-index');
              var lineage = row.attr('data-lineage');
              var value = self.settings.dataset;
              if (lineage) {
                var drilldown = lineage.split('.');
                drilldown.push(rowIdx);
                var first = true;
                drilldown.forEach(function (childIdx) {
                  if (first && value[childIdx]) {
                    value = value[childIdx];
                  } else if (value.children && value.children[childIdx]) {
                    value = value.children[childIdx];
                  }
                  first = false;
                });
              } else {
                value = value[rowIdx];
              }
              var colIdx = self.columnIdxById(col.id);
              var args = {
                row: rowIdx,
                cell: colIdx,
                value: value,
                col: col,
                api: self
              };

              self.settings.onPostRenderCell(row.find('td').eq(colIdx).find('.datagrid-cell-wrapper .content')[0], args);
            });
          }
        };

        for (var i = 0; i < this.settings.columns.length; i++) {
          _loop2(i);
        }
      }

      // Init Inline Elements
      var dropdowns = self.tableBody.find('select.dropdown');
      if (dropdowns.dropdown) {
        dropdowns.dropdown();
      }

      // Commit Edits for inline editing
      self.tableBody.find('.dropdown-wrapper.is-inline').prev('select').on('listclosed', function () {
        var elem = $(this);
        var newValue = elem.val();
        var row = elem.closest('tr');

        self.updateCellNode(row.attr('aria-rowindex'), elem.closest('td').index(), newValue, false, true);
      });

      var spinboxes = self.tableBody.find('.spinbox');
      if (spinboxes.spinbox) {
        spinboxes.spinbox();
      }

      // Set UI elements after dataload
      if (!self.settings.source) {
        self.displayCounts();
        self.checkEmptyMessage();
      }

      self.setAlternateRowShading();
      self.createDraggableRows();

      if (!self.activeCell || !self.activeCell.node) {
        self.activeCell = { node: self.cellNode(0, 0).attr('tabindex', '0'), isFocused: false, cell: 0, row: 0 };
      }

      if (self.activeCell.isFocused) {
        self.setActiveCell(self.activeCell.row, self.activeCell.cell);
      }

      // Deselect rows when changing pages
      if (self.settings.paging && self.settings.source && !self.settings.allowSelectAcrossPages) {
        self._selectedRows = [];
        self.syncSelectedUI();
      }

      // Restore selected rows when pages change
      if (self.settings.paging && self.settings.source && self.settings.allowSelectAcrossPages) {
        self.syncSelectedRows();
        self.syncSelectedUI();
      }

      // Restore selected rows when pages change for single select
      if (self.settings.paging && !self.settings.source && self.settings.allowSelectAcrossPages === null) {
        self.syncSelectedRows();
        self.syncSelectedUI();
      }

      /**
      * Fires after the entire grid is rendered.
      * @event afterrender
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {HTMLElement} body Object table body area
      * @property {HTMLElement} header Object table header area
      * @property {HTMLElement} pager Object pager body area
      */
      setTimeout(function () {
        self.element.trigger('afterrender', { body: self.bodyContainer, header: self.headerContainer, pager: self.pagerBar });

        // Hack for scrolling issue on windows
        if (self.hasRightPane && _this2.isWindows) {
          var w = self.tableRight.width() + 17;
          self.tableRight.parent().width(w);
          self.tableRight.parent().find('.datagrid-column-wrapper').eq(0).width(w);
          self.headerTableRight.width(w);
        }
      });
    },


    /**
    * Trigger the onDestroyCell for each cell
    * @private
    */
    triggerDestroyCell: function triggerDestroyCell() {
      var _this3 = this;

      var self = this;

      if (!self.tableBody) {
        return;
      }

      // Call onDestroyCell
      if (this.settings.onPostRenderCell && this.settings.onDestroyCell) {
        var rows = self.tableBody.find('tr');

        if (rows.length === 0) {
          return;
        }

        var _loop3 = function _loop3(i) {
          var col = _this3.settings.columns[i];

          if (col.component) {
            rows.each(function () {
              var row = $(this);
              var rowIdx = row.index();
              var colIdx = self.columnIdxById(col.id);
              var args = {
                row: row.index(),
                cell: colIdx,
                value: self.settings.dataset[rowIdx],
                col: col,
                api: self
              };

              self.settings.onDestroyCell(row.find('td').eq(colIdx).find('.datagrid-cell-wrapper .content')[0], args);
            });
          }
        };

        for (var i = 0; i < this.settings.columns.length; i++) {
          _loop3(i);
        }
      }
    },


    /**
    * Cache info on virtual scrolling for better performance.
    * @private
    */
    cacheVirtualStats: function cacheVirtualStats() {
      var containerHeight = this.element[0].offsetHeight;
      var scrollTop = this.bodyWrapperCenter[0].scrollTop;
      var headerHeight = this.settings.rowHeight === 'normal' ? 40 : this.settings.rowHeight === 'medium' ? 30 : 25;
      var bodyH = containerHeight - headerHeight;
      var rowH = this.settings.rowHeight === 'normal' ? 50 : this.settings.rowHeight === 'medium' ? 40 : 30;

      this.virtualRange = {
        rowHeight: rowH,
        top: Math.max(scrollTop - (this.settings.virtualRowBuffer - 1) * rowH, 0),
        bottom: scrollTop + bodyH + (this.settings.virtualRowBuffer - 1) * rowH,
        totalHeight: rowH * this.settings.dataset.length,
        bodyHeight: bodyH
      };
    },


    /**
    * Check if the row is in the visble scroll area + buffer
    * Just call renderRows() on events that change
    * @private
    * @param  {number} rowIndex Row index to check.
    * @returns {boolean} Current row visibility.
    */
    isRowVisible: function isRowVisible(rowIndex) {
      if (!this.settings.virtualized) {
        if (this.settings.paging && !this.settings.source && rowIndex && this.pagerAPI) {
          return (this.pagerAPI.activePage - 1) * this.settings.pagesize >= rowIndex && this.pagerAPI.activePage * this.settings.pagesize <= rowIndex;
        }

        return true;
      }

      if (rowIndex === 0) {
        this.cacheVirtualStats();
      }

      // determine if the row is in view
      var pos = rowIndex * this.virtualRange.rowHeight;

      if (pos >= this.virtualRange.top && pos < this.virtualRange.bottom) {
        return true;
      }

      return false;
    },


    /**
     * Set the heights on top or bottom based on scroll position
     * @private
     */
    setVirtualHeight: function setVirtualHeight() {
      if (!this.settings.virtualized || !this.virtualRange) {
        return;
      }

      var bottom = this.virtualRange.totalHeight - this.virtualRange.bottom;
      var vTop = this.virtualRange.top;

      this.topSpacer = this.tableBody.find('.datagrid-virtual-row-top');
      this.bottomSpacer = this.tableBody.find('.datagrid-virtual-row-bottom');

      if (vTop > 0 && !this.topSpacer.length) {
        this.topSpacer = $('<tr class="datagrid-virtual-row-top" style="height: ' + vTop + 'px"><td colspan="' + this.visibleColumns().length + '"></td></tr>');
        this.tableBody.prepend(this.topSpacer);
      }

      if (vTop > 0 && this.topSpacer.length) {
        this.topSpacer.css('height', vTop + 'px');
      }

      if (vTop === 0 && (this.topSpacer.length || this.virtualRange.topRow <= 1)) {
        this.topSpacer.remove();
      }

      if (bottom > 0 && !this.bottomSpacer.length) {
        this.bottomSpacer = $('<tr class="datagrid-virtual-row-bottom" style="height: ' + bottom + 'px"><td colspan="' + this.visibleColumns().length + '"></td></tr>');
        this.tableBody.append(this.bottomSpacer);
      }

      if (bottom > 0 && this.bottomSpacer.length) {
        this.bottomSpacer.css('height', bottom + 'px');
      }

      if (bottom <= 0 && (this.bottomSpacer.length || this.virtualRange.bottomRow >= this.settings.dataset.length)) {
        this.bottomSpacer.remove();
      }
    },


    /**
     * Set the alternate shading class.
     * @private
     */
    setAlternateRowShading: function setAlternateRowShading() {
      if (this.settings.alternateRowShading && this.settings.treeGrid) {
        $('tr[role="row"]:visible', this.tableBody).removeClass('alt-shading').filter(':odd').addClass('alt-shading');
      }
    },


    /**
     * The default cell formatters thats used when no formatter is provided.
     * @private
     * @param  {function} formatter The formatter function.
     * @param  {number} row The row index.
     * @param  {number} cell The cell index.
     * @param  {string} fieldValue The current field value.
     * @param  {object} columnDef The column settings.
     * @param  {object} rowData The current row data.
     * @param  {object} api The grid API reference.
     * @returns {void}
     */
    formatValue: function formatValue(formatter, row, cell, fieldValue, columnDef, rowData, api) {
      var formattedValue = void 0;
      api = api || this;

      // Use default formatter if undefined
      if (formatter === undefined) {
        formatter = this.defaultFormatter;
      }

      if (typeof formatter === 'string') {
        formattedValue = formatters[formatter](row, cell, fieldValue, columnDef, rowData, api);
        formattedValue = formattedValue.toString();
      } else {
        formattedValue = formatter(row, cell, fieldValue, columnDef, rowData, api).toString();
      }
      return formattedValue;
    },


    /**
     * Return the html markup for the row.
     * @private
     * @param  {object} rowData The data to use to render the row
     * @param  {number} dataRowIdx The row index.
     * @param  {number} actualIndex The actual data index
     * @param  {boolean} isGroup If true we are building a group row.
     * @param  {object} isFooter If true we are building a footer row.
     * @param  {string} actualIndexLineage Series of actualIndex values to reach a child actualIndex in a tree
     * @param  {boolean} skipChildren If true we dont append children.
     * @returns {string} The html used to construct the row.
     */
    rowHtml: function rowHtml(rowData, dataRowIdx, actualIndex, isGroup, isFooter, actualIndexLineage, skipChildren) {
      var isEven = false;
      var self = this;
      var isSummaryRow = this.settings.summaryRow && !isGroup && isFooter;
      var activePage = self.pagerAPI ? self.pagerAPI.activePage : 1;
      var containerHtml = { left: '', center: '', right: '' };
      var d = self.settings.treeDepth ? self.settings.treeDepth[dataRowIdx] : 0;
      var depth = null;
      var j = 0;
      var isHidden = false;
      var skipColumns = void 0;

      if (!rowData) {
        return '';
      }

      // Default
      d = d ? d.depth : 0;
      depth = d;

      // Setup if this row will be hidden or not
      if (self.settings.treeDepth && self.settings.treeDepth.length) {
        for (var i = 0; i < self.settings.treeDepth.length; i++) {
          var treeDepthItem = self.settings.treeDepth[i];

          if (dataRowIdx === treeDepthItem.idx - 1) {
            var parentNode = null;
            var currentDepth = 0;
            for (var i2 = i; i2 >= 0; i2--) {
              currentDepth = self.settings.treeDepth[i2].depth < currentDepth || currentDepth === 0 ? self.settings.treeDepth[i2].depth : currentDepth;
              if (currentDepth < treeDepthItem.depth) {
                parentNode = self.settings.treeDepth[i2];

                if (parentNode.node.isExpanded !== undefined && !parentNode.node.isExpanded || currentDepth === 1) {
                  break;
                }
              }
            }

            if (parentNode && parentNode.node.expanded !== undefined && !parentNode.node.expanded) {
              isHidden = true;
            } else {
              isHidden = rowData.isFiltered;
            }

            depth = treeDepthItem.depth;

            break;
          }
        }
      }

      if (this.settings.groupable) {
        var groupSettings = this.settings.groupable;
        isHidden = groupSettings.expanded === undefined ? false : !groupSettings.expanded;

        if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
          isHidden = !groupSettings.expanded(dataRowIdx, 0, null, null, rowData, this);
        }
      }

      // Group Rows
      var visibleColumnsLeft = this.settings.frozenColumns.left.length;
      var visibleColumnsRight = this.settings.frozenColumns.right.length;
      var visibleColumnsCenter = this.visibleColumns().length - visibleColumnsLeft - visibleColumnsRight;

      if (this.settings.groupable && isGroup && !isFooter) {
        var groupRowHtml = formatters.GroupRow(dataRowIdx, 0, null, null, rowData, this);
        containerHtml.left = '<tr class="datagrid-rowgroup-header' + (isHidden ? '' : ' is-expanded') + '" role="rowgroup"><td role="gridcell" colspan="' + visibleColumnsLeft + '">' + (groupRowHtml.left || '<span>&nbsp;</span>') + '</td></tr>';
        containerHtml.center = '<tr class="datagrid-rowgroup-header' + (isHidden ? '' : ' is-expanded') + '" role="rowgroup"><td role="gridcell" colspan="' + visibleColumnsCenter + '">' + (groupRowHtml.center || '<span>&nbsp;</span>') + '</td></tr>';
        containerHtml.right = '<tr class="datagrid-rowgroup-header' + (isHidden ? '' : ' is-expanded') + '" role="rowgroup"><td role="gridcell" colspan="' + visibleColumnsRight + '">' + (groupRowHtml.right || '<span>&nbsp;</span>') + '</td></tr>';
        return containerHtml;
      }

      if (this.settings.groupable && isGroup && isFooter) {
        var groupFooterHtml = formatters.GroupFooterRow(dataRowIdx, 0, null, null, rowData, this);
        containerHtml.left = '<tr class="datagrid-row datagrid-rowgroup-footer' + (isHidden ? '' : ' is-expanded') + '" role="rowgroup">' + (groupFooterHtml.left || '<span>&nbsp;</span>') + '</tr>';
        containerHtml.center = '<tr class="datagrid-row datagrid-rowgroup-footer' + (isHidden ? '' : ' is-expanded') + '" role="rowgroup">' + (groupFooterHtml.center || '<span>&nbsp;</span>') + '</tr>';
        containerHtml.right = '<tr class="datagrid-row datagrid-rowgroup-footer' + (isHidden ? '' : ' is-expanded') + '" role="rowgroup">' + (groupFooterHtml.right || '<span>&nbsp;</span>') + '</tr>';
        return containerHtml;
      }

      var ariaRowindex = dataRowIdx + 1 + (self.settings.source && !self.settings.indeterminate ? (activePage - 1) * self.settings.pagesize : 0);

      isEven = this.recordCount % 2 === 0;
      var isSelected = this.isRowSelected(rowData);
      var isActivated = rowData._rowactivated;
      var rowStatus = { class: '', svg: '' };

      if (rowData && rowData.rowStatus && (rowData.rowStatus.icon === 'new' ? self.settings.showNewRowIndicator : true)) {
        rowStatus.show = true;
        rowStatus.class = ' rowstatus-row-' + rowData.rowStatus.icon;
        rowStatus.icon = rowData.rowStatus.icon === 'success' ? '#icon-check' : '#icon-exclamation';
        rowStatus.title = rowData.rowStatus.tooltip !== '' ? ' title="' + rowData.rowStatus.tooltip + '"' : '';
        rowStatus.svg = '<svg class="icon icon-rowstatus" focusable="false" aria-hidden="true" role="presentation"' + rowStatus.title + '><use xlink:href="' + rowStatus.icon + '"></use></svg>';
      }

      containerHtml.center = '<tr role="row" aria-rowindex="' + ariaRowindex + '"' + (' data-index="' + actualIndex + '"' + (actualIndexLineage ? ' data-lineage="' + actualIndexLineage + '"' : '') + (self.settings.treeGrid && rowData.children ? ' aria-expanded="' + (rowData.expanded ? 'true"' : 'false"') : '') + (self.settings.treeGrid ? ' aria-level= "' + depth + '"' : '') + (isSelected ? ' aria-selected= "true"' : '') + ' class="datagrid-row' + rowStatus.class + (isHidden ? ' is-hidden' : '') + (rowData.isFiltered ? ' is-filtered' : '') + (isActivated ? ' is-rowactivated' : '') + (isSelected ? this.settings.selectable === 'mixed' ? ' is-selected hide-selected-color' : ' is-selected' : '') + (self.settings.alternateRowShading && !isEven ? ' alt-shading' : '') + (isSummaryRow ? ' datagrid-summary-row' : '') + (!self.settings.cellNavigation && self.settings.selectable !== false ? ' is-clickable' : '') + (self.settings.treeGrid ? rowData.children ? ' datagrid-tree-parent' : depth > 1 ? ' datagrid-tree-child' : '' : '') + '">');

      containerHtml.left = containerHtml.center;
      containerHtml.right = containerHtml.center;

      for (j = 0; j < self.settings.columns.length; j++) {
        var _col = self.settings.columns[j];
        var container = this.getContainer(_col.id);
        var cssClass = '';
        var defaultFormatter = _col.summaryRowFormatter || _col.formatter || self.defaultFormatter;
        var formatter = isSummaryRow ? defaultFormatter : _col.formatter || self.defaultFormatter;
        var formatted = self.formatValue(formatter, dataRowIdx, j, self.fieldValue(rowData, self.settings.columns[j].field), self.settings.columns[j], rowData, self);

        if (formatted.indexOf('<span class="is-readonly">') === 0) {
          _col.readonly = true;
        }

        if (formatted.indexOf('datagrid-checkbox') > -1 || formatted.indexOf('btn-actions') > -1) {
          cssClass += ' l-center-text';
        }

        if (formatted.indexOf('trigger') > -1) {
          cssClass += ' datagrid-trigger-cell';
        }

        if (_col.editor) {
          cssClass += ' has-editor';
        }

        if (_col.expanded) {
          self.treeExpansionField = _col.expanded;
        }

        if (_col.align) {
          cssClass += ' l-' + _col.align + '-text';
        }

        if (_col.textOverflow === 'ellipsis') {
          cssClass += ' text-ellipsis';
        }

        if (_col.uppercase) {
          cssClass += ' uppercase-text';
        }

        // Add Column Css Classes

        // Add a readonly class if set on the column
        cssClass += _col.readonly ? ' is-readonly' : '';
        cssClass += _col.hidden ? ' is-hidden' : '';

        // Run a function that helps check if editable
        if (_col.isEditable && !_col.readonly) {
          var fieldVal = self.fieldValue(rowData, self.settings.columns[j].field);
          var canEdit = _col.isEditable(ariaRowindex - 1, j, fieldVal, _col, rowData);

          if (!canEdit) {
            cssClass += ' is-readonly';
          }
        }

        // Run a function that helps check if readonly
        var ariaReadonly = _col.id !== 'selectionCheckbox' && (_col.readonly || _col.editor === undefined) ? 'aria-readonly="true"' : '';

        if (_col.isReadonly && !_col.readonly && _col.id !== 'selectionCheckbox') {
          var _fieldVal = self.fieldValue(rowData, self.settings.columns[j].field);
          var isReadonly = _col.isReadonly(this.recordCount, j, _fieldVal, _col, rowData);

          if (isReadonly) {
            cssClass += ' is-cell-readonly';
            ariaReadonly = 'aria-readonly="true"';
          }
        }

        var cellValue = self.fieldValue(rowData, self.settings.columns[j].field);

        // Run a function that dynamically adds a class
        if (_col.cssClass && typeof _col.cssClass === 'function') {
          cssClass += ' ' + _col.cssClass(this.recordCount, j, cellValue, _col, rowData);
        }

        if (_col.cssClass && typeof _col.cssClass === 'string') {
          cssClass += ' ' + _col.cssClass;
        }

        cssClass += _col.focusable ? ' is-focusable' : '';

        var rowspan = this.calculateRowspan(cellValue, dataRowIdx, _col);

        if (rowspan === '') {
          continue;
        }

        // Set Width of table col / col group elements
        var colWidth = '';

        if (this.recordCount === 0) {
          colWidth = this.columnWidth(_col, j);

          switch (container) {
            case 'left':
              self.bodyColGroupHtmlLeft += '<col' + colWidth + (_col.hidden ? ' class="is-hidden"' : '') + '></col>';
              break;
            case 'right':
              self.bodyColGroupHtmlRight += '<col' + colWidth + (_col.hidden ? ' class="is-hidden"' : '') + '></col>';
              break;
            default:
              self.bodyColGroupHtml += '<col' + colWidth + (_col.hidden ? ' class="is-hidden"' : '') + '></col>';
          }

          if (_col.colspan) {
            this.hasColSpans = true;
          }
        }

        if (skipColumns > 0 && !_col.hidden) {
          skipColumns -= 1;
          cssClass += ' is-hidden';
        }

        // Run an optional function to calculate a colspan
        var colspan = null;
        if (_col.colspan && typeof _col.colspan === 'function') {
          var _fieldVal2 = self.fieldValue(rowData, self.settings.columns[j].field);
          colspan = _col.colspan(ariaRowindex - 1, j, _fieldVal2, _col, rowData, self);

          var max = self.settings.columns.length - j;
          colspan = colspan && colspan > max ? max : colspan;
          if (colspan && colspan > 1) {
            skipColumns = colspan - 1;
            if (_col.align) {
              cssClass = cssClass.replace(' l-' + _col.align + '-text', '');
            }
            cssClass += ' l-left-text';
          } else {
            colspan = null;
          }
        }

        // Set rowStatus info
        if (j !== 0) {
          rowStatus.class = '';
          rowStatus.svg = '';
        }

        if (rowStatus.class !== '') {
          cssClass += ' rowstatus-cell';
        }

        if (self.isCellDirty(dataRowIdx, j)) {
          cssClass += ' is-dirty-cell';
        }

        // Trim extra spaces
        if (cssClass !== '') {
          cssClass = cssClass.replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ');
        }

        containerHtml[container] += '<td role="gridcell" ' + ariaReadonly + ' aria-colindex="' + (j + 1) + '"' + (' aria-describedby="' + self.uniqueId('-header-' + j) + '"' + (isSelected ? ' aria-selected= "true"' : '') + (cssClass ? ' class="' + cssClass + '"' : '') + (colspan ? ' colspan="' + colspan + '"' : '') + (_col.tooltip && typeof _col.tooltip === 'string' ? ' title="' + _col.tooltip.replace('{{value}}', cellValue) + '"' : '') + (self.settings.columnGroups ? 'headers = "' + self.uniqueId('-header-' + j) + ' ' + self.getColumnGroup(j) + '"' : '') + (rowspan || '') + '>' + rowStatus.svg + '<div class="datagrid-cell-wrapper">');

        if (_col.contentVisible) {
          var canShow = _col.contentVisible(dataRowIdx + 1, j, cellValue, _col, rowData);
          if (!canShow) {
            formatted = '';
          }
        }

        if (self.settings.onPostRenderCell && _col.component) {
          containerHtml[container] += '<div class="content"></div>';
          formatted = '';
        }

        containerHtml[container] += formatted + '</div></td>';
      }

      containerHtml.left += '</tr>';
      containerHtml.center += '</tr>';
      containerHtml.right += '</tr>';

      if (self.settings.rowTemplate) {
        var tmpl = self.settings.rowTemplate;
        var item = rowData;
        var renderedTmpl = '';

        if (Tmpl && item) {
          renderedTmpl = Tmpl.compile('{{#dataset}}' + tmpl + '{{/dataset}}', { dataset: item });
        }

        if (this.hasLeftPane) {
          containerHtml.left += '<tr class="datagrid-expandable-row no-border"><td colspan="' + visibleColumnsLeft + '">\n          <div class="datagrid-row-detail"><div style="height: ' + (self.settings.rowTemplateHeight || '107') + 'px"></div></div>\n          </td></tr>';
        }
        containerHtml.center += '<tr class="datagrid-expandable-row"><td colspan="' + visibleColumnsCenter + '">\n        <div class="datagrid-row-detail"><div class="datagrid-row-detail-padding">' + renderedTmpl + '</div></div>\n        </td></tr>';
        if (this.hasRightPane) {
          containerHtml.right += '<tr class="datagrid-expandable-row"><td colspan="' + visibleColumnsLeft + '">\n          </td></tr>';
        }
      }

      if (self.settings.expandableRow) {
        if (this.hasLeftPane) {
          containerHtml.left += '<tr class="datagrid-expandable-row"><td colspan="' + visibleColumnsLeft + '">' + '<div class="datagrid-row-detail"><div class="datagrid-row-detail-padding"></div></div>' + '</td></tr>';
        }
        containerHtml.center += '<tr class="datagrid-expandable-row"><td colspan="' + visibleColumnsCenter + '">' + '<div class="datagrid-row-detail"><div class="datagrid-row-detail-padding"></div></div>' + '</td></tr>';
      }

      // Render Tree Children
      if (rowData.children && !skipChildren) {
        for (var _i6 = 0, l = rowData.children.length; _i6 < l; _i6++) {
          var lineage = actualIndexLineage ? actualIndexLineage + '.' + actualIndex : '' + actualIndex;
          this.recordCount++;
          var childRowHtml = self.rowHtml(rowData.children[_i6], this.recordCount, _i6, false, false, lineage);

          containerHtml.center += childRowHtml.center;
          containerHtml.left += childRowHtml.center;
          containerHtml.right += childRowHtml.right;
        }
      }

      return containerHtml;
    },


    /**
     * This Function approximates the table auto widthing
     * Except use all column values and compare the text width of the header as max
     * @private
     * @param  {object} columnDef The column to check.
     * @returns {number} The text width.
     */
    calculateTextWidth: function calculateTextWidth(columnDef) {
      var max = 0;
      var maxText = '';
      var chooseHeader = false;
      var hasButton = false;
      var self = this;
      var title = columnDef.name || '';

      // Get max cell value length for this column
      for (var i = 0; i < this.settings.dataset.length; i++) {
        var val = this.fieldValue(this.settings.dataset[i], columnDef.field);
        var len = 0;
        var row = this.settings.dataset[i];

        // Get formatted value (without html) so we have accurate string that
        // will display for this cell
        val = self.formatValue(columnDef.formatter, i, 0, val, columnDef, row, self);
        hasButton = val.toString().indexOf('btn-secondary') > -1;
        val = xssUtils.stripHTML(val);

        len = val.toString().length;

        if (this.settings.groupable && row.values) {
          for (var k = 0; k < row.values.length; k++) {
            var groupVal = this.fieldValue(row.values[k], columnDef.field);
            groupVal = self.formatValue(columnDef.formatter, i, 0, groupVal, columnDef, row, self);
            groupVal = xssUtils.stripHTML(groupVal);

            len = groupVal.toString().length;
            if (len > max) {
              max = len;
              maxText = groupVal;
            }
          }
        }

        if (len > max) {
          max = len;
          maxText = val;
        }
      }

      var hasTag = columnDef.formatter ? columnDef.formatter.toString().indexOf('<span class="tag') > -1 : false;

      var hasAlert = columnDef.formatter ? columnDef.formatter.toString().indexOf('datagrid-alert-icon') > -1 : false;

      if (hasAlert) {
        max += 10;
      }

      // Use header text length as max if bigger than all data cells
      if (title.length > max) {
        max = title.length;
        maxText = title;
        chooseHeader = true;
      }

      if (maxText === '' || this.settings.dataset.length === 0) {
        maxText = columnDef.name || ' Default ';
        chooseHeader = true;
      }

      // if given, use cached canvas for better performance, else, create new canvas
      this.canvas = this.canvas || (this.canvas = document.createElement('canvas'));
      var context = this.canvas.getContext('2d');
      context.font = '14px arial';

      var metrics = context.measureText(maxText);
      var padding = chooseHeader ? 40 : 45;

      if (hasAlert && !chooseHeader) {
        padding += 20;
      }

      if (hasTag && !chooseHeader) {
        padding += 10;
      }

      if (hasButton) {
        padding += 50;
      }

      if (columnDef.filterType) {
        var minWidth = columnDef.filterType === 'date' ? 170 : 100;

        if (columnDef.filterType === 'checkbox') {
          minWidth = 40;
          padding = 40;
        }

        return Math.round(Math.max(metrics.width + padding, minWidth));
      }

      return Math.round(metrics.width + padding); // Add padding and borders
    },


    /**
     * Return the currently cached table width ready for the css style.
     * @private
     * @param  {string} container The container (left, right, center).
     * @returns {string} The css width
     */
    headerTableWidth: function headerTableWidth(container) {
      var cacheWidths = this.headerWidths[this.settings.columns.length - 1];
      var hasVisibleScrollbars = false;

      if (!cacheWidths) {
        return '';
      }

      if (this.hasRightPane && container === 'right') {
        hasVisibleScrollbars = Environment.os.name === 'Mac OS X' && this.bodyWrapperRight.width() - this.tableRight.width() > 0;
      }

      if (cacheWidths.widthPercent) {
        return '100%';
      } else if (!isNaN(this.totalWidths[container])) {
        if (hasVisibleScrollbars) {
          return parseFloat(this.totalWidths[container]) + 15 + 'px';
        }
        return parseFloat(this.totalWidths[container]) + 'px';
      }

      return '';
    },


    /**
     * Return the currently cached table min width ready for the css style.
     * @private
     * @param  {string} container The container (left, right, center).
     * @returns {string} The css width
     */
    headerTableMinWidth: function headerTableMinWidth(container) {
      if (!isNaN(this.totalMinWidths[container])) {
        return parseFloat(this.totalMinWidths[container]) + 'px';
      }
      return '';
    },


    /**
     * Set the scroll class if the scrollbar is visible to effect the scrollheight.
     * @private
     */
    setScrollClass: function setScrollClass() {
      var height = parseInt(this.bodyWrapperCenter[0].offsetHeight, 10);
      var hasScrollBarV = parseInt(this.bodyWrapperCenter[0].scrollHeight, 10) > height + 2;
      var width = parseInt(this.bodyWrapperCenter[0].offsetWidth, 10);
      var hasScrollBarH = parseInt(this.bodyWrapperCenter[0].scrollWidth, 10) > width;
      this.element.removeClass('has-vertical-scroll has-less-rows');

      if (hasScrollBarV) {
        this.element.addClass('has-vertical-scroll');
      }
      if (hasScrollBarH) {
        this.element.addClass('has-horizontal-scroll');
      }

      if (!hasScrollBarV && this.tableBody[0].offsetHeight < height) {
        this.element.addClass('has-less-rows');
      }

      if (this.hasRightPane) {
        this.element.addClass('has-frozen-right-columns');

        if (utils.getScrollbarWidth() > 0) {
          this.element.addClass('has-visible-scrollbars');
        }
      }
    },


    /**
     * Clear internal header cache info.
     * @private
     * @returns {void}
     */
    clearHeaderCache: function clearHeaderCache() {
      this.headerWidths = [];
      this.totalWidths.left = 0;
      this.totalWidths.center = 0;
      this.totalWidths.right = 0;
      this.totalMinWidths.left = 0;
      this.totalMinWidths.center = 0;
      this.totalMinWidths.right = 0;
      this.elemWidth = 0;
      this.lastColumn = null;
      this.isInitialRender = true;
      this.cacheColumnWidths();
    },


    /**
     * Calculate and cache the width for all the columns
     * Simulates https://www.w3.org/TR/CSS21/tables.html#width-layout
     * @private
     */
    cacheColumnWidths: function cacheColumnWidths() {
      for (var i = 0; i < this.settings.columns.length; i++) {
        var _col2 = this.settings.columns[i];
        this.calculateColumnWidth(_col2, i);
      }
    },


    /**
     * Return the width for a column (upfront with no rendering)
     * Simulates https://www.w3.org/TR/CSS21/tables.html#width-layout
     * @private
     * @param  {[type]} col The column object to use
     * @param  {[type]} index The column index
     * @returns {void}
     */
    columnWidth: function columnWidth(col, index) {
      if (!this.elemWidth) {
        this.elemWidth = this.element.outerWidth();

        if (this.elemWidth === 0) {
          // handle on invisible tab container
          this.elemWidth = this.element.closest('.tab-container').outerWidth();
        }

        this.widthSpecified = false;
      }

      // use cache
      if (this.headerWidths[index]) {
        var cacheWidths = this.headerWidths[index];

        if (cacheWidths.width === 'default' || !cacheWidths.width) {
          return '';
        }
        return ' style="width: ' + cacheWidths.width + (cacheWidths.widthPercent ? '%' : 'px') + '"';
      }
      return this.calculateColumnWidth(col, index);
    },


    /**
     * Calculate the width for a column (upfront with no rendering)
     * Simulates https://www.w3.org/TR/CSS21/tables.html#width-layout
     * @private
     * @param {object} col The column object to use
     * @param {number} index The column index
     * @returns {void}
     */
    calculateColumnWidth: function calculateColumnWidth(col, index) {
      var _this4 = this;

      var colPercWidth = void 0;
      var visibleColumns = this.visibleColumns(true);
      var lastColumn = index === this.lastColumnIdx();
      var container = this.getContainer(col.id);

      if (!this.elemWidth) {
        this.elemWidth = this.element.outerWidth();

        if (this.elemWidth === 0) {
          // handle on invisible tab container
          this.elemWidth = this.element.closest('.tab-container').outerWidth();
        }

        this.widthSpecified = false;
        this.widthPixel = false;
      }

      // use cache
      if (this.headerWidths[index]) {
        var cacheWidths = this.headerWidths[index];

        if (cacheWidths.width === 'default') {
          return '';
        }

        if (this.widthSpecified && !cacheWidths.width) {
          return '';
        }

        return ' style="width: ' + cacheWidths.width + (cacheWidths.widthPercent ? '%' : 'px') + '"';
      }

      // A column element with a value other than 'auto' for the 'width' property
      // sets the width for that column.
      if (col.width) {
        this.widthSpecified = true;
        this.widthPercent = false;
      }

      if (!this.widthPixel && col.width) {
        this.widthPixel = typeof col.width !== 'string';
      }

      var colWidth = col.width;

      if (typeof col.width === 'string' && col.width.indexOf('px') === -1) {
        this.widthPercent = true;
        colPercWidth = col.width.replace('%', '');
      }

      var textWidth = this.calculateTextWidth(col); // reasonable default on error

      if (!this.widthSpecified || !colWidth) {
        colWidth = Math.max(textWidth, colWidth || 0);
      }

      lastColumn = index === this.lastColumnIdx();

      // Simulate Auto Width Algorithm
      if ((!this.widthSpecified || col.width === undefined) && this.settings.sizeColumnsEqually && ['selectionCheckbox', 'expander', 'drilldown', 'rowStatus', 'favorite'].indexOf(col.id) === -1) {
        var percentWidth = Math.round(this.elemWidth / visibleColumns.length);
        colWidth = percentWidth - (lastColumn ? 2 : 0); // borders causing scroll

        // Handle Columns where auto width is bigger than the percent width
        if (percentWidth < textWidth) {
          colWidth = textWidth;
        }
      }

      // Some Built in columns
      if (col.id === 'selectionCheckbox' || col.id === 'favorite') {
        colWidth = 43;
        col.width = colWidth;
      }

      if (col.id === 'favorite') {
        colWidth = 62;
        col.width = colWidth;
      }

      if (col.id === 'expander') {
        colWidth = 55;
        col.width = colWidth;
      }

      if (col.id === 'rowStatus') {
        colWidth = 62;
        col.width = colWidth;
      }

      if (col.id === 'rowReorder') {
        colWidth = 62;
        col.width = colWidth;
      }

      if (col.id === 'drilldown') {
        colWidth = 78;
        col.width = colWidth;
      }

      // cache the header widths
      this.headerWidths[index] = {
        id: col.id,
        width: this.widthPercent ? colPercWidth : colWidth,
        widthPercent: this.widthPercent
      };

      if (col.id !== 'spacerColumn') {
        this.totalWidths[container] += col.hidden ? 0 : colWidth;
      }

      // For the last column stretch it if it doesnt fit the area
      if (lastColumn && this.isInitialRender && !this.settings.spacerColumn) {
        var diff = this.elemWidth - this.totalWidths[container];

        if (this.settings.stretchColumn === 'last' && !this.settings.sizeColumnsEqually) {
          if (diff > 0 && diff > colWidth && !this.widthPercent && !col.width) {
            colWidth = '';
            this.headerWidths[index] = {
              id: col.id,
              width: colWidth,
              widthPercent: this.widthPercent
            };
            this.totalMinWidths[container] = this.totalWidths[container];
            this.totalWidths[container] = '100%';
          }
          if (diff > 0 && diff < colWidth && !this.widthPercent && !col.width) {
            colWidth += diff;
            this.headerWidths[index] = {
              id: col.id,
              width: colWidth,
              widthPercent: this.widthPercent
            };
            this.totalWidths[container] += colWidth;
            this.totalMinWidths[container] = this.totalWidths[container];
          }
        }

        if (this.settings.stretchColumn !== 'last') {
          this.headerWidths[index] = { id: col.id, width: colWidth, widthPercent: this.widthPercent };
          var diff2 = this.elemWidth - this.totalWidths[container];
          var stretchColumn = $.grep(this.headerWidths, function (e) {
            return e.id === _this4.settings.stretchColumn;
          });
          if (diff2 > 0 && !stretchColumn[0].widthPercent) {
            stretchColumn[0].width += diff2 - 2;
          }
          this.totalWidths[container] = '100%';
        }

        if (this.widthPercent) {
          this.table.css('width', '100%');
        } else if (!isNaN(this.totalWidths[container])) {
          this.table.css('width', this.totalWidths.center);
        }
        if (!isNaN(this.totalMinWidths.center) && this.totalMinWidths.center > 0) {
          this.table.css('min-width', this.totalMinWidths.center + 'px');
        }

        if (this.hasLeftPane) {
          this.tableLeft.css('width', this.totalWidths.left);
        }
        if (!isNaN(this.totalMinWidths.left) && this.totalMinWidths.left > 0) {
          this.table.css('min-width', this.totalMinWidths.left + 'px');
        }
        if (this.hasRightPane) {
          this.tableRight.css('width', this.totalWidths.right);
        }
        if (!isNaN(this.totalMinWidths.right) && this.totalMinWidths.right > 0) {
          this.table.css('min-width', this.totalMinWidths.right + 'px');
        }
        this.isInitialRender = false;
      }

      if (lastColumn && this.isInitialRender && this.settings.spacerColumn) {
        var _diff = this.elemWidth - this.totalWidths[container];
        this.totalWidths[container] += _diff;

        if (_diff > 0 && !this.widthPercent && !col.width) {
          this.settings.columns.push({ id: 'spacerColumn', cssClass: 'is-spacer', name: '', field: '', width: _diff - 4 - colWidth });
        }
      }

      if (lastColumn && this.settings.spacerColumn && this.isInitialRender) {
        if (this.widthPercent) {
          this.table.css('width', '100%');
        } else if (!isNaN(this.totalWidths[container])) {
          this.table.css('width', this.totalWidths[container]);
        }
        this.isInitialRender = false;
      }

      if (!this.widthPercent && colWidth === undefined) {
        return '';
      }

      return ' style="width: ' + (this.widthPercent ? colPercWidth + '%' : colWidth + 'px') + '"';
    },


    /**
    * Figure out if the row spans and should skip rendiner.
    * @private
    * @param  {any} value Value to check
    * @param  {number} row Row index
    * @param  {number} col Column index
    * @returns {void}
    */
    calculateRowspan: function calculateRowspan(value, row, col) {
      var total = 0;
      var min = null;

      if (!col.rowspan) {
        return null;
      }

      for (var i = 0; i < this.settings.dataset.length; i++) {
        if (value === this.settings.dataset[i][col.field]) {
          total++;
          if (min === null) {
            min = i;
          }
        }
      }

      return row === min ? ' rowspan ="' + total + '"' : '';
    },


    /**
    * Summary Row Totals use the aggregators
    * @private
    * @returns {number} the total widths
    */
    calculateTotals: function calculateTotals() {
      this.settings.totals = aggregators.aggregate(this.settings.dataset, this.settings.columns);
      return this.settings.totals;
    },


    /**
    * Set unit type (pixel or percent)
    * @private
    * @param  {any} v value to check
    * @returns {number} the total widths
    */
    setUnit: function setUnit(v) {
      return v + (/(px|%)/i.test('' + v) ? '' : 'px');
    },


    /**
     * Setup tooltips on the cells.
     * @private
     * @param  {boolean} rowstatus true set tootip with row status
     * @param  {boolean} isForced true set tootip
     * @returns {void}
     */
    setupTooltips: function setupTooltips(rowstatus, isForced) {
      if (!rowstatus && !isForced && !this.settings.enableTooltips) {
        return;
      }

      var self = this;
      var defaultDelay = 400;
      var tooltipTimer = void 0;

      // Set selector
      var selector = {
        th: '.datagrid-header th',
        td: '.datagrid-body tr.datagrid-row td[role="gridcell"]:not(.rowstatus-cell)',
        rowstatus: '.datagrid-body tr.datagrid-row td[role="gridcell"] .icon-rowstatus'
      };

      if (this.settings.filterable) {
        selector.headerColumn = selector.th + ' .datagrid-column-wrapper';
        selector.headerFilter = selector.th + ' .datagrid-filter-wrapper .btn-menu';
        selector.header = selector.headerColumn + ', ' + selector.headerFilter;
      } else {
        selector.header = selector.th;
      }

      selector.iconAlert = selector.td + ' .icon-alert';
      selector.iconSuccess = selector.td + ' .icon-success';
      selector.iconError = selector.td + ' .icon-error';
      selector.iconInfo = selector.td + ' .icon-info';

      selector.icons = selector.iconAlert + ', ' + selector.iconSuccess + ', ' + selector.iconError + ', ' + selector.iconInfo;

      // Selector string
      if (rowstatus && this.settings.enableTooltips) {
        selector.str = selector.header + ', ' + selector.td + ', ' + selector.icons + ', ' + selector.rowstatus;
      } else if (rowstatus) {
        selector.str = selector.header + ', ' + selector.rowstatus;
      } else {
        selector.str = selector.header + ', ' + selector.td + ', ' + selector.icons;
      }

      // Handle tooltip to show
      var handleShow = function handleShow(elem, delay) {
        delay = typeof delay === 'undefined' ? defaultDelay : delay;
        tooltipTimer = setTimeout(function () {
          var isHeaderColumn = utils.hasClass(elem, 'datagrid-column-wrapper');
          var isHeaderFilter = utils.hasClass(elem.parentNode, 'datagrid-filter-wrapper');
          var isPopup = isHeaderFilter ? elem.parentNode.querySelectorAll('.popupmenu.is-open').length > 0 : false;
          var tooltip = $(elem).data('gridtooltip') || self.cacheTooltip(elem);
          var containerEl = isHeaderColumn ? elem.parentNode : elem;
          var width = self.getOuterWidth(containerEl);

          if (tooltip && (tooltip.forced || tooltip.textwidth > width - 35) && !isPopup) {
            self.showTooltip(tooltip);
          }
        }, delay);
      };

      // Handle tooltip to hide
      var handleHide = function handleHide(elem, delay) {
        delay = typeof delay === 'undefined' ? defaultDelay : delay;
        clearTimeout(tooltipTimer);
        setTimeout(function () {
          self.hideTooltip();
          // Clear cache for header filter, so it can use always current selected
          if (utils.hasClass(elem.parentNode, 'datagrid-filter-wrapper')) {
            self.removeTooltipData(elem);
          }
        }, delay);
      };

      // Bind events
      this.element.off('mouseenter.gridtooltip', selector.str).on('mouseenter.gridtooltip', selector.str, function () {
        handleShow(this);
      }).off('mouseleave.gridtooltip click.gridtooltip', selector.str).on('mouseleave.gridtooltip click.gridtooltip', selector.str, function () {
        handleHide(this);
      }).off('longpress.gridtooltip', selector.str).on('longpress.gridtooltip', selector.str, function () {
        handleShow(this, 0);
      }).off('keydown.gridtooltip', selector.str).on('keydown.gridtooltip', selector.str, function (e) {
        var key = e.which || e.keyCode || e.charCode || 0;
        var handle = false;

        if (e.shiftKey && key === 112) {
          // Shift + F1
          handleShow(this, 0);
        } else if (key === 27) {
          // Escape
          handle = self.isGridtooltip();
          handleHide(this, 0);
        }

        if (handle) {
          e.preventDefault();
        }
        return !handle;
      });
    },


    /**
     * Get outerWidth for a given element.
     * @private
     * @param  {boolean} element to calculate the outerWidth
     * @returns {number} computed outerWidth
     */
    getOuterWidth: function getOuterWidth(element) {
      var style = getComputedStyle(element);
      var width = element.offsetWidth;
      width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
      return width;
    },


    /**
     * Get closest element of a given element by passing callback to
     * target by class, id, or tag name
     * Callback usage as:
     * const elem = this.element[0].querySelector(selectorString);
     * class: const closestEl = this.closest(elem, el => el.classList.contains('some-class'));
     * id: const closestEl = this.closest(elem, el => el.id === 'some-id');
     * tag: const closestEl = this.closest(elem, el => el.tagName.toLowerCase() === 'some-tag');
     * http://clubmate.fi/jquerys-closest-function-and-pure-javascript-alternatives/
     * @private
     * @param  {object} el The element to start from.
     * @param  {object} fn The callback function.
     * @returns {object} The closest element.
     */
    closest: function closest(el, fn) {
      return el && (fn(el) ? el : this.closest(el.parentNode, fn));
    },


    /**
     * Returns all header nodes (not the groups)
     * @private
     * @returns {array} Array with all header dom nodes
     */
    headerNodes: function headerNodes() {
      if (!this.headerContainer) {
        return $();
      }
      return this.headerContainer.find('tr:not(.datagrid-header-groups) th');
    },


    /**
     * Refresh one row in the grid
     * @param  {number} idx The row index to update.
     * @param  {object} data The data object.
     * @returns {void}
     */
    updateRow: function updateRow(idx, data) {
      var s = this.settings;
      var rowData = data;

      if (!rowData) {
        rowData = s.treeGrid ? s.treeDepth[idx].node : s.dataset[idx];
      }

      for (var j = 0; j < this.settings.columns.length; j++) {
        var _col3 = this.settings.columns[j];

        if (_col3.hidden) {
          continue;
        }

        this.updateCellNode(idx, j, this.fieldValue(rowData, _col3.field), true);
      }
    },


    /**
     * Given a new column set update the rows and reload
     * @param  {array} columns The array with columns to use.
     * @param  {array} columnGroups The array with new columns groups to use.
     * @returns {void}
     */
    updateColumns: function updateColumns(columns, columnGroups) {
      this.settings.columns = columns;

      if (columnGroups) {
        this.settings.columnGroups = columnGroups;
      }

      this.rerender();
      this.resetPager('updatecolumns');

      /**
      * Fires after the entire grid is rendered.
      * @event columnchange
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {HTMLElement} args Additional arguments
      * @property {string} args.type Info on the type of column change action, can be 'updatecolumns', 'hidecolumn', 'showcolumn', 'resizecolumn'
      * @property {object} args.columns The columns object
      */
      this.element.trigger('columnchange', [{ type: 'updatecolumns', columns: this.settings.columns }]);
      this.saveColumns();
      this.saveUserSettings();
    },


    /**
     * Save the columns to local storage
     * This method is slated to be removed in a future v4.16.0 or v5.0.0.
     * @deprecated as of v4.10.0. Please use `saveUserSettings()` instead.
     * @returns {void}
     */
    saveColumns: function saveColumns() {
      warnAboutDeprecation(this.saveUserSettings, this.saveColumns);

      if (!this.settings.saveColumns) {
        return;
      }

      // Save to local storage
      if (this.canUseLocalStorage()) {
        localStorage[this.uniqueId('columns')] = JSON.stringify(this.settings.columns);
      }
    },


    /**
     * Omit events and save to local storage for supported settings.
     * @returns {void}
     */
    saveUserSettings: function saveUserSettings() {
      /**
      * Fires after settings are changed in some way
      * @event settingschanged
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.rowHeight The current row height
      * @property {object} args.columns The columns object
      * @property {string} args.sortOrder The current sort column.
      * @property {number} args.pagesize The current page size
      * @property {boolean} args.showPageSizeSelector If the page size selector is shown.
      * @property {number} args.activePage The currently active page.
      * @property {string} args.filter Info on the type of column change action, can be 'updatecolumns'
      */
      this.element.trigger('settingschanged', [{
        rowHeight: this.settings.rowHeight,
        columns: this.settings.columns,
        sortOrder: this.sortColumn,
        pagesize: this.settings.pagesize,
        showPageSizeSelector: this.settings.showPageSizeSelector,
        activePage: this.pagerAPI ? this.pagerAPI.activePage : 1,
        filter: this.filterConditions()
      }]);

      // Save to Local Storage if the settings are set
      var savedSettings = this.settings.saveUserSettings;
      if ($.isEmptyObject(savedSettings) || !this.canUseLocalStorage()) {
        return;
      }

      // Save Columns
      if (savedSettings.columns) {
        localStorage[this.uniqueId('usersettings-columns')] = JSON.stringify(this.settings.columns);
      }

      // Save Row Height
      if (savedSettings.rowHeight) {
        localStorage[this.uniqueId('usersettings-row-height')] = this.settings.rowHeight;
      }

      // Save Sort Order
      if (savedSettings.sortOrder) {
        localStorage[this.uniqueId('usersettings-sort-order')] = JSON.stringify(this.sortColumn);
      }

      // Save Page Size
      if (savedSettings.pagesize) {
        localStorage[this.uniqueId('usersettings-pagesize')] = this.settings.pagesize;
      }

      // Save Show Page Size Selector
      if (savedSettings.showPageSizeSelector) {
        localStorage[this.uniqueId('usersettings-show-pagesize-selector')] = this.settings.showPageSizeSelector;
      }

      // Save Page Num
      if (savedSettings.activePage && this.pagerAPI) {
        localStorage[this.uniqueId('usersettings-active-page')] = this.pagerAPI.activePage;
      }

      // Filter Conditions
      if (savedSettings.filter) {
        localStorage[this.uniqueId('usersettings-filter')] = JSON.stringify(this.filterConditions());
      }
    },


    /**
     * Returns true if local storage may be used / is available
     * @private
     * @returns {boolean} If it can be used.
     */
    canUseLocalStorage: function canUseLocalStorage() {
      try {
        if (localStorage.getItem) {
          return true;
        }
      } catch (exception) {
        return false;
      }

      return false;
    },


    /**
     * Parse a JSON array with columns and return the column object.
     * @private
     * @param  {string} columnStr The json represntation of the column object.
     * @returns {array} The array of columns.
     */
    columnsFromString: function columnsFromString(columnStr) {
      if (!columnStr) {
        return [];
      }

      var self = this;
      var columns = JSON.parse(columnStr);

      if (!columns) {
        return [];
      }

      // Map back the missing functions/objects
      for (var i = 0; i < columns.length; i++) {
        var isHidden = void 0;
        var orgColumn = self.columnById(columns[i].id);

        if (orgColumn) {
          isHidden = columns[i].hidden;

          $.extend(columns[i], orgColumn[0]);

          if (isHidden !== undefined) {
            columns[i].hidden = isHidden;
          }
        }
      }

      return columns;
    },


    /**
    * Restore the columns from a provided list or local storage
    * @param {array} cols - The columns list to restore, if you saved the settings manually.
    */
    restoreColumns: function restoreColumns(cols) {
      if (!this.settings.saveColumns || !this.canUseLocalStorage()) {
        return;
      }

      if (cols) {
        this.updateColumns(cols);
        return;
      }

      // Done on load as apposed to passed in
      var lsCols = localStorage[this.uniqueId('columns')];

      if (!cols && lsCols) {
        this.originalColumns = this.settings.columns;
        this.settings.columns = this.columnsFromString(lsCols);
      }
    },


    /**
     * Restore the user settings from local Storage or as passed in.
     * @param  {object} settings The object containing the settings to use.
     * @returns {void}
     */
    restoreUserSettings: function restoreUserSettings(settings) {
      var options = this.settings.saveUserSettings;

      if (!settings && ($.isEmptyObject(options) || !this.canUseLocalStorage())) {
        return;
      }

      // Restore The data thats passed in
      if (settings) {
        if (settings.columns) {
          this.updateColumns(settings.columns);
        }

        if (settings.rowHeight) {
          this.rowHeight(settings.rowHeight);
        }

        if (settings.sortOrder) {
          this.setSortColumn(settings.sortOrder.sortId, settings.sortOrder.sortAsc);
        }

        if (settings.pagesize) {
          this.settings.pagesize = parseInt(settings.pagesize, 10);
          this.pagerAPI.settings.pagesize = parseInt(settings.pagesize, 10);
          this.pagerAPI.setActivePage(1, true);
        }

        if (settings.showPageSizeSelector) {
          this.settings.showPageSizeSelector = settings.showPageSizeSelector;
          this.pagerAPI.showPageSizeSelector(settings.showPageSizeSelector);
        }

        if (settings.activePage) {
          this.pagerAPI.setActivePage(parseInt(settings.activePage, 10), true);
        }

        if (settings.filter) {
          this.applyFilter(settings.filter, 'restore');
        }
        return;
      }

      // Restore Column Width and Order
      if (options.columns) {
        var savedColumns = localStorage[this.uniqueId('usersettings-columns')];
        if (savedColumns) {
          this.originalColumns = this.settings.columns;
          this.settings.columns = this.columnsFromString(savedColumns);
        }
      }

      // Restore Row Height
      if (options.rowHeight) {
        var savedRowHeight = localStorage[this.uniqueId('usersettings-row-height')];

        if (savedRowHeight) {
          this.settings.rowHeight = savedRowHeight;
        }
      }

      // Restore Sort Order
      if (options.sortOrder) {
        var savedSortOrder = localStorage[this.uniqueId('usersettings-sort-order')];
        if (savedSortOrder) {
          this.sortColumn = JSON.parse(savedSortOrder);
          this.restoreSortOrder = true;
        }
      }

      // Restore Page Size
      if (options.pagesize) {
        var savedPagesize = localStorage[this.uniqueId('usersettings-pagesize')];
        if (savedPagesize) {
          this.settings.pagesize = parseInt(savedPagesize, 10);
        }
      }

      // Restore Show Page Size Selector
      if (options.showPageSizeSelector) {
        var savedShowPageSizeSelector = localStorage[this.uniqueId('usersettings-show-pagesize-selector')];
        savedShowPageSizeSelector = savedShowPageSizeSelector.toString().toLowerCase() === 'true';
        if (savedShowPageSizeSelector) {
          this.settings.showPageSizeSelector = savedShowPageSizeSelector;
        }
      }

      // Restore Active Page
      if (options.activePage) {
        var savedActivePage = localStorage[this.uniqueId('usersettings-active-page')];
        if (savedActivePage) {
          this.savedActivePage = parseInt(savedActivePage, 10);
          this.restoreActivePage = true;
        }
      }

      if (options.filter) {
        var savedFilter = localStorage[this.uniqueId('usersettings-filter')];
        if (savedFilter) {
          this.savedFilter = JSON.parse(savedFilter);
          this.restoreFilter = true;
        }
      }
    },


    /**
    * Reset Columns to defaults (used on restore menu item)
    */
    resetColumns: function resetColumns() {
      if (this.canUseLocalStorage()) {
        localStorage.removeItem(this.uniqueId('columns'));
      }

      if (this.originalColumns) {
        var originalColumns = this.columnsFromString(JSON.stringify(this.originalColumns));
        var columnGroups = this.settings.columnGroups && this.originalColGroups ? this.originalColGroups : null;
        this.updateColumns(originalColumns, columnGroups);
      }

      this.clearFilter();
    },


    /**
    * Hide a column.
    * @param {string} id The id of the column to hide.
    */
    hideColumn: function hideColumn(id) {
      var idx = this.columnIdxById(id);

      if (idx === -1) {
        return;
      }

      this.settings.columns[idx].hidden = true;
      this.headerNodes().eq(idx).addClass('is-hidden');
      this.tableBody.find('> tr > td:nth-child(' + (idx + 1) + ')').addClass('is-hidden');
      this.headerColGroup.find('col').eq(idx).addClass('is-hidden');

      // Shrink or remove colgroups
      this.updateColumnGroup();

      if (this.bodyColGroup) {
        this.bodyColGroup.find('col').eq(idx).addClass('is-hidden');
      }

      // Handle colSpans if present on the column
      if (this.hasColSpans) {
        var colSpan = this.headerContainer.find('th').eq(idx).attr('colspan');

        if (colSpan && colSpan > 0) {
          colSpan -= 1;
          for (var i = 0; i < colSpan; i++) {
            idx += colSpan;
            this.tableBody.find('> tr > td:nth-child(' + (idx + 1) + ')').addClass('is-hidden');
          }
        }
      }

      // Handle expandable rows
      if (this.settings.rowTemplate || this.settings.expandableRow) {
        this.syncExpandableRowColspan();
      }

      this.element.trigger('columnchange', [{ type: 'hidecolumn', index: idx, columns: this.settings.columns }]);
      this.saveColumns();
      this.saveUserSettings();
    },


    /**
    * Sync the colspan on the expandable row. (When column count changes)
    * @private
    */
    syncExpandableRowColspan: function syncExpandableRowColspan() {
      var visibleColumnCount = this.visibleColumns().length;
      this.tableBody.find('.datagrid-expandable-row > td').attr('colspan', visibleColumnCount);
    },


    /**
    * Show a hidden column.
    * @param {string} id The id of the column to show.
    */
    showColumn: function showColumn(id) {
      var idx = this.columnIdxById(id);

      if (idx === -1) {
        return;
      }

      this.settings.columns[idx].hidden = false;
      this.headerNodes().eq(idx).removeClass('is-hidden');
      this.tableBody.find('> tr > td:nth-child(' + (idx + 1) + ')').removeClass('is-hidden');
      this.headerColGroup.find('col').eq(idx).removeClass('is-hidden');

      if (this.bodyColGroup) {
        this.bodyColGroup.find('col').eq(idx).removeClass('is-hidden');
      }

      // Shrink or add colgroups
      this.updateColumnGroup();

      // Handle colSpans if present on the column
      if (this.hasColSpans) {
        var colSpan = this.headerContainer.find('th').eq(idx).attr('colspan');

        if (colSpan && colSpan > 0) {
          colSpan -= 1;
          for (var i = 0; i < colSpan; i++) {
            idx += colSpan;
            this.tableBody.find('> tr > td:nth-child(' + (idx + 1) + ')').removeClass('is-hidden');
          }
        }
      }

      // Handle expandable rows
      if (this.settings.rowTemplate || this.settings.expandableRow) {
        this.syncExpandableRowColspan();
      }

      this.element.trigger('columnchange', [{ type: 'showcolumn', index: idx, columns: this.settings.columns }]);
      this.saveColumns();
      this.saveUserSettings();
    },


    /**
    * Export the grid contents to csv
    * @param {string} fileName The desired export filename in the download.
    * @param {string} customDs An optional customized version of the data to use.
    * @param {string} separator (optional) If user's machine is configured for a locale with alternate default seperator.
    */
    exportToCsv: function exportToCsv(fileName, customDs, separator) {
      excel.exportToCsv(fileName, customDs, separator, this);
    },


    /**
    * Export the grid contents to xls format. This may give a warning when opening the file.
    * exportToCsv may be prefered.
    * Consider Deprecated use excel.exportToExcel
    * @param {string} fileName The desired export filename in the download.
    * @param {string} worksheetName A name to give the excel worksheet tab.
    * @param {string} customDs An optional customized version of the data to use.
    */
    exportToExcel: function exportToExcel(fileName, worksheetName, customDs) {
      excel.exportToExcel(fileName, worksheetName, customDs, this);
    },
    copyToDataSet: function copyToDataSet(pastedValue, rowCount, colIndex, dataSet) {
      excel.copyToDataSet(pastedValue, rowCount, colIndex, dataSet, this);
    },


    /**
    * Open the personalization dialog.
    * @private
    */
    personalizeColumns: function personalizeColumns() {
      var self = this;
      var spanNext = 0;
      var markup = '<div class="listview-search alternate-bg"><label class="audible" for="gridfilter">Search</label><input class="searchfield" placeholder="' + Locale.translate('SearchColumnName') + '" name="searchfield" id="gridfilter"></div>';
      markup += '<div class="listview alternate-bg" id="search-listview"><ul>';

      for (var i = 0; i < this.settings.columns.length; i++) {
        var _col4 = this.settings.columns[i];
        var colName = _col4.name;

        if (colName && spanNext <= 0) {
          colName = colName.replace('<br>', ' ').replace('<br/>', ' ').replace('<br />', ' ');
          markup += '<li><a href="#" target="_self" tabindex="-1"> <label class="inline"><input tabindex="-1" ' + (_col4.hideable === false ? 'disabled' : '') + ' type="checkbox" class="checkbox" ' + (_col4.hidden ? '' : ' checked') + ' data-column-id="' + (_col4.id || i) + '"><span class="label-text">' + colName + '</span></label></a></li>';
        }

        if (spanNext > 0) {
          spanNext--;
        }

        if (_col4.colspan) {
          spanNext = _col4.colspan - 1;
        }
      }
      markup += '</ul></div>';

      $('body').modal({
        title: Locale.translate('PersonalizeColumns'),
        content: markup,
        cssClass: 'full-width datagrid-columns-dialog',
        buttons: [{
          text: Locale.translate('Close'),
          click: function click(e, modal) {
            modal.close();
            $('body').off('open.datagrid');
          }
        }]
      }).on('beforeopen.datagrid', function () {
        self.isColumnsChanged = false;
      }).on('open.datagrid', function (e, modal) {
        modal.element.find('.searchfield').searchfield({ clearable: true });
        modal.element.find('.listview').listview({ searchable: true, selectOnFocus: false }).on('selected', function (selectedEvent, args) {
          var chk = args.elem.find('.checkbox');
          var id = chk.attr('data-column-id');
          var isChecked = chk.prop('checked');

          args.elem.removeClass('is-selected hide-selected-color');

          if (chk.is(':disabled')) {
            return;
          }
          self.isColumnsChanged = true;

          if (!isChecked) {
            self.showColumn(id);
            chk.prop('checked', true);
          } else {
            self.hideColumn(id);
            chk.prop('checked', false);
          }
        });

        modal.element.on('close.datagrid', function () {
          self.isColumnsChanged = false;
        });
        modal.element.on('keydown.datagrid', function (event) {
          // Escape Button Code. Make sure to close the modal correctly.
          if (event.keyCode === 27) {
            modal.close();
            $('body').off('open.datagrid');
          }
        });
      });
    },


    /**
    * Explicitly Set the width of a column
    * @private
    * @param {string} id Specifies if the column info is provide by id or as a node reference.
    * @param {number} width The width of the column
    * @param {number} diff The difference between the old and new width
    */
    setColumnWidth: function setColumnWidth(id, width) {
      var self = this;
      var percent = parseFloat(width);
      var columnSettings = this.columnById(id)[0];
      var idx = -1;

      if (!percent) {
        return;
      }

      if (typeof id === 'string') {
        self.headerNodes().each(function (i) {
          var col = $(this);

          if (col.attr('data-column-id') === id) {
            idx = i;
          }
        });
      }

      // calculate percentage
      if (typeof width !== 'number') {
        width = percent / 100 * self.element.width();
      }

      // Prevent Sub Pixel Thrashing
      if (Math.abs(width - columnSettings.width) < 2) {
        return;
      }

      // Handle Col Span - as the width is calculated on the total
      if (typeof columnSettings.colspan === 'number') {
        width /= columnSettings.colspan;
      }

      // Save the column back in settings for later
      if (columnSettings) {
        columnSettings.width = width;
      }

      this.element.trigger('columnchange', [{ type: 'resizecolumn', index: idx, columns: this.settings.columns }]);
      this.saveColumns();
      this.saveUserSettings();
      this.headerWidths[idx].width = width;
    },


    /**
     * Check if given column header should be able to set active ellipsis
     * @private
     * @param {string} column to check ellipsis
     * @returns {boolean} true if should be able to set ellipsis
     */
    isEllipsisActiveHeader: function isEllipsisActiveHeader(column) {
      column = column || {};
      var isSortable = column.sortable === undefined ? true : column.sortable;
      return isSortable && column.textOverflow === 'ellipsis';
    },


    /**
     * Set active ellipsis on all columns header
     * @private
     * @returns {void}
     */
    activeEllipsisHeaderAll: function activeEllipsisHeaderAll() {
      for (var i = 0, l = this.settings.columns.length; i < l; i++) {
        var id = this.settings.columns[i].id;
        var column = this.columnById(id)[0];
        if (this.isEllipsisActiveHeader(column)) {
          var columnEl = this.headerContainer[0].querySelector('th[data-column-id="' + id + '"]');
          this.activeEllipsisHeader(columnEl);
        }
      }
    },


    /**
     * Set active ellipsis on given column header
     * @private
     * @param {string} columnEl to set ellipsis active
     * @returns {void}
     */
    activeEllipsisHeader: function activeEllipsisHeader(columnEl) {
      if (columnEl) {
        var textEl = columnEl.querySelector('.datagrid-column-wrapper .datagrid-header-text');
        var isEllipsisActive = columnEl.scrollWidth < textEl.scrollWidth + 65; // 65:sort-icons
        columnEl.classList[isEllipsisActive ? 'add' : 'remove']('is-ellipsis-active');
      }
    },


    /**
     * Change the width of the column as the user drags the resizeHandle
     * @private
     * @param {boolean} idOrNode Specifies if the column info is provide by id or as a node reference.
     * @param {number} width The width of the column
     * @param {number} diff The difference between the old and new width
     */
    resizeColumnWidth: function resizeColumnWidth(idOrNode, width, diff) {
      var idx = idOrNode.index();
      this.headerColGroup.find('col').eq(idx)[0].style.width = width + 'px';

      if (this.settings.dataset.length > 0) {
        this.bodyColGroup.find('col').eq(idx)[0].style.width = width + 'px';
      }

      if (this.tableWidth && diff) {
        this.headerTable.css('width', parseInt(this.tableWidth, 10) + diff);
        this.table.css('width', parseInt(this.tableWidth, 10) + diff);
      }
    },


    /**
    * Generate the ui handles used to resize columns.
    * @private
    */
    createResizeHandle: function createResizeHandle() {
      var self = this;
      if (this.resizeHandle) {
        return;
      }

      this.resizeHandle = $('<div class="resize-handle" aria-hidden="true"></div>');
      if (this.settings.columnGroups) {
        this.resizeHandle[0].style.height = '80px';
      }

      if (this.settings.filterable) {
        this.resizeHandle[0].style.height = '62px';
      }

      this.headerContainerCenter.find('table').before(this.resizeHandle);

      var columnId = void 0;
      var startingLeft = void 0;
      var draggingLeft = void 0;
      var columnStartWidth = void 0;
      var column = void 0;

      this.resizeHandle.drag({ axis: 'x', containment: this.element }).on('dragstart.datagrid', function () {
        if (!self.currentHeader) {
          return;
        }

        self.dragging = true;

        columnId = self.currentHeader.attr('data-column-id');
        column = self.columnById(columnId)[0]; // eslint-disable-line

        startingLeft = self.currentHeader.position().left + (self.table.scrollLeft() - 10);
        self.tableWidth = self.table[0].offsetWidth;
        columnStartWidth = self.currentHeader[0].offsetWidth;
        if (self.isEllipsisActiveHeader(column)) {
          self.currentHeader[0].classList.add('is-ellipsis-active');
        }
      }).on('drag.datagrid', function (e, ui) {
        if (!self.currentHeader || !column) {
          return;
        }

        var width = ui.left - startingLeft - 1;
        var minWidth = column.minWidth || 12;
        var maxWidth = column.maxWidth || 1000;

        if (width < minWidth || width > maxWidth) {
          self.resizeHandle.css('cursor', 'inherit');
          return;
        }

        width = Math.round(width);
        draggingLeft = ui.left;
        self.resizeColumnWidth(self.currentHeader, width, width - columnStartWidth);
      }).on('dragend.datagrid', function () {
        var width = draggingLeft - startingLeft - 1;
        self.dragging = false;
        self.setColumnWidth(self.currentHeader.attr('data-column-id'), width);
        if (self.isEllipsisActiveHeader(column)) {
          self.activeEllipsisHeader(self.currentHeader[0]);
        }
      });
    },


    /**
    * Show Summary and any other count info
    * @private
    * @param {boolean} totals The total to display on the UI.
    */
    displayCounts: function displayCounts(totals) {
      var self = this;
      var count = self.tableBody.find('tr:visible').length;
      var isClientSide = self.settings.paging && !self.settings.source;

      if (isClientSide || !totals) {
        this.recordCount = self.settings.dataset.length;
        count = self.settings.dataset.length;
      }

      // Update Selected
      if (self.contextualToolbar && self.contextualToolbar.length) {
        self.contextualToolbar.find('.selection-count').text(self._selectedRows.length + ' ' + Locale.translate('Selected'));
      }

      if (totals && totals !== -1) {
        count = totals;
      }

      if (!totals && this.settings.source) {
        count = this.lastCount;
      }

      var countText = void 0;
      if (self.settings.showFilterTotal && self.filteredCount > 0) {
        countText = '(' + Locale.formatNumber(count - self.filteredCount, { style: 'integer' }) + ' of ' + Locale.formatNumber(count, { style: 'integer' }) + ' ' + Locale.translate(count === 1 ? 'Result' : 'Results') + ')';
      } else {
        countText = '(' + Locale.formatNumber(count, { style: 'integer' }) + ' ' + Locale.translate(count === 1 ? 'Result' : 'Results') + ')';
      }

      if (self.settings.resultsText) {
        if (typeof self.settings.resultsText === 'function') {
          if (self.grandTotal) {
            countText = self.settings.resultsText(self, self.grandTotal, count);
          } else {
            var filteredCount = self.filteredCount === 0 ? 0 : count - self.filteredCount;
            countText = self.settings.resultsText(self, count, filteredCount);
          }
        } else {
          countText = self.settings.resultsText;
        }
      }

      if (self.toolbar) {
        DOM.html(self.toolbar.find('.datagrid-result-count'), countText, '<span>');
        self.toolbar[0].setAttribute('aria-label', self.toolbar.find('.title').text());
        self.toolbar.find('.datagrid-row-count').text(count);
      }
      DOM.html(self.element.closest('.modal').find('.datagrid-result-count'), countText, '<span>');
      this.lastCount = count;

      this.checkEmptyMessage();
    },


    /**
    * Set the content dynamically on the empty message area.
    * @param {object} emptyMessage The update empty message config object.
    */
    setEmptyMessage: function setEmptyMessage(emptyMessage) {
      if (!this.emptyMessage) {
        this.emptyMessageContainer = $('<div>');
        this.bodyContainer.before(this.emptyMessageContainer);
        this.emptyMessage = this.emptyMessageContainer.emptymessage(emptyMessage).data('emptymessage');
        this.checkEmptyMessage();
      } else {
        this.emptyMessage.settings = emptyMessage;
        this.emptyMessage.updated();
      }
    },


    /**
    * See if the empty message object should be shown.
    * @private
    */
    checkEmptyMessage: function checkEmptyMessage() {
      if (this.emptyMessage && this.emptyMessageContainer) {
        if (this.filteredCount === this.recordCount || this.recordCount === 0) {
          this.emptyMessageContainer.show();
          this.element.addClass('is-empty');
        } else {
          this.emptyMessageContainer.hide();
          this.element.removeClass('is-empty');
        }
      }
    },


    /**
    * Trigger event on parent and compose the args
    * @private
    * @param  {strung} eventName Event to trigger
    * @param  {object} e  Actual event
    * @param  {boolean} stopPropagation If stopPropagation should be done
    * @returns {boolean} False when the event should not propagte.
    */
    triggerRowEvent: function triggerRowEvent(eventName, e, stopPropagation) {
      var self = this;
      var cell = $(e.target).closest('td').index();
      var rowElem = $(e.target).closest('tr');
      var row = this.settings.treeGrid ? this.actualRowIndex(rowElem) : this.dataRowIndex(rowElem);
      var isTrigger = true;

      if ($(e.target).is('a')) {
        stopPropagation = false;
      }

      if (stopPropagation) {
        e.stopPropagation();
        e.preventDefault();
      }

      var item = self.settings.dataset[row];

      //  Groupable
      if (this.settings.groupable) {
        if (rowElem.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer')) {
          isTrigger = false; // No need to trigger if no data item
        } else {
          row = self.actualPagingRowIndex(self.actualRowIndex(rowElem));
          item = self.settings.dataset[self.groupArray[row].group];
          if (item && item.values) {
            item = item.values[self.groupArray[row].node];
          }
        }
      }

      if (isTrigger) {
        self.element.trigger(eventName, [{ row: row, cell: cell, item: item, originalEvent: e }]);
      }

      return false;
    },


    /**
     * Sync the containers when scrolling on the y axis.
     * @private
     */
    handleScrollX: function handleScrollX() {
      var left = this.bodyWrapperCenter[0].scrollLeft;

      if (left !== this.scrollLeft && this.headerContainerCenter) {
        this.scrollLeft = left;
        this.headerContainerCenter[0].scrollLeft = this.scrollLeft;
      }
    },


    /**
     * Sync the containers when scrolling on the y axis.
     * @private
     * @param  {jQuery} e The event object
     */
    handleScrollY: function handleScrollY(e) {
      var elem = e.currentTarget;
      var top = elem.scrollTop;

      if (top !== this.scrollTop && this.bodyWrapperCenter && (this.bodyWrapperLeft || this.bodyWrapperRight)) {
        this.scrollTop = top;

        if (this.bodyWrapperLeft) {
          this.bodyWrapperLeft[0].scrollTop = this.scrollTop;
        }
        if (this.bodyWrapperRight) {
          this.bodyWrapperRight[0].scrollTop = this.scrollTop;
        }
        this.bodyWrapperCenter[0].scrollTop = this.scrollTop;
      }
    },


    /**
    * Resize event handler.
    * @private
    */
    rerender: function rerender() {
      this.clearHeaderCache();
      this.renderRows();
      this.renderHeader();
    },


    /**
     * Attach All relevant event handlers.
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this5 = this;

      var self = this;
      var isMultiple = this.settings.selectable === 'multiple';
      var isMixed = this.settings.selectable === 'mixed';

      // Set Focus on rows
      if (!self.settings.cellNavigation && self.settings.rowNavigation) {
        self.bodyContainer.on('focus.datagrid', 'tbody > tr', function () {
          $(this).addClass('is-active-row');
        }).on('blur.datagrid', 'tbody > tr', function () {
          $('tbody > tr', self.table).removeClass('is-active-row');
        });
      }

      // Handle Paging
      if (this.settings.paging) {
        this.element.on('afterpaging.' + COMPONENT_NAME$18, function (e, args) {
          // Hide the entire pager bar if we're only showing one page, if applicable
          if (self.pagerAPI.hidePagerBar(args)) {
            self.element.removeClass('paginated');
          } else {
            self.element.addClass('paginated');
          }

          self.recordCount = args.total;
          self.displayCounts(args.total);

          // Handle row selection across pages
          self.syncSelectedUI();

          if (self.filterExpr && self.filterExpr[0] && self.filterExpr[0].column === 'all') {
            self.highlightSearchRows(self.filterExpr[0].value);
          }
        });

        this.tableBody.on('page.' + COMPONENT_NAME$18, function (e, pagingInfo) {
          self.render(null, pagingInfo);
        }).on('pagesizechange.' + COMPONENT_NAME$18, function (e, pagingInfo) {
          self.render(null, pagingInfo);
        });
      }

      // Handle Hover States
      if (self.settings.showHoverState) {
        self.bodyContainer.off('mouseenter.datagrid, mouseleave.datagrid').on('mouseenter.datagrid', 'tbody > tr', function () {
          var rowNodes = self.rowNodes($(this));
          rowNodes.addClass('is-hover-row');
        }).on('mouseleave.datagrid', 'tbody > tr', function () {
          var rowNodes = self.rowNodes($(this));
          rowNodes.removeClass('is-hover-row');
        });
      }

      // Sync Header and Body During scrolling
      self.bodyContainer.find('.datagrid-body').on('scroll.table', function (e) {
        self.handleScrollY(e);
      });

      if (this.hasLeftPane || this.hasRightPane) {
        self.bodyContainer.find('.datagrid-body').on('wheel.table', function (e) {
          if (e.originalEvent.deltaY !== 0) {
            e.currentTarget.scrollTop += e.originalEvent.deltaY;
            e.preventDefault();
            self.handleScrollY(e);
          }
        });
      }

      self.bodyContainer.find('.datagrid-body.scroll-x').on('scroll.tablex', function (e) {
        self.handleScrollX(e);
      });

      if (this.settings.virtualized) {
        var oldScroll = 0;
        var oldHeight = 0;

        self.bodyWrapperCenter.on('scroll.vtable', debounce(function () {
          var scrollTop = this.scrollTop;
          var buffer = 25;
          var hitBottom = scrollTop > self.virtualRange.bottom - self.virtualRange.bodyHeight - buffer;
          var hitTop = scrollTop < self.virtualRange.top + buffer;

          if (scrollTop !== oldScroll && (hitTop || hitBottom)) {
            oldScroll = this.scrollTop;
            self.renderRows();
          }
        }, 0));

        $('body').on('resize.vtable', function () {
          var height = this.offsetHeight;

          if (height !== oldHeight) {
            oldHeight = this.scrollTop;
            self.renderRows();
          }
        });
      }

      // Handle Sorting
      this.headerContainer.off('click.datagrid-header').on('click.datagrid-header', '.datagrid-header th.is-sortable, .datagrid-header th.btn-filter', function (e) {
        if ($(e.target).parent().is('.datagrid-filter-wrapper') || $(e.target).parent().is('.lookup-wrapper')) {
          return;
        }

        self.setSortColumn($(this).attr('data-column-id'));
      });

      // Prevent redirects
      this.element.off('click.datagrid').on('click.datagrid', 'tbody .datagrid-row a', function (e) {
        var href = e.currentTarget.getAttribute('href');
        if (!href || href === '#') {
          e.preventDefault();
        }
      });

      // Add a paste event for handling pasting from excel
      if (self.settings.editable) {
        this.element.off('paste.datagrid').on('paste.datagrid', function (e) {
          var pastedData = void 0;
          if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
            pastedData = e.originalEvent.clipboardData.getData('text/plain');
          } else {
            pastedData = window.clipboardData && window.clipboardData.getData ? window.clipboardData.getData('Text') : false;
          }

          var hasLineFeed = /\n/.exec(pastedData);
          var hasCarriageReturn = /\r/.exec(pastedData);
          var hasBoth = /\r\n/.exec(pastedData);

          if (self.activeCell && self.activeCell.node.hasClass('is-readonly')) {
            return; // disallow pasting on non editable cells.
          }

          if (pastedData && hasCarriageReturn || hasLineFeed || hasBoth) {
            var splitData = hasLineFeed ? pastedData.split('\n') : pastedData.split('\r');
            if (hasBoth) {
              splitData = pastedData.split('\r\n');
            }

            splitData.pop();

            var startRowCount = parseInt($(e.target)[0].parentElement.parentElement.parentElement.getAttribute('data-index'), 10);
            var startColIndex = parseInt($(e.target)[0].parentElement.parentElement.getAttribute('aria-colindex'), 10) - 1;

            if (self.editor && self.editor.input) {
              self.commitCellEdit(self.editor.input);
            }
            self.copyToDataSet(splitData, startRowCount, startColIndex, self.settings.dataset);
          }
        });
      }

      this.element.off('click.datagrid').on('click.datagrid', 'tbody td', function (e) {
        var rowNode = null;
        var dataRowIdx = null;
        var target = $(e.target);

        if ($(e.currentTarget).parent().hasClass('.datagrid-row-detail')) {
          return;
        }

        if (target.parents('td').length > 1) {
          e.preventDefault(); // stop nested clicks from propagating
          e.stopPropagation();
        }

        /**
        * Fires after a row is clicked.
        * @event click
        * @memberof Datagrid
        * @property {object} event The jquery event object
        * @property {object} args Additional arguments
        * @property {number} args.row The current row height
        * @property {number} args.cell The columns object
        * @property {object} args.item The current sort column.
        * @property {object} args.originalEvent The original event object.
        */
        self.triggerRowEvent('click', e, true);
        self.setActiveCell(target.closest('td'));

        // Dont Expand rows or make cell editable when clicking expand button
        if (target.is('.datagrid-expand-btn')) {
          rowNode = $(this).closest('tr');
          dataRowIdx = self.actualRowIndex(rowNode);

          self.toggleRowDetail(dataRowIdx);
          self.toggleGroupChildren(rowNode);
          self.toggleChildren(e, dataRowIdx);
          return false; //eslint-disable-line
        }

        var isSelectionCheckbox = target.is('.datagrid-selection-checkbox') || target.find('.datagrid-selection-checkbox').length === 1;
        var canSelect = self.settings.clickToSelect ? true : isSelectionCheckbox;

        if (target.is('.datagrid-drilldown')) {
          canSelect = false;
        }

        if (isMixed) {
          canSelect = isSelectionCheckbox;

          // Then Activate
          if (!canSelect) {
            if (e.shiftKey && self.activatedRow().length) {
              self.selectRowsBetweenIndexes([self.activatedRow()[0].row, target.closest('tr').index()]);
              e.preventDefault();
            }

            self.toggleRowActivation(target.closest('tr'));
          }
        }

        if (canSelect && isMultiple && e.shiftKey) {
          self.selectRowsBetweenIndexes([self.lastSelectedRow, target.closest('tr').index()]);
          e.preventDefault();
        } else if (canSelect) {
          self.toggleRowSelection(target.closest('tr'));
        }

        var isEditable = self.makeCellEditable(self.activeCell.rowIndex, self.activeCell.cell, e);

        // Handle Cell Click Event
        var elem = $(this).closest('td');
        var cell = elem.attr('aria-colindex') - 1;
        var col = self.columnSettings(cell);

        if (col.click && typeof col.click === 'function' && target.is('button, input[checkbox], a') || target.parent().is('button')) {
          //eslint-disable-line
          var rowElem = $(this).closest('tr');
          var rowIdx = self.actualRowIndex(rowElem);
          dataRowIdx = self.dataRowIndex(rowElem);
          var item = self.settings.treeGrid ? self.settings.treeDepth[rowIdx].node : self.settings.dataset[dataRowIdx];

          if (elem.hasClass('is-focusable')) {
            if (!target.is(self.buttonSelector)) {
              if (!target.parent('button').is(self.buttonSelector)) {
                return;
              }
            }
          }

          if (self.settings.groupable) {
            if (!rowElem.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer')) {
              rowIdx = self.actualPagingRowIndex(self.actualRowIndex(rowElem));
              item = self.settings.dataset[self.groupArray[rowIdx].group];
              if (item && item.values) {
                item = item.values[self.groupArray[rowIdx].node];
              }
            }
          }

          if (!elem.hasClass('is-cell-readonly') && target.is('button, input[checkbox], a') || target.parent().is('button')) {
            //eslint-disable-line
            col.click(e, [{ row: rowIdx, cell: self.activeCell.cell, item: item, originalEvent: e }]);
          }
        }

        // Handle Context Menu on Some
        if (col.menuId) {
          var btn = $(this).find('button');
          btn.popupmenu({ attachToBody: true, autoFocus: false, mouseFocus: true, menuId: col.menuId, trigger: 'immediate', offset: { y: 5 } });

          if (col.selected) {
            btn.on('selected.datagrid', col.selected);
          }
        }

        // Apply Quick Edit Mode
        if (isEditable) {
          setTimeout(function () {
            if ($('textarea, input', elem).length && !$('.dropdown,' + '[type=file],' + '[type=image],' + '[type=button],' + '[type=submit],' + '[type=reset],' + '[type=checkbox],' + '[type=radio]', elem).length) {
              self.quickEditMode = true;
            }
          }, 0);
        }
      });

      if (this.stretchColumn !== 'last') {
        $(window).on('orientationchange.datagrid', function () {
          _this5.rerender();
        });
      }

      /**
      * Fires after a row is double clicked.
      * @event dblclick
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row The current row height
      * @property {number} args.cell The columns object
      * @property {object} args.item The current sort column.
      * @property {object} args.originalEvent The original event object.
      */
      this.element.off('dblclick.datagrid').on('dblclick.datagrid', 'tbody tr', function (e) {
        self.triggerRowEvent('dblclick', e, true);
      });

      /**
      * Fires after a row has a right click action.
      * @event contextmenu
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row The current row height
      * @property {number} args.cell The columns object
      * @property {object} args.item The current sort column.
      * @property {object} args.originalEvent The original event object.
      */
      this.element.off('contextmenu.datagrid').on('contextmenu.datagrid', 'tbody tr', function (e) {
        if (!self.isSubscribedTo(e, 'contextmenu')) {
          return;
        }

        self.triggerRowEvent('contextmenu', e, !!self.settings.menuId);
        e.preventDefault();

        if (self.settings.menuId && $('#' + self.settings.menuId).length > 0) {
          $(e.currentTarget).popupmenu({
            menuId: self.settings.menuId,
            eventObj: e,
            beforeOpen: self.settings.menuBeforeOpen,
            attachToBody: true,
            trigger: 'immediate'
          }).off('selected').on('selected', function (selectedEvent, args) {
            if (self.settings.menuSelected) {
              self.settings.menuSelected(selectedEvent, args);
            }
          }).off('close').on('close', function () {
            var elem = $(this);
            if (elem.data('popupmenu')) {
              elem.data('popupmenu').destroy();
            }
          });
        }

        return false; // eslint-disable-line
      });

      // Move the drag handle to the end or start of the column
      this.headerRow.off('mousemove.datagrid').on('mousemove.datagrid', 'th', function (e) {
        if (self.dragging) {
          return;
        }

        self.currentHeader = $(e.target).closest('th');

        if (!self.currentHeader.hasClass('is-resizable')) {
          return;
        }

        var headerDetail = self.currentHeader.closest('.header-detail');
        var extraMargin = headerDetail.length ? parseInt(headerDetail.css('margin-left'), 10) : 0;
        var leftEdge = parseInt(self.currentHeader.position().left, 10) - (extraMargin || 0) + self.element.scrollLeft();
        var rightEdge = leftEdge + self.currentHeader.outerWidth();
        var alignToLeft = e.pageX - leftEdge > rightEdge - e.pageX;
        var leftPos = 0;
        leftPos = alignToLeft ? rightEdge - 6 : leftEdge - 6;

        // Ignore First Column
        if (self.currentHeader.index() === 0 && !alignToLeft) {
          leftPos = '-999';
        }

        if (!alignToLeft) {
          self.currentHeader = self.currentHeader.prevAll(':visible').not('.is-hidden').first();
        }

        if (!self.currentHeader.hasClass('is-resizable')) {
          return;
        }

        self.createResizeHandle();
        self.resizeHandle[0].style.left = leftPos + 'px';
        self.resizeHandle[0].style.cursor = '';
      }).off('contextmenu.datagrid').on('contextmenu.datagrid', 'th', function (e) {
        // Add Header Context Menu Support
        e.preventDefault();

        if (self.settings.headerMenuId) {
          $(e.currentTarget).popupmenu({
            menuId: self.settings.headerMenuId,
            eventObj: e,
            attachToBody: true,
            beforeOpen: self.settings.headerMenuBeforeOpen,
            trigger: 'immediate'
          }).off('selected.gridpopup').on('selected.gridpopup', function (selectedEvent, args) {
            self.settings.headerMenuSelected(selectedEvent, args);
          });
        }

        return false;
      });

      // Handle Clicking Header Checkbox
      this.headerContainer.off('click.datagrid-header-select').on('click.datagrid-header-select', 'th .datagrid-checkbox', function () {
        var checkbox = $(this);

        if (!checkbox.hasClass('is-checked')) {
          checkbox.addClass('is-checked').attr('aria-checked', 'true');

          self.selectAllRows();
        } else {
          checkbox.removeClass('is-checked').attr('aria-checked', 'true');
          self.unSelectAllRows();
        }
      });

      // Implement Editing Auto Commit Functionality
      this.element.off('focusout.datagrid').on('focusout.datagrid', 'tbody td input, tbody td textarea, tbody div.dropdown', function (e) {
        // Keep icon clickable in edit mode
        var target = e.target;

        if ($(target).is('input.lookup, input.timepicker, input.datepicker, input.spinbox, input.colorpicker')) {
          // Wait for modal popup, if did not found modal popup means
          // icon was not clicked, then commit cell edit
          setTimeout(function () {
            var focusElem = $('*:focus');

            if (!$('.lookup-modal.is-visible, #timepicker-popup, #monthview-popup, #colorpicker-menu').length && self.editor) {
              if (focusElem.is('.spinbox')) {
                return;
              }

              if (focusElem.is('.trigger')) {
                return;
              }

              if (!$(target).is(':visible')) {
                return;
              }

              if (focusElem && self.editor.className && focusElem.closest(self.editor.className).length > 0) {
                return;
              }

              self.commitCellEdit(self.editor.input);
            }
          }, 150);

          return;
        }

        // Popups are open
        if ($('#dropdown-list, .autocomplete.popupmenu.is-open, #timepicker-popup').is(':visible')) {
          return;
        }

        if (self.editor && self.editor.input) {
          self.commitCellEdit(self.editor.input);
        }
      });
    },


    /**
    * Check if the event is subscribed to.
    * @private
    * @param {object} e The update empty message config object.
    * @param {object} eventName The update empty message config object.
    * @returns {boolean} If the event is subscribed to.
    */
    isSubscribedTo: function isSubscribedTo(e, eventName) {
      var self = this;

      for (var event in $._data(self.element[0]).events) {
        //eslint-disable-line
        if (event === eventName) {
          return true;
        }
      }

      return false;
    },


    /**
    * Refresh the heights based on the rowHeight setting.
    * @private
    */
    refreshSelectedRowHeight: function refreshSelectedRowHeight() {
      var toolbar = this.element.parent().find('.toolbar:not(.contextual-toolbar)');
      var short = toolbar.find('[data-option="row-short"]');
      var med = toolbar.find('[data-option="row-medium"]');
      var normal = toolbar.find('[data-option="row-normal"]');

      if (this.settings.rowHeight === 'short') {
        short.parent().addClass('is-checked');
        med.parent().removeClass('is-checked');
        normal.parent().removeClass('is-checked');
      }

      if (this.settings.rowHeight === 'medium') {
        short.parent().removeClass('is-checked');
        med.parent().addClass('is-checked');
        normal.parent().removeClass('is-checked');
      }

      if (this.settings.rowHeight === 'normal') {
        short.parent().removeClass('is-checked');
        med.parent().removeClass('is-checked');
        normal.parent().addClass('is-checked');
      }

      // Set draggable targets arrow height
      $('.drag-target-arrows', this.element).css('height', this.getTargetHeight() + 'px');
    },


    /**
    * Append all the UI elements for the toolbar above the grid.
    * @private
    */
    appendToolbar: function appendToolbar() {
      var toolbar = null;
      var title = '';
      var more = null;
      var self = this;

      if (!this.settings.toolbar) {
        return;
      }

      // Allow menu to be added manually
      if (this.element.parent().find('.toolbar:not(.contextual-toolbar)').length === 1) {
        toolbar = this.element.parent().find('.toolbar:not(.contextual-toolbar)');
        this.refreshSelectedRowHeight();
      } else {
        toolbar = $('<div class="toolbar" role="toolbar"></div>');
        this.removeToolbarOnDestroy = true;

        if (this.settings.toolbar.title) {
          title = $('<div class="title">' + this.settings.toolbar.title + '  </div>');
        }

        if (!title) {
          title = toolbar.find('.title');
        }
        toolbar.append(title);

        if (this.settings.toolbar.results) {
          // Actually value filled in displayResults
          title.append('<span class="datagrid-result-count"></span>');
        }

        var buttonSet = $('<div class="buttonset"></div>').appendTo(toolbar);

        if (this.settings.toolbar.keywordFilter) {
          var labelMarkup = $('<label class="audible" for="gridfilter">' + Locale.translate('Keyword') + '</label>');
          var searchfieldMarkup = $('<input class="searchfield" name="searchfield" placeholder="' + Locale.translate('Keyword') + '" id="gridfilter">');

          buttonSet.append(labelMarkup);

          if (!this.settings.toolbar.collapsibleFilter) {
            searchfieldMarkup.attr('data-options', '{ "collapsible": false }');
          }

          buttonSet.append(searchfieldMarkup);
        }

        if (this.settings.toolbar.dateFilter) {
          buttonSet.append('<button class="btn" type="button">' + $.createIcon({ icon: 'calendar' }) + '<span>' + Locale.translate('Date') + '</span></button>');
        }

        if (this.settings.toolbar.actions) {
          more = $('<div class="more"></div>').insertAfter(buttonSet);
          more.append('<button class="btn-actions" title="More" type="button">' + $.createIcon({ icon: 'more' }) + '<span class="audible">Grid Features</span></button>');
          toolbar.addClass('has-more-button');
        }

        var menu = $('<ul class="popupmenu"></ul>');

        if (this.settings.toolbar.personalize) {
          menu.append('<li><a href="#" data-option="personalize-columns">' + Locale.translate('PersonalizeColumns') + '</a></li>');
        }

        if (this.settings.toolbar.resetLayout) {
          menu.append('<li><a href="#" data-option="reset-layout">' + Locale.translate('ResetDefault') + '</a></li>');
        }

        if (this.settings.toolbar.exportToExcel) {
          menu.append('<li><a href="#" data-option="export-to-excel">' + Locale.translate('ExportToExcel') + '</a></li>');
        }

        if (this.settings.toolbar.advancedFilter) {
          menu.append('<li><a href="#">' + Locale.translate('AdvancedFilter') + '</a></li>');
        }

        if (this.settings.toolbar.views) {
          menu.append('<li><a href="#">' + Locale.translate('SaveCurrentView') + '</a></li> ' + '<li class="separator"></li> ' + ('<li class="heading">' + Locale.translate('SavedViews') + '</li>') + '<li><a href="#">View One</a></li>');
        }

        if (this.settings.toolbar.rowHeight) {
          menu.append('' + ('<li class="separator single-selectable-section"></li>' + '<li class="heading">') + Locale.translate('RowHeight') + '</li>' + ('<li class="is-selectable' + (this.settings.rowHeight === 'short' ? ' is-checked' : '') + '"><a data-option="row-short">' + Locale.translate('Short') + '</a></li>') + ('<li class="is-selectable' + (this.settings.rowHeight === 'medium' ? ' is-checked' : '') + '"><a data-option="row-medium">' + Locale.translate('Medium') + '</a></li>') + ('<li class="is-selectable' + (this.settings.rowHeight === 'normal' ? ' is-checked' : '') + '"><a data-option="row-normal">' + Locale.translate('Normal') + '</a></li>'));
        }

        if (this.settings.toolbar.filterRow) {
          menu.append('' + ('<li class="separator"></li>' + '<li class="heading">') + Locale.translate('Filter') + '</li>' + ('<li class="' + (this.settings.filterable ? 'is-checked ' : '') + 'is-toggleable"><a data-option="show-filter-row">' + Locale.translate('ShowFilterRow') + '</a></li>') + ('<li class="is-indented"><a data-option="run-filter">' + Locale.translate('RunFilter') + '</a></li>') + ('<li class="is-indented"><a data-option="clear-filter">' + Locale.translate('ClearFilter') + '</a></li>'));
        }

        if (this.settings.toolbar.actions) {
          more.append(menu);
        }

        if (this.element.prev().is('.contextual-toolbar')) {
          this.element.prev().before(toolbar);
        } else {
          this.element.before(toolbar);
        }
      }

      toolbar.find('.btn-actions').popupmenu().on('selected', function (e, args) {
        var action = args.attr('data-option');
        if (action === 'row-short' || action === 'row-medium' || action === 'row-normal') {
          self.rowHeight(action.substr(4));
        }

        if (action === 'personalize-columns') {
          self.personalizeColumns();
        }

        if (action === 'reset-layout') {
          self.resetColumns();
        }

        if (action === 'export-to-excel') {
          // self.exportToExcel();
          self.exportToCsv();
        }

        // Filter actions
        if (action === 'show-filter-row') {
          self.toggleFilterRow();
        }
        if (action === 'run-filter') {
          self.applyFilter(null, 'menu');
        }
        if (action === 'clear-filter') {
          self.clearFilter();
        }
      });

      if (this.settings.initializeToolbar && !toolbar.data('toolbar')) {
        var opts = $.fn.parseOptions(toolbar);

        if (this.settings.toolbar.fullWidth) {
          opts.rightAligned = true;
        }

        toolbar.toolbar(opts);
      }

      if (this.settings.toolbar && this.settings.toolbar.keywordFilter) {
        var thisSearch = toolbar.find('.searchfield');
        var xIcon = thisSearch.parent().find('.close.icon');

        thisSearch.off('keypress.datagrid').on('keypress.datagrid', function (e) {
          if (e.keyCode === 13 || e.type === 'change') {
            e.preventDefault();
            self.keywordSearch(thisSearch.val());
          }
        });

        xIcon.off('click.datagrid').on('click.datagrid', function () {
          self.keywordSearch(thisSearch.val());
        });
      }

      if (this.settings.toolbar && this.settings.toolbar.contextualToolbar) {
        var contextualToolbar = '\n        <div class="contextual-toolbar datagrid-contextual-toolbar toolbar is-hidden">\n          <div class="title selection-count">1 Selected</div>\n        </div>';

        this.element.before(contextualToolbar);
        this.contextualToolbar = this.element.prev('.contextual-toolbar');
      }

      this.toolbar = toolbar;
      this.element.addClass('has-toolbar');
    },


    /**
     * Get or Set the Row Height.
     * @param  {string} height The row height to use, can be 'short', 'normal' or 'medium'
     * @Returns {string} The current row height
     */
    rowHeight: function rowHeight(height) {
      if (height) {
        this.settings.rowHeight = height;
      }

      this.element.add(this.table).add(this.tableLeft).add(this.tableRight).removeClass('short-rowheight medium-rowheight normal-rowheight').addClass(this.settings.rowHeight + '-rowheight');

      if (this.virtualRange && this.virtualRange.rowHeight) {
        this.virtualRange.rowHeight = height === 'normal' ? 40 : height === 'medium' ? 30 : 25;
      }

      this.saveUserSettings();
      this.refreshSelectedRowHeight();
      return this.settings.rowHeight;
    },


    /**
    * Search a Term across all columns
    * @param  {string} term The term to search for.
    */
    keywordSearch: function keywordSearch(term) {
      this.bodyContainer.find('tr[role="row"]').removeClass('is-filtered').show();
      this.filterExpr = [];

      this.bodyContainer.find('.datagrid-expandable-row').each(function () {
        var row = $(this);
        // Collapse All rows
        row.prev().find('.datagrid-expand-btn').removeClass('is-expanded');
        row.prev().find('.plus-minus').removeClass('active');
        row.removeClass('is-expanded').css('display', '');
        row.find('.datagrid-row-detail').css('height', '');
      });

      this.bodyContainer.find('.search-mode').each(function () {
        var cell = $(this);
        var text = cell.text();
        cell.text(text.replace('<i>', '').replace('</i>', ''));
      });

      term = (term || '').toLowerCase();
      this.filterExpr.push({ column: 'all', operator: 'contains', value: term, keywordSearch: true });

      this.filterKeywordSearch();
      this.renderRows();
      this.setSearchActivePage({ trigger: 'searched' });

      if (!this.settings.paging) {
        this.highlightSearchRows(term);
      }
    },


    /**
     * Sets optional filtering conditions on the pager during changes
     * in searching/filtering of datagrid rows
     * @private
     * @param {object} pagingInfo incoming paging state information
     * @returns {void}
     */
    setSearchActivePage: function setSearchActivePage(pagingInfo) {
      if (!this.pagerAPI) {
        return;
      }

      var self = this;
      if (!pagingInfo) {
        pagingInfo = {};
      }

      function reset(obj) {
        obj.activePage = 1;
        if (self.grandTotal) {
          obj.grandTotal = self.grandTotal;
        }
        return obj;
      }

      if (this.filterExpr && this.filterExpr.length === 1) {
        if (this.filterExpr[0].value !== '') {
          pagingInfo.activePage = this.pagerAPI.filteredActivePage || 1;
        } else if (this.filterExpr[0].value === '' && this.pagerAPI.filteredActivePage) {
          pagingInfo = reset(pagingInfo);
        }
      } else {
        pagingInfo = reset(pagingInfo);
      }

      this.renderPager(pagingInfo);
    },


    /**
     * Filter to keyword search.
     * @private
     */
    filterKeywordSearch: function filterKeywordSearch() {
      var self = this;
      var dataset = void 0;
      var isFiltered = void 0;
      var i = void 0;
      var len = void 0;
      var filterExpr = self.filterExpr;

      var checkRow = function checkRow(data, row) {
        var isMatch = false;

        var checkColumn = function checkColumn(columnId) {
          var column = self.columnById(columnId)[0];
          var fieldValue = self.fieldValue(data, column.field);
          var value = void 0;
          var cell = self.settings.columns.indexOf(column);

          // Use the formatted value (what the user sees in the cells)
          // since it's a more reliable match
          value = self.formatValue(column.formatter, row, cell, fieldValue, column, data, self);
          value = value.toLowerCase();

          // Strip any html markup that might be in the formatted value
          value = value.replace(/(<([^>]+)>)|(amp;)|(&lt;([^>]+)&gt;)/ig, '');

          return value.indexOf(filterExpr.value) > -1;
        };

        // Check in all visible columns
        if (filterExpr.column === 'all') {
          self.headerContainer.find('th:visible').each(function () {
            //eslint-disable-line
            var th = $(this);
            var columnId = th.attr('data-column-id');

            isMatch = checkColumn(columnId);
            if (isMatch) {
              return false;
            }
          });
        } else if (filterExpr.columnId) {
          // Check in only one column, given by columnId
          isMatch = checkColumn(filterExpr.columnId);
        }
        return isMatch;
      };

      // Make sure not more/less than one filter expr
      if (!filterExpr || filterExpr.length !== 1) {
        return;
      }
      filterExpr = filterExpr[0];

      // Check in dataset
      if (self.settings.treeGrid) {
        dataset = self.settings.treeDepth;
        for (i = 0, len = dataset.length; i < len; i++) {
          isFiltered = filterExpr.value === '' ? false : !checkRow(dataset[i].node, i);
          dataset[i].node.isFiltered = isFiltered;
        }
      } else {
        dataset = self.settings.dataset;
        for (i = 0, len = dataset.length; i < len; i++) {
          isFiltered = filterExpr.value === '' ? false : !checkRow(dataset[i], i);
          dataset[i].isFiltered = isFiltered;
        }
      }
    },


    /**
     * Highlight the term in the grid.
     * @private
     * @param  {string} term The term to highlight
     * @returns {void}
     */
    highlightSearchRows: function highlightSearchRows(term) {
      var _this6 = this;

      var self = this;

      if (!term || term === '') {
        return;
      }

      var findInRows = function findInRows(rowNodes) {
        var found = false;
        rowNodes.toArray().forEach(function (row) {
          [].slice.call(row.querySelectorAll('td')).forEach(function (cell) {
            var cellText = cell.innerText.toLowerCase();
            var isSearchExpandableRow = self.settings.searchExpandableRow ? true : !DOM.hasClass(_this6, 'datagrid-expandable-row');

            if (cellText.indexOf(term) > -1 && isSearchExpandableRow) {
              found = true;
              [].slice.call(cell.querySelectorAll('*')).forEach(function (node) {
                if (xssUtils.unescapeHTML(node.innerHTML) === node.textContent) {
                  var contents = node.textContent;
                  var exp = new RegExp('(' + stringUtils.escapeRegExp(term) + ')', 'gi');

                  DOM.addClass(node, 'search-mode');
                  DOM.html(node, contents.replace(exp, '<i>$1</i>'));
                }
              });
            }
          });
        });
        return found;
      };

      // Move across all visible cells and rows, highlighting
      var visibleRows = self.tableBody.find('tr');
      visibleRows.toArray().forEach(function (row) {
        var rowContainers = self.rowNodes(row.getAttribute('aria-rowindex') - 1);
        var found = findInRows(rowContainers);

        // Hide non matching rows and non detail rows
        if (!found && !rowContainers.find('.datagrid-row-detail').length) {
          rowContainers.addClass('is-filtered').hide();
        } else if (self.settings.searchExpandableRow && found && rowContainers.is('.datagrid-expandable-row') && term !== '') {
          rowContainers.prev().show();
          rowContainers.prev().find('.datagrid-expand-btn').addClass('is-expanded');
          rowContainers.prev().find('.plus-minus').addClass('active');
          rowContainers.addClass('is-expanded').css('display', 'table-row');
          rowContainers.find('.datagrid-row-detail').css('height', 'auto');
        }
      });
    },


    /**
    * Select all rows. If serverside paging, this will be only the current page.
    * For client side paging, all rows across all pages are selected.
    */
    selectAllRows: function selectAllRows() {
      var rows = [];
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;

      for (var i = 0, l = dataset.length; i < l; i++) {
        var idx = this.pagingRowIndex(i);
        if (this.filterRowRendered || this.filterExpr && this.filterExpr[0] && this.filterExpr[0].keywordSearch) {
          if (!dataset[i].isFiltered) {
            rows.push(idx);
          }
        } else {
          rows.push(idx);
        }
      }

      this.dontSyncUi = true;
      this.selectRows(rows, true, true);
      this.dontSyncUi = false;
      this.syncSelectedUI();

      /**
      * Fires after a row is selected.
      * @event contextmenu
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {array} args.selectedRows An array of selected rows.
      * @property {string} args.trigger The action can be 'selectall', 'deselectall', 'select', 'deselect'
      * @property {object} args.item The current sort column.
      * @property {object} args.originalEvent The original event object.
      */
      this.element.triggerHandler('selected', [this._selectedRows, 'selectall']);
    },


    /**
    * Deselect all rows that are currently selected.
    */
    unSelectAllRows: function unSelectAllRows() {
      this.dontSyncUi = true;

      for (var i = this._selectedRows.length - 1; i >= 0; i--) {
        var idx = this.pagingRowIndex(this._selectedRows[i].idx);
        this.unselectRow(idx, true, true);
      }
      this.dontSyncUi = false;
      this.syncSelectedUI();
      this.element.triggerHandler('selected', [this._selectedRows, 'deselectall']);
    },


    /**
    * Check if node index is exists in selected nodes
    * @private
    * @param {object} row The row to compare.
    * @returns {boolean} If its selected or not.
    */
    isRowSelected: function isRowSelected(row) {
      // As of 4.3.3, return the rows that have _selected = true
      return row ? row._selected === true : false;
    },


    /**
     * Select a row node on the UI
     * @private
     * @param {object} elem The row node to select
     * @param {number} index The row index to select
     * @param {object} data The object attached to the row
     * @param {boolean} force Dont check if already selected
     * @returns {void}
     */
    selectNode: function selectNode(elem, index, data, force) {
      var checkbox = null;
      var self = this;
      var selectClasses = 'is-selected' + (self.settings.selectable === 'mixed' ? ' hide-selected-color' : '');

      // do not add if already exists in selected
      if ((!data || self.isRowSelected(data)) && !force) {
        return;
      }

      checkbox = elem.find('.datagrid-selection-checkbox').closest('td');
      elem.addClass(selectClasses).attr('aria-selected', 'true');

      if (self.columnIdxById('selectionCheckbox') !== -1) {
        checkbox = self.cellNode(elem, self.columnIdxById('selectionCheckbox'));
        checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked').attr('aria-checked', 'true');
      }

      if (data) {
        data._selected = true;
      }
    },


    /**
     * Toggle selection on a single row
     * @param {number} idx The row index to select
     * @param {boolean} nosync Do sync the header
     * @param {boolean} noTrigger Do not trigger events.
     * @returns {void}
     */
    selectRow: function selectRow(idx, nosync, noTrigger) {
      var rowNode = null;
      var dataRowIndex = void 0;
      var self = this;
      var s = this.settings;

      if (idx === undefined || idx === -1 || !s.selectable) {
        return;
      }

      rowNode = this.rowNodes(idx);
      dataRowIndex = this.dataRowIndex(rowNode);

      if (isNaN(dataRowIndex)) {
        dataRowIndex = idx;
      }

      if (!rowNode || !rowNode.length && s.source) {
        return;
      }

      if (s.selectable === 'single') {
        var selectedIndex = -1;
        if (this._selectedRows.length > 0) {
          selectedIndex = this._selectedRows[0].idx;
        } else if (rowNode[0] && rowNode[0].classList.contains('is-selected')) {
          selectedIndex = dataRowIndex;
        }
        if (selectedIndex !== -1) {
          this.unselectRow(selectedIndex, true, true);
        }
      }

      if (!rowNode.hasClass('is-selected')) {
        var rowData = void 0;

        if (s.treeGrid) {
          if (rowNode.is('.datagrid-tree-parent') && s.selectable === 'multiple') {
            // Select node and node-children
            rowNode.add(rowNode.nextUntil('[aria-level="1"]')).each(function (i) {
              var elem = $(this);
              var index = elem.attr('aria-rowindex') - 1;
              var data = s.treeDepth[index].node;

              // Allow select node if selectChildren is true or only first node
              // if selectChildren is false
              if (s.selectChildren || !s.selectChildren && i === 0) {
                self.selectNode(elem, index, data);
              }
            });
          } else if (s.selectable === 'siblings') {
            this.unSelectAllRows();

            // Select node and node-siblings
            var level = rowNode.attr('aria-level');
            var nexts = rowNode.nextUntil('[aria-level!="' + level + '"]');
            var prevs = rowNode.prevUntil('[aria-level!="' + level + '"]');

            if (level === '1') {
              nexts = rowNode.parent().find('[aria-level="1"]');
              prevs = null;
            }

            rowNode.add(nexts).add(prevs).each(function (i) {
              var elem = $(this);
              var index = elem.attr('aria-rowindex') - 1;
              var data = s.treeDepth[index].node;

              // Allow select node if selectChildren is true or only first node
              // if selectChildren is false
              if (s.selectChildren || !s.selectChildren && i === 0) {
                self.selectNode(elem, index, data);
              }
            });
          } else {
            // Default to Single element selection
            rowData = s.treeDepth[self.pagerAPI && s.source ? rowNode.index() : idx].node;
            self.selectNode(rowNode, idx, rowData);
          }
          self.setNodeStatus(rowNode);
        } else {
          rowData = s.dataset[dataRowIndex];
          if (s.groupable) {
            var row = self.actualPagingRowIndex(self.actualRowIndex(rowNode));
            if (isNaN(row)) {
              return;
            }
            var gData = self.groupArray[row];
            rowData = self.settings.dataset[gData.group].values[gData.node];
            dataRowIndex = self.actualPagingRowIndex(idx);
            this._selectedRows.push({
              idx: dataRowIndex,
              data: rowData,
              elem: rowNode,
              group: s.dataset[self.groupArray[row].group]
            });
          }
          self.selectNode(rowNode, dataRowIndex, rowData);
          self.lastSelectedRow = idx; // Rememeber index to use shift key
        }

        // Append data to selectedRows
        if (!s.groupable) {
          var actualIdx = self.actualPagingRowIndex(idx);
          if (actualIdx === -1) {
            actualIdx = idx;
          }

          this._selectedRows.push({
            idx: actualIdx,
            data: rowData,
            elem: self.visualRowNode(actualIdx),
            page: this.pagerAPI ? this.pagerAPI.activePage : 1,
            pagingIdx: idx,
            pagesize: this.settings.pagesize
          });
        }
      }

      if (!nosync) {
        self.syncSelectedUI();
      }

      if (!noTrigger) {
        this.element.triggerHandler('selected', [this._selectedRows, 'select']);
      }
    },


    /**
    * Select rows between indexes
    * @private
    * @param  {array} indexes The ranges to select.
    * @returns {void}
    */
    selectRowsBetweenIndexes: function selectRowsBetweenIndexes(indexes) {
      indexes.sort(function (a, b) {
        return a - b;
      });
      for (var i = indexes[0]; i <= indexes[1]; i++) {
        this.selectRow(i);
      }

      this.displayCounts();
    },


    /**
    * Set the checkbox on the header based on selections.
    * @private
    * @param  {array} rows The rows to select.
    * @returns {void}
    */
    syncHeaderCheckbox: function syncHeaderCheckbox(rows) {
      if (this.headerNodes().length === 0) {
        return;
      }

      var headerCheckbox = this.headerNodes().find('.datagrid-checkbox');
      var rowsLength = rows.length;
      var selectedRowsLength = this._selectedRows.length;
      var status = headerCheckbox.data('selected');

      // Do not run if checkbox in same state
      if (selectedRowsLength !== rowsLength && selectedRowsLength > 0 && status === 'partial' || selectedRowsLength === rowsLength && status === 'all' && selectedRowsLength !== 0 || selectedRowsLength === 0 && status === 'none') {
        return;
      }

      // Sync the header checkbox
      if (selectedRowsLength > 0) {
        headerCheckbox.data('selected', 'partial').addClass('is-checked is-partial');
      }

      if (selectedRowsLength === rowsLength) {
        headerCheckbox.data('selected', 'all').addClass('is-checked').removeClass('is-partial');
      }

      if (selectedRowsLength === 0) {
        headerCheckbox.data('selected', 'none').removeClass('is-checked is-partial');
      }
    },


    /**
     * Mark selected rows on the page as selected
     * @private
     * @returns {void}
     */
    syncSelectedRows: function syncSelectedRows() {
      var idx = null;

      for (var i = 0; i < this._selectedRows.length; i++) {
        if (this.pagerAPI && this._selectedRows[i].page === this.pagerAPI.activePage) {
          idx = this._selectedRows[i].idx;
          this.selectNode(this.visualRowNode(idx), idx, this.settings.dataset[idx], true);
        }
        // Check for rows that changed page
        idx = this._selectedRows[i].pagingIdx;
        if (this._selectedRows[i].pagesize !== this.settings.pagesize && this.settings.dataset[idx]) {
          this.selectNode(this.visualRowNode(idx), idx, this.settings.dataset[idx], true);
          this._selectedRows[i].pagesize = this.settings.pagesize;
          this._selectedRows[i].idx = idx;
          this._selectedRows[i].page = this.pagerAPI.activePage;
        }

        if (this._selectedRows[i].pagesize !== this.settings.pagesize && !this.settings.dataset[idx]) {
          this._selectedRows[i].idx = idx % this.settings.pagesize;
          this._selectedRows[i].page = Math.round(idx / this.settings.pagesize) + 1;
          this._selectedRows[i].pagesize = this.settings.pagesize;
        }
      }
    },


    /**
     * Run throught the array and remark the idx's after a row reorder.
     * @private
     * @returns {void}
     */
    syncSelectedRowsIdx: function syncSelectedRowsIdx() {
      if (this._selectedRows.length === 0 || this.settings.dataset.length === 0) {
        return;
      }
      this._selectedRows = [];

      for (var i = 0; i < this.settings.dataset.length; i++) {
        if (this.settings.dataset[i]._selected) {
          this._selectedRows.push({
            idx: i,
            data: this.settings.dataset[i],
            elem: this.dataRowNode(i),
            page: this.pagerAPI ? this.pagerAPI.activePage : 1,
            pagingIdx: i,
            pagesize: this.settings.pagesize
          });
        }
      }
    },


    /**
     * Set ui elements based on selected rows
     * @private
     * @returns {void}
     */
    syncSelectedUI: function syncSelectedUI() {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var rows = dataset;

      if (this.settings.groupable) {
        rows = [];
        for (var i = 0, l = dataset.length; i < l; i++) {
          if (dataset[i].values) {
            for (var i2 = 0, l2 = dataset[i].values.length; i2 < l2; i2++) {
              rows.push(i2);
            }
          }
        }
      }

      if (this.filterRowRendered) {
        rows = [];
        for (var _i7 = 0, _l = dataset.length; _i7 < _l; _i7++) {
          if (!dataset[_i7].isFiltered) {
            rows.push(_i7);
          }
        }
      }

      this.syncHeaderCheckbox(rows);

      // Open or Close the Contextual Toolbar.
      if (this.contextualToolbar.length !== 1 || this.dontSyncUi) {
        return;
      }

      if (this._selectedRows.length === 0) {
        this.contextualToolbar.animateClosed();
      }

      if (this._selectedRows.length > 0 && this.contextualToolbar.height() === 0) {
        this.contextualToolbar.css('display', 'block').one('animateopencomplete.datagrid', function () {
          $(this).triggerHandler('recalculate-buttons');
        }).animateOpen();
      }
    },


    /**
     * Activate a row when in mixed selection mode
     * @param  {number} idx The index.
     */
    activateRow: function activateRow(idx) {
      if (this.activatedRow()[0].row !== idx) {
        this.toggleRowActivation(idx);
      }
    },


    /**
    * Deactivate the currently activated row.
    */
    deactivateRow: function deactivateRow() {
      var idx = this.activatedRow()[0].row;
      if (idx >= 0) {
        this.toggleRowActivation(idx);
      }
    },


    /**
    * Gets the currently activated row.
    * @returns {object} Information about the activated row.
    */
    activatedRow: function activatedRow() {
      var r = [{ row: -1, item: undefined, elem: undefined }];

      if (this.tableBody) {
        var s = this.settings;
        var dataset = s.treeGrid ? s.treeDepth : s.dataset;
        var activatedRow = this.tableBody.find('tr.is-rowactivated');

        if (activatedRow.length) {
          var dataRowIndex = this.dataRowIndex(activatedRow);
          var rowIndex = s.indeterminate ? dataRowIndex : this.actualRowIndex(activatedRow);
          r = [{ row: rowIndex, item: dataset[rowIndex], elem: activatedRow }];
        } else {
          r = null;
          // Activated row may be filtered or on another page, so check all until find it
          for (var i = 0; i < dataset.length; i++) {
            if (dataset[i]._rowactivated) {
              r = [{ row: i, item: dataset[i], elem: undefined }];
              break;
            }
          }

          if (r === null) {
            r = [{ row: -1, item: undefined, elem: activatedRow }];
          }
        }
      }
      return r;
    },


    /**
    * Toggle the current activation state from on to off.
    * @param  {number} idx The row to toggle
    * @returns {void}
    */
    toggleRowActivation: function toggleRowActivation(idx) {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var row = void 0;
      var rowJq = void 0;
      var rowIndex = void 0;

      if (typeof idx === 'number') {
        row = this.tableBody[0].querySelector('tr[aria-rowindex="' + (idx + 1) + '"]');
        rowIndex = idx;

        if (this.pagerAPI && s.source && s.indeterminate) {
          var rowIdx = idx + (this.pagerAPI.activePage - 1) * s.pagesize;
          row = this.tableBody[0].querySelector('tr[aria-rowindex="' + (rowIdx + 1) + '"]');
        }
      } else {
        rowJq = idx instanceof jQuery ? idx : $(idx);
        row = rowJq[0];
        rowIndex = s.treeGrid || s.groupable ? this.actualRowIndex(rowJq) : this.dataRowIndex(rowJq);
      }

      if (s.indeterminate && !row) {
        rowJq = this.actualRowNode(rowIndex);
        row = rowJq[0];
      }

      var isActivated = dataset[rowIndex] ? dataset[rowIndex]._rowactivated : false;

      // Toggle it
      if (isActivated) {
        this.deactivateRowNode(rowIndex, dataset);
      } else {
        this.deactivateAllRowNodes(dataset);
        this.activateAllRowNodes(rowIndex, dataset);
      }
    },


    /**
     * Activate given row with mixed selection mode.
     * @private
     * @param  {number} idx The row index to activated
     * @param  {object} dataset Optional data to use
     * @returns {void}
     */
    activateAllRowNodes: function activateAllRowNodes(idx, dataset) {
      var _this7 = this;

      if (typeof idx !== 'number' || idx < 0) {
        return;
      }
      var s = this.settings;

      if (typeof dataset === 'undefined') {
        dataset = s.treeGrid ? s.treeDepth : s.dataset;
      }

      var args = [{ row: idx, item: dataset[idx] }];

      var doRowactivated = function doRowactivated() {
        var rowNodes = _this7.rowNodes(idx).toArray();
        rowNodes.forEach(function (rowElem) {
          rowElem.classList.add('is-rowactivated');
        });
        dataset[idx]._rowactivated = true;
        args = [{ row: idx, item: dataset[idx] }];

        /**
         * Fires after a row is activated in mixed selection mode.
         * @event rowactivated
         * @memberof Datagrid
         * @property {object} event The jquery event object
         * @property {object} args Additional arguments
         * @property {array} args.row An array of selected rows.
         * @property {object} args.item The current sort column.
         */
        _this7.element.triggerHandler('rowactivated', args);
      };

      if (dataset[idx]) {
        $.when(this.element.triggerHandler('beforerowactivated', args)).done(function (response) {
          var isFalse = function isFalse(v) {
            return typeof v === 'string' && v.toLowerCase() === 'false' || typeof v === 'boolean' && v === false || typeof v === 'number' && v === 0;
          };
          if (!isFalse(response)) {
            doRowactivated();
          }
        });
      }
    },


    /**
    * Deactivate given row with mixed selection mode.
    * @private
    * @param  {number} idx The row index to deactivated
    * @param  {object} dataset Optional data to use
    * @returns {void}
    */
    deactivateRowNode: function deactivateRowNode(idx, dataset) {
      if (typeof idx !== 'number' || idx < 0) {
        return;
      }
      var s = this.settings;

      if (typeof dataset === 'undefined') {
        dataset = s.treeGrid ? s.treeDepth : s.dataset;
      }

      if (dataset[idx] && !s.disableRowDeactivation) {
        var rowNodes = this.rowNodes(idx).toArray();
        rowNodes.forEach(function (row) {
          row.classList.remove('is-rowactivated');
        });
        delete dataset[idx]._rowactivated;

        /**
         * Fires after a row is deactivated in mixed selection mode.
         * @event rowdeactivated
         * @memberof Datagrid
         * @property {object} event The jquery event object
         * @property {object} args Additional arguments
         * @property {array} args.row An array of selected rows.
         * @property {object} args.item The current sort column.
         */
        this.element.triggerHandler('rowdeactivated', [{ row: idx, item: dataset[idx] }]);
      }
    },


    /**
    * Deactivate all rows with mixed selection mode.
    * @private
    * @param  {object} dataset Optional data to use
    * @returns {void}
    */
    deactivateAllRowNodes: function deactivateAllRowNodes(dataset) {
      var s = this.settings;
      var triggerData = null;

      if (typeof dataset === 'undefined') {
        dataset = s.treeGrid ? s.treeDepth : s.dataset;
      }

      // Deselect activated row
      var activated = [].slice.call(this.bodyContainer[0].querySelectorAll('tr.is-rowactivated'));
      if (activated.length > 0) {
        activated.forEach(function (row) {
          row.classList.remove('is-rowactivated');
        });
        var idx = s.treeGrid || s.groupable ? this.actualRowIndex($(activated)) : this.dataRowIndex($(activated));
        triggerData = { row: idx, item: dataset[idx] };
        if (dataset[idx]) {
          delete dataset[idx]._rowactivated;
        }
      } else {
        // actived row may be filtered or on another page, so check all until find it
        for (var i = 0; i < dataset.length; i++) {
          var data = dataset[i];
          if (data._rowactivated) {
            delete data._rowactivated;
            triggerData = { row: i, item: data };
            break;
          }
        }
      }

      if (triggerData !== null) {
        this.element.triggerHandler('rowdeactivated', [triggerData]);
      }
    },


    /**
    * Toggle the current selection state from on to off.
    * @param  {number} idx The row to select/unselect
    * @returns {void}
    */
    toggleRowSelection: function toggleRowSelection(idx) {
      var row = typeof idx === 'number' ? this.tableBody.find('tr[aria-rowindex="' + (idx + 1) + '"]') : idx;
      var isSingle = this.settings.selectable === 'single';
      var rowIndex = typeof idx === 'number' ? idx : this.settings.treeGrid || this.settings.groupable ? this.actualRowIndex(row) : this.actualRowIndex(row);

      if (this.settings.selectable === false) {
        return;
      }

      if (this.editor && row.hasClass('is-selected')) {
        return;
      }

      if (isSingle && row.hasClass('is-selected')) {
        this.unselectRow(rowIndex);
        this.displayCounts();
        return this._selectedRows; // eslint-disable-line
      }

      if (row.hasClass('is-selected')) {
        this.unselectRow(rowIndex);
      } else {
        this.selectRow(rowIndex);
      }

      this.displayCounts();

      return this._selectedRows; // eslint-disable-line
    },


    /**
    * De-select a selected row.
    * @param  {number} idx The row index
    * @param  {boolean} nosync Do not sync the header
    * @param  {boolean} noTrigger Do not trgger any events
    */
    unselectRow: function unselectRow(idx, nosync, noTrigger) {
      var self = this;
      var s = self.settings;
      var rowNode = self.rowNodes(idx);
      var checkbox = null;

      if (!rowNode || idx === undefined) {
        return;
      }

      // Unselect it
      var unselectNode = function unselectNode(elem, index) {
        var removeSelected = function removeSelected(node, selIdx) {
          delete node._selected;
          self.selectedRowCount--;
          if (typeof selIdx === 'undefined') {
            selIdx = index;
          }
          for (var i = 0; i < self._selectedRows.length; i++) {
            if (self._selectedRows[i].idx === selIdx) {
              self._selectedRows.splice(i, 1);
              break;
            }
          }
        };

        var selectClasses = 'is-selected hide-selected-color';
        checkbox = self.cellNode(elem, self.columnIdxById('selectionCheckbox'));
        elem.removeClass(selectClasses).removeAttr('aria-selected');

        if (self.columnIdxById('selectionCheckbox') !== -1) {
          checkbox = self.cellNode(elem, self.columnIdxById('selectionCheckbox'));
          checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').removeClass('is-checked no-animate').attr('aria-checked', 'false');
        }

        if (s.treeGrid) {
          for (var i = 0; i < s.treeDepth.length; i++) {
            if (self.isRowSelected(s.treeDepth[i].node)) {
              if (typeof index !== 'undefined') {
                if (index === s.treeDepth[i].idx - 1) {
                  removeSelected(s.treeDepth[i].node);
                }
              } else {
                removeSelected(s.treeDepth[i].node);
              }
            }
          }
        } else {
          var selIdx = elem.length ? self.dataRowIndex(elem) : index;
          var rowData = void 0;

          if (selIdx !== undefined && selIdx > -1) {
            rowData = s.dataset[selIdx];
          }
          if (s.groupable) {
            var row = self.actualPagingRowIndex(self.actualRowIndex(rowNode));
            var gData = self.groupArray[row];
            rowData = s.dataset[gData.group].values[gData.node];
          }
          if (rowData !== undefined) {
            if (s.paging && s.source) {
              removeSelected(rowData, selIdx);
            } else {
              removeSelected(rowData);
            }
          }
        }
      };

      if (s.treeGrid) {
        if (rowNode.is('.datagrid-tree-parent') && s.selectable === 'multiple') {
          // Select node and node-children
          rowNode.add(rowNode.nextUntil('[aria-level="1"]')).each(function (i) {
            var elem = $(this);
            var index = elem.attr('aria-rowindex') - 1;

            // Allow unselect node if selectChildren is true or only first node
            if (s.selectChildren || !s.selectChildren && i === 0) {
              unselectNode(elem, index);
            }
          });
        } else if (s.selectable === 'siblings') {
          rowNode.parent().find('.is-selected').each(function (i) {
            var elem = $(this);
            var index = elem.attr('aria-rowindex') - 1;

            // Allow unselect node if selectChildren is true or only first node
            if (s.selectChildren || !s.selectChildren && i === 0) {
              unselectNode(elem, index);
            }
          });
        } else {
          // Single element unselection
          unselectNode(rowNode, idx);
        }
        self.setNodeStatus(rowNode);
      } else {
        unselectNode(rowNode, idx);
      }

      if (!nosync) {
        self.syncSelectedUI();
      }

      if (!noTrigger) {
        self.element.triggerHandler('selected', [self._selectedRows, 'deselect']);
      }
    },


    /**
     * Set the current status on the row status column
     * @param {HTMLElement} node The node to set the status on
     */
    setNodeStatus: function setNodeStatus(node) {
      var self = this;
      var isMultiselect = self.settings.selectable === 'multiple';
      var s = self.settings;
      var checkbox = self.cellNode(node, self.columnIdxById('selectionCheckbox'));
      var nodes = void 0;

      // Not multiselect
      if (!isMultiselect) {
        checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').removeClass('is-checked is-partial').attr('aria-checked', 'false');

        if (node.is('.is-selected')) {
          checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked').attr('aria-checked', 'true');
        }
        return;
      }

      var setStatus = function setStatus(nodeElems, isFirstSkipped) {
        nodeElems.each(function () {
          var nodeToUse = $(this);
          var checkboxToUse = self.cellNode(nodeToUse, self.columnIdxById('selectionCheckbox'));
          var status = self.getSelectedStatus(nodeToUse, isFirstSkipped);

          checkboxToUse.find('.datagrid-cell-wrapper .datagrid-checkbox').removeClass('is-checked is-partial').attr('aria-checked', 'false');

          if (status === 'mixed') {
            checkboxToUse.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked is-partial').attr('aria-checked', 'mixed');
          } else if (status) {
            checkboxToUse.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked').attr('aria-checked', 'true');
          }
        });
      };

      // Multiselect
      nodes = node.add(node.nextUntil('[aria-level="1"]')).filter('.datagrid-tree-parent');

      // Prevent selecting of parent element when selectChildren is false
      if (s.selectChildren) {
        setStatus(nodes);
      }

      nodes = node;
      if (+node.attr('aria-level') > 1) {
        nodes = nodes.add(node.prevUntil('[aria-level="1"]')).add(node.prevAll('[aria-level="1"]:first'));
      }
      nodes = nodes.filter('.datagrid-tree-parent');

      // Prevent selecting of parent element when selectChildren is false
      if (s.selectChildren) {
        setStatus(nodes);
      }
    },


    /**
    * Get current selection status.
    * @private
    * @param  {object} node The dom element.
    * @returns {object} The status
    */
    getSelectedStatus: function getSelectedStatus(node) {
      var status = false;
      var total = 0;
      var selected = 0;
      var unselected = 0;

      node.add(node.nextUntil('[aria-level="1"]')).each(function () {
        total++;
        if ($(this).is('.is-selected')) {
          selected++;
        } else {
          unselected++;
        }
      });

      status = total === selected ? true : total === unselected ? false : 'mixed';
      return status;
    },


    /**
     * Get the currently selected rows.
     * @returns {array} An array containing the selected rows
     */
    selectedRows: function selectedRows() {
      return this._selectedRows;
    },


    /**
     * Set the selected rows by passing the row index or an array of row indexes.
     * @param  {number/array} row A row index or array of row indexes to select.
     * @param  {boolean} nosync Dont sync the header.
     * @param  {boolean} selectAll Internally used.
     * @returns {void}
     */
    selectRows: function selectRows(row, nosync, selectAll) {
      var idx = -1;
      var s = this.settings;
      var isSingle = s.selectable === 'single';
      var isMultiple = s.selectable === 'multiple' || s.selectable === 'mixed';
      var isSiblings = s.selectable === 'siblings';
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var gIdx = idx;

      if (typeof row === 'number') {
        row = [row];
      }

      if (!row || row.length === 0) {
        return this._selectedRows;
      }

      if (isSingle) {
        // Unselect
        if (this._selectedRows.length) {
          this.unselectRow(this._selectedRows[0].idx, true, true);
        }

        // Select - may be passed array or int
        idx = Object.prototype.toString.call(row) === '[object Array]' ? row[0] : row.index();
        this.selectRow(idx, true, true);
      }

      if (isMultiple || isSiblings) {
        if (Object.prototype.toString.call(row) === '[object Array]') {
          for (var i = 0; i < row.length; i++) {
            if (s.groupable) {
              for (var k = 0; k < dataset[i].values.length; k++) {
                gIdx++;
                this.selectRow(gIdx, true, true);
              }
            } else {
              this.selectRow(row[i], true, true);
            }
          }

          if (row.length === 0) {
            for (var j = 0, l = dataset.length; j < l; j++) {
              this.unselectRow(j, true, true);
            }
          }
        } else {
          this.selectRow(row.index(), true, true);
        }
      }

      this.displayCounts();

      if (!nosync) {
        this.syncSelectedUI();
      }
      if (!selectAll) {
        this.element.triggerHandler('selected', [this._selectedRows, 'select']);
      }

      return this._selectedRows;
    },


    /**
     * Returns an array of row numbers for the rows containing the value for the specified field.
     * @param  {string} fieldName The field name to search.
     * @param  {any} value The value to use in search.
     * @returns {array} an array of row numbers.
     */
    findRowsByValue: function findRowsByValue(fieldName, value) {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var idx = -1;
      var matchedRows = [];
      for (var i = 0, data; i < dataset.length; i++) {
        if (s.groupable) {
          for (var k = 0; k < dataset[i].values.length; k++) {
            idx++;
            data = dataset[i].values[k];
            if (data[fieldName] === value) {
              matchedRows.push(idx);
            }
          }
        } else {
          data = s.treeGrid ? dataset[i].node : dataset[i];
          if (data[fieldName] === value) {
            matchedRows.push(i);
          }
        }
      }
      return matchedRows;
    },


    /**
    * Sets the row status
    * @param {object} idx The index of the row to add status to.
    * @param {string} status The status type 'error', 'info' ect
    * @param {object} tooltip The information for the message/tooltip
    */
    rowStatus: function rowStatus(idx, status, tooltip) {
      if (!status) {
        delete this.settings.dataset[idx].rowStatus;
        this.updateRow(idx);
        return;
      }

      if (/dirty/.test(status)) {
        return;
      }

      if (!this.settings.dataset[idx]) {
        return;
      }

      this.settings.dataset[idx].rowStatus = {};
      var rowStatus = this.settings.dataset[idx].rowStatus;

      rowStatus.icon = status;
      status = status.charAt(0).toUpperCase() + status.slice(1);
      status = status.replace('-progress', 'Progress');
      rowStatus.text = Locale.translate(status);

      tooltip = tooltip ? tooltip.charAt(0).toUpperCase() + tooltip.slice(1) : rowStatus.text;
      rowStatus.tooltip = tooltip;

      this.updateRow(idx);
      this.setupTooltips(true);
    },


    /**
    * Get the column object by id
    * @param  {number} id The column id to find
    * @returns {object} The corresponding column.
    */
    columnById: function columnById(id) {
      return $.grep(this.settings.columns, function (e) {
        return e.id === id;
      });
    },


    /**
    * Get the column index from the col's id
    * @param  {number} id The column id to find
    * @returns {object} The corresponding columns current position.
    */
    columnIdxById: function columnIdxById(id) {
      var cols = this.settings.columns;
      var idx = -1;

      for (var i = 0; i < cols.length; i++) {
        if (cols[i].id === id) {
          idx = i;
          break;
        }
      }
      return idx;
    },


    /**
    * Handle all keyboard behavior
    * @private
    * @returns {void}
    */
    handleKeys: function handleKeys() {
      var self = this;
      var isMultiple = self.settings.selectable === 'multiple';
      var checkbox = $('th .datagrid-checkbox', self.headerRow);

      // Handle header navigation
      self.headerContainer.on('keydown.datagrid', 'th', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0;
        var th = $(this);
        var index = self.columnIdxById(th.attr('data-column-id'));
        var last = self.visibleColumns().length - 1;
        var triggerEl = void 0;
        var move = void 0;

        if ($(e.target).closest('.popupmenu').length > 0) {
          return;
        }

        // Enter or Space
        if (key === 13 || key === 32) {
          triggerEl = isMultiple && index === 0 ? $('.datagrid-checkbox', th) : th;
          triggerEl.trigger('click.datagrid').focus();

          if (key === 32) {
            // Prevent scrolling with space
            e.preventDefault();
          }
        }

        // Press Home, End, Left and Right arrow to move to first, last, previous or next
        if ([35, 36, 37, 39].indexOf(key) !== -1) {
          move = index;

          // Home, End or Ctrl/Meta + Left/Right arrow to move to the first or last
          if (/35|36/i.test(key) || (e.ctrlKey || e.metaKey) && /37|39/i.test(key)) {
            if (Locale.isRTL()) {
              move = key === 36 || (e.ctrlKey || e.metaKey) && key === 37 ? last : 0;
            } else {
              move = key === 35 || (e.ctrlKey || e.metaKey) && key === 39 ? last : 0;
            }
          } else if (Locale.isRTL()) {
            // Left and Right arrow
            move = key === 39 ? index > 0 ? index - 1 : index : index < last ? index + 1 : last;
          } else {
            move = key === 37 ? index > 0 ? index - 1 : index : index < last ? index + 1 : last;
          }
          // Update active cell
          self.activeCell.cell = move;

          // Making moves
          th.removeAttr('tabindex').removeClass('is-active');
          $('th:not(.is-hidden)', this.headerContainer).eq(move).attr('tabindex', '0').addClass('is-active').focus();
          e.preventDefault();

          // Sync the body scroll area
          self.syncBodyScroll(th);
        }

        // Down arrow
        if (key === 40) {
          th.removeAttr('tabindex');
          self.activeCell.node = self.cellNode(0, self.settings.groupable ? 0 : self.activeCell.cell).attr('tabindex', '0').focus();
          e.preventDefault();
        }
      });

      // Handle Editing / Keyboard
      self.bodyContainer.on('keydown.datagrid', 'td, input', function (e) {
        //eslint-disable-line
        var key = e.which || e.keyCode || e.charCode || 0;
        var handled = false;

        // F2 - toggles actionableMode "true" and "false"
        if (key === 113) {
          self.settings.actionableMode = !self.settings.actionableMode;
          handled = true;
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return handled;
        }
      });

      // Press PageUp or PageDown to open the previous or next page and set focus to the first row.
      // Press Alt+Up or Alt+Down to set focus to the first or last row on the current page.
      // Press Alt+PageUp or Alt+PageDown to open the first or last page and
      // set focus to the first row.

      // Handle rest of the keyboard
      self.bodyContainer.on('keydown.datagrid', 'td', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0;
        var handled = false;
        var isRTL = Locale.isRTL();
        var node = self.activeCell.node;
        var rowNode = $(this).parent();
        var prevRow = rowNode.prevAll(':not(.is-hidden, .datagrid-expandable-row)').first();
        var nextRow = rowNode.nextAll(':not(.is-hidden, .datagrid-expandable-row)').first();
        var row = self.activeCell.row;
        var cell = self.activeCell.cell;
        var col = self.columnSettings(cell);
        var isGroupRow = rowNode.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');
        var item = self.settings.dataset[self.dataRowIndex(node)];
        var visibleRows = self.tableBody.find('tr:visible');
        var getVisibleRows = function getVisibleRows(index) {
          var visibleRow = visibleRows.filter('[aria-rowindex="' + (index + 1) + '"]');
          if (visibleRow.is('.datagrid-rowgroup-header')) {
            return visibleRow.index();
          }
          return self.dataRowIndex(visibleRow);
        };

        var getGroupCell = function getGroupCell(currentCell, lastCell, prev) {
          var n = self.activeCell.groupNode || node;
          var nextCell = currentCell + (prev ? -1 : +1);

          if (nextCell > lastCell) {
            nextCell = prev ? n.prevAll(':visible').last() : n.nextAll(':visible').last();
          } else {
            nextCell = prev ? n.prevAll(':visible').first() : n.nextAll(':visible').first();
          }
          return nextCell;
        };

        var getNextVisibleCell = function getNextVisibleCell(currentCell, lastCell, prev) {
          if (isGroupRow) {
            return getGroupCell(currentCell, lastCell, prev);
          }
          var nextCell = currentCell + (prev ? -1 : +1);
          if (nextCell > lastCell) {
            return lastCell;
          }
          while (self.settings.columns[nextCell] && self.settings.columns[nextCell].hidden) {
            nextCell = prev ? nextCell - 1 : nextCell + 1;
          }
          return nextCell;
        };

        var isSelectionCheckbox = !!$('.datagrid-selection-checkbox', node).length;
        var lastRow = visibleRows.last();
        var lastCell = self.settings.columns.length - 1;

        // Tab, Left and Right arrow keys.
        if ([9, 37, 39].indexOf(key) !== -1) {
          if (key === 9 && self.settings.onKeyDown) {
            var ret = self.settings.onKeyDown(e);
            if (ret === false) {
              e.stopPropagation();
              e.preventDefault();
              return;
            }
          }

          if (key === 9 && self.editor && self.editor.name === 'input' && col.inlineEditor === true) {
            // Editor.destroy
            self.editor.destroy();
            self.editor = null;
            return;
          }

          if (key === 9 && !self.settings.actionableMode) {
            return;
          }

          if (key !== 9 && e.altKey) {
            // [Alt + Left/Right arrow] to move to the first or last cell on the current row.
            cell = key === 37 && !isRTL || key === 39 && isRTL ? 0 : lastCell;
            self.setActiveCell(row, cell);
          } else if (!self.quickEditMode || key === 9) {
            if (!isRTL && (key === 37 || key === 9 && e.shiftKey) || // eslint-disable-line
            isRTL && (key === 39 || key === 9)) {
              // eslint-disable-line
              cell = getNextVisibleCell(cell, lastCell, true);
            } else {
              cell = getNextVisibleCell(cell, lastCell);
            }

            if (cell instanceof jQuery) {
              self.setActiveCell(cell);
            } else {
              self.setActiveCell(row, cell);
            }

            if (key === 9 && self.settings.actionableMode) {
              self.makeCellEditable(self.activeCell.rowIndex, cell, e);
              if (self.containsTextField(node) && self.containsTriggerField(node)) {
                self.quickEditMode = true;
              }
            }
            self.quickEditMode = false;
            handled = true;
          }
        }

        // Up arrow key
        if (key === 38 && !self.quickEditMode) {
          // Press [Control + Up] arrow to move to the first row on the first page.
          if (e.altKey || e.metaKey) {
            var firstRow = getVisibleRows(0);
            self.setActiveCell(firstRow, cell);
            handled = true;
          } else {
            // Up arrow key to navigate by row.
            if (row === 0 && !prevRow.is('.datagrid-rowgroup-header')) {
              node.removeAttr('tabindex');
              self.headerContainer.find('th').eq(cell).attr('tabindex', '0').focus();
              return;
            }
            self.setActiveCell(prevRow, cell);
            handled = true;
          }
        }

        // Down arrow key
        if (key === 40 && !self.quickEditMode) {
          // Press [Control + Down] arrow to move to the last row on the last page.
          if (e.altKey || e.metaKey) {
            self.setActiveCell(lastRow, cell);
            handled = true;
          } else {
            // Down arrow key to navigate by row.
            self.setActiveCell(nextRow, cell);
            handled = true;
          }
        }

        // Press Control+Spacebar to announce the current row when using a screen reader.
        if (key === 32 && e.ctrlKey && node) {
          var string = '';
          row = node.closest('tr');

          row.children().each(function () {
            var cellNode = $(this);
            // Read Header
            // string += $('#' + cell.attr('aria-describedby')).text() + ' ' + cell.text() + ' ';
            string += cellNode.text() + ' ';
          });

          $('body').toast({ title: '', audibleOnly: true, message: string });
          handled = true;
        }

        // Press Home or End to move to the first or last cell on the current row.
        if (key === 36) {
          self.setActiveCell(row, 0);
          handled = true;
        }

        // Home to Move to the end of the current row
        if (key === 35) {
          self.setActiveCell(row, lastCell);
          handled = true;
        }

        // End to Move to last row of current cell
        if (key === 34) {
          self.setActiveCell(lastRow, cell);
          handled = true;
        }

        // End to Move to first row of current cell
        if (key === 33) {
          self.setActiveCell(getVisibleRows(0), cell);
          handled = true;
        }

        // For mode 'Selectable':
        // Press Space to toggle row selection, or click to activate using a mouse.
        if (key === 32 && (!self.settings.editable || isSelectionCheckbox)) {
          row = node.closest('tr');

          if ($(e.target).closest('.datagrid-row-detail').length === 1) {
            return;
          }
          e.preventDefault();

          // Toggle datagrid-expand with Space press
          var btn = $(e.target).find('.datagrid-expand-btn, .datagrid-drilldown');
          if (btn && btn.length) {
            btn.trigger('click.datagrid');
            e.preventDefault();
            return;
          }

          if (isMultiple && e.shiftKey) {
            self.selectRowsBetweenIndexes([self.lastSelectedRow, row.index()]);
          } else {
            self.toggleRowSelection(row);
          }
        }

        // For Editable mode - press Enter or Space to edit or toggle a cell,
        // or click to activate using a mouse.
        if (self.settings.editable && key === 32) {
          if (!self.editor) {
            self.makeCellEditable(self.activeCell.rowIndex, cell, e);
          }
        }

        // if column have click function to fire [ie. action button]
        if (key === 13 && col.click && typeof col.click === 'function') {
          if (!node.hasClass('is-cell-readonly')) {
            col.click(e, [{ row: row, cell: cell, item: item, originalEvent: e }]);
          }
        }

        if (self.settings.editable && key === 13) {
          // Allow shift to add a new line
          if ($(e.target).is('textarea') && e.shiftKey) {
            return;
          }

          if (self.editor) {
            self.quickEditMode = false;
            self.commitCellEdit(self.editor.input);
            self.setNextActiveCell(e);
          } else {
            self.makeCellEditable(self.activeCell.rowIndex, cell, e);
            if (self.containsTextField(node) && self.containsTriggerField(node)) {
              self.quickEditMode = true;
            }
          }
          handled = true;
        }

        // Any printable character - well make it editable
        if ([9, 13, 32, 35, 36, 37, 38, 39, 40, 113].indexOf(key) === -1 && !e.altKey && !e.shiftKey && !e.ctrlKey && !e.metaKey && self.settings.editable) {
          if (!self.editor) {
            self.makeCellEditable(self.activeCell.rowIndex, cell, e);
          }
        }

        // If multiSelect is enabled, press Control+A to toggle select all rows
        if (isMultiple && !self.editor && (e.ctrlKey || e.metaKey) && key === 65) {
          checkbox.addClass('is-checked').removeClass('is-partial').attr('aria-checked', 'true');
          self.selectAllRows();
          handled = true;
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false; // eslint-disable-line
        }
      });
    },


    /**
     * Sync the body area with the header or other containers.
     * @private
     * @param  {element} elem The element to check.
     */
    syncBodyScroll: function syncBodyScroll(elem) {
      var container = elem.closest('.datagrid-header');
      if (container.length > 0) {
        var left = container.scrollLeft();
        if (!(elem.is(':last-child') && left === 0)) {
          this.bodyWrapperCenter.scrollLeft(container.scrollLeft());
        }
        return;
      }

      container = elem.closest('.datagrid-body.left, .datagrid-body.right');
      if (container.length > 0) {
        this.bodyWrapperCenter.scrollTop(container.scrollTop());
      }
    },


    /**
     * Does the column editor have a text field.
     * @private
     * @param  {object} container The dom element
     * @returns {boolean} If it does or not
     */
    containsTextField: function containsTextField(container) {
      var noTextTypes = ['image', 'button', 'submit', 'reset', 'checkbox', 'radio'];
      var selector = 'textarea, input';
      var l = noTextTypes.length;
      var i = void 0;

      selector += l ? ':not(' : '';
      for (i = 0; i < l; i++) {
        selector += '[type=' + noTextTypes[i] + '],';
      }
      selector = l ? selector.slice(0, -1) + ')' : '';

      return !!$(selector, container).length;
    },


    /**
     * Does the column editor have a picker/trigger field.
     * @private
     * @param  {object} container The dom element
     * @returns {boolean} If it does or not
     */
    containsTriggerField: function containsTriggerField(container) {
      var selector = '.dropdown, .datepicker, .lookup';
      return !$(selector, container).length;
    },


    /**
     * Is a specific row/cell editable?
     * @param  {number} row The row index
     * @param  {number} cell The cell index
     * @returns {boolean} returns true if the cell is editable
     */
    isCellEditable: function isCellEditable(row, cell) {
      if (!this.settings.editable) {
        return false;
      }

      var col = this.columnSettings(cell);
      if (col.readonly) {
        return false;
      }

      // Check if cell is editable via hook function
      var cellNode = this.activeCell.node.find('.datagrid-cell-wrapper');
      var cellValue = cellNode.text() ? cellNode.text() : this.fieldValue(this.settings.dataset[row], col.field);

      if (col.isEditable) {
        var canEdit = col.isEditable(row, cell, cellValue, col, this.settings.dataset[row]);

        if (!canEdit) {
          return false;
        }
      }

      if (!col.editor) {
        return false;
      }

      return true;
    },


    /**
     * Invoked in three cases
     * 1) a row click
     * 2) keyboard and enter
     * 3) In actionable mode and tabbing
     * @private
     * @param  {number} row The row index
     * @param  {number} cell The cell index
     * @param  {object} event The event information.
     * @returns {boolean} returns true if the cell is editable
     */
    makeCellEditable: function makeCellEditable(row, cell, event) {
      if (this.activeCell.node.closest('tr').hasClass('datagrid-summary-row')) {
        return;
      }

      // Already in edit mode
      var cellNode = this.activeCell.node.find('.datagrid-cell-wrapper');
      var cellParent = cellNode.parent('td');
      var treeNode = $('.datagrid-tree-node', cellNode).length > 0;
      var treeExpandBtn = $('.datagrid-expand-btn', cellNode).length > 0;

      if (cellParent.hasClass('is-editing') || cellParent.hasClass('is-editing-inline')) {
        return false; // eslint-disable-line
      }

      // Commit Previous Edit
      if (this.editor && this.editor.input) {
        this.commitCellEdit(this.editor.input);
      }

      // Locate the Editor
      var col = this.columnSettings(cell);

      // Select the Rows if the cell is editable
      if (!col.editor) {
        if (event.keyCode === 32 && !$(event.currentTarget).find('.datagrid-selection-checkbox').length) {
          this.toggleRowSelection(this.activeCell.node.closest('tr'));
        }
        return false; // eslint-disable-line
      }

      var thisRow = this.actualRowNode(row);
      var idx = this.settings.treeGrid ? this.actualRowIndex(thisRow) : this.dataRowIndex(thisRow);
      var rowData = this.settings.treeGrid ? this.settings.treeDepth[idx].node : this.settings.dataset[idx];
      var cellWidth = cellParent.outerWidth();
      var isEditor = $('.is-editor', cellParent).length > 0;
      var isPlaceholder = $('.is-placeholder', cellNode).length > 0;
      var cellValue = cellNode.text() ? cellNode.text() : this.fieldValue(rowData, col.field);

      if (isEditor || isPlaceholder) {
        cellValue = this.fieldValue(rowData, col.field);
      }

      if (!this.isCellEditable(idx, cell)) {
        return false; // eslint-disable-line
      }

      if (treeExpandBtn || treeNode) {
        if (treeExpandBtn) {
          cellValue = $('> span', cellNode).text();
        }
        if (typeof cellValue === 'string') {
          cellValue = cellValue.replace(/^\s/, '');
        }
      }

      // In Show Editor mode the editor is on form already
      if (!col.inlineEditor) {
        if (isEditor) {
          cellNode.css({ position: 'static', height: cellNode.outerHeight() });
        }
        // initialis Editor
        cellParent.addClass('is-editing').css({ 'max-width': cellWidth, 'min-width': cellWidth, width: cellWidth });

        cellNode.empty();
      } else {
        cellParent.addClass('is-editing-inline');
      }

      /**
      * Fires before a cell goes into edit mode. Giving you a chance to adjust column settings.
      * @event entereditmode
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row An array of selected rows.
      * @property {number} args.cell An array of selected rows.
      * @property {object} args.item The current sort column.
      * @property {HTMLElement} args.target The cell html element that was entered.
      * @property {any} args.value The cell value.
      * @property {object} args.column The column object
      * @property {object} args.editor The editor object.
      */
      this.element.triggerHandler('beforeentereditmode', [{ row: idx, cell: cell, item: rowData, target: cellNode, value: cellValue, column: col, editor: this.editor }]);

      this.editor = new col.editor(idx, cell, cellValue, cellNode, col, event, this, rowData); // eslint-disable-line

      if (this.settings.onEditCell) {
        this.settings.onEditCell(this.editor);
      }

      if (this.editor.useValue) {
        cellValue = this.fieldValue(rowData, col.field);
      }
      this.editor.val(cellValue);

      // Set original data for trackdirty
      if (this.settings.showDirty) {
        var originalVal = cellValue;

        if (originalVal === '' && /checkbox|favorite/i.test(this.editor.name)) {
          originalVal = false;
        }

        var data = { originalVal: originalVal, isDirty: false };
        if (typeof this.dirtyArray === 'undefined') {
          this.dirtyArray = [];
        }
        if (typeof this.dirtyArray[idx] === 'undefined') {
          this.dirtyArray[idx] = [];
          this.dirtyArray[idx][cell] = data;
        } else if (typeof this.dirtyArray[idx][cell] === 'undefined') {
          this.dirtyArray[idx][cell] = data;
        }
      }

      this.editor.focus();

      /**
      * Fires after a cell goes into edit mode.
      * @event entereditmode
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row An array of selected rows.
      * @property {number} args.cell An array of selected rows.
      * @property {object} args.item The current sort column.
      * @property {HTMLElement} args.target The cell html element that was entered.
      * @property {any} args.value The cell value.
      * @property {object} args.column The column object
      * @property {object} args.editor The editor object.
      */
      this.element.triggerHandler('entereditmode', [{ row: idx, cell: cell, item: rowData, target: cellNode, value: cellValue, column: col, editor: this.editor }]);

      return true; //eslint-disable-line
    },


    /**
     * Commit the cell thats currently in edit mode.
     * @private
     * @param  {number} input The input dom element.
     */
    commitCellEdit: function commitCellEdit(input) {
      if (!this.editor) {
        return;
      }

      var newValue = void 0;
      var cellNode = void 0;
      var isEditor = this.editor.name === 'editor';
      var isFileupload = this.editor.name === 'fileupload';
      var isUseActiveRow = !input.is('.timepicker, .datepicker, .lookup, .spinbox .colorpicker');

      // Editor.getValue
      newValue = this.editor.val();

      if (isEditor) {
        cellNode = this.editor.td;
      } else if (isFileupload) {
        if (this.editor.status === 'clear') {
          newValue = '';
        } else if (this.editor.status === 'init' || this.editor.status === 'cancel') {
          newValue = this.editor.originalValue;
        }
        // Fix: Not sure why, but `input.closest('td')` did not work
        cellNode = this.tableBody.find('#' + input.attr('id')).closest('td');
        newValue = xssUtils.escapeHTML(newValue);
      } else {
        cellNode = input.closest('td');
        newValue = xssUtils.escapeHTML(newValue);
      }

      // Format Cell again
      var isInline = cellNode.hasClass('is-editing-inline');
      cellNode.removeClass('is-editing is-editing-inline');

      // Editor.destroy
      this.editor.destroy();
      this.editor = null;

      var rowIndex = void 0;
      var dataRowIndex = void 0;
      if (this.settings.source !== null && isUseActiveRow) {
        rowIndex = this.activeCell.rowIndex;
        dataRowIndex = this.activeCell.dataRow;
      } else {
        rowIndex = this.actualRowIndex(cellNode.parent());
        dataRowIndex = this.dataRowIndex(cellNode.parent());
      }

      var cell = cellNode.attr('aria-colindex') - 1;
      var col = this.columnSettings(cell);
      var rowData = this.settings.treeGrid ? this.settings.treeDepth[dataRowIndex].node : this.settings.dataset[dataRowIndex];
      var oldValue = this.fieldValue(rowData, col.field);

      // Save the Cell Edit back to the data set
      this.updateCellNode(rowIndex, cell, newValue, false, isInline);
      var value = this.fieldValue(rowData, col.field);

      /**
      * Fires after a cell goes out of edit mode.
      * @event exiteditmode
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row An array of selected rows.
      * @property {number} args.cell An array of selected rows.
      * @property {object} args.item The current sort column.
      * @property {HTMLElement} args.target The cell html element that was entered.
      * @property {any} args.value The cell value.
      * @property {any} args.oldValue The previous cell value.
      * @property {object} args.column The column object
      * @property {object} args.editor The editor object.
      */
      this.element.triggerHandler('exiteditmode', [{
        row: rowIndex,
        cell: cell,
        item: rowData,
        target: cellNode,
        value: value,
        oldValue: oldValue,
        column: col,
        editor: this.editor
      }]);
    },


    /**
     * Run validation for the column, for a particular cell.
     * @param  {number} row The row index
     * @param  {number} cell The cell index
     */
    validateCell: function validateCell(row, cell) {
      var _$,
          _this8 = this;

      var self = this;
      var column = this.columnSettings(cell);
      var validate = column.validate;
      var validationType = void 0;

      if (!validate) {
        return;
      }

      var dfd = void 0;
      var dfds = [];
      var rules = column.validate.split(' ');
      var validator = $.fn.validation;
      var cellValue = this.fieldValue(this.settings.dataset[row], column.field);
      var messages = [];
      var messageText = '';
      var i = void 0;

      function manageResult(result, displayMessage, ruleName, dfrd) {
        var rule = validator.rules[ruleName];

        validationType = $.fn.validation.ValidationTypes[rule.type] || $.fn.validation.ValidationTypes.error;
        messageText = '';

        if (messages[validationType.type]) {
          messageText = messages[validationType.type];
        }

        if (!result && displayMessage) {
          if (messageText) {
            messageText = (/^\u2022/.test(messageText) ? '' : '\u2022 ') + messageText;
            messageText += '<br/>' + '\u2022 ' + rule.message;
          } else {
            messageText = rule.message;
          }

          messages[validationType.type] = messageText;
        }

        dfrd.resolve();
      }

      for (i = 0; i < rules.length; i++) {
        var rule = validator.rules[rules[i]];
        var gridInfo = { row: row, cell: cell, item: this.settings.dataset[row], column: column, grid: self };

        dfd = $.Deferred();

        if (rule.async) {
          rule.check(cellValue, $('<input>').val(cellValue), gridInfo, manageResult, dfd);
        } else {
          manageResult(rule.check(cellValue, $('<input>').val(cellValue), gridInfo), true, rules[i], dfd);
        }
        dfds.push(dfd);
      }

      (_$ = $).when.apply(_$, dfds).then(function () {
        var validationTypes = $.fn.validation.ValidationTypes;
        for (var props in validationTypes) {
          // eslint-disable-line
          messageText = '';
          validationType = validationTypes[props];
          if (messages[validationType.type]) {
            messageText = messages[validationType.type];
          }
          if (messageText !== '') {
            self.showCellError(row, cell, messageText, validationType.type);
            var rowNode = _this8.dataRowNode(row);
            self.element.trigger('cell' + validationType.type, { row: row, cell: cell, message: messageText, target: _this8.cellNode(rowNode, cell), value: cellValue, column: column });
          } else {
            self.clearCellError(row, cell, validationType.type);
          }
        }
      });
    },


    /**
    * Show the cell errors.
    * @param  {number} row The row index.
    * @param  {number} cell The cell index.
    * @param  {string} message The message text.
    * @param  {string} type The message type (infor, error, alert )
    * @returns {void}
    */
    showCellError: function showCellError(row, cell, message, type) {
      var rowNode = this.dataRowNode(row);
      var node = this.cellNode(rowNode, cell);

      // clear the table nonVisibleCellErrors for the row and cell
      this.clearNonVisibleCellErrors(row, cell, type);

      if (!node.length) {
        // Store the nonVisibleCellError
        this.nonVisibleCellErrors.push({ row: row, cell: cell, message: message, type: type });
        this.showNonVisibleCellErrors();
        return;
      }

      // Add icon and classes
      node.addClass(type).attr('data-' + type + 'message', message);

      // Add and show tooltip
      var icon = node.find('.icon-' + type);
      if (!icon.length) {
        var wrapper = node.find('.datagrid-cell-wrapper');
        wrapper.append($($.createIcon({ classes: ['icon-' + type], icon: type })));
        icon = node.find('.icon-' + type);

        var tooltip = {
          forced: true,
          placement: 'bottom',
          content: message,
          isError: type === 'error' || type === 'dirtyerror',
          wrapper: icon
        };
        this.cacheTooltip(icon, tooltip);
        this.setupTooltips(false, true);
      }
    },


    /**
     * Show all non visible cell errors
     * @private
     * @returns {void}
     */
    showNonVisibleCellErrors: function showNonVisibleCellErrors() {
      var _this9 = this;

      // Create empty toolbar
      if (!this.toolbar) {
        this.settings.toolbar = { title: ' ' };
        this.appendToolbar();
      }

      // process via type

      var _loop4 = function _loop4(props) {
        // eslint-disable-line
        var validationType = $.fn.validation.ValidationTypes[props].type;
        var errors = $.grep(_this9.nonVisibleCellErrors, function (error) {
          return error.type === validationType;
        });
        _this9.showNonVisibleCellErrorType(errors, validationType);
      };

      for (var props in $.fn.validation.ValidationTypes) {
        _loop4(props);
      }
    },


    /**
     * Show all non visible cell errors, for a given message/validation type.
     * @private
     * @param  {array} nonVisibleCellErrors An array of non visible cells, in error state.
     * @param  {string} type The message type to show
     */
    showNonVisibleCellErrorType: function showNonVisibleCellErrorType(nonVisibleCellErrors, type) {
      var messages = void 0;
      var tableerrors = void 0;
      var icon = void 0;
      var i = void 0;
      var nonVisiblePages = [];
      var validationType = $.fn.validation.ValidationTypes[type] || $.fn.validation.ValidationTypes.error;

      if (this.toolbar.parent().find('.table-errors').length === 1) {
        tableerrors = this.toolbar.parent().find('.table-errors');
      }

      if (nonVisibleCellErrors.length === 0) {
        // clear the displayed message
        if (tableerrors && tableerrors.length) {
          icon = tableerrors.find('.icon-' + validationType.type);
          this.hideTooltip();
          tableerrors.find('.icon-' + validationType.type).remove();
        }
        return;
      }

      // Process message type, so it displays one message per page
      for (i = 0; i < nonVisibleCellErrors.length; i++) {
        var page = Math.floor((nonVisibleCellErrors[i].row + this.settings.pagesize) / this.settings.pagesize);
        if ($.inArray(page, nonVisiblePages) === -1) {
          nonVisiblePages.push(page);
        }
      }

      for (i = 0; i < nonVisiblePages.length; i++) {
        messages = (messages ? messages + '<br>' : '') + Locale.translate(validationType.pagingMessageID) + ' ' + nonVisiblePages[i];
      }

      if (this.toolbar.parent().find('.table-errors').length === 0) {
        tableerrors = $('<div class="table-errors"></div>');
      }
      icon = tableerrors.find('.icon-' + type);
      if (!icon.length) {
        tableerrors.append($($.createIcon({ classes: ['icon-' + type], icon: type })));
        icon = tableerrors.find('.icon-' + type);
      }

      if (this.element.hasClass('has-toolbar')) {
        // Add Error to the Toolbar
        this.toolbar.children('.title').append(tableerrors);
      }

      this.cacheTooltip(icon, {
        forced: true,
        placement: 'bottom',
        content: messages,
        isError: type === 'error' || type === 'dirtyerror',
        wrapper: icon
      });
    },


    /**
     * Clear all error for a given cell in a row
     * @param {number} row The row index.
     * @param {number} cell The cell index.
     * @returns {void}
     */
    clearAllCellError: function clearAllCellError(row, cell) {
      var validationTypes = $.fn.validation.ValidationTypes;
      for (var props in validationTypes) {
        // eslint-disable-line
        var _validationType = validationTypes[props];
        this.clearCellError(row, cell, _validationType.type);
      }
    },


    /**
     * Clear a cell with an error of a given type
     * @param {number} row The row index.
     * @param {number} cell The cell index.
     * @param {string} type of error.
     * @returns {void}
     */
    clearCellError: function clearCellError(row, cell, type) {
      this.clearNonVisibleCellErrors(row, cell, type);
      var rowNode = this.dataRowNode(row);
      var node = this.cellNode(rowNode, cell);

      if (!node.length) {
        return;
      }

      this.clearNodeErrors(node, type);
    },


    /**
     * Clear a non visible cells from errors of a given type
     * @private
     * @param {number} row The row index.
     * @param {number} cell The cell index.
     * @param {string} type of error.
     * @returns {void}
     */
    clearNonVisibleCellErrors: function clearNonVisibleCellErrors(row, cell, type) {
      if (!this.nonVisibleCellErrors.length) {
        return;
      }

      this.nonVisibleCellErrors = $.grep(this.nonVisibleCellErrors, function (error) {
        if (!(error.row === row && error.cell === cell && error.type === type)) {
          return error;
        }
        return '';
      });

      if (!this.nonVisibleCellErrors.length) {
        this.showNonVisibleCellErrors();
      }
    },


    /**
     * Clear a row level all errors, alerts, info messages
     * @param {number} row The row index.
     * @returns {void}
     */
    clearRowError: function clearRowError(row) {
      var classList = 'error alert rowstatus-row-error rowstatus-row-alert rowstatus-row-info rowstatus-row-in-progress rowstatus-row-success';
      var rowNode = this.dataRowNode(row);

      rowNode.removeClass(classList);
      this.rowStatus(row, '', '');
      for (var cell = 0; cell < this.settings.columns.length; cell++) {
        this.clearAllCellError(row, cell);
      }
    },


    /**
     * Clear all errors, alerts and info messages in entire datagrid.
     * @returns {void}
     */
    clearAllErrors: function clearAllErrors() {
      var rowStatus = 0;
      for (var row = 0; row < this.settings.dataset.length; row++) {
        if (this.settings.dataset[row].rowStatus) {
          delete this.settings.dataset[row].rowStatus;
          rowStatus++;
        }
        for (var cell = 0; cell < this.settings.columns.length; cell++) {
          this.clearAllCellError(row, cell);
        }
      }

      if (rowStatus > 0) {
        this.render();
      }
    },


    /**
     * Remove messages form a cell element.
     * @private
     * @param {object} node cell element.
     * @param {string} type of messages.
     * @returns {void}
     */
    clearNodeErrors: function clearNodeErrors(node, type) {
      node = node instanceof jQuery ? node[0] : node;
      node.classList.remove(type);
      node.removeAttribute('data-' + type + 'message');

      var icon = node.querySelector('.icon-' + type);
      if (icon) {
        icon.parentNode.removeChild(icon);
        this.hideTooltip();
      }
    },


    /**
    * Set the row status on a row to none.
    * @returns {void}
    */
    resetRowStatus: function resetRowStatus() {
      var errors = this.settings.dataset.filter(function (row) {
        return row.rowStatus;
      });
      for (var i = 0; i < errors.length; i++) {
        delete errors[i].rowStatus;
      }
      if (errors.length > 0) {
        this.render();
      }

      // Clear dirty cells
      this.clearDirty();
    },


    /**
     * Clear dirty css class on all cells for given parent element.
     * @private
     * @param  {object} elem The parent element.
     * @returns {void}
     */
    clearDirtyClass: function clearDirtyClass(elem) {
      elem = elem instanceof jQuery ? elem[0] : elem;
      if (elem) {
        var cells = [].slice.call(elem.querySelectorAll('.is-dirty-cell'));
        cells.forEach(function (cell) {
          cell.classList.remove('is-dirty-cell');
        });
      }
    },


    /**
     * Clear all dirty cells.
     * @returns {void}
     */
    clearDirty: function clearDirty() {
      if (this.settings.showDirty && this.dirtyArray) {
        this.clearDirtyClass(this.element);
        this.dirtyArray = undefined;
      }
    },


    /**
     * Clear all dirty cells in given row.
     * @param  {number} row The row index.
     * @returns {void}
     */
    clearDirtyRow: function clearDirtyRow(row) {
      if (this.settings.showDirty && this.dirtyArray && typeof row === 'number') {
        var rowNode = this.rowNodes(row);
        this.clearDirtyClass(rowNode);
        this.dirtyArray[row] = undefined;
      }
    },


    /**
     * Clear dirty on given cell.
     * @param  {number} row The row index.
     * @param  {number} cell The cell index.
     * @returns {void}
     */
    clearDirtyCell: function clearDirtyCell(row, cell) {
      if (this.settings.showDirty && this.dirtyArray && typeof row === 'number' && typeof cell === 'number') {
        var dirtyRow = this.dirtyArray[row];
        if (typeof dirtyRow !== 'undefined') {
          this.cellNode(row, cell).removeClass('is-dirty-cell');
          this.dirtyArray[row][cell] = undefined;
        }
      }
    },


    /**
    * Return all of the currently dirty cells.
    * @returns {array} An array of dirty cells.
    */
    dirtyCells: function dirtyCells() {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var cells = [];

      if (s.showDirty && this.dirtyArray && this.dirtyArray.length) {
        for (var i = 0, l = dataset.length; i < l; i++) {
          var row = this.dirtyArray[i];
          if (typeof row !== 'undefined') {
            for (var i2 = 0, l2 = row.length; i2 < l2; i2++) {
              var _col5 = row[i2];
              if (typeof _col5 !== 'undefined' && _col5.isDirty) {
                cells.push(s.treeGrid ? dataset[i].node : dataset[i]);
              }
            }
          }
        }
      }
      return cells;
    },


    /**
    * Return all of the currently dirty rows by row index.
    * @returns {array} An array of dirty rows.
    */
    dirtyRows: function dirtyRows() {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var rows = [];

      if (s.showDirty && this.dirtyArray && this.dirtyArray.length) {
        for (var i = 0, l = dataset.length; i < l; i++) {
          var row = this.dirtyArray[i];
          if (typeof row !== 'undefined') {
            for (var i2 = 0, l2 = row.length; i2 < l2; i2++) {
              var _col6 = row[i2];
              if (typeof _col6 !== 'undefined' && _col6.isDirty) {
                rows.push(s.treeGrid ? dataset[i].node : dataset[i]);
                break;
              }
            }
          }
        }
      }
      return rows;
    },


    /**
     * Show an error on a row of a given type.
     * @param  {number} row The row index.
     * @param  {string} message The row description.
     * @param  {string} type The error type.
     * @returns {void}
     */
    showRowError: function showRowError(row, message, type) {
      var messageType = type || 'error';
      var rowNode = this.dataRowNode(row);

      rowNode.addClass(type);
      this.rowStatus(row, messageType, message);
    },


    /**
     * Validate all visible cells in a row if they have validation on the column
     * @param  {number} row The row index.
     * @returns {void}
     */
    validateRow: function validateRow(row) {
      if (!row) {
        return;
      }

      for (var i = 0; i < this.settings.columns.length; i++) {
        this.validateCell(row, i);
      }
    },


    /**
     * Validate all rows and cells in the entire grid if they have validation on the column
     * @returns {void}
     */
    validateAll: function validateAll() {
      for (var j = 0; j < this.settings.dataset.length; j++) {
        for (var i = 0; i < this.settings.columns.length; i++) {
          this.validateCell(j, i);
        }
      }
    },


    /**
     * Get the settings for a column by index.
     * @private
     * @param  {number} idx The column index.
     * @returns {array} The settings array
     */
    columnSettings: function columnSettings(idx) {
      var foundColumn = this.settings.columns[idx];
      return foundColumn || {};
    },


    /**
     * Attempt to serialize the value back into the dataset
     * @private
     * @param {any} value The new column value
     * @param {any} oldVal The old column value.
     * @param {number} col The column definition
     * @param {number} row  The row index.
     * @param {number} cell The cell index.
     * @returns {void}
     */
    coerceValue: function coerceValue(value, oldVal, col, row, cell) {
      var newVal = void 0;

      if (col.serialize) {
        newVal = col.serialize(value, oldVal, col, row, cell, this.settings.dataset[row]);
        return newVal;
      } else if (col.sourceFormat) {
        if (value instanceof Date) {
          newVal = Locale.parseDate(value, col.sourceFormat);
        } else {
          newVal = Locale.formatDate(value, { pattern: col.sourceFormat });
        }
      } else if (typeof oldVal === 'number' && value) {
        newVal = Locale.parseNumber(value); // remove thousands sep , keep a number a number
      }

      return newVal;
    },


    /**
     * Update one cell with a specific value
     * @param {number} row  The row index.
     * @param {number} cell The cell index.
     * @param {any} value The value to use.
     * @returns {void}
     */
    updateCell: function updateCell(row, cell, value) {
      var col = this.columnSettings(cell);

      if (value === undefined) {
        value = this.fieldValue(this.settings.dataset[row], col.field);
      }

      this.updateCellNode(row, cell, value, true);
    },


    /**
     * Update one cell with a specific value
     * @private
     * @param {number} row  The row index.
     * @param {number} cell The cell index.
     * @param {any} value The value to use.
     * @param {boolean} fromApiCall Us from an api call.
     * @param {boolean} isInline If the editor is an inline value.
     * @returns {void}
     */
    updateCellNode: function updateCellNode(row, cell, value, fromApiCall, isInline) {
      var coercedVal = void 0;
      var rowNodes = this.rowNodes(row);
      var cellNode = rowNodes.find('td').eq(cell);
      var col = this.settings.columns[cell] || {};
      var formatted = '';
      var formatter = col.formatter ? col.formatter : this.defaultFormatter;
      var isEditor = $('.editor', cellNode).length > 0;
      var isTreeGrid = this.settings.treeGrid;
      var dataRowIndex = this.dataRowIndex(rowNodes);
      if (dataRowIndex === null || dataRowIndex === undefined || isNaN(dataRowIndex)) {
        dataRowIndex = row;
      }
      var rowData = isTreeGrid ? this.settings.treeDepth[row].node : this.settings.dataset[dataRowIndex];

      if (rowNodes.length === 0 && this.settings.paging) {
        // TODO Frozen Editing with Paging
        rowNodes = this.visualRowNode(row);
        cellNode = rowNodes.find('td').eq(cell);
      }
      var oldVal = this.fieldValue(rowData, col.field);

      // Coerce/Serialize value if from cell edit
      if (!fromApiCall) {
        coercedVal = this.coerceValue(value, oldVal, col, row, cell);

        // coerced value may be coerced to empty string, null, or 0
        if (coercedVal === undefined) {
          coercedVal = value;
        }
      } else {
        coercedVal = value;
      }

      // Remove rowStatus icon
      if (rowNodes.length && rowData && !rowData.rowStatus) {
        var rowstatusIcon = rowNodes.find('svg.icon-rowstatus');
        if (rowstatusIcon.length) {
          rowstatusIcon.remove();
        }
      }

      // Remove older tooltip data
      this.removeTooltipData(cellNode);

      // Update the value in the dataset
      if (cell === 0 && rowData && rowData.rowStatus) {
        var svg = cellNode.find('svg.icon-rowstatus');

        if (rowNodes && cellNode[0]) {
          for (var i = 0; i < rowNodes.length; i++) {
            rowNodes[i].classList.add('rowstatus-row-' + rowData.rowStatus.icon);
          }
          cellNode[0].classList.add('rowstatus-cell');

          if (!svg.length) {
            var svgIcon = rowData.rowStatus.icon === 'success' ? '#icon-check' : '#icon-exclamation';
            cellNode.prepend('<svg class="icon icon-rowstatus" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="' + svgIcon + '"></use></svg>');
          }
        }
        if (rowData.rowStatus.tooltip) {
          svg = cellNode.find('svg.icon-rowstatus');
          var statusIcon = rowData.rowStatus.icon;
          this.cacheTooltip(svg, {
            forced: true,
            placement: 'right',
            content: rowData.rowStatus.tooltip,
            isError: statusIcon === 'error' || statusIcon === 'dirtyerror',
            wrapper: cellNode
          });
        }
      }

      coercedVal = xssUtils.unescapeHTML(coercedVal);

      if (col.field && coercedVal !== oldVal) {
        if (col.field.indexOf('.') > -1) {
          var rowDataObj = rowData;
          var nbrParts = col.field.split('.').length;
          col.field.split('.').forEach(function (part, index) {
            if (index === nbrParts - 1) {
              rowDataObj[part] = coercedVal;
            } else {
              rowDataObj = rowDataObj[part];
            }
          });
        } else {
          rowData[col.field] = coercedVal;
        }
      }

      // update cell value
      var escapedVal = xssUtils.escapeHTML(coercedVal);
      var val = isEditor ? coercedVal : escapedVal;
      formatted = this.formatValue(formatter, row, cell, val, col, rowData);

      if (col.contentVisible) {
        var canShow = col.contentVisible(row, cell, escapedVal, col, rowData);
        if (!canShow) {
          formatted = '';
        }
      }

      if (!isInline) {
        cellNode.find('.datagrid-cell-wrapper').html(formatted);
      }

      if (!fromApiCall) {
        // Validate the cell
        this.validateCell(dataRowIndex, cell);

        // Update and set trackdirty
        if (this.isDirtyCellNotUndefined(row, cell)) {
          this.dirtyArray[row][cell].value = value;
          this.dirtyArray[row][cell].coercedVal = coercedVal;
          this.dirtyArray[row][cell].escapedCoercedVal = xssUtils.escapeHTML(coercedVal);
          this.dirtyArray[row][cell].cellNodeText = cellNode.text();
          this.setIsDirtyAndIcon(row, cell, cellNode);
        }
      }

      if (coercedVal !== oldVal && !fromApiCall) {
        var args = {
          row: this.settings.source !== null ? dataRowIndex : row,
          relativeRow: row,
          cell: cell,
          target: cellNode,
          value: coercedVal,
          oldValue: oldVal,
          column: col
        };
        args.rowData = isTreeGrid && this.settings.treeDepth[row] ? this.settings.treeDepth[row].node : rowData;

        /**
         * Fires when a cell value is changed via the editor.
         * @event cellchange
         * @memberof Datagrid
         * @property {object} event The jquery event object
         * @property {object} args Additional arguments
         * @property {number} args.row An array of selected rows.
         * @property {number} args.cell An array of selected rows.
         * @property {HTMLElement} args.target The cell html element that was entered.
         * @property {any} args.value The cell value.
         * @property {any} args.oldValue The previous cell value.
         * @property {object} args.column The column object
         */
        this.element.trigger('cellchange', args);
        this.wasJustUpdated = true;
      }
    },


    /**
     * Function to check if given cell has true value for isDirty
     * @private
     * @param {number} row The row index
     * @param {number} cell The cell index
     * @returns {boolean} true if isDirty
     */
    isCellDirty: function isCellDirty(row, cell) {
      return this.isDirtyCellNotUndefined(row, cell) ? this.dirtyArray[row][cell].isDirty : false;
    },


    /**
     * Set isDirty value and Add/Remove dirty icon to given cell
     * must checked before to be true from `isDirtyCellNotUndefined(row, cell)`
     * must checked before not undefined `cellNode`
     * @private
     * @param {number} row The row index
     * @param {number} cell The cell index
     * @param {object} cellNode jQuery cell node
     * @returns {void}
     */
    setIsDirtyAndIcon: function setIsDirtyAndIcon(row, cell, cellNode) {
      var d = this.dirtyArray[row][cell];
      if (d.originalVal === d.value || d.originalVal === d.coercedVal || d.originalVal === d.escapedCoercedVal || d.originalVal === d.cellNodeText) {
        this.dirtyArray[row][cell].isDirty = false;
        cellNode[0].classList.remove('is-dirty-cell');
      } else {
        this.dirtyArray[row][cell].isDirty = true;
        cellNode[0].classList.add('is-dirty-cell');
      }
    },


    /**
     * Function to check given cell is cache to dirtyArray
     * @private
     * @param {number} row The row index
     * @param {number} cell The cell index
     * @returns {boolean} true if found
     */
    isDirtyCellNotUndefined: function isDirtyCellNotUndefined(row, cell) {
      return this.settings.showDirty && typeof row === 'number' && typeof cell === 'number' && row > -1 && cell > -1 && typeof this.dirtyArray !== 'undefined' && typeof this.dirtyArray[row] !== 'undefined' && typeof this.dirtyArray[row][cell] !== 'undefined';
    },


    /**
     * For the row node get the index adjusting for paging / invisible rowsCache
     * @private
     * @param {number} row The row index
     * @returns {number} The row index adjusted for paging/non visible rows.
     */
    visualRowIndex: function visualRowIndex(row) {
      var selector = 'tr:visible:not(.is-hidden, .datagrid-expandable-row)';
      var idx = this.tableBody.find(selector).index(row);
      if (idx === -1 && this.tableBodyLeft) {
        idx = this.tableBodyLeft.find(selector).index(row);
      }
      if (idx === -1 && this.tableBodyRight) {
        idx = this.tableBodyRight.find(selector).index(row);
      }
      return idx;
    },


    /**
     * For the row index get the node adjusting for paging / invisible rowsCache
     * @private
     * @param {number} idx The row index
     * @returns {object} The row node adjusted for paging/non visible rows.
     */
    visualRowNode: function visualRowNode(idx) {
      var rowIdx = idx;

      if (this.settings.paging && this.settings.source) {
        rowIdx += (this.pagerAPI.activePage - 1) * this.settings.pagesize;
      }

      if (!this.isRowVisible(idx)) {
        return $([]);
      }

      return this.tableBody.find('tr[aria-rowindex="' + (rowIdx + 1) + '"]');
    },


    /**
     * For an internal row index, get the dataset row index
     * @private
     * @param {number} idx The row index
     * @returns {object} The row index in the dataset.
     */
    actualRowNode: function actualRowNode(idx) {
      return this.tableBody.find('tr[aria-rowindex="' + (idx + 1) + '"]');
    },


    /**
     * Returns the row dom jQuery node.
     * @param  {number} row The row index.
     * @returns {object} The dom jQuery node
     */
    rowNodes: function rowNodes(row) {
      if (row instanceof jQuery) {
        row = row.attr('aria-rowindex') - 1;
      }
      var leftNodes = this.tableBodyLeft ? this.tableBodyLeft.find('tr[aria-rowindex="' + (row + 1) + '"]') : $();
      var centerNodes = this.tableBody.find('tr[aria-rowindex="' + (row + 1) + '"]');
      var rightNodes = this.tableBodyRight ? this.tableBodyRight.find('tr[aria-rowindex="' + (row + 1) + '"]') : $();

      return $(centerNodes).add(leftNodes).add(rightNodes);
    },

    /**
     * Returns the cell dom node.
     * @param  {number} row The row index.
     * @param  {number} cell The cell index.
     * @returns {object} The dom node
     */
    cellNode: function cellNode(row, cell) {
      var cells = this.rowNodes(row).find('td');
      return cells.eq(cell >= cells.length ? cells.length - 1 : cell);
    },


    /**
     * For an internal row node, get the dataset row index.
     * @private
     * @param {number} row The row node.
     * @returns {object} The row index in the dataset.
     */
    actualRowIndex: function actualRowIndex(row) {
      return row.attr('aria-rowindex') - 1;
    },


    /**
     * For an internal row index, get row index across page number.
     * This may or may not be the one in the dataset.
     * @private
     * @param {number} idx The row idx.
     * @returns {object} The row index
     */
    pagingRowIndex: function pagingRowIndex(idx) {
      var rowIdx = idx;

      if (this.settings.paging && this.settings.source && !this.settings.indeterminate) {
        rowIdx += (this.pagerAPI.activePage - 1) * this.settings.pagesize;
      }
      return rowIdx;
    },


    /**
     * For an internal row index, get row index across page number.
     * This may or may not be the one in the dataset.
     * @private
     * @param {number} idx The row idx.
     * @returns {object} The row index
     */
    actualPagingRowIndex: function actualPagingRowIndex(idx) {
      var rowIdx = idx;

      if (this.settings.paging && this.settings.source && !this.settings.indeterminate) {
        rowIdx -= (this.pagerAPI.activePage - 1) * this.settings.pagesize;
      }
      return rowIdx;
    },


    /**
     * Return the data node for a row. This is the newer way of getting this info.
     * @private
     * @param {number} idx The row idx to find
     * @returns {object} The row node
     */
    dataRowNode: function dataRowNode(idx) {
      return this.tableBody.find('tr[data-index="' + idx + '"]');
    },


    /**
     * Return the data index for a row. This is the newer way of getting this info.
     * @private
     * @param {number} row The row idx
     * @returns {number} The row index in the dataset.
     */
    dataRowIndex: function dataRowIndex(row) {
      return parseInt(row.attr('data-index'), 10);
    },


    /**
     * Sets focus on a cell.
     * @param  {number} row The row index
     * @param  {number} cell The cell index
     */
    setActiveCell: function setActiveCell(row, cell) {
      var self = this;
      var prevCell = self.activeCell;
      var rowElem = row;
      var rowNum = void 0;
      var rowIndex = void 0;
      var dataRowNum = void 0;
      var isGroupRow = row instanceof jQuery && row.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');

      if (row instanceof jQuery && row.length === 0) {
        return;
      }

      if (typeof row === 'number') {
        rowNum = row;
        rowElem = this.tableBody.find('tr:visible').eq(row);
        rowIndex = this.actualRowIndex(rowElem);
        dataRowNum = this.dataRowIndex(rowElem);
      }

      // Support passing the td in to focus that cell
      if (row instanceof jQuery && row.is('td')) {
        isGroupRow = row.parent().is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');
        if (isGroupRow) {
          rowElem = row.parent();
        }
        cell = row.attr('aria-colindex') - 1;
        rowNum = this.visualRowIndex(row.parent());
        rowIndex = this.actualRowIndex(row.parent());
        dataRowNum = this.dataRowIndex(row.parent());
        rowElem = row.parent();
      }

      if (row instanceof jQuery && row.is('tr')) {
        rowNum = this.visualRowIndex(row);
        rowIndex = this.actualRowIndex(row);
        dataRowNum = this.dataRowIndex(row);
        rowElem = row;
      }

      if (rowNum < 0 || cell < 0) {
        return;
      }

      // Remove previous tab index
      if (prevCell.node && prevCell.node.length === 1) {
        self.activeCell.node.removeAttr('tabindex').removeClass('is-active');
      }

      // Hide any cell tooltips (Primarily for validation)
      if (prevCell.cell !== cell || prevCell.row !== row) {
        self.hideTooltip();
      }

      // Find the cell if it exists
      self.activeCell.node = self.cellNode(isGroupRow || rowElem ? rowElem : rowIndex > -1 ? rowIndex : rowNum, cell).attr('tabindex', '0');

      if (self.activeCell.node && prevCell.node.length === 1) {
        self.activeCell.row = rowNum;
        self.activeCell.cell = cell;
        rowIndex = this.actualRowIndex(self.activeCell.node.parent());
        dataRowNum = this.dataRowIndex(self.activeCell.node.parent());
      } else {
        self.activeCell = prevCell;
      }

      if (!$('input, button:not(.btn-secondary, .row-btn, .datagrid-expand-btn, .datagrid-drilldown, .btn-icon)', self.activeCell.node).length) {
        self.activeCell.node.focus();
        if (isGroupRow) {
          self.activeCell.groupNode = self.activeCell.node;
        }
      }
      if (self.activeCell.node.hasClass('is-focusable')) {
        self.activeCell.node.find('button').focus();
      }

      if (dataRowNum !== undefined) {
        self.activeCell.dataRow = dataRowNum;
      }

      if (rowIndex !== undefined) {
        self.activeCell.rowIndex = rowIndex;
      }

      var colSpan = +rowElem.find('td[colspan]').attr('colspan');

      if (isGroupRow && self.activeCell.node && prevCell.node && !(row instanceof jQuery && row.is('td'))) {
        if (cell < colSpan) {
          rowElem.find('td[colspan]').attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td[colspan]');
        } else if (cell >= colSpan) {
          rowElem.find('td').eq(cell - colSpan + 1).attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td').eq(cell - colSpan + 1);
        } else {
          rowElem.find('td').eq(cell).attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td').eq(cell);
        }
      }

      if (isGroupRow && row instanceof jQuery && row.is('td')) {
        self.activeCell.cell = colSpan - 1 + cell;
        if (row.is('[colspan]')) {
          self.activeCell.cell = cell;
        }
      }

      if (this.settings.cellNavigation) {
        var headers = self.headerNodes();
        var prevSpans = 0;

        // Check if any previous rows are spanned
        if (this.hasColSpans) {
          prevSpans = 0;

          headers.eq(cell).prevAll('[colspan]').each(function (i, elem) {
            var span = $(elem).attr('colspan') - 1;
            prevSpans += span;
          });

          cell -= prevSpans;
        }

        headers.removeClass('is-active');
        headers.eq(cell).addClass('is-active');
      }
      this.activeCell.isFocused = true;

      // Expand On Activate Feature
      var col = this.settings.columns[cell];
      if (col && col.expandOnActivate && this.activeCell && this.activeCell.node) {
        self.activeCell.node.addClass('is-active');
      }

      self.syncBodyScroll(self.activeCell.node);

      /**
      * Fires when a cell is focued.
      * @event activecellchange
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {HTMLElement} args.node  The cell element that was entered.
      * @property {number} args.cell The selected cell
      * @property {number} args.row The selected row
      */
      self.element.trigger('activecellchange', [{ node: this.activeCell.node, row: this.activeCell.row, cell: this.activeCell.cell }]);
    },


    /**
     * Sets focus to the next active cell, depending on a key.
     * @private
     * @param {object} e The event object
     */
    setNextActiveCell: function setNextActiveCell(e) {
      var self = this;
      if (e.type === 'keydown') {
        if (this.settings.actionableMode) {
          setTimeout(function () {
            var evt = $.Event('keydown.datagrid');
            evt.keyCode = 40; // move down
            self.activeCell.node.trigger(evt);
          }, 0);
        } else {
          this.setActiveCell(this.activeCell.row, this.activeCell.cell);
        }
      }
    },


    /**
     * Add children to treegrid dataset
     * @private
     * @param {object} parent The parent object
     * @param {object} data The data for the child
     */
    addChildren: function addChildren(parent, data) {
      if (!data || data && !data.length || parent < 0) {
        return;
      }
      var node = this.settings.treeDepth[parent].node;
      node.children = node.children || [];

      // Make sure it's not reference pointer to data object, make copy of data
      data = JSON.parse(JSON.stringify(data));

      for (var i = 0, len = data.length; i < len; i++) {
        node.children.push(data[i]);
      }
      this.updateDataset(this.settings.dataset);
    },


    /**
     * Set the expanded property in the dataset
     * @private
     * @param {number} dataRowIndex The index in the dataset.
     * @param {boolean} isExpanded Expanded value to set.
     */
    setExpandedInDataset: function setExpandedInDataset(dataRowIndex, isExpanded) {
      this.settings.treeDepth[dataRowIndex].node.expanded = isExpanded;
    },


    /**
     * Expand the tree children
     * @private
     * @param {object} e The event data from the click or keyboard event.
     * @param {number} dataRowIndex Index in the dataset
     */
    toggleChildren: function toggleChildren(e, dataRowIndex) {
      if (this.settings.groupable) {
        return;
      }
      var self = this;
      var rowElement = this.settings.treeGrid ? this.actualRowNode(dataRowIndex) : this.visualRowNode(dataRowIndex);
      var expandButton = rowElement.find('.datagrid-expand-btn');
      var level = parseInt(rowElement.attr('aria-level'), 10);
      var children = rowElement.nextUntil('[aria-level="' + level + '"]');
      var isExpanded = expandButton.hasClass('is-expanded');
      var args = [{ grid: self, row: dataRowIndex, item: rowElement, children: children }];

      if (self.settings.treeDepth && self.settings.treeDepth[dataRowIndex]) {
        args[0].rowData = self.settings.treeDepth[dataRowIndex].node;
      }

      if (!rowElement.hasClass('datagrid-tree-parent') || !$(e.target).is(expandButton) && (self.settings.editable || self.settings.selectable)) {
        return;
      }

      var toggleExpanded = function toggleExpanded() {
        rowElement = self.settings.treeGrid ? self.actualRowNode(dataRowIndex) : self.visualRowNode(dataRowIndex);
        expandButton = rowElement.find('.datagrid-expand-btn');
        children = rowElement.nextUntil('[aria-level="' + level + '"]');

        if (isExpanded) {
          rowElement.attr('aria-expanded', false);
          expandButton.removeClass('is-expanded').find('.plus-minus').removeClass('active');
        } else {
          rowElement.attr('aria-expanded', true);
          expandButton.addClass('is-expanded').find('.plus-minus').addClass('active');
        }
        self.setExpandedInDataset(dataRowIndex, !isExpanded);

        var setChildren = function setChildren(elem, lev, expanded) {
          var nodes = elem.nextUntil('[aria-level="' + level + '"]');

          if (expanded) {
            nodes.each(function () {
              var node = $(this);
              var nodeLevel = parseInt(node.attr('aria-level'), 10);
              if (nodeLevel > lev) {
                node.addClass('is-hidden');
              }
            });
          } else {
            nodes.each(function () {
              var node = $(this);
              var nodeLevel = parseInt(node.attr('aria-level'), 10);

              if (nodeLevel === lev + 1) {
                if (!node.hasClass('is-filtered')) {
                  node.removeClass('is-hidden');
                }

                if (node.is('.datagrid-tree-parent')) {
                  var nodeIsExpanded = node.find('.datagrid-expand-btn.is-expanded').length > 0;
                  if (nodeIsExpanded) {
                    setChildren(node, nodeLevel, !nodeIsExpanded);
                  }
                }
              }
            });
          }
        };

        setChildren(rowElement, level, isExpanded);
        self.setAlternateRowShading();
      };

      /**
      * Fires when a row is collapsed to show its detail.
      * @event collapserow
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {object} args.self The grid api.
      * @property {number} args.row The selected row index
      * @property {object} args.item The selected row data.
      * @property {array} args.children The selected rows children (tree grid)
      */

      /**
      * Fires when a row is expanded to show its detail.
      * @event expandrow
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {object} args.self The grid api.
      * @property {number} args.row The selected row index
      * @property {object} args.item The selected row data.
      * @property {array} args.children The selected rows children (tree grid)
      */
      $.when(self.element.triggerHandler(isExpanded ? 'collapserow' : 'expandrow', args)).done(function () {
        toggleExpanded();
      });
    },


    /**
     * Expand Detail Row Or Tree Row
     * @param  {number} dataRowIndex The row to toggle
     * @returns {void}
     */
    toggleRowDetail: function toggleRowDetail(dataRowIndex) {
      var self = this;
      var rowElement = self.rowNodes(dataRowIndex);
      if (!rowElement.length && self.settings.paging && (self.settings.rowTemplate || self.settings.expandableRow)) {
        dataRowIndex += (self.pagerAPI.activePage - 1) * self.settings.pagesize;
        rowElement = self.dataRowNode(dataRowIndex);
      }
      var expandRow = rowElement.next();
      var expandButton = rowElement.find('.datagrid-expand-btn');
      var detail = expandRow.find('.datagrid-row-detail');
      var item = self.settings.dataset[self.dataRowIndex(rowElement)];

      if (rowElement.hasClass('datagrid-tree-parent')) {
        return;
      }

      if (self.settings.allowOneExpandedRow && self.settings.groupable === null) {
        // collapse any other expandable rows
        var prevExpandRow = self.tableBody.find('tr.is-expanded');
        var prevExpandButton = prevExpandRow.prev().find('.datagrid-expand-btn');
        var parentRow = prevExpandRow.prev();
        var parentRowIdx = self.actualRowNode(parentRow);
        var parentdataRowIdx = self.dataRowIndex(parentRow);

        if (prevExpandRow.length && expandRow.index() !== prevExpandRow.index()) {
          var prevDetail = prevExpandRow.find('.datagrid-row-detail');

          prevExpandRow.add(prevExpandButton).removeClass('is-expanded');
          parentRow.removeClass('is-rowactivated');
          parentRow.find('.plus-minus').removeClass('active');
          prevDetail.animateClosed().on('animateclosedcomplete', function () {
            prevExpandRow.removeClass('is-expanded');
            self.element.triggerHandler('collapserow', [{ grid: self, row: parentRowIdx, detail: prevDetail, item: self.settings.dataset[parentdataRowIdx] }]);
          });

          var prevActionBtn = prevExpandRow.prev().find('.btn-primary');
          if (prevActionBtn.length) {
            prevActionBtn.attr('class', prevActionBtn.attr('class').replace('btn-primary', 'btn-secondary'));
          }
        }

        // Toggle the button to make it primary
        var isExpanded = !expandRow.hasClass('is-expanded');
        var actionButton = expandRow.prev().find(isExpanded ? '.btn-secondary' : '.btn-primary');

        if (actionButton.length > 0 && parentRow && actionButton) {
          var currentClass = actionButton.attr('class') || '';

          actionButton.attr('class', currentClass.replace(isExpanded ? 'btn-secondary' : 'btn-primary', isExpanded ? 'btn-primary' : 'btn-secondary'));
        }
      }

      if (expandRow.hasClass('is-expanded')) {
        // expandRow.removeClass('is-expanded');
        detail.one('animateclosedcomplete', function () {
          expandRow.removeClass('is-expanded');
        }).animateClosed();

        expandButton.removeClass('is-expanded').find('.plus-minus').removeClass('active');

        if (self.settings.allowOneExpandedRow) {
          rowElement.removeClass('is-rowactivated');
        }

        // detail.animateClosed();
        self.element.triggerHandler('collapserow', [{ grid: self, row: dataRowIndex, detail: detail, item: item }]);
      } else {
        expandRow.addClass('is-expanded');
        expandButton.addClass('is-expanded').find('.plus-minus').addClass('active');

        // Optionally Contstrain the width
        expandRow.find('.constrained-width').css('max-width', this.element.outerWidth());

        var eventData = [{ grid: self, row: dataRowIndex, detail: detail, item: item }];
        self.element.triggerHandler('expandrow', eventData);

        if (self.settings.allowOneExpandedRow) {
          rowElement.addClass('is-rowactivated');
        }

        if (self.settings.onExpandRow) {
          var response = function response(markup) {
            if (markup) {
              detail.find('.datagrid-row-detail-padding').empty().append(markup);
            }
            detail.animateOpen();
          };

          self.settings.onExpandRow(eventData[0], response);
        } else {
          detail.animateOpen();
        }
      }
    },


    /**
     * Expand the grouped row children
     * @private
     * @param {object} rowElement The row DOM element
     */
    toggleGroupChildren: function toggleGroupChildren(rowElement) {
      if (!this.settings.groupable) {
        return;
      }

      var self = this;
      var rowIdx = rowElement.index();
      var childrenLeft = $();
      var children = $();
      var childrenRight = $();

      if (this.hasLeftPane) {
        childrenLeft = this.tableLeft.find('tr').eq(rowIdx).nextUntil('.datagrid-rowgroup-header');
      }
      children = this.table.find('tr').eq(rowIdx).nextUntil('.datagrid-rowgroup-header');
      if (this.hasRightPane) {
        childrenRight = this.tableRight.find('tr').eq(rowIdx).nextUntil('.datagrid-rowgroup-header');
      }
      var expandButton = rowElement.find('.datagrid-expand-btn');

      if (rowElement.hasClass('is-expanded')) {
        expandButton.removeClass('is-expanded').find('.plus-minus').removeClass('active');

        childrenLeft.hide();
        childrenLeft.addClass('is-hidden');
        children.hide();
        children.addClass('is-hidden');
        childrenRight.hide();
        childrenRight.addClass('is-hidden');
        self.element.triggerHandler('collapserow', [{ grid: self, row: rowElement.index(), detail: children, item: {} }]);

        rowElement.removeClass('is-expanded');
      } else {
        expandButton.addClass('is-expanded').find('.plus-minus').addClass('active');

        childrenLeft.show();
        childrenLeft.removeClass('is-hidden');
        children.show();
        children.removeClass('is-hidden');
        childrenRight.show();
        childrenRight.removeClass('is-hidden');
        self.element.triggerHandler('expandrow', [{ grid: self, row: rowElement.index(), detail: children, item: {} }]);

        rowElement.addClass('is-expanded');
      }
    },


    /**
     * Set the current datagrid sort column
     * @param {string} id The column id
     * @param {boolean} ascending Set the sort in ascending or descending order
     */
    setSortColumn: function setSortColumn(id, ascending) {
      // Set Direction based on if passed in or toggling existing field
      if (ascending !== undefined) {
        this.sortColumn.sortAsc = ascending;
      } else {
        if (this.sortColumn.sortId === id) {
          this.sortColumn.sortAsc = !this.sortColumn.sortAsc;
        } else {
          this.sortColumn.sortAsc = true;
        }
        ascending = this.sortColumn.sortAsc;
      }

      this.sortColumn.sortId = id;
      this.sortColumn.sortField = this.columnById(id)[0] ? this.columnById(id)[0].field : id;
      this.sortColumn.sortAsc = ascending;

      // Do Sort on Data Set
      this.setSortIndicator(id, ascending);
      this.sortDataset();

      if (!this.settings.focusAfterSort && this.activeCell && this.activeCell.isFocused) {
        this.activeCell.isFocused = false;
      }

      var wasFocused = this.activeCell.isFocused;
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();
      this.renderRows();
      // Update selected and Sync header checkbox
      this.syncSelectedUI();

      if (wasFocused && this.activeCell.node.length === 1) {
        this.setActiveCell(this.activeCell.row, this.activeCell.cell);
      }

      this.resetPager('sorted');
      this.tableBody.removeClass('is-loading');
      this.saveUserSettings();
      this.validateAll();
      this.element.trigger('sorted', [this.sortColumn]);
    },


    /**
     * Sort the currently attached dataset.
     * @private
     */
    sortDataset: function sortDataset() {
      if (this.settings.disableClientSort) {
        this.restoreSortOrder = true;
        return;
      }

      if (this.originalDataset) {
        this.settings.dataset = this.originalDataset;
      }
      var sort = this.sortFunction(this.sortColumn.sortId, this.sortColumn.sortAsc);

      this.setDirtyBeforeSort();
      this.settings.dataset.sort(sort);
      this.setTreeDepth();
      this.setDirtyAfterSort();

      // Resync the _selectedRows array
      if (this.settings.selectable) {
        this.syncDatasetWithSelectedRows();
      }
    },


    /**
    * Set current data to sync up dirtyArray before sort
    * @private
    * @returns {void}
    */
    setDirtyBeforeSort: function setDirtyBeforeSort() {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      if (s.showDirty && !this.settings.source && this.dirtyArray && this.dirtyArray.length) {
        for (var i = 0, l = dataset.length; i < l; i++) {
          if (typeof this.dirtyArray[i] !== 'undefined') {
            var node = s.treeGrid ? dataset[i].node : dataset[i];
            node.tempNodeIndex = i;
          }
        }
      }
    },


    /**
    * Set current data to sync up dirtyArray after sort
    * @private
    * @returns {void}
    */
    setDirtyAfterSort: function setDirtyAfterSort() {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      if (s.showDirty && this.dirtyArray && this.dirtyArray.length) {
        var changes = [];
        for (var i = 0, l = dataset.length; i < l; i++) {
          var node = s.treeGrid ? dataset[i].node : dataset[i];
          if (typeof node.tempNodeIndex !== 'undefined') {
            changes.push({ newIdx: i, oldIdx: node.tempNodeIndex });
            delete node.tempNodeIndex;
          }
        }
        var newDirtyArray = [];
        for (var _i8 = 0, _l2 = changes.length; _i8 < _l2; _i8++) {
          newDirtyArray[changes[_i8].newIdx] = this.dirtyArray[changes[_i8].oldIdx];
        }
        this.dirtyArray = newDirtyArray;
      }
    },


    /**
    * Sync the dataset._selected elements with the _selectedRows array
    * @private
    */
    syncDatasetWithSelectedRows: function syncDatasetWithSelectedRows() {
      this._selectedRows = [];
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var idx = -1;

      for (var i = 0, data; i < dataset.length; i++) {
        if (s.groupable) {
          for (var k = 0; k < dataset[i].values.length; k++) {
            idx++;
            data = dataset[i].values[k];
            if (this.isRowSelected(data)) {
              this._selectedRows.push({
                idx: idx,
                data: data,
                elem: this.dataRowNode(idx),
                group: dataset[i],
                page: this.pagerAPI ? this.pagerAPI.activePage : 1,
                pagingIdx: idx,
                pagesize: this.settings.pagesize
              });
            }
          }
        } else {
          data = s.treeGrid ? dataset[i].node : dataset[i];
          if (this.isRowSelected(data)) {
            this._selectedRows.push({
              idx: i,
              data: data,
              elem: this.visualRowNode(i),
              pagesize: this.settings.pagesize,
              page: this.pagerAPI ? this.pagerAPI.activePage : 1,
              pagingIdx: idx
            });
          }
        }
      }
    },


    /**
     * Sort the ui sort indicator on the column.
     * @private
     * @param {string} id The column id
     * @param {boolean} ascending Set the sort in ascending or descending order
     */
    setSortIndicator: function setSortIndicator(id, ascending) {
      if (!this.headerRow) {
        return;
      }

      // Set Visual Indicator
      this.headerContainer.find('.is-sorted-asc, .is-sorted-desc').removeClass('is-sorted-asc is-sorted-desc').attr('aria-sort', 'none');
      this.headerContainer.find('[data-column-id="' + id + '"]').addClass(ascending ? 'is-sorted-asc' : 'is-sorted-desc').attr('aria-sort', ascending ? 'ascending' : 'descending');
    },


    /**
    * Overridable function to conduct array sorting
    * @param {string} id The matching field/id in the array to sort on
    * @param {boolean} ascending Determines direction of the sort.
    * @returns {boolean} If found.
    */
    sortFunction: function sortFunction(id, ascending) {
      var column = this.columnById(id);
      // Assume the field and id match if no column found
      var field = column.length === 0 ? id : column[0].field;

      var self = this;
      var primer = function primer(a) {
        a = a === undefined || a === null ? '' : a;

        if (typeof a === 'string') {
          a = a.toUpperCase();

          if ($.isNumeric(a)) {
            a = parseFloat(a);
          }
        }
        return a;
      };

      var key = function key(x) {
        return primer(self.fieldValue(x, field));
      };

      ascending = !ascending ? -1 : 1;

      return function (a, b) {
        a = key(a);
        b = key(b);

        if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== (typeof b === 'undefined' ? 'undefined' : _typeof(b))) {
          a = a.toString().toLowerCase();
          b = b.toString().toLowerCase();
        }

        return ascending * ((a > b) - (b > a));
      };
    },


    /**
    * Determine equality for two deeply nested JavaScript objects.
    * @private
    * @param {object} obj1 First object to compare
    * @param {object} obj2 Second object to compare
    * @returns {boolean} If it is equal or not
    */
    isEquivalent: function isEquivalent(obj1, obj2) {
      function _equals(a, b) {
        return JSON.stringify(a) === JSON.stringify($.extend(true, {}, a, b));
      }
      return _equals(obj1, obj2) && _equals(obj2, obj1);
    },


    /**
     * The default formatter to use (just plain text). When no formatter is specified.
     * @param  {number} row The rowindex
     * @param  {number} cell The cell index
     * @param  {any} value The data value
     * @returns {string} The html string
     */
    defaultFormatter: function defaultFormatter(row, cell, value) {
      return value === null || value === undefined || value === '' ? '' : value.toString();
    },


    /**
    * Add the pager and paging functionality.
    * @private
    */
    handlePaging: function handlePaging() {
      if (!this.settings.paging) {
        return;
      }

      this.element.addClass('paginated');
      this.tableBody.pager({
        componentAPI: this,
        dataset: this.settings.dataset,
        hideOnOnePage: this.settings.hidePagerOnOnePage,
        source: this.settings.source,
        pagesize: this.settings.pagesize,
        indeterminate: this.settings.indeterminate,
        rowTemplate: this.settings.rowTemplate,
        pagesizes: this.settings.pagesizes,
        showPageSizeSelector: this.settings.showPageSizeSelector,
        activePage: this.restoreActivePage ? parseInt(this.savedActivePage, 10) : 1
      });

      if (this.restoreActivePage) {
        this.savedActivePage = null;
        this.restoreActivePage = false;
      }
    },


    /**
    * Add the pager and paging functionality.
    * @param {string} pagingInfo The paging object with activePage ect used by pager.js
    * @param {boolean} isResponse Internal flag used to prevent callbacks from rexecuting.
    * @param {function} callback The callback function.
    */
    renderPager: function renderPager(pagingInfo, isResponse, callback) {
      if (!this.pagerAPI) {
        return;
      }

      if (!this.settings.source) {
        this.pagerAPI.settings.dataset = this.settings.dataset;
        pagingInfo.isFilteredClientside = true;
      }

      this.pagerAPI.updatePagingInfo(pagingInfo, isResponse);

      if (!isResponse) {
        this.triggerSource(pagingInfo, callback);
      }

      // Update selected and Sync header checkbox
      this.syncSelectedUI();
    },


    /**
    * Reset the pager to the first page.
    * @private
    * @param {string} type The action type, which gets sent to the source callback.
    * @param {string} trigger The triggering action
    */
    resetPager: function resetPager(type, trigger) {
      if (!this.pagerAPI) {
        return;
      }

      this.pagerAPI.reset(type, trigger);
    },


    /**
     * Reliably gets all the pre-rendered elements in the container and returns them for use.
     * @private
     * @returns {array} TThe pagable items
     */
    getPageableElements: function getPageableElements() {
      var elements = this.element.children().not('.datagrid-expandable-row');
      if (elements.is('table')) {
        elements = elements.find('tr');
      }
      return elements;
    },


    /**
    * Add grid tooltip to the page.
    * @private
    * @param {string} extraClass class to add to target uniqueness
    * @returns {void}
    */
    appendTooltip: function appendTooltip(extraClass) {
      var _this10 = this;

      var defaultClass = 'grid-tooltip';
      var regExp = new RegExp('\\b' + defaultClass + '\\b', 'g');

      // Set default css class
      if (typeof extraClass === 'string') {
        if (!regExp.test(extraClass)) {
          extraClass += ' ' + defaultClass;
        }
      } else {
        extraClass = defaultClass;
      }

      // Unique id for tooltip
      var tooltipId = this.uniqueId('tooltip');
      this.tooltip = document.getElementById(tooltipId);

      if (!this.tooltip) {
        var tooltip = '' + ('<div id="' + tooltipId + '" class="tooltip ' + extraClass + ' is-hidden">\n          <div class="arrow"></div>\n          <div class="tooltip-content"></div>\n        </div>');
        document.body.insertAdjacentHTML('beforeend', tooltip);

        this.tooltip = document.getElementById(tooltipId);

        if (this.isTouch) {
          this.tooltip.style.pointerEvents = 'auto';
          $(this.tooltip).on('touchend.gridtooltip', function () {
            _this10.hideTooltip();
          });
        }
      }
    },


    /**
     * Cache tooltip content so it can use for more then once
     * @private
     * @param  {object} elem The element to be cached.
     * @param  {object} tooltip Optional to cache given data.
     * @returns {object} tooltip object.
     */
    cacheTooltip: function cacheTooltip(elem, tooltip) {
      if (typeof tooltip === 'undefined') {
        var contentTooltip = elem.querySelector('.is-editor.content-tooltip');
        var aTitle = elem.querySelector('a[title]');
        var isRowstatus = utils.hasClass(elem, 'rowstatus-cell');
        var isSvg = elem.tagName.toLowerCase() === 'svg';
        var isTh = elem.tagName.toLowerCase() === 'th';
        var isHeaderColumn = utils.hasClass(elem, 'datagrid-column-wrapper');
        var isHeaderFilter = utils.hasClass(elem.parentNode, 'datagrid-filter-wrapper');
        var title = void 0;

        tooltip = { content: '', wrapper: elem.querySelector('.datagrid-cell-wrapper') };

        if (isTh || isHeaderColumn || isHeaderFilter) {
          tooltip.wrapper = elem;
          tooltip.distance = isHeaderFilter ? 15 : null;
          tooltip.placement = isHeaderColumn ? 'top' : 'bottom';
        }

        // Cache rowStatus cell
        if (isRowstatus || isSvg) {
          var rowNode = this.closest(elem, function (el) {
            return utils.hasClass(el, 'datagrid-row');
          });
          var classList = rowNode ? rowNode.classList : [];
          tooltip.isError = classList.contains('rowstatus-row-error');
          tooltip.placement = 'right';

          // For nonVisibleCellErrors
          if (isSvg) {
            tooltip.wrapper = this.closest(elem, function (el) {
              return el.tagName.toLowerCase() === 'td';
            });
          }
        }

        if (contentTooltip) {
          // Used with rich text editor
          var cell = elem.getAttribute('aria-colindex') - 1;
          var _col7 = this.columnSettings(cell);
          var width = _col7.editorOptions && _col7.editorOptions.width ? this.setUnit(_col7.editorOptions.width) : false;

          // Width for tooltip can be come from column options
          contentTooltip.style.width = width || elem.offsetWidth + 'px';
          var wrapperHTML = tooltip.wrapper.innerHTML;

          if (xssUtils.stripHTML(wrapperHTML) !== '') {
            tooltip.content = wrapperHTML;
            tooltip.extraClassList = ['popover', 'alternate', 'content-tooltip'];
          }
        } else if (aTitle) {
          // Title attribute on links `a`
          tooltip.content = aTitle.getAttribute('title');
          aTitle.removeAttribute('title');
        } else {
          title = elem.getAttribute('title');
          if (title) {
            // Title attribute on current element
            tooltip.content = title;
            elem.removeAttribute('title');
          } else if (isTh && !isHeaderFilter) {
            var targetEl = elem.querySelector('.datagrid-header-text');
            tooltip.content = targetEl ? xssUtils.stripHTML(targetEl.textContent) : '';
          } else if (isHeaderFilter) {
            // Disabled filterable headers
            var filterDisabled = elem.parentNode.querySelectorAll('.dropdown.is-disabled, input[type="text"][disabled], .btn-filter[disabled]').length > 0;
            if (!filterDisabled) {
              var _targetEl = elem.parentNode.querySelector('.is-checked');
              tooltip.content = _targetEl ? xssUtils.stripHTML(_targetEl.textContent) : '';
            }
          } else {
            // Default use wrapper content
            tooltip.content = xssUtils.stripHTML(tooltip.wrapper.textContent);
          }
        }

        // Clean up text in selects
        var select = tooltip.wrapper.querySelector('select');
        if (select && select.selectedIndex && select.options[select.selectedIndex] && select.options[select.selectedIndex].innerHTML) {
          tooltip.content = Environment.features.touch ? '' : select.options[select.selectedIndex].innerHTML.trim();
        }

        if (isTh) {
          tooltip.content = tooltip.content.trim();
        }

        if (tooltip.content !== '') {
          var isEllipsis = utils.hasClass(isHeaderColumn ? elem.parentNode : elem, 'text-ellipsis');
          var icons = [].slice.call(elem.querySelectorAll('.icon'));
          var extraWidth = isEllipsis ? 8 : 0;
          icons.forEach(function (icon) {
            extraWidth += icon.getBBox().width + 8;
          });
          if (isEllipsis && isHeaderColumn) {
            var textEl = elem.querySelector('.datagrid-header-text');
            tooltip.textwidth = textEl.scrollWidth + (select ? 0 : extraWidth);
          } else {
            tooltip.textwidth = stringUtils.textWidth(tooltip.content) + (select ? 0 : extraWidth);
          }

          if (isTh) {
            tooltip.textwidth = stringUtils.textWidth(tooltip.content);
          }

          tooltip.content = contentTooltip ? tooltip.content : '<p>' + tooltip.content + '</p>';
          if (title || isHeaderFilter) {
            tooltip.forced = true;
          }
        }
      }

      elem = elem instanceof jQuery ? elem : $(elem);
      elem.data('gridtooltip', tooltip);
      return tooltip;
    },


    /**
     * Show Tooltip
     * @private
     * @param  {object} [options] for tooltip.
     * @param  {string} [options.content] The tooltip contents.
     * @param  {object} [options.wrapper] The parent DOM element.
     * @param  {boolean} [options.isError] True for if is error color.
     * @param  {string} [options.placement] 'top'|'right'|'bottom'|'left'.
     * @param  {array} [options.extraClassList] list of css classes to be added to tooltip.
     * @returns {void}
     */
    showTooltip: function showTooltip(options) {
      var _this11 = this;

      if (this.tooltip) {
        var tooltip = $(this.tooltip);
        var tooltipContentEl = this.tooltip.querySelector('.tooltip-content');
        if (tooltipContentEl) {
          tooltipContentEl.innerHTML = options.content;
          this.tooltip.classList.remove('is-hidden', 'top', 'right', 'bottom', 'left');
          this.tooltip.style.display = '';
          this.tooltip.classList.add(options.placement || 'top');

          if (options.isError) {
            this.tooltip.classList.add('is-error');
          }
          if (options.extraClassList) {
            options.extraClassList.map(function (className) {
              return _this11.tooltip.classList.add(className);
            });
          }

          var distance = typeof options.distance === 'number' ? options.distance : 10;
          var placeOptions = {
            x: 0,
            y: distance,
            container: this.element.closest('.page-container.scrollable') || $('body'),
            containerOffsetX: options.wrapper.offsetLeft,
            containerOffsetY: options.wrapper.offsetTop,
            parent: $(options.wrapper),
            placement: options.placement || 'top',
            strategies: ['flip', 'nudge']
          };
          if (placeOptions.placement === 'left' || placeOptions.placement === 'right') {
            placeOptions.x = distance;
            placeOptions.y = 0;
          }

          // If not already have place instance
          if (!tooltip.data('place')) {
            tooltip.place(placeOptions);
          }

          // Apply place
          tooltip.data('place').place(placeOptions);

          // Flag to mark as gridtooltip
          tooltip.data('gridtooltip', true);

          tooltip.one('afterplace.gridtooltip', function (e, placementObj) {
            _this11.handleAfterPlaceTooltip(e, placementObj);
          }).on('click.gridtooltip', function () {
            _this11.hideTooltip();
          });

          // Hide the tooltip when the page scrolls.
          $('body, .scrollable').off('scroll.gridtooltip').on('scroll.gridtooltip', function () {
            _this11.hideTooltip();
          });
        }
      }
    },


    /**
     * Placement behavior's "afterplace" handler.
     * @private
     * @param {jquery.event} e custom `afterPlace` event
     * @param {placementobject} placementObj object containing placement settings
     * @returns {void}
     */
    handleAfterPlaceTooltip: function handleAfterPlaceTooltip(e, placementObj) {
      var tooltip = $('#tooltip');
      if (tooltip[0]) {
        tooltip.data('place').setArrowPosition(e, placementObj, tooltip);
        tooltip.triggerHandler('tooltipafterplace', [placementObj]);
      }
    },


    /**
     * Hide the visible tooltip.
     * @private
     * @returns {void}
     */
    hideTooltip: function hideTooltip() {
      var _this12 = this;

      if (this.tooltip) {
        this.removeTooltipData(this.tooltip); // Remove flag as gridtooltip
        this.tooltip.classList.add('is-hidden');
        this.tooltip.classList.remove('is-error', 'popover', 'alternate', 'content-tooltip');
        this.tooltip.style.left = '-999px';
      }

      // Remove scroll events
      $('body, .scrollable').off('scroll.gridtooltip', function () {
        _this12.hideTooltip();
      });
    },


    /**
     * Check for tooltip type gridtooltip or component
     * @private
     * @returns {boolean} True if is gridtooltip
     */
    isGridtooltip: function isGridtooltip() {
      var isGridtooltipType = false;
      if (this.tooltip) {
        var tooltipJQ = this.tooltip instanceof jQuery ? this.tooltip : $(this.tooltip);
        if (tooltipJQ.data('gridtooltip')) {
          isGridtooltipType = true;
        }
      }
      return isGridtooltipType;
    },


    /**
     * Remove the tooltip data from given node
     * @private
     * @param {object} elem The DOM element to remove data
     * @returns {void}
     */
    removeTooltipData: function removeTooltipData(elem) {
      elem = elem instanceof jQuery ? elem : $(elem);
      if (elem.data('gridtooltip')) {
        $.removeData(elem[0], 'gridtooltip');
      }
    },


    /**
     * Remove the tooltip from the DOM
     * @private
     * @returns {void}
     */
    removeTooltip: function removeTooltip() {
      var _this13 = this;

      if (this.tooltip) {
        var tooltip = $(this.tooltip);

        // Set selector
        var selector = {
          th: '.datagrid-header th',
          td: '.datagrid-body tr.datagrid-row td[role="gridcell"]:not(.rowstatus-cell)',
          rowstatus: '.datagrid-body tr.datagrid-row td[role="gridcell"] .icon-rowstatus'
        };
        selector.str = selector.th + ', ' + selector.td + ', ' + selector.rowstatus;

        // Unbind events
        $('body, .scrollable').off('scroll.gridtooltip');
        tooltip.off('touchend.gridtooltip');
        this.element.off('mouseenter.gridtooltip mouseleave.gridtooltip click.gridtooltip longpress.gridtooltip keydown.gridtooltip', selector.str);

        // Remove the place component
        var placeApi = tooltip.data('place');
        if (placeApi) {
          placeApi.destroy();
        }

        // Remove cached tooltip data
        var nodes = [].slice.call(this.element[0].querySelectorAll(selector.str));
        nodes.forEach(function (node) {
          return _this13.removeTooltipData(node);
        });

        if (this.tooltip.parentNode) {
          this.tooltip.parentNode.removeChild(this.tooltip);
        }
      }
      this.tooltip = undefined;
    },


    /**
    * Unwrap the grid back to a simple div, and destory all events and pointers.
    * @returns {object} The plugin api for chaining.
    */
    destroy: function destroy() {
      // Remove grid tooltip
      this.removeTooltip();

      // UnBind the pager
      if (this.pagerAPI) {
        this.pagerAPI.element.off('afterpaging.' + COMPONENT_NAME$18);
        this.tableBody.off('page.' + COMPONENT_NAME$18 + ' pagesizechange.' + COMPONENT_NAME$18);
        this.pagerAPI.destroy();
      }

      // Remove the toolbar, clean the div out and remove the pager
      this.element.off().empty().removeClass('datagrid-container');
      var toolbar = this.element.prev('.toolbar');

      this.triggerDestroyCell();

      if (this.removeToolbarOnDestroy && this.settings.toolbar && this.settings.toolbar.keywordFilter) {
        var searchfield = toolbar.find('.searchfield');
        if (searchfield.data('searchfield')) {
          searchfield.data('searchfield').destroy();
        }
        searchfield.removeData('options');
      }

      if (this.removeToolbarOnDestroy) {
        // only remove toolbar if it was created by this datagrid
        if (toolbar.data('toolbar')) {
          toolbar.data('toolbar').destroy();
        }
        toolbar.remove();
      }

      this.element.next('.pager-toolbar').remove();
      $.removeData(this.element[0], COMPONENT_NAME$18);

      this.element.off();
      $(document).off('touchstart.datagrid touchend.datagrid touchcancel.datagrid click.datagrid touchmove.datagrid');
      this.bodyContainer.off().remove();
      $('body').off('resize.vtable resize.datagrid');
      $(window).off('orientationchange.datagrid');
      return this;
    },


    /**
    * Update the datagrid and optionally apply new settings.
    * @param  {object} settings the settings to update to.
    * @returns {object} The plugin api for chaining.
    */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.frozenColumns) {
        this.headerRow = undefined;
        this.element.empty();
        this.firstRender();
      }

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      if (settings && settings.columns) {
        this.settings.columns = settings.columns;
      }

      this.render();

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Datagrid
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.datagrid = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$18);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$18, new Datagrid(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$19 = 'formcompact';

  // Settings
  var FORMCOMPACT_DEFAULTS = {};

  /**
   * @class FormCompact
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings=null] Incoming settings
   */
  function FormCompact(element, settings) {
    if (!(element instanceof HTMLElement)) {
      throw new Error('Element used for `FormCompact` component must be an instance of HTMLElement');
    }

    this.settings = utils.mergeSettings(element, settings, FORMCOMPACT_DEFAULTS);
    this.element = element;

    this.init();
  }

  FormCompact.prototype = {

    /**
     * @private
     * Builds the component up from scratch
     * @returns {void}
     */
    init: function init() {
      this.form = this.element.querySelector('form');
      this.inputs = utils.getArrayFromList(this.element.querySelectorAll('input'));

      this.renderProps();
      this.handleEvents();
    },


    /**
     * Render CSS classes on column containers for some states
     * @returns {void}
     */
    renderProps: function renderProps() {
      var _this = this;

      if (!this.inputs || !this.inputs.length) {
        return;
      }

      var props = ['disabled', 'readonly'];
      this.inputs.forEach(function (input) {
        props.forEach(function (prop) {
          _this.setState(prop, input);
        });
      });
    },


    /**
     * @private
     * Sets up event listeners on the component
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      var focusedCssClass = 'is-focused';
      $(this.form).on('focusin.' + COMPONENT_NAME$19, 'input', function (e) {
        e.target.parentNode.classList.add(focusedCssClass);
      }).on('focusout.' + COMPONENT_NAME$19, 'input', function (e) {
        e.target.parentNode.classList.remove(focusedCssClass);
      });

      // Listen to attribute changes (disabled/readonly) on cells
      var attributeNames = ['disabled', 'readonly'];
      this.inputsObserver = new MutationObserver(function (mutationsList) {
        if (!mutationsList.length) {
          return;
        }

        mutationsList.forEach(function (mutation) {
          if (mutation.type === 'attributes') {
            if (attributeNames.indexOf(mutation.attributeName) > -1) {
              _this2.setState(mutation.attributeName, mutation.target);
            }
          }
        });
      });

      var config = {
        attributes: true
      };
      this.inputs.forEach(function (input) {
        _this2.inputsObserver.observe(input, config);
      });
    },


    /**
     * @private
     * Sets a CSS Class on the parent column of a form input.
     * @param {string} name property being set
     * @param {HTMLElement} target the node to be evaluated
     */
    setState: function setState(name, target) {
      if (typeof name !== 'string' || !(target instanceof HTMLElement)) {
        return;
      }

      if (name === 'readonly') {
        name = 'readOnly';
      }
      var isActive = target[name] === true;
      var operation = isActive ? 'add' : 'remove';
      target.parentNode.classList[operation]('is-' + name.toLowerCase());
    },


    /**
     * Updates the component with new settings
     * @param {object} [settings=null] if defined, new incoming settings
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.teardown();
      this.init();
    },


    /**
     * Removes all bound events and extraneous HTML markup
     * @returns {void}
     */
    teardown: function teardown() {
      this.inputsObserver.disconnect();
      delete this.inputsObserver;

      $(this.form).off(['focusin.' + COMPONENT_NAME$19, 'focusout.' + COMPONENT_NAME$19].join(' '));
      delete this.form;
      delete this.inputs;
    },


    /**
     * Destroys the component and removes its contents from the DOM
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element, COMPONENT_NAME$19);
    }
  };

  /**
   * jQuery Component Wrapper for FormContact
   * @param {object} [settings=undefined] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.formcompact = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$19);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$19, new FormCompact(this, settings));
      }
    });
  };

  // The Component Name
  var COMPONENT_NAME$1a = 'header';

  /**
   * Special Header with Toolbar at the top of the page used to faciliate IDS Enterprise Nav Patterns
   * @class Header
   * @param {HTMLElement|jQuery[]} element the base element
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.demoOptions = true] Used to enable/disable default IDS Enterprise options for demo purposes
   * @param {boolean} [settings.useBackButton = true] If true, displays a back button next to the title in the header toolbar
   * @param {boolean} [settings.useBreadcrumb = false] If true, displays a breadcrumb on drilldown
   * @param {boolean} [settings.usePopupmenu = false] If true, changes the Header Title into a popupmenu that can change the current page
   * @param {array} [settings.tabs = null] If defined as an array of Tab objects, displays a series of tabs that represent application sections
   * @param {array} [settings.wizardTicks = null] If defined as an array of Wizard Ticks, displays a Wizard Control that represents steps in a process
   * @param {boolean} [settings.useAlternate = null] If true, use alternate background/text color for sub-navigation areas
   * @param {boolean} [settings.addScrollClass = false] If true a class will be added as the page scrolls up and down
   * to the header for manipulation. Eg: Docs Page.
   */
  var HEADER_DEFAULTS = {
    demoOptions: true,
    useBackButton: true,
    useBreadcrumb: false,
    usePopupmenu: false,
    tabs: null,
    wizardTicks: null,
    useAlternate: false,
    addScrollClass: false
  };

  function Header(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, HEADER_DEFAULTS);
    this.init();
  }

  Header.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup().build().handleEvents();

      // Theme, Personalization, Language Changer, Scrolling
      if (this.settings.demoOptions) {
        this.initPageChanger();
      }
    },


    /**
     * @private
     * @returns {this} component instance
     */
    setup: function setup() {
      // TODO: Settings all work independently, but give better descriptions
      this.settings.demoOptions = this.element.attr('data-demo-options') ? this.element.attr('data-demo-options') === 'true' : this.settings.demoOptions;
      this.settings.useBackButton = this.element.attr('data-use-backbutton') ? this.element.attr('data-use-backbutton') === 'true' : this.settings.useBackButton;
      this.settings.useBreadcrumb = this.element.attr('data-use-breadcrumb') ? this.element.attr('data-use-breadcrumb') === 'true' : this.settings.useBreadcrumb;
      this.settings.useAlternate = this.element.attr('data-use-alternate') ? this.element.attr('data-use-alternate') === 'true' : this.settings.useAlternate;

      this.settings.tabs = !$.isArray(this.settings.tabs) ? null : this.settings.tabs;
      this.settings.wizardTicks = !$.isArray(this.settings.wizardTicks) ? null : this.settings.wizardTicks;

      this.titleText = this.element.find('.title > h1');

      // Used to track levels deep
      this.levelsDeep = [];
      this.levelsDeep.push('' + this.titleText.text());

      return this;
    },


    /**
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      this.toolbarElem = this.element.find('.toolbar');

      // Build toolbar if it doesn't exist
      if (!this.toolbarElem.data('toolbar')) {
        this.toolbarElem.toolbar();
      }
      this.toolbar = this.toolbarElem.data('toolbar');

      // Hamburger Icon is optional, but tracking it is necessary.
      this.titleButton = this.element.find('.title > .application-menu-trigger');
      this.hasTitleButton = this.titleButton.length > 0;

      if (this.hasTitleButton) {
        this.toolbarElem.addClass('has-title-button');
        var appMenu = $('#application-menu').data('applicationmenu');
        if (appMenu) {
          appMenu.modifyTriggers([this.titleButton], null, true);
        } else {
          $('#application-menu').applicationmenu({
            triggers: [this.titleButton]
          });
        }
      }

      // Application Tabs would be available from the Application Start, so activate
      // them during build if they exist
      if (this.settings.tabs && this.settings.tabs.length) {
        this.buildTabs();
      }

      if (this.settings.wizardTicks && this.settings.wizardTicks.length) {
        this.buildWizard();
      }

      if (this.settings.usePopupmenu) {
        this.buildPopupmenu();
      }

      // Add a Scrolling Class to manipulate the header
      if (this.settings.addScrollClass) {
        var self = $(this.element);
        var scrollDiv = $(this.element).next('.scrollable');
        var container = scrollDiv.length === 1 ? scrollDiv : $(window);
        var scrollThreshold = this.settings.scrollThreshold ? this.settings.scrollThreshold : 15;

        container.on('scroll.header', function () {
          if (this.scrollTop > scrollThreshold) {
            self.addClass('is-scrolled-down');
          } else {
            self.removeClass('is-scrolled-down');
          }
        });

        if (container.scrollTop() > scrollThreshold) {
          self.addClass('is-scrolled-down');
        }
      }

      return this;
    },


    /**
     * @private
     * @returns {void}
     */
    buildTitleButton: function buildTitleButton() {
      if (this.levelsDeep.length > 1 && !this.hasTitleButton && !this.titleButton.length) {
        this.titleButton = $('<button class="btn-icon back-button" type="button"></button>');
        this.titleButton.html('<span class="audible">' + Locale.translate('Drillup') + '</span>' + '<span class="icon app-header go-back">' + '<span class="one"></span>' + '<span class="two"></span>' + '<span class="three"></span>' + '</span>');
        this.titleButton.prependTo(this.element.find('.title'));

        // Need to trigger an update on the toolbar control to make sure tabindexes
        // and events are all firing on the button
        this.toolbar.element.triggerHandler('updated');
      }

      this.titleButton.find('.icon.app-header').addClass('go-back');
    },


    /**
     * Used for adding a Breadcrumb Element to the Header
     * @private
     * @returns {void}
     */
    buildBreadcrumb: function buildBreadcrumb() {
      var self = this;
      var breadcrumbClass = 'has-breadcrumb';

      if (this.settings.useAlternate) {
        breadcrumbClass = 'has-alternate-breadcrumb';
      }
      this.element.addClass(breadcrumbClass);

      this.breadcrumb = this.element.find('.breadcrumb');
      if (!this.breadcrumb.length) {
        this.breadcrumb = $('<nav class="breadcrumb hidden" role="navigation"></nav>').appendTo(this.element);
        this.breadcrumb.on('click', 'a', function (e) {
          self.handleBreadcrumbClick(e);
        });
      }

      this.breadcrumb[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');
      this.adjustBreadcrumb();
    },


    /**
     * Builds Breadcrumb markup that reflects the current state of the application
     * @private
     * @returns {void}
     */
    adjustBreadcrumb: function adjustBreadcrumb() {
      var last = this.levelsDeep[this.levelsDeep.length - 1];
      this.breadcrumb.empty();

      var bcMarkup = $('<ol aria-label="breadcrumb"></ol>').appendTo(this.breadcrumb);
      $.each(this.levelsDeep, function (i, txt) {
        var current = '';
        if (last === txt) {
          current = ' current';
        }

        bcMarkup.append($('<li><a href="#" class="hyperlink' + current + '">' + txt + '</a></li>'));
      });
    },


    /**
     * Builds Header Tabs
     * @private
     * @returns {void}
     */
    buildTabs: function buildTabs() {
      this.tabsContainer = this.element.find('.tab-container');
      if (!this.tabsContainer.length) {
        this.tabsContainer = $('<div class="tab-container"></div>').appendTo(this.element);

        // TODO: Flesh this out so that the header control can build tabs based on options
        var tablist = $('<ul class="tab-list" role="tablist"></ul>').appendTo(this.tabsContainer);
        $('<li class="tab"><a href="#header-tabs-home" role="tab">IDS Enterprise Controls | Patterns</a></li>').appendTo(tablist);
        $('<li class="tab"><a href="#header-tabs-level-1" role="tab">Level 1 Detail</a></li>').appendTo(tablist);
        $('<li class="tab"><a href="#header-tabs-level-2" role="tab">Level 2 Detail</a></li>').appendTo(tablist);
      }

      this.element.addClass(this.settings.useAlternate ? 'has-alternate-tabs' : 'has-tabs');
      this.tabsContainer[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');

      // NOTE: For demo purposes the markup for tab panels is already inside the
      // Nav Patterns Test page.
      $('#header-tabs-level-1').removeAttr('style');
      $('#header-tabs-level-2').removeAttr('style');

      // Invoke Tabs Control
      this.tabsContainer.tabs({
        containerElement: '#maincontent'
      });
    },


    /**
     * Builds a Header Wizard
     * @private
     * @returns {void}
     */
    buildWizard: function buildWizard() {
      this.element.addClass('has-wizard');

      this.wizard = this.element.find('.wizard');
      if (!this.wizard.length) {
        this.wizard = $('<div class="wizard"></div>').appendTo(this.element);
        var header = $('<div class="wizard-header"></div>').appendTo(this.wizard);
        var bar = $('<div class="bar"></div>').appendTo(header);
        $('<div class="completed-range"></div>').appendTo(bar);

        // TODO: Flesh this out so the header control can build the Wizard Ticks based on options
        $('<a href="#" class="tick current"><span class="label">Context Apps</span></a>').appendTo(bar);
        $('<a href="#" class="tick"><span class="label">Utility Apps</span></a>').appendTo(bar);
        $('<a href="#" class="tick"><span class="label">Inbound Configuration</span></a>').appendTo(bar);
        $('<a href="#" class="tick"><span class="label">OID Mapping</span></a>').appendTo(bar);
      }

      this.wizard[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');

      // NOTE: For Demo Purposes, the shifting forms associated with the Wizard are coded
      // inside the Nav Patterns Test page.
      // TODO: Build shifting forms

      // Invoke the Wizard Control
      this.wizard.wizard();
    },


    /**
     * Builds a Popupmenu in place of the usual Title text, to allow for context swapping.
     * @private
     * @returns {void}
     */
    buildPopupmenu: function buildPopupmenu() {
      var title = this.toolbarElem.children('.title');
      this.titlePopup = title.find('.btn-menu');
      if (!this.titlePopup.length) {
        var heading = title.find('h1'); // If H1 doesn't exist here, you're doing it wrong.
        heading.wrap('<button id="header-menu" type="button" class="btn-menu"></button>');
        this.titlePopup = heading.parent('.btn-menu');
      }
      this.titlePopupMenu = this.titlePopup.next('.popupmenu');
      if (!this.titlePopupMenu.length) {
        this.titlePopupMenu = $('<ul class="popupmenu is-selectable"></ul>').insertAfter(this.titlePopup);
        $('<li class="is-checked"><a href="#">Page One Title</a></li>' + '<li><a href="#">Page Two Title</a></li>' + '<li><a href="#">Page Three Title</a></li>' + '<li class="is-disabled"><a href="#">Page Four Title</a></li>' + '<li><a href="#">Page Five Title</a></li>').appendTo(this.titlePopupMenu);
      }
      this.titlePopupMenu.addClass('is-selectable');

      // Set the text on the Title
      var selectedText = this.titlePopupMenu.children('.is-checked').first().text();
      if (!selectedText) {
        selectedText = this.titlePopupMenu.children().first().text();
      }
      this.titlePopup.children('h1').text(selectedText);

      // Invoke the Popupmenu on the Title
      this.titlePopup.button().popupmenu();

      // Update the Header toolbar to account for the new button
      this.toolbarElem.triggerHandler('updated');
    },


    /**
     * Sets up header-level events
     * @fires Header#events
     * @listens updated
     * @listens reset
     * @listens drilldown
     * @listens drillup
     * @listens click
     * @listens selected
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.element.on('updated.header', function (e, settings) {
        self.updated(settings);
      }).on('reset.header', function () {
        self.reset();
      }).on('drilldown.header', function (e, viewTitle) {
        self.drilldown(viewTitle);
      }).on('drillup.header', function (e, viewTitle) {
        self.drillup(viewTitle);
      });

      // Events for the title button.  e.preventDefault(); stops Application Menu
      // functionality while drilled
      this.titleButton.bindFirst('click.header', function (e) {
        if (self.levelsDeep.length > 1) {
          e.stopImmediatePropagation();
          self.drillup();
          e.returnValue = false;
        }
      });

      // Popupmenu Events
      if (this.settings.usePopupmenu) {
        this.titlePopup.on('selected.header', function (e, anchor) {
          $(this).children('h1').text(anchor.text());
        });
      }

      return this;
    },


    /**
     * Handles click events on Breadcrumb elements
     * @private
     * @param {jQuery.Event} e `click` event
     * @returns {void}
     */
    handleBreadcrumbClick: function handleBreadcrumbClick(e) {
      var selected = $(e.target).parent();
      var breadcrumbs = this.breadcrumb.find('li');
      var selectedIndex = breadcrumbs.index(selected);
      var delta = void 0;

      if (selected.hasClass('current')) {
        return;
      }

      if (selectedIndex === 0) {
        this.reset();
        return;
      }

      if (selectedIndex < breadcrumbs.length - 1) {
        delta = breadcrumbs.length - 1 - selectedIndex;
        while (delta > 0) {
          this.drillup();
          delta -= 1;
        }
      }
    },


    /**
     * Sets up the `selected` events on the More Actions area of the header, which can include
     * Menu Options for changing the current theme, persoanlization colors, and language locale.
     * @private
     * @param {jQuery.Event} e `click` event
     * @returns {void}
     */
    initPageChanger: function initPageChanger() {
      this.element.find('.page-changer').on('selected.header', function (e, link) {
        // Change Theme
        if (link.attr('data-theme')) {
          var theme = link.attr('data-theme');
          $('body').trigger('changetheme', theme.replace('-theme', ''));
          return;
        }

        // TODO: Change Lang
        if (link.attr('data-lang')) {
          Locale.set(link.attr('data-lang'));
          return;
        }

        // Change Color
        var color = link.attr('data-rgbcolor');
        $('body').trigger('changecolors', [color]);
      });
    },


    /**
     * Drills deeper into a breadcrumb structure while updating the Header title to reflect state.
     * @private
     * @param {string} viewTitle text contents to put in place of the title area.
     * @returns {void}
     */
    drilldown: function drilldown(viewTitle) {
      this.element.addClass('is-drilldown');
      this.levelsDeep.push(viewTitle.toString());
      this.titleText.text(this.levelsDeep[this.levelsDeep.length - 1]);

      if (this.settings.useBackButton) {
        this.buildTitleButton();
      }

      if (this.settings.useBreadcrumb) {
        if (!this.breadcrumb || !this.breadcrumb.length) {
          this.buildBreadcrumb();
          this.breadcrumb.css({ display: 'block', height: 'auto' }).removeClass('hidden');
        } else {
          this.adjustBreadcrumb();
        }
      }
    },


    /**
     * Moves up into a breadcrumb structure while updating the Header title to reflect state.
     * @private
     * @param {string} viewTitle text contents to put in place of the title area.
     * @returns {void}
     */
    drillup: function drillup(viewTitle) {
      var title = void 0;
      this.element.removeClass('is-drilldown');

      if (this.levelsDeep.length > 1) {
        this.levelsDeep.pop();
        title = this.levelsDeep[this.levelsDeep.length - 1];
      }

      if (viewTitle !== undefined) {
        title = viewTitle;
      }

      if (this.levelsDeep.length > 1) {
        if (this.settings.useBreadcrumb) {
          this.adjustBreadcrumb();
        }
        this.titleText.text(title);
        return;
      }

      // Completely reset all the way back to normal
      title = this.levelsDeep[0];

      if (this.settings.useBackButton) {
        this.removeButton();
      }
      if (this.settings.useBreadcrumb) {
        this.removeBreadcrumb();
      }
      if (this.settings.usePopupmenu) {
        this.removePopupmenu();
      }

      this.titleText.text(title);
      this.element.trigger('drillTop');
    },


    /**
     * Reset the toolbar to its default removing the drilled in patterns.
     * @returns {this} component instance
     */
    reset: function reset() {
      while (this.levelsDeep.length > 1) {
        this.levelsDeep.pop();
      }
      this.titleText.text(this.levelsDeep[0]);

      this.removeBreadcrumb();
      this.removeTabs();
      this.removeWizard();
      this.removePopupmenu();
      this.removeButton();

      this.element.trigger('afterreset');
      return this;
    },


    /**
     * Removes a previously-built Button pattern from the Header.
     * @private
     * @returns {void}
     */
    removeButton: function removeButton() {
      if (this.hasTitleButton) {
        this.titleButton.find('.icon.app-header').removeClass('go-back');
        return;
      }

      if (this.titleButton && this.titleButton.length) {
        this.titleButton.remove();
        this.titleButton = $();

        // Need to trigger an update on the toolbar control to make sure
        // tabindexes and events are all firing on the button
        this.toolbar.element.triggerHandler('updated');
      }
    },


    /**
     * @public
     * Manually remove go-back class from button
     */
    removeBackButton: function removeBackButton() {
      this.element.find('.go-back').removeClass('go-back');
    },


    /**
     * Removes a previously-built Breadcrumb structure from the Header.
     * @private
     * @returns {void}
     */
    removeBreadcrumb: function removeBreadcrumb() {
      if (!this.breadcrumb || !this.breadcrumb.length) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitionEndName();
      var timeout = void 0;

      function destroyBreadcrumb() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }

        self.element.off(transitionEnd + '.breadcrumb-header');
        self.breadcrumb.off().remove();
        self.breadcrumb = $();
      }

      self.element.removeClass('has-breadcrumb').removeClass('has-alternate-breadcrumb');
      if (this.breadcrumb.is(':not(:hidden)')) {
        this.element.one(transitionEnd + '.breadcrumb-header', destroyBreadcrumb);
        timeout = setTimeout(destroyBreadcrumb, 300);
      } else {
        destroyBreadcrumb();
      }
    },


    /**
     * Removes a previously-built Header Tabs pattern from the Header.
     * @private
     * @returns {void}
     */
    removeTabs: function removeTabs() {
      if (!this.tabsContainer || !this.tabsContainer.length) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitionEndName();
      var timeout = void 0;

      function destroyTabs() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }

        self.element.off(transitionEnd + '.tabs-header');
        self.tabsContainer.data('tabs').destroy();
        self.tabsContainer.remove();
        self.tabsContainer = null;

        // NOTE: For demo purposes the markup for tab panels is already
        // inside the Nav Patterns Test page.
        $('#header-tabs-level-1').css('display', 'none');
        $('#header-tabs-level-2').css('display', 'none');
      }

      this.element.removeClass('has-tabs').removeClass('has-alternate-tabs');
      if (this.tabsContainer.is(':not(:hidden)')) {
        this.element.one(transitionEnd + '.tabs-header', destroyTabs);
        timeout = setTimeout(destroyTabs, 300);
      } else {
        destroyTabs();
      }
    },


    /**
     * Removes a previously-built Header Wizard pattern from the Header.
     * @private
     * @returns {void}
     */
    removeWizard: function removeWizard() {
      if (!this.wizard || !this.wizard.length) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitionEndName();
      var timeout = void 0;

      function destroyWizard() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }

        self.element.off(transitionEnd + '.wizard-header');
        self.wizard.data('wizard').destroy();
        self.wizard.remove();
        self.wizard = null;
      }

      this.element.removeClass('has-wizard');
      if (this.wizard.is(':not(:hidden)')) {
        this.element.one(transitionEnd + '.wizard-header', destroyWizard);
        timeout = setTimeout(destroyWizard, 300);
      } else {
        destroyWizard();
      }
    },


    /**
     * Removes a previously-built Popupmenu pattern from the Header's title.
     * @private
     * @returns {void}
     */
    removePopupmenu: function removePopupmenu() {
      var self = this;

      if (!this.titlePopup || !this.titlePopup.length) {
        return;
      }

      this.titlePopup.data('popupmenu').destroy();
      this.titlePopup.data('button').destroy();
      this.titlePopupMenu.remove();
      this.titlePopup.children('h1').detach().insertBefore(self.titlePopup);
      this.titlePopup.remove();

      this.titlePopup = undefined;
      this.titlePopupMenu = undefined;

      this.toolbarElem.triggerHandler('updated');
    },


    /**
     * Removes bound events from the Header
     * @private
     * @returns {this} component instance
     */
    unbind: function unbind() {
      this.titleButton.off('click.header');
      this.element.off('drilldown.header drillup.header');
      return this;
    },


    /**
     * Sync up the ui with settings.
     * @param {object} [settings] incoming settings.
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.reset().unbind().init();
    },


    /**
     * Teardown and destroy the menu and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      if (this.hasTitleButton) {
        this.toolbarElem.removeClass('has-title-button');
      }

      $.removeData(this.element[0], COMPONENT_NAME$1a);
    }
  };

  /**
   * jQuery Component Wrapper for Header
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.header = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1a);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1a, new Header(this, settings));
      }
    });
  };

  /* eslint-disable no-continue: "off, no-underscore-dangle */

  // Component Name
  var COMPONENT_NAME$1b = 'lookup';

  // Lookup components are "modal" (one on-screen at any given time)
  var LOOKUP_GRID_ID = 'lookup-datagrid';

  /**
   * Input element that opens a dialog with a list for selection.
   * @class Lookup
   * @param {jquery[]|htmlelement} element the base element
   * @param {object} [settings] incoming settings
   * @param {function} [settings.click] Provide a special function to run when the dialog opens to customize the interaction entirely.
   * @param {string} [settings.clickArguments={}] If a click method is defined, this flexible object can be passed
   * into the click method, and augmented with parameters specific to the implementation.
   * @param {string} [settings.field='id'] Field name to return from the dataset or can be a function which returns a string on logic
   * @param {string} [settings.title] Dialog title to show, or befault shows  field label + "Lookup"
   * @param {array} [settings.buttons] Pass dialog buttons or Cancel / Apply
   * @param {object} [settings.options] Options to pass to the datagrid
   * @param {function} [settings.beforeShow] Call back that executes async before the lookup is opened.
   * @param {string} [settings.modalContent] Custom modal markup can be sent in here
   * @param {boolean} [settings.editable=true] Can the user type text in the field
   * @param {boolean} [settings.autoApply=true] If set to false the dialog wont apply the value on clicking a value.
   * @param {function} [settings.validator] A function that fires to let you validate form items on open and select
   * @param {boolean} [settings.autoWidth=false] If true the field will grow/change in size based on the content selected.
   * @param {char} [settings.delimiter=','] A character being used to separate data strings
   * @param {int} [settings.minWidth=400] Applys a minimum width to the lookup
   */

  var LOOKUP_DEFAULTS = {
    click: null,
    field: 'id',
    title: null,
    buttons: [],
    options: null,
    beforeShow: null,
    modalContent: null,
    editable: true,
    typeahead: false, // Future TODO
    autoApply: true,
    validator: null,
    autoWidth: false,
    clickArguments: {},
    delimiter: ',',
    minWidth: 400
  };

  function Lookup(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, LOOKUP_DEFAULTS);
    this.init();
  }

  Lookup.prototype = {

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = !!this.inlineLabelText.length;
      this.build();
      this.handleEvents();
      this.grid = null;
      this.selectedRows = null;
    },


    /**
     * Build the UI for the Lookup
     * @private
     * @returns {void}
     */
    build: function build() {
      var lookup = this.element;

      // appends a wrapper to the lookup field.
      function getWrapperCSSClass() {
        var str = 'lookup-wrapper';

        if (lookup.is('.input-xs')) {
          str += ' xs';
        }
        if (lookup.is('.input-sm')) {
          str += ' sm';
        }
        if (lookup.is('.input-lg')) {
          str += ' lg';
        }

        return str;
      }
      var cssClass = getWrapperCSSClass();

      if (this.element.is('.has-actions')) {
        cssClass += ' has-actions-wrapper';
      }

      // Add Button
      this.icon = $('<span class="trigger" tabindex="-1"></span>').append($.createIcon('search-list'));
      if (this.isInlineLabel) {
        this.inlineLabel.addClass(cssClass);
      } else {
        this.container = $('<span class="' + cssClass + '"></span>');

        if (this.element.is('.field-options')) {
          var field = this.element.closest('.field');
          var fieldOptionsTrigger = field.find('.btn-actions');

          lookup.add(fieldOptionsTrigger).add(fieldOptionsTrigger.next('.popupmenu')).wrapAll(this.container);
        } else {
          lookup.wrap(this.container);
        }
      }

      lookup.after(this.icon);

      // Hide icon if lookup input is hidden
      if (lookup.hasClass('hidden')) {
        this.icon.addClass('hidden');
      }

      if (this.settings.autoWidth) {
        this.applyAutoWidth();
      }

      // Add Masking to show the #
      if (lookup.attr('data-mask')) {
        lookup.mask();
      }

      if (this.element.is(':disabled')) {
        this.disable();
      }

      if (!this.settings.editable) {
        this.element.attr('readonly', 'true').addClass('is-not-editable');
      }

      // Fix field options in case lookup is initialized after
      var wrapper = this.element.parent('.lookup-wrapper');
      if (wrapper.next().is('.btn-actions')) {
        if (this.element.data('fieldoptions')) {
          this.element.data('fieldoptions').destroy();
        }
        this.element.fieldoptions();
      }

      this.addAria();
    },


    /**
     * Add/Update Aria
     * @private
     * @returns {void}
     */
    addAria: function addAria() {
      var self = this;
      self.label = self.isInlineLabel ? self.inlineLabelText : $('label[for="' + self.element.attr('id') + '"]');

      if (self.label) {
        self.label.append('<span class="audible">' + Locale.translate('UseEnter') + '</span>');
      }
    },


    /**
     * Handle events on the field
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;

      this.icon.on('click.lookup', function (e) {
        self.openDialog(e);
      });

      // Down Arrow opens the dialog in this field
      this.element.on('keyup.lookup', function (e) {
        // If autocomplete open dont open list
        if ($('#autocomplete-list').length > 0) {
          return;
        }

        if (e.which === 40) {
          self.openDialog(e);
        }
      });
    },


    /**
     * Create and Open the Dialog
     * @private
     * @param {jquery.event} e click or keyup event
     * @returns {void}
     */
    openDialog: function openDialog(e) {
      var self = this;
      /**
        * Fires before open dialog.
        *
        * @event beforeopen
        * @memberof Lookup
        * @property {object} event - The jquery event object
        */
      var canOpen = self.element.triggerHandler('beforeopen');

      if (canOpen === false) {
        return;
      }

      if (self.isDisabled() || self.isReadonly() && !self.element.hasClass('is-not-editable')) {
        return;
      }

      if (self.settings.click) {
        self.settings.click(e, this, self.settings.clickArguments);
        return;
      }

      if (this.settings.beforeShow) {
        var response = function response(grid) {
          if (grid) {
            self.createGrid(grid);
          }

          if (typeof grid === 'boolean' && grid === false) {
            return false;
          }

          self.createModal();
          /**
            * Fires on complete dialog open (for busy indicator).
            *
            * @event complete
            * @memberof Lookup
            * @property {object} event - The jquery event object
            */
          self.element.triggerHandler('complete'); // for Busy Indicator

          /**
            * Fires on open dialog.
            *
            * @event open
            * @memberof Lookup
            * @property {object} event - The jquery event object
            * @property {object} modal instance
            * @property {object} grid in lookup
            */
          self.element.trigger('open', [self.modal, self.grid]);

          if (self.settings.validator) {
            self.settings.validator(self.element, self.modal, self.grid);
          }
          return true;
        };

        /**
          * Fires before start open dialog (for busy indicator).
          *
          * @event start
          * @memberof Lookup
          * @property {object} event - The jquery event object
          */
        this.element.triggerHandler('start'); // for Busy Indicator
        this.settings.beforeShow(this, response);
        return;
      }

      if (!this.settings.options) {
        return;
      }

      self.createModal();
      self.element.trigger('open', [self.modal, self.grid]);
      self.modal.element.find('.btn-actions').removeClass('is-selected');

      // Set tabindex on first row
      if (self.grid) {
        self.grid.cellNode(0, 0, true).attr('tabindex', '0');
      }

      // Fix: IE-11 more button was not showing
      var thisMoreBtn = self.modal.element.find('.toolbar .more > .btn-actions');
      if (thisMoreBtn.length) {
        setTimeout(function () {
          utils.fixSVGIcons(thisMoreBtn);
        }, 600);
      }

      /**
        * Fires after open dialog.
        *
        * @event afteropen
        * @memberof Lookup
        * @property {object} event - The jquery event object
        * @property {object} modal instance
        * @property {object} grid in lookup
        */
      self.element.trigger('afteropen', [self.modal, self.grid]);

      if (self.settings.validator) {
        self.settings.validator(self.element, self.modal, self.grid);
      }
    },


    /**
     * Overidable function to create the modal dialog
     * @returns {void}
     */
    createModal: function createModal() {
      var self = this;
      var content = '<div id="' + LOOKUP_GRID_ID + '"></div>';
      var thisLabel = $('label[for="' + self.element.attr('id') + '"]');

      function getLabelText() {
        if (self.isInlineLabel) {
          return self.inlineLabelText;
        }
        if (thisLabel.length) {
          return thisLabel.clone().find('span').remove().end().text();
        }
        if (self.settings.title) {
          return self.settings.title;
        }
        return '';
      }
      var labelText = getLabelText();

      var settingContent = this.settings.modalContent;
      if (settingContent && settingContent instanceof jQuery) {
        content = settingContent;
        settingContent.show();
      }

      if (settingContent && !(settingContent instanceof jQuery)) {
        content = settingContent;
      }

      var buttons = this.settings.buttons;
      if (this.settings.options && this.settings.options.selectable === 'multiple' && buttons.length === 0 || !self.settings.autoApply && buttons.length === 0) {
        buttons = [{
          text: Locale.translate('Cancel'),
          click: function click(e, modal) {
            self.element.focus();
            modal.close();
          }
        }, {
          text: Locale.translate('Apply'),
          click: function click(e, modal) {
            modal.close();
            self.insertRows(self.grid.selectedRows());
          },

          isDefault: true
        }];
      }

      if (this.settings.options && this.settings.options.selectable === 'single' && buttons.length === 0 && self.settings.autoApply) {
        buttons = [{
          text: Locale.translate('Cancel'),
          click: function click(e, modal) {
            self.element.focus();
            modal.close();
          }
        }];
      }

      var hasKeywordSearch = this.settings.options && this.settings.options.toolbar && this.settings.options.toolbar.keywordFilter;

      $('body').modal({
        title: labelText,
        content: content,
        buttons: buttons,
        cssClass: 'lookup-modal' + (!hasKeywordSearch ? ' lookup-no-search' : '')
      }).off('open.lookup').on('open.lookup', function () {
        self.createGrid();
      }).off('close.lookup').on('close.lookup', function () {
        self.element.focus();
        /**
          * Fires on close dialog.
          *
          * @event close
          * @memberof Lookup
          * @property {object} event - The jquery event object
          * @property {object} modal instance
          * @property {object} grid in lookup
          */
        self.element.triggerHandler('close', [self.modal, self.grid]);
      });

      self.modal = $('body').data('modal');
      if (!this.settings.title) {
        self.modal.element.find('.modal-title').append(' <span class="datagrid-result-count"></span>');
      }

      self.modal.element.off('afterclose.lookup').on('afterclose.lookup', function () {
        self.closeTearDown();
      });

      // Wait until search field available
      setTimeout(function () {
        $('.modal.is-visible .searchfield').on('keypress.lookup', function (e) {
          if (e.keyCode === 13) {
            return false; // Prevent for closing modal
          }
          return true;
        });
      }, 300);
    },


    /**
     * Tears down the modal/grid elements by removing events, markup, and component instances.
     * @private
     * @returns {void}
     */
    closeTearDown: function closeTearDown() {
      var search = $('.modal.is-visible .searchfield').off('keypress.lookup');
      if (search.data() && search.data('searchfield')) {
        search.data('searchfield').destroy();
      }

      if (search.data() && search.data('searchfield')) {
        search.data('searchfield').destroy();
        search.removeData();
      }
      search = null;

      if (this.grid && this.grid.destroy) {
        this.grid.destroy();
        this.grid = null;
      }
    },


    /**
     * Overridable Function in which we create the grid on the current UI dialog.
     * @interface
     * @param {jquery[]} grid jQuery wrapped element containing a pre-invoked datagrid instance
     * @returns {void}
     */
    createGrid: function createGrid(grid) {
      var self = this;
      var lookupGrid = void 0;

      if (grid) {
        lookupGrid = grid;
        LOOKUP_GRID_ID = grid.attr('id');
        self.settings.options = grid.data('datagrid').settings;
      } else {
        lookupGrid = self.modal.element.find('#' + LOOKUP_GRID_ID);
      }

      if (this.settings.minWidth) {
        lookupGrid = this.applyMinWidth(lookupGrid);
      }

      if (self.settings.options) {
        if (self.settings.options.selectable === 'single' && self.settings.autoApply) {
          self.settings.options.cellNavigation = false;
          lookupGrid.find('tr').addClass('is-clickable');
        }

        self.settings.options.isList = true;

        // Create grid (unless already exists from passed in grid)
        if (!lookupGrid.data('datagrid')) {
          lookupGrid.datagrid(self.settings.options);
        }
      }

      self.grid = lookupGrid.data('datagrid');
      if (!this.settings.title && self.modal) {
        self.modal.element.find('.title').not('.selection-count').remove();
      }

      var hasKeywordSearch = this.settings.options && this.settings.options.toolbar && this.settings.options.toolbar.keywordFilter;

      if (!hasKeywordSearch && self.modal) {
        self.modal.element.find('.toolbar').appendTo(self.modal.element.find('.modal-header'));
      }

      // Reset keyword search from previous loads
      if (hasKeywordSearch && self.grid) {
        if (!self.grid.filterExpr || self.grid.filterExpr && self.grid.filterExpr[0] && self.grid.filterExpr[0].value !== '') {
          self.grid.keywordSearch('');
        }
      }

      // Mark selected rows
      lookupGrid.off('selected.lookup');
      var val = self.element.val();
      if (val && !this.settings.options.source) {
        self.selectGridRows(val);
      }

      // Restore selected rows when pages change
      if (this.settings.options.source) {
        lookupGrid.off('afterpaging.lookup').on('afterpaging.lookup', function () {
          var fieldVal = self.element.val();
          if (fieldVal) {
            self.selectGridRows(fieldVal);
          }
        });
      }

      if (this.settings.options) {
        lookupGrid.on('selected.lookup', function (e, selectedRows) {
          // Only proceed if a row is selected
          if (!selectedRows || selectedRows.length === 0) {
            return;
          }

          if (self.settings.validator) {
            self.settings.validator(self.element, self.modal, self.grid);
          }

          if (self.settings.options.selectable === 'single' && self.settings.autoApply) {
            self.modal.close();
            self.insertRows();
          }
        });
      }
    },


    /**
     * Given a field value, select the row
     * @param {object} val incoming value from the grid row
     * @returns {void}
     */
    selectGridRows: function selectGridRows(val) {
      var selectedId = val;
      var adjust = false;

      if (!val) {
        return;
      }

      if (this.grid && this.settings.options.source) {
        for (var k = 0; k < this.grid._selectedRows.length; k++) {
          if (isNaN(this.grid._selectedRows[k].idx)) {
            this.grid._selectedRows.splice(k, 1);
          }
        }
      }

      // Multi Select
      if (selectedId.indexOf(this.settings.delimiter) > 1) {
        var selectedIds = selectedId.split(this.settings.delimiter);
        var isFound = false;

        for (var i = 0; i < selectedIds.length; i++) {
          isFound = this.selectRowByValue(this.settings.field, selectedIds[i]);

          if (this.grid && this.settings.options.source && !isFound) {
            var data = {};
            var foundInData = false;
            for (var j = 0; j < this.grid._selectedRows.length; j++) {
              if (this.grid._selectedRows[j].data[this.settings.field].toString() === selectedIds[i].toString()) {
                foundInData = true;
              }
            }

            if (!foundInData) {
              data[this.settings.field] = selectedIds[i];
              this.grid._selectedRows.push({ data: data });
            }
            adjust = true;
          }
        }

        // There are rows selected off page. Update the count.
        if (adjust) {
          this.modal.element.find('.contextual-toolbar .selection-count').text(selectedIds.length + ' ' + Locale.translate('Selected'));
        }
        return;
      }

      this.selectRowByValue(this.settings.field, selectedId);
    },


    /**
     * Find the row and select it based on select value / function / field value
     * @param {string} field the ID of the field whose value is to be returned.
     * @param {string} value the value to set.
     * @returns {boolean} True if the id is found.
     */
    selectRowByValue: function selectRowByValue(field, value) {
      if (!this.settings.options) {
        return false;
      }

      var data = this.settings.options.source ? this.grid.settings.dataset : this.settings.options.dataset;
      var selectedRows = [];

      // in this case we will recall on source - server side paging
      if (!data) {
        return false;
      }

      for (var i = 0; i < data.length; i++) {
        var isMatch = false;
        if (typeof this.settings.match === 'function') {
          if (this.settings.match(value, data[i], this.element, this.grid)) {
            isMatch = true;
          }
        }

        if (typeof this.settings.match !== 'function' && data[i][field].toString() === value.toString()) {
          isMatch = true;
        }

        if (isMatch) {
          var rowIndex = this.grid.settings.source ? this.grid.actualRowIndex(this.grid.tableBody.find('tr').eq(i)) : i;
          selectedRows.push(rowIndex);
        }
      }

      if (this.grid && selectedRows.length > 0) {
        this.grid.selectRows(selectedRows, false, true);
        return true;
      }

      return false;
    },


    /**
     * Get the selected rows and return them to the UI
     * @returns {void}
     */
    insertRows: function insertRows() {
      var value = '';

      this.selectedRows = this.grid.selectedRows();

      for (var i = 0; i < this.selectedRows.length; i++) {
        var currValue = '';

        if (typeof this.settings.field === 'function') {
          currValue = this.settings.field(this.selectedRows[i].data, this.element, this.grid);
        } else {
          currValue = this.selectedRows[i].data[this.settings.field];
        }

        value += (i !== 0 ? this.settings.delimiter : '') + currValue;

        // Clear _selected tag
        var idx = this.selectedRows[i].idx;
        if (this.settings.options.dataset && this.settings.options.dataset[idx]) {
          delete this.settings.options.dataset[idx]._selected;
        }
      }

      /**
        * Fires on input value change.
        *
        * @event change
        * @memberof Lookup
        * @property {object} event - The jquery event object
        * @property {object} selected rows
        */
      this.element.val(value).trigger('change', [this.selectedRows]);
      this.applyAutoWidth();
      this.element.focus();
    },


    /**
     * Enable the input.
     * @returns {void}
     */
    enable: function enable() {
      this.element.prop('disabled', false).prop('readonly', false);
      this.element.parent().removeClass('is-disabled');
    },


    /**
     * Disable the input.
     * @returns {void}
     */
    disable: function disable() {
      this.element.prop('disabled', true);
      this.element.parent().addClass('is-disabled');
    },


    /**
     * Make the input readonly.
     * @returns {void}
     */
    readonly: function readonly() {
      this.element.prop('readonly', true);
    },


    /**
     * Make the input the size of the text.
     * @private
     * @returns {void}
     */
    applyAutoWidth: function applyAutoWidth() {
      var value = this.element.val();
      var length = value.length;
      var isUpperCase = value === value.toUpperCase();
      var isNumber = !isNaN(value);

      this.element.attr('size', length + (isUpperCase && !isNumber ? 2 : 1));
    },


    /**
     * apply the min width setting to the datagrid.
     * @private
     * @param {jquery[]} lookupGrid jQuery wrapped element
     * @returns {jquery[]} grid jQuery wrapped element with the css applied
     */
    applyMinWidth: function applyMinWidth(lookupGrid) {
      if (this.settings.minWidth == null) {
        return lookupGrid;
      }

      // check that the minWidth is less than the windows width, so
      // that the control remains responsive
      if ($(window).width() > this.settings.minWidth) {
        var minWidth = this.settings.minWidth + 'px';
        lookupGrid.css({
          'min-width': minWidth
        });
      }

      return lookupGrid;
    },


    /**
     * Input is disabled or not
     * @returns {boolean} whether or not the Input is disabled
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },


    /**
     * Input is readonly or not
     * @returns {boolean} whether or not the Input is readonly
     */
    isReadonly: function isReadonly() {
      return this.element.prop('readonly');
    },


    /**
     * Updates the lookup instance with new settings
     * @param {object} settings incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }
    },


    /**
    * Send in a new data set to display in the datagrid in the lookup.
    * This will work whether or not the lookup is open or closed.
    * @param {object} dataset The array of data to show in the datagridgrid.
    * @param {object} pagerInfo The extra pager info object with information like activePage and pagesize.
    */
    updateDataset: function updateDataset(dataset, pagerInfo) {
      this.settings.options.dataset = dataset;

      if (pagerInfo && pagerInfo.activePage) {
        this.settings.options.activePage = pagerInfo.activePage;
      }

      if (pagerInfo && pagerInfo.pagesize) {
        this.settings.options.pagesize = pagerInfo.pagesize;
      }

      if (this.grid) {
        this.grid.updateDataset(dataset, pagerInfo);
      }
    },


    /**
    * Teardown events and objects.
    * @returns {void}
    */
    destroy: function destroy() {
      $.removeData(this.element[0], COMPONENT_NAME$1b);
      this.element.off('click.dropdown keypress.dropdown');

      this.icon.remove();
      this.element.unwrap();

      if (this.label && this.label != null) {
        this.label.find('.audible').remove();
      }
    }
  };

  /**
   * jQuery Component Wrapper for Lookup
   * @param {object} settings The settings to apply.
   * @returns {jQuery[]} The jquery object for chaining.
   */
  $.fn.lookup = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1b);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1b, new Lookup(this, settings));
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$1c = 'multitabs';

  // Default Settings for MultiTabs
  var MULTITABS_DEFAULTS = {
    tabContainers: []
  };

  // Pre-defined names used internally for tab containers
  var TAB_CONTAINER_NAMES = ['primary', 'secondary', 'tertiary'];

  /**
   * Scaffolding for containment of multiple, associated tabs containers.
   *
   * @class MultiTabs
   * @param {jQuery[]|HTMLElement} element base element
   * @param {object} [settings] incoming settings
   * @param {array} [settings.tabContainers] contains pre-set tab containers
   */
  function MultiTabs(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, MULTITABS_DEFAULTS);

    // internal stuff
    this.tabContainers = {};

    return this.init();
  }

  MultiTabs.prototype = {
    /**
     * Extra initializing steps
     * @private
     * @returns {void}
     */
    init: function init() {
      var self = this;
      var tabContainers = [];

      if (this.settings.tabContainers instanceof Array && this.settings.tabContainers.length) {
        tabContainers = this.settings.tabContainers;
      } else {
        tabContainers = this.element.find('.tab-container').filter(function () {
          return !$(this).parents('.tab-panel-container').length;
        });
      }

      $(tabContainers).each(function () {
        self.setupTabsInstance($(this));
      });
    },


    /**
     * Builds and stores an instance of a Tabs component.
     * @param {jQuery[]} tabContainer a reference to a `.tab-container` element.
     * @returns {void}
     */
    setupTabsInstance: function setupTabsInstance(tabContainer) {
      if (!(tabContainer instanceof $)) {
        return;
      }

      var self = this;
      var didAdd = false;

      TAB_CONTAINER_NAMES.forEach(function (propname) {
        if (didAdd || Object.prototype.hasOwnProperty.call(self.tabContainers, propname)) {
          return;
        }

        var api = tabContainer.data('tabs');
        if (!api) {
          tabContainer.tabs();
          api = tabContainer.data('tabs');
        }
        api.multitabsID = propname;

        tabContainer.attr('data-multitabs', propname);
        self.tabContainers[propname] = tabContainer;
        didAdd = true;
      });

      if (!didAdd) {
        throw new Error('all tab-container slots in MultiTabs component are taken, so a new tabs container was not invoked and stored');
      }
    },


    /**
     * Pass-through method for adding tabs that takes the container into account.
     * @param {jQuery[]|String} tabContainer the tab container to target
     * @param {string} tabId (directly passed into the Tabs `add` method)
     * @param {object} options (directly passed into the Tabs `add` method)
     * @param {number} [atIndex] (directly passed into the Tabs `add` method)
     * @returns {Tabs} the tabs API
     */
    add: function add(tabContainer, tabId, options, atIndex) {
      tabContainer = this.checkForValidTabContainer(tabContainer);

      var api = tabContainer.data('tabs');
      return api.add(tabId, options, atIndex);
    },


    /**
     * Pass-through method for removing tabs that takes the container into account.
     * @param {jQuery[]|String} tabContainer the tab container being removed
     * @param {string} tabId - (directly passed into the Tabs `add` method)
     * @param {boolean} [disableBeforeClose] - (directly passed into the Tabs `add` method)
     * @returns {Tabs} the tabs API instance
     */
    remove: function remove(tabContainer, tabId, disableBeforeClose) {
      tabContainer = this.checkForValidTabContainer(tabContainer);

      var api = tabContainer.data('tabs');
      return api.remove(tabId, disableBeforeClose);
    },


    /**
     * Finds an existing Tab Panel in any of the tab containers, and moves it
     *  to a designated target tab container.
     * @param {string} tabId the ID of the tab panel (and HREF attribute of the tab) being moved.
     * @param {string} targetTabContainerName name of the tab container that will receive the panel.
     * @param {boolean} [doActivate] optionally activtes the tab after it's moved.
     * @returns {void}
     */
    move: function move(tabId, targetTabContainerName, doActivate) {
      if (!tabId || !targetTabContainerName) {
        throw new Error('can\'t move a tab without both a tabId and a targetTabContainerName');
      }

      var tabMarkup = void 0;
      var panelMarkup = void 0;
      var allTabContainers = this.getFilterableTabContainers();
      var originalTabContainerName = void 0;

      allTabContainers.each(function () {
        var api = $(this).data('tabs');
        var tab = api.getTab(null, tabId);

        // No tabs exist by this id
        if (tab === null) {
          return;
        }

        originalTabContainerName = api.multitabsID;
        tabMarkup = tab.clone();
        panelMarkup = api.getPanel(tabId).children();
      });

      if (!tabMarkup) {
        throw new Error('No tab markup was found in any Multitabs container for href "' + tabId + '"');
      }

      this.remove(originalTabContainerName, tabId);
      this.add(targetTabContainerName, tabId, {
        name: tabMarkup.children('a').text().trim(),
        content: panelMarkup,
        doActivate: doActivate
      }); // TODO: test atIndex
    },


    /**
     * Uses the internal name of the tab container to either get a reference to an existing
     *  Tab container, or a null reference.
     * @private
     * @param {string} name - the internal name used for this tabs instance
     * @returns {jQuery[]|undefined} a tab container reference
     */
    getTabContainer: function getTabContainer(name) {
      var self = this;
      var ref = void 0;

      TAB_CONTAINER_NAMES.forEach(function (propname) {
        if (ref || !self.tabContainers[propname]) {
          return;
        }

        if (name === propname) {
          ref = self.tabContainers[propname];
        }
      });

      return ref;
    },


    /**
     * Gets all currently-setup tab containers in a jQuery selector.
     * @private
     * @returns {jQuery[]} a jQuery-based collection of all available tab containers
     */
    getFilterableTabContainers: function getFilterableTabContainers() {
      var ret = $();

      this.performOnAllContainers(function (propname, container) {
        ret = ret.add(container);
      });

      return ret;
    },


    /**
     * Validates an incoming tabContainer name, or jQuery-wrapped Tab Container instance, and returns.
     * @private
     * @param {jQuery[]|string} tabContainer the tab container being checked
     * @returns {jQuery[]} the validated tab container
     */
    checkForValidTabContainer: function checkForValidTabContainer(tabContainer) {
      if (!tabContainer) {
        throw new Error('Need to have a tabContainer defined to hide a tabs instance');
      }
      if (typeof tabContainer === 'string') {
        tabContainer = this.getTabContainer(tabContainer);
      }
      if (!(tabContainer instanceof $) || !tabContainer.length) {
        throw new Error('No matching tabContainer could be found and hidden.');
      }

      return tabContainer;
    },


    /**
     * Runs a callback function on all available tab containers.
     * @param {function} callback the callback function to be executed
     * @param {array} [additionalArgs] any additional arguments to be run in the
     *  context of the callback.
     * @returns {void}
     */
    performOnAllContainers: function performOnAllContainers(callback, additionalArgs) {
      var self = this;

      // Make sure additionalArgs is an array of some sort.
      if (!Array.isArray(additionalArgs)) {
        if (!additionalArgs) {
          additionalArgs = [];
        } else {
          additionalArgs = [additionalArgs];
        }
      }

      TAB_CONTAINER_NAMES.forEach(function (propname) {
        var container = self.tabContainers[propname];
        var args = [];

        if (container) {
          args.push(propname, container);
          args = args.concat(additionalArgs);
          callback.apply(this, args);
        }
      });
    },


    /**
     * Re-adjust Module-tab containers' tab widths/alignments so everything lines up.
     * @private
     * @returns {void}
     */
    adjustModuleTabContainers: function adjustModuleTabContainers() {
      this.performOnAllContainers(function (propname, container) {
        var api = container.data('tabs');
        if (api.isModuleTabs()) {
          api.adjustModuleTabs();
        }
      });
    },


    /**
     * Temporarily removes a tabset from view without destroying it.
     * @param {jQuery[]|string} tabContainer the tab container to be hidden.
     * @returns {void}
     */
    hideTabsInstance: function hideTabsInstance(tabContainer) {
      tabContainer = this.checkForValidTabContainer(tabContainer);
      tabContainer.parent('.multitabs-section').addClass('hidden');
      this.adjustModuleTabContainers();
    },


    /**
     * Re-displays a tabset that has temporarily been removed from view.
     * @param {jQuery[]|string} tabContainer the tab container to be shown.
     * @returns {void}
     */
    showTabsInstance: function showTabsInstance(tabContainer) {
      tabContainer = this.checkForValidTabContainer(tabContainer);
      tabContainer.parent('.multitabs-section').removeClass('hidden');
      this.adjustModuleTabContainers();
    },


    /**
     * Destroys a tabs instance and removes it from the queue.
     * NOTE: This only happens if the tabContainer is a part of this instance of Multitabs.
     * @param {jQuery[]} tabContainer the tab container to be destroyed.
     * @returns {void}
     */
    destroyTabsInstance: function destroyTabsInstance(tabContainer) {
      if (!(tabContainer instanceof $) || !tabContainer.data('tabs') || typeof tabContainer.data('tabs').destroy !== 'function') {
        return;
      }

      var self = this;
      var doRemove = false;

      TAB_CONTAINER_NAMES.forEach(function (propname) {
        if (doRemove || !self.tabContainers[propname].is(tabContainer)) {
          return;
        }

        var api = tabContainer.data('tabs');

        delete api.multitabsID;
        tabContainer.removeAttr('data-multitabs');

        api.destroy();
        delete self.tabContainers[propname];
        doRemove = true;
      });

      if (!doRemove) {
        throw new Error('could not destroy a tabContainer because it was not associated with this Multitabs instance');
      }
    },


    /**
     * Detects whether or not a Tab Container is currently hidden
     * @param {jQuery[]|string} tabContainer the tab container to be checked.
     * @returns {boolean} whether or not the tab container is currently hidden.
     */
    isHidden: function isHidden(tabContainer) {
      tabContainer = this.checkForValidTabContainer(tabContainer);
      return tabContainer.parent('.multitabs-section').is('.hidden');
    },


    /**
     * Update this multi-tabs instance with new settings
     * @param {object} [settings] incoming settings.
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }
    },


    /**
     * Tears down a Multitabs instance
     * @returns {this} component instance
     */
    teardown: function teardown() {
      var _this = this;

      var containers = Object.keys(this.tabContainers);
      containers.forEach(function (container) {
        _this.destroyTabsInstance(container);
      });

      return this;
    },


    /**
     * Destroys a Multitabs instance
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$1c);
    }
  };

  /**
   * jQuery Component Wrapper for MultiTabs
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} invoked/updated component elements
   */
  $.fn.multitabs = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1c);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1c, new MultiTabs(this, settings));
      }
    });
  };

  // All desired Soho jQuery-based components ==================== /

  // Component Name
  var COMPONENT_NAME$1d = 'listdetail';
  // Available breakpoint types for Edge Bleeding
  var LIST_DETAIL_EDGE_BLEED_BREAKPOINTS = ['phone', 'tablet'];

  /**
   * @class ListDetail
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {HTMLElement} [settings.backElement] defines a trigger button that will be used to "drill up" from the detail
   * back to the list on the responsive view of this pattern.
   * @param {boolean} [settings.edgeBleed=false] if true, will show an interactive edge of the "list" element while the
   * detail view is active.  Clicking the left edge (or a button in the left edge) will cause the "drillup" operation to occur
   * while making the list active.
   * @param {string} [settings.edgeBleedBreakpoint='phone'] Defines the breakpoint where the responsive "edge bleeding" style will occur.
   * @param {HTMLElement} [settings.listElement] the base element for the Soho component that will be used as the "List" to be chosen from.
   * Must implement a Soho Accordion or Listview element.
   * @param {HTMLElement} [settings.listCloseElement]  defines a trigger button element that can be used to collapse a bleeding-edge list drawer.
   * @param {HTMLElement} [settings.detailElement] the base element for the Soho component that will be used as "detail" or content area that can
   * change based on what is picked from the list.
   */
  var LIST_DETAIL_DEFAULTS = {
    backElement: undefined,
    edgeBleed: false,
    edgeBleedBreakpoint: LIST_DETAIL_EDGE_BLEED_BREAKPOINTS[0],
    listElement: undefined,
    listCloseElement: undefined,
    detailElement: undefined
  };

  // Available Soho Elements to be used as the list
  var LIST_DETAIL_SUPPORTED_LIST_TYPES = ['accordion', 'listview'];

  /**
   * Gets the type of list component
   * @private
   * @param {HTMLElement} listElement the element being checked
   * @returns {string|undefined} the type of component, or undefined
   */
  function getListType(listElement) {
    if (!(listElement instanceof HTMLElement)) {
      return undefined;
    }

    var components = Object.keys($(listElement).data());
    var type = void 0;
    components.forEach(function (key) {
      if (LIST_DETAIL_SUPPORTED_LIST_TYPES.indexOf(key) > -1) {
        type = key;
      }
    });

    return type;
  }

  /**
   * Checks an HTMLElement for a Soho Component instance that can be used for the list
   * @private
   * @param {HTMLElement} listElement the element being checked
   * @returns {boolean} whether or not the element is a valid list type
   */
  function isValidList(listElement) {
    if (!(listElement instanceof HTMLElement)) {
      return false;
    }

    var type = getListType(listElement);
    return type !== undefined;
  }

  /**
   * Implements cross-functionality between a list component and a content area that are described by
   * a Soho List/Detail pattern
   * @constructor
   * @param {HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   * @returns {void}
   */
  function ListDetail(element, settings) {
    if (!(element instanceof HTMLElement)) {
      return;
    }

    this.element = element;
    this.settings = utils.mergeSettings(this.element, settings, LIST_DETAIL_DEFAULTS);
    this.init();
  }

  ListDetail.prototype = {

    /**
     * @private
     */
    init: function init() {
      var _this = this;

      this.setInternalElementReference('listElement', function (elemType) {
        return isValidList(_this.settings[elemType]);
      });
      this.setInternalElementReference('detailElement');
      this.setInternalElementReference('backElement');
      this.setInternalElementReference('listCloseElement');

      // Single sanity-check for showing the detail area.
      this.showDetail = false;
      if (this.element.classList.contains('show-detail')) {
        this.showDetail = true;
      }

      // If a proper listElement has been provided, set a flag on its Component API
      // that notifies the API that it's controlling an adjacent detail area.
      if (this.listElement) {
        this.listComponentType = getListType(this.listElement);
        var API = this.getListAPI();
        if (API) {
          API.isControllingDetails = true;
        }
      }

      if (this.backElement) {
        this.backElement.classList.add('list-detail-back-button');

        // If it's an icon button, get a reference to the icon so we can change its state.
        var hasIcon = this.backElement.querySelector('.icon');
        if (hasIcon) {
          this.backElementIcon = hasIcon;
        }

        // Setup internal references that can be used to find out where a backElement
        // is located internally in this pattern instance.
        this.listContainsBackElement = this.listElement.contains(this.backElement);
        this.detailContainsBackElement = this.detailElement.contains(this.backElement);
      }

      // Gets children list/detail components
      var children = this.element.querySelectorAll('.list-detail');
      if (children) {
        this.childrenListDetailElements = children;
      }

      // Change edgebleed setting
      if (this.settings.edgeBleed) {
        this.edgeBleed = true;
        this.element.classList.add('bleeding-edge__' + this.settings.edgeBleedBreakpoint);
      } else {
        this.edgeBleed = false;
        this.element.classList.remove('bleeding-edge__phone', 'bleeding-edge__tablet');
      }

      // Flags for responsive behavior
      this.setBreakpointChecks();

      this.handleEvents();
    },


    /**
     * Sets internal checks for certain breakpoints
     * @private
     * @returns {void}
     */
    setBreakpointChecks: function setBreakpointChecks() {
      this.abovePhoneBreakpoint = breakpoints.isAbove('phone-to-tablet');
      this.aboveTabletBreakpoint = breakpoints.isAbove('desktop');
    },


    /**
     * Takes elements defined as settings properties, and evaluates them to determine if they
     * are valid. If so, they are set as internal component properties for future use.
     * @private
     * @param {string} elementType corresponds to a setting on the pattern that
     *  represents an element reference.
     * @param {function} [storageConditions] if defined as a function, will provide an
     *  additional set of parameters for determining if an HTMLElement is valid for this element type.
     * @returns {void}
     */
    setInternalElementReference: function setInternalElementReference(elementType, storageConditions) {
      if (typeof this.settings[elementType] === 'string' && this.settings[elementType].length) {
        var queryForElem = document.querySelector(this.settings[elementType]);
        if (queryForElem) {
          this.settings[elementType] = queryForElem;
        }
      }

      // Set to true to simply pass the next check, if a callback isn't provided.
      // Otherwise, resolve the callback (which should return a boolean)
      if (typeof storageConditions !== 'function') {
        storageConditions = true;
      } else {
        storageConditions = storageConditions(elementType);
      }

      if (this.settings[elementType] instanceof HTMLElement && storageConditions) {
        this[elementType] = this.settings[elementType];
      }
    },


    /**
     * @private
     * @listens drilldown custom jQuery event that causes the detail area to become active
     * @listens drillup custom jQuery event that causes the list area to become active
     * @listens click
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      $(this.element).on('drilldown.' + COMPONENT_NAME$1d, function (e, item) {
        e.stopPropagation();
        _this2.drilldown(item, e.target);
      }).on('drillup.' + COMPONENT_NAME$1d, function (e) {
        e.stopPropagation();
        _this2.drillup();
      });

      if (this.backElement) {
        this.backElement.addEventListener('click', this.handleBackClick.bind(this));
      }

      if (this.listCloseElement) {
        this.listCloseElement.addEventListener('click', this.handleClose.bind(this));
      }

      // Run certain responsive checks on page resize
      $('body').off('resize.' + COMPONENT_NAME$1d).on('resize.' + COMPONENT_NAME$1d, function () {
        _this2.handleResize();
      });
    },


    /**
     * Causes the list/detail pattern to activate the detail area, "drilling down"
     *  into it, away from the list area.
     * @param {HTMLElement} section provides context from the element chosen from the list
     * @param {HTMLElement} [eventTarget] will cause the drilldown operation to stop if the
     *  element provided isn't registered as the list in this list/detail instance (used when
     *  events trigger this method).
     * @returns {void}
     */
    drilldown: function drilldown(section, eventTarget) {
      if (this.showDetail) {
        return;
      }

      // If eventTarget's provided, check to see if it's the same element as the
      // stored ListElement.  If they're not, don't continue (could have been triggered
      // by an inner-detail area ListView/Accordion)
      if (eventTarget && eventTarget.innerHTML !== this.listElement.innerHTML) {
        return;
      }

      this.showDetail = true;
      this.element.classList.add('show-detail');

      this.addBackElementIconContext();

      if (!this.isAboveBreakpoint()) {
        this.getListAPI().disable();
      }

      // Pass an event to the Detail Area's main element with some context about
      // what was clicked inside the list.
      if (this.detailArea) {
        $(this.detailElement).triggerHandler('activatescreen', [section]);
      }
    },


    /**
     * Causes the list/detail pattern to activate the list area, "drilling up" from the detail area.
     * @returns {void}
     */
    drillup: function drillup() {
      if (!this.showDetail) {
        return;
      }

      this.removeBackElementIconContext();

      this.getListAPI().enable();

      this.showDetail = false;
      this.element.classList.remove('show-detail');
    },


    /**
     * @private
     * @returns {void}
     */
    addBackElementIconContext: function addBackElementIconContext() {
      if (this.showDetail && this.backElementIcon && !this.backElementIcon.classList.contains('go-back')) {
        this.backElementIcon.classList.add('go-back');
      }
    },


    /**
     * @private
     * @returns {void}
     */
    removeBackElementIconContext: function removeBackElementIconContext() {
      if (this.backElementIcon && this.backElementIcon.classList.contains('go-back')) {
        this.backElementIcon.classList.remove('go-back');
      }
    },


    /**
     * Handles `click` events passed to the `backElement`.
     * @private
     * @param {Event} e `click` event
     * @returns {boolean} whether or not the click operation should be allowed to continue
     */
    handleBackClick: function handleBackClick(e) {
      function cancelClick() {
        // Prevent the normal `click` operation of the backElement.
        // (FX: if `backElement` is the App Menu trigger, prevents the App Menu from opening)
        e.stopPropagation();
        e.stopImmediatePropagation();
        e.preventDefault();
      }

      if (!this.showDetail) {
        // In "edgeBleed" configuration, the BackElement can be used to drill back into a previously
        // selected list item, if one was previously selected.
        if (this.edgeBleed) {
          var selected = this.getCurrentSelectedListItem();
          if (selected) {
            this.drilldown(selected);
            cancelClick();
            return false;
          }
        }

        return true;
      }

      this.drillup();

      if (this.childrenListDetailElements) {
        this.childrenListDetailElements.forEach(function (elem) {
          var api = $(elem).data(COMPONENT_NAME$1d);
          if (api && typeof api.drillup === 'function') {
            api.drillup();
          }
        });
      }

      cancelClick();
      return false;
    },


    /**
     * Handler for the listCloseElement's `click` event.
     * @returns {void}
     */
    handleClose: function handleClose() {
      if (this.showDetail) {
        return;
      }

      // `selected` may be undefined here
      var selected = this.getCurrentSelectedListItem();
      this.drilldown(selected);
    },


    /**
     * Event handler for `body.on('resize')`. Runs whenever the page is resized.
     * @returns {void}
     */
    handleResize: function handleResize() {
      this.setBreakpointChecks();
      var listAPI = this.getListAPI();

      if (this.isAboveBreakpoint()) {
        if (this.edgeBleed && !this.showDetail && this.listElement.classList.contains('is-disabled')) {
          listAPI.enable();
        }
      } else if (this.edgeBleed && this.showDetail && !this.listElement.classList.contains('is-disabled')) {
        listAPI.disable();
      }

      // Removes the `go-back` class from the hamburger icon if we're above the breakpoint.
      if (this.isAboveBreakpoint()) {
        this.removeBackElementIconContext();
      } else {
        this.addBackElementIconContext();
      }

      // Make sure the list is always re-enabled on desktop
      if (breakpoints.isAbove('desktop')) {
        listAPI.enable();
      }
    },


    /**
     * Checks to see if the screen size is currently above the defined breakpoint
     * @returns {boolean} whether or not the screen size is larger than the defined breakpoint.
     */
    isAboveBreakpoint: function isAboveBreakpoint() {
      var breakpoint = this.settings.edgeBleedBreakpoint;
      var breakpointPropname = 'above' + stringUtils.capitalize(breakpoint) + 'Breakpoint';

      return this[breakpointPropname];
    },


    /**
     * Gets a reference to the defined List Element's Component API.
     * @returns {object|undefined} a Soho Component API from a supported list type, or undefined
     * if no API currently exists.
     */
    getListAPI: function getListAPI() {
      if (!this.listElement) {
        return undefined;
      }
      return $(this.listElement).data(this.listComponentType);
    },


    /**
     * Finds whatever item is currently selected by the listElement.
     * @returns {HTMLElement} a reference to that element.
     */
    getCurrentSelectedListItem: function getCurrentSelectedListItem() {
      if (!this.listElement) {
        return '';
      }

      var item = void 0;
      var API = this.getListAPI();

      switch (this.listComponentType) {
        case 'accordion':
          item = API.getSelected();
          break;
        default:
          // 'listview'
          item = API.getSelected();
          break;
      }

      // Most components are still using jQuery,
      // Run through a simple reference extraction to get at the HTMLElement
      item = DOM.convertToHTMLElement(item);

      return item;
    },


    /**
     * Updates the List/Detail pattern with new settings
     * @param {object} [settings] incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.teardown();
      this.init();
    },


    /**
     * Removes all bound events and internal references to other components' elements/APIs
     * @private
     * @returns {void}
     */
    teardown: function teardown() {
      $('body').off('resize.' + COMPONENT_NAME$1d);

      $(this.element).off('drilldown.' + COMPONENT_NAME$1d + ' drillup.' + COMPONENT_NAME$1d);

      if (this.backElement) {
        this.backElement.removeEventListener('click', this.handleBackClick.bind(this));
      }

      if (this.listCloseElement) {
        this.listCloseElement.removeEventListener('click', this.handleClose.bind(this));
      }

      if (this.listComponentType) {
        var API = this.getListAPI();
        if (API) {
          delete API.isControllingDetails;
        }
      }

      delete this.listElement;
      delete this.detailElement;
      delete this.backElement;
      delete this.backElementIcon;
      delete this.edgeBleed;
      delete this.listContainsBackElement;
      delete this.detailContainsBackElement;
      delete this.childrenListDetailElements;
      delete this.showDetail;
    },


    /**
     * @private
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element, COMPONENT_NAME$1d);
    }
  };

  /**
   * jQuery Component Wrapper for List/Detail Pattern
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */
  $.fn.listdetail = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1d);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1d, new ListDetail(this, settings));
        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, COMPONENT_NAME$1d);
        };
      }
    });
  };

  // Component Name
  var COMPONENT_NAME$1e = 'stepprocess';

  // Default Stepprocess Options
  var STEPPROCESS_DEFAULTS = {
    linearProgression: false,
    folderIconOpen: 'caret-up',
    folderIconClosed: 'caret-down',
    stepList: '#step-list',
    stepLi: '.js-step',
    stepLink: '.js-step-link',
    stepFolder: '.js-step-folder',
    btnPrev: '.js-step-link-prev',
    btnNext: '.js-step-link-next',
    btnSaveClose: '.js-btn-save-changes',
    beforeSelectStep: null
  };

  /**
   * A Stepprocess/wizard control
   *
   * @class Stepprocess
   * @param {string} element The component element.
   * @param {string} [settings] The component settings.
   * @param {boolean} [settings.linearProgression = false] The Main Application Name to display
   in the header. (Defaults to false)
   * @param {string} [settings.folderIconOpen = 'caret-up'] A specific folder open icon. (Defaults to 'caret-up')
   * @param {string} [settings.folderIconClosed =  'caret-down'] A specific folder close icon. (Defaults to 'caret-down')
   * @param {boolean} [settings.stepList = '#step-list'] Determines whether or not to display device
   information (Browser, Platform, Locale, Cookies Enabled).
   * @param {string} [settings.stepLi = '.js-step'] jQuery selector for the step elements.
   * @param {boolean} [settings.stepLink =  '.js-step-link'] jQuery selector for the step link elements.
   * @param {string} [settings.stepFolder = '.js-step-folder'] jQuery selector for the step folder elements.
   * @param {string} [settings.btnPrev = '.js-step-link-prev'] jQuery selector for the previous step button.
   * @param {string} [settings.btnNext = '.js-step-link-prev'] jQuery selector for the next step button.
   * @param {function} [settings.beforeSelectStep] A callback (function or promise)
   that gives args: stepLink (the step link element) and isStepping
   (whether we are prev/next'ing or not).
   */
  function Stepprocess(element, settings) {
    this.settings = utils.mergeSettings(element, settings, STEPPROCESS_DEFAULTS);

    this.element = $(element);
    this.init();
  }

  // Stepprocess Methods
  Stepprocess.prototype = {

    /**
     * Init stepprocess
     * @private
     */
    init: function init() {
      this.stepListJq = $(this.settings.stepList);
      this.initStepprocess();
      this.handleKeys();
      this.setupEvents();
      this.focusFirst();
    },


    /**
     * Initialize stepprocess
     * @private
     * @returns {void}
     */
    initStepprocess: function initStepprocess() {
      var steps = this.stepListJq.find(this.settings.stepLi);

      for (var i = 0, l = steps.length; i < l; i++) {
        this.decorateNode(steps[i]);
      }

      var startingStep = $(this.settings.stepLi + '.is-selected');
      var startingStepLink = startingStep.find(this.settings.stepLink);
      this.selectStep(startingStepLink);
    },


    /**
     * Set initial attributes on each step its counterparts
     * @private
     * @param  {object} step - The step element to decorate
     * @returns {void}
     */
    decorateNode: function decorateNode(step) {
      var self = this;
      var stepJq = $(step);
      var stepLinkJq = stepJq.children(this.settings.stepLink);
      var stepFolderJq = stepJq.children(this.settings.stepFolder);
      var isDisabled = stepLinkJq.hasClass('is-disabled');
      var isOpen = stepFolderJq.hasClass('is-open');

      if (isDisabled) {
        stepLinkJq.attr('aria-disabled', 'true');
      }

      if (stepFolderJq.length) {
        stepJq.addClass('folder');
        stepFolderJq.attr('role', 'group');

        if (isDisabled) {
          stepFolderJq.addClass('disabled');

          if (isOpen) {
            var stepLinks = stepFolderJq.children();

            for (var i = 0, l = stepLinks.length; i < l; i++) {
              $(stepLinks[i]).find(self.settings.stepLink).addClass('is-disabled').attr('aria-disabled', 'true');
            }
          }
        }

        stepLinkJq.attr('aria-expanded', isOpen);
      }

      // parentCount 'aria-level' to the node's level depth
      var parentCount = stepLinkJq.parentsUntil(this.stepListJq, 'ul').length - 1;

      // Set the current stepprocess item node position relative to its aria-setsize
      var posinset = stepJq.index();

      // Set the current stepprocess item aria-setsize
      var listCount = stepJq.siblings().addBack().length;

      stepLinkJq.attr({
        role: 'stepitem',
        tabindex: '-1',
        'aria-selected': 'false',
        'aria-level': parentCount + 1,
        'aria-posinset': posinset + 1,
        'aria-setsize': listCount,
        'aria-disabled': isDisabled
      }).addClass('hide-focus').hideFocus();
    },


    /**
     * Set tabindex to be focus first
     * @private
     * @returns {void}
     */
    focusFirst: function focusFirst() {
      this.stepListJq.find(this.settings.stepLi + ':first').attr('tabindex', '0');
    },


    /**
     * Set initial attributes on each step its counterparts
     * @private
     * @param  {object} step - The step element
     * @returns {void}
     */
    folderClose: function folderClose(step) {
      var _this = this;

      var stepJq = $(step);
      var stepLinkJq = stepJq.children(this.settings.stepLink);
      var stepFolderJq = stepJq.children(this.settings.stepFolder);

      var treeIcon = stepLinkJq.closest('.folder').removeClass('is-open').end().find('svg.icon-tree');

      this.setIcon(treeIcon, this.settings.folderIconClosed);
      this.isAnimating = true;

      stepFolderJq.one('animateclosedcomplete', function () {
        stepFolderJq.removeClass('is-open');
        _this.isAnimating = false;
      }).animateClosed();

      stepLinkJq.attr('aria-expanded', 'false');
    },


    /**
     * Folder open
     * @private
     * @param  {object} step - The step element
     * @returns {void}
     */
    folderOpen: function folderOpen(step) {
      var _this2 = this;

      var stepJq = $(step);

      if (!this.isOpen(stepJq)) {
        var stepLinkJq = stepJq.children(this.settings.stepLink);
        var stepFolderJq = stepJq.children(this.settings.stepFolder);

        stepJq.addClass('is-open');
        stepLinkJq.attr('aria-expanded', 'true');

        var svgElem = stepLinkJq.find('svg.icon-tree');
        this.setIcon(svgElem, this.settings.folderIconOpen);

        this.isAnimating = true;

        stepFolderJq.one('animateopencomplete', function () {
          _this2.isAnimating = false;
        }).addClass('is-open').css('height', 0).animateOpen();
      }
    },


    /**
     * Folder toggle
     * @private
     * @param  {object} stepLink - Description
     * @returns {void}
     */
    folderToggle: function folderToggle(stepLink) {
      var stepJq = stepLink.closest(this.settings.stepLi);

      if (this.isFolder(stepJq)) {
        var stepFolderJq = stepJq.children(this.settings.stepFolder);
        if (this.isOpen(stepFolderJq)) {
          this.folderClose(stepJq);
        } else {
          this.folderOpen(stepJq);
        }
      }
    },


    /**
     * Get selected step
     * @private
     * @returns {object} selected step
     */
    getSelectedStep: function getSelectedStep() {
      return $(this.settings.stepLi + '.is-selected', this.stepListJq);
    },


    /**
     * Get next node
     * @private
     * @param  {object} stepLink - The step link element
     * @returns {object} node
     */
    getNextNode: function getNextNode(stepLink) {
      var s = this.settings;
      var next = stepLink.parent().next().find(s.stepLink + ':first');

      // Possibly Move Into Children
      if (stepLink.next().is(s.stepFolder) && stepLink.next().hasClass('is-open')) {
        next = stepLink.next().find(s.stepLink + ':first');
      }

      // Skip disabled
      if (next.hasClass('is-disabled')) {
        next = this.getNextNode(next);
      }

      // Bottom of a group..{l=2: max folders to be deep }
      if (next.length === 0) {
        for (var i = 0, l = 2, closest = stepLink; i < l; i++) {
          closest = closest.parent().closest('.folder');
          next = closest.next().find(s.stepLink + ':first');
          if (next.length) {
            break;
          }
        }
      }

      return next;
    },


    /**
     * Get the next step in the tree
     * (not to be confused with getNextNode, which includes folders)
     * @private
     * @param  {object} curStepJq - The step link element
     * @returns {object} next step
     */
    getNextStep: function getNextStep(curStepJq) {
      var curStepLinkJq = curStepJq.children(this.settings.stepLink);
      var curStepFolderJq = curStepJq.next(this.settings.stepFolder);
      var nextStepLinkJq = this.getNextNode(curStepLinkJq);
      var nextStepFolderJq = nextStepLinkJq.next(this.settings.stepFolder);
      var stepLinkToSelect = null;
      var theFolder = null;

      if (curStepFolderJq.length) {
        // Select the first node of the current folder,
        // unless its empty, which means nextStep will be the folder's "title"
        theFolder = curStepFolderJq;
        stepLinkToSelect = theFolder.children().length ? theFolder.find(this.settings.stepLink).first() : nextStepLinkJq;
      } else if (nextStepFolderJq.length) {
        // Select the first node of the next node's folder,
        // unless its empty, which means nextStep will be the folder's "title"
        theFolder = nextStepFolderJq;
        stepLinkToSelect = theFolder.children().length ? theFolder.find(this.settings.stepLink).first() : nextStepLinkJq;
      } else {
        // Neither folders options work so select the next node
        stepLinkToSelect = nextStepLinkJq;
      }

      // Skip disabled
      if (stepLinkToSelect.hasClass('is-disabled')) {
        stepLinkToSelect = this.getNextStep(stepLinkToSelect.parent());
      }

      return stepLinkToSelect;
    },


    /**
     * Get the previous node
     * @private
     * @param  {object} stepLink - The step link element
     * @returns {object} previous node
     */
    getPreviousNode: function getPreviousNode(stepLink) {
      var s = this.settings;
      var prev = stepLink.parent().prev().find(s.stepLink + ':first');
      var prevStepJq = prev.closest(s.stepLi);

      // Move into children at bottom
      if (prevStepJq.is('.folder.is-open') && prevStepJq.find('ul.is-open a').length && !prevStepJq.find('ul.is-disabled').length) {
        prev = prevStepJq.find('ul.is-open ' + s.stepLink + ':last');
      }

      // Skip disabled
      if (prev.hasClass('is-disabled')) {
        this.getPreviousNode(prev);
      }

      // Top of a group
      if (prev.length === 0) {
        prev = stepLink.closest(s.stepFolder).prev(s.stepLink);
      }
      return prev;
    },


    /**
     * Get the previous step in the tree
     * (not to be confused with getPreviousNode, which includes folders)
     * @private
     * @param  {object} curStepJq - The step link element
     * @returns {object} previous step
     */
    getPreviousStep: function getPreviousStep(curStepJq) {
      var s = this.settings;
      var curStepLinkJq = curStepJq.children(s.stepLink);

      // Get the previous step to switch to
      var prevStepLinkJq = this.getPreviousNode(curStepLinkJq);
      var prevStepJq = prevStepLinkJq.closest(s.stepLi);
      var stepLinkToSelect = prevStepLinkJq;

      // If we are moving upwards and hit a folder title step
      if (this.isFolder(prevStepJq)) {
        if (this.isOpen(prevStepJq)) {
          // If the folder is open, and we got here, that means we
          // were currently at the first step in the folder and need to
          // go to the prev step above the folder step (aka the prev to the prev)
          stepLinkToSelect = this.getPreviousNode(prevStepLinkJq);
        } else {
          var theFolder = prevStepJq.children(s.stepFolder);

          if (theFolder.children().length) {
            stepLinkToSelect = theFolder.find(s.stepLink).last();
          }
        }
      }

      // Skip disabled
      if (stepLinkToSelect.hasClass('is-disabled')) {
        stepLinkToSelect = this.getPreviousStep(stepLinkToSelect.parent());
      }

      return stepLinkToSelect;
    },


    /**
     * Go to the next step element
     * @private
     * @returns {void}
     */
    goToNextStep: function goToNextStep() {
      var self = this;
      var curStepJq = this.getSelectedStep();
      var stepLink = self.getNextStep(curStepJq);
      if (stepLink.length) {
        self.selectStep(stepLink, 'next');
      } else if (typeof self.settings.beforeSelectStep === 'function') {
        var args = { isStepping: 'next' };
        self.settings.beforeSelectStep(args);
      }
    },


    /**
     * Go to the previous step element
     * @private
     * @returns {void}
     */
    goToPreviousStep: function goToPreviousStep() {
      var curStepJq = this.getSelectedStep();
      var stepLink = this.getPreviousStep(curStepJq);
      if (stepLink.length) {
        this.selectStep(stepLink, 'prev');
      }
    },


    /**
     * Key Behavior as per:
     * http://access.aol.com/dhtml-style-guide-working-group/#treeview
     * @private
     * @returns {void}
     */
    handleKeys: function handleKeys() {
      /* eslint-disable consistent-return */
      var self = this;
      var s = this.settings;

      this.stepListJq.on('focus.stepprocess', s.stepLink, function () {
        var target = $(this);
        if (parseInt(target.attr('aria-level'), 10) === 0 && parseInt(target.attr('aria-posinset'), 10) === 1) {
          // First element if disabled
          if (target.hasClass('is-disabled')) {
            var e = $.Event('keydown.stepprocess');
            e.keyCode = 40; // move down
            target.trigger(e);
            return; // eslint-disable-line
          }
        }
      });

      // Handle Up/Down Arrow Keys and Space
      this.stepListJq.on('keydown.stepprocess', s.stepLink, function (e) {
        var charCode = e.charCode || e.keyCode;
        var target = $(this);
        var next = void 0;
        var prev = void 0;

        if (self.isAnimating) {
          return;
        }

        // Down arrow
        if (charCode === 40) {
          var nextNode = self.getNextNode(target);
          self.setFocus(nextNode);
        }

        // Up arrow,
        if (charCode === 38) {
          var prevNode = self.getPreviousNode(target);
          self.setFocus(prevNode);
        }

        // Space
        if (e.keyCode === 32) {
          target.trigger('click.stepprocess');
        }

        // Left arrow
        if (charCode === 37) {
          if (Locale.isRTL()) {
            if (target.next().hasClass('is-open')) {
              prev = target.next().find(s.stepLink + ':first');
              self.setFocus(prev);
            } else {
              self.folderToggle(target);
            }
          } else if (target.next().hasClass('is-open')) {
            self.folderToggle(target);
          } else {
            prev = target.closest('.folder').find(s.stepLink + ':first');
            self.setFocus(prev);
          }
          e.stopPropagation();
          return false;
        }

        // Right arrow
        if (charCode === 39) {
          if (Locale.isRTL()) {
            if (target.next().hasClass('is-open')) {
              self.folderToggle(target);
            } else {
              next = target.closest('.folder').find(s.stepLink + ':first');
              self.setFocus(next);
            }
          } else if (target.next().hasClass('is-open')) {
            next = target.next().find(s.stepLink + ':first');
            self.setFocus(next);
          } else {
            self.folderToggle(target);
            self.setFocus(target);
          }
          e.stopPropagation();
          return false; // eslint-disable-line
        }

        // Home  (fn-right on mac)
        if (charCode === 36) {
          next = self.stepListJq.find(s.stepLink + ':first:visible');
          self.setFocus(next);
        }

        // End (fn-right on mac)
        if (charCode === 35) {
          next = self.stepListJq.find(s.stepLink + ':last:visible');
          self.setFocus(next);
        }
      });

      // Handle Left/Right Arrow Keys
      this.stepListJq.on('keypress.stepprocess', s.stepLink, function (e) {
        var charCode = e.charCode || e.keyCode;
        var target = $(this);

        if (charCode >= 37 && charCode <= 40 || charCode === 32) {
          e.stopPropagation();
          return false;
        }

        // Printable Chars Jump to first high level node with it...
        if (e.which !== 0) {
          target.closest(s.stepLi).nextAll().find('.js-step-link:visible').each(function () {
            var node = $(this);
            var first = node.text().substr(0, 1).toLowerCase();
            var term = String.fromCharCode(e.which).toLowerCase();

            if (first === term) {
              self.setFocus(node);
              return false;
            }
          });
        }
      });
      /* eslint-enable consistent-return */
    },


    /**
     * Checks if given step element is folder.
     * @private
     * @param {object} step - The step element
     * @returns {boolean} true if folder
     */
    isFolder: function isFolder(step) {
      return $(step).hasClass('folder');
    },


    /**
     * Checks if given step element is in folder.
     * @private
     * @param {object} step - The step element
     * @returns {boolean} true is in folder
     */
    isInFolder: function isInFolder(step) {
      return $(step).closest(this.settings.stepFolder, this.stepListJq).length;
    },


    /**
     * Checks if given step folder is open.
     * @private
     * @param {object} stepFolder element
     * @returns {boolean} true is open
     */
    isOpen: function isOpen(stepFolder) {
      return $(stepFolder).hasClass('is-open');
    },


    /**
     * Set focus on given step link.
     * @private
     * @param {object} stepLink element
     * @returns {void}
     */
    setFocus: function setFocus(stepLink) {
      stepLink.focus();
    },


    /**
     * Replace all "icon-", "hide-focus", "\s? - all spaces if any" with nothing.
     * @private
     * @param {object} svg element.
     * @param {string} icon to set.
     * @returns {void}
     */
    setIcon: function setIcon(svg, icon) {
      var iconStr = icon.replace(/icon-|hide-focus|\s?/gi, '');
      svg.changeIcon(iconStr);
    },


    /**
     * Select a step
     * @private
     * @param  {object} stepLink - The jquery object for the step link element
     * @param  {string} linearDirection - [none|previous|next] Which direction we are traveling
     * @returns {void}
     */
    selectStep: function selectStep(stepLink, linearDirection) {
      var self = this;
      if (linearDirection === undefined) {
        linearDirection = 'none';
      }

      // Possibly Call the beforeSelectStep
      var result = void 0;
      if (typeof self.settings.beforeSelectStep === 'function') {
        var args = {
          stepLink: stepLink,
          isStepping: linearDirection
        };
        result = self.settings.beforeSelectStep(args);

        if (result.done && typeof result.done === 'function') {
          // A promise is returned
          result.done(function (continueSelectNode, stepLinkToSelect) {
            if (continueSelectNode) {
              if (stepLinkToSelect) {
                stepLink = stepLinkToSelect;
              }
              self.selectStepFinish(stepLink, linearDirection);
            }
          });
        } else if (result) {
          // boolean is returned instead of a promise
          self.selectStepFinish(stepLink, linearDirection);
        }
      } else {
        // No Callback specified
        self.selectStepFinish(stepLink, linearDirection);
      }
    },


    /**
     * Finishes selecting a step
     * @private
     * @param  {object} stepLink - Description
     * @param  {string} [linearDirection=previous|next] - Description
     * @returns {void}
     */
    selectStepFinish: function selectStepFinish(stepLink, linearDirection) {
      var self = this;
      var allStepLinksJq = $(this.settings.stepLink, this.stepListJq);
      var stepJq = stepLink.closest(this.settings.stepLi);

      if (!this.isFolder(stepJq)) {
        allStepLinksJq.attr({
          tabindex: '-1',
          'aria-selected': 'false'
        }).parent().removeClass('is-selected');

        stepLink.attr({
          tabindex: '0',
          'aria-selected': 'true'
        });

        stepJq.addClass('is-selected');
      }

      if (this.isFolder(stepJq)) {
        // It is a folder
        if (linearDirection === 'none') {
          this.folderToggle(stepJq); // clicking toggles
        } else {
          this.folderOpen(stepJq); // going prev/next always opens
        }
      } else {
        // Its not a folder
        var parentIsFolder = stepJq.closest(this.settings.stepFolder, this.stepListJq);

        if (parentIsFolder.length) {
          // If the step is in a folder, make sure that folder opens
          this.folderOpen(parentIsFolder.closest(this.settings.stepLi));
        }

        // Show the step's panel
        this.showStepPanel(stepLink.attr('href'));
      }
      stepLink.focus();

      setTimeout(function () {
        /**
         * Fires when selected step link.
         * @event selected
         * @memberof Stepprocess
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} stepLink element
         */
        self.element.triggerHandler('selected', stepLink);
      }, 0);
    },


    /**
     * Un selected node
     * @private
     * @param {object} step - The step element to decorate
     * @returns {void}
     */
    unSelectedNode: function unSelectedNode(step) {
      var aTags = $(this.settings.stepLink, this.stepListJq);
      var stepJq = $(step);
      var stepLinkJq = stepJq.children(this.settings.stepLink);

      aTags.attr('tabindex', '-1');
      stepLinkJq.attr('tabindex', '0');

      stepJq.removeClass('is-selected');
      stepLinkJq.attr('aria-selected', 'false');
    },


    /**
     * Setup events
     * @private
     * @returns {void}
     */
    setupEvents: function setupEvents() {
      var _this3 = this;

      var self = this;
      var s = this.settings;

      // Updated and Click events
      this.stepListJq.on('updated.stepprocess', function () {
        _this3.initStepprocess();
      }).on('click.stepprocess', s.stepLink + ':not(.is-clone)', function (e) {
        e.preventDefault();

        if (!s.linearProgression) {
          var targetJq = $(this);

          if (!targetJq.is('.is-disabled, .is-loading')) {
            self.selectStep(targetJq);
            e.stopPropagation();
          }
        }
      });

      // Next Button Click
      $(s.btnPrev).on('click', function (e) {
        e.preventDefault();
        _this3.goToPreviousStep.call(self);
      });

      // Previous Button Click
      $(s.btnNext).on('click', function (e) {
        e.preventDefault();
        _this3.goToNextStep.call(self);
      });

      // Setup main scrolling
      $(s.contentScroll).scrollaction({
        scrollActionTarget: '.main'
      });

      // Setup sidebar scrolling
      $(s.stepListScroll).scrollaction({
        scrollActionTarget: '.sidebar'
      });

      // Toggle sidebar
      // Button to toggle the tree in responsive view
      $('.js-toggle-sidebar').click(function (e) {
        e.preventDefault();
        _this3.element.toggleClass('tablet-hide-steps').toggleClass('phone-hide-steps');
      });
    },


    /**
     * Show the content panel for the step
     * @private
     * @param  {string} contentId - The contentId to show
     * @returns {void}
     */
    showStepPanel: function showStepPanel(contentId) {
      $('.step-panel-active').removeClass('step-panel-active');
      $(contentId).addClass('step-panel-active');
      this.element.addClass('phone-hide-steps');
    },


    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.stepListJq.off('updated.stepprocess click.stepprocess focus.stepprocess keydown.stepprocess keypress.stepprocess').empty();
      return this;
    },


    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, STEPPROCESS_DEFAULTS);
      }
      return this.unbind().init();
    },


    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$1e);
    }
  };

  /**
   * jQuery Component Wrapper for Stepprocess
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */
  $.fn.stepprocess = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1e);
      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1e, new Stepprocess(this, settings));
      }
    });
  };

  // Soho Patterns (jQuery Components)

  // Component Defaults
  var INITIALIZE_DEFAULTS = {
    locale: null
  };

  // Contains excluded CSS selectors that prevent automatic initialization
  var noinitExcludes = '.no-init, [data-init]';

  // Invokes a Soho component against an Element
  function invoke(elem, pluginName, settings) {
    return $(elem)[pluginName](settings);
  }

  // Finds child elements that match a CSS selector
  function matchedItems(elem, selector) {
    var items = elem.find(selector).not(noinitExcludes);
    if (elem.filter(selector).length) {
      items = items.add(elem);
    }
    return items;
  }

  // Array of plugin names, selectors (optional), and callback functions (optional),
  // for no-configuration initializations.
  var PLUGIN_MAPPINGS = [

  // Mobile Zoom Control
  // Needs manual invokation because the rest of initialization is scoped to the
  // calling element, which is the <body> tag.
  ['zoom', null, function () {
    $('head').zoom();
  }],

  // Application Menu
  ['applicationmenu', '#application-menu', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      $(item).applicationmenu({
        triggers: rootElem.find('.application-menu-trigger')
      });
    });
  }],

  // Personalization
  ['personalize', null, function () {
    $('html').personalize();
  }],

  // Hyperlinks
  ['hyperlink'],

  // Icons
  ['icon'],

  // Radio switch
  ['radio', '.radio-section input:radio.handle', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).change(function () {
      if (this.checked) {
        var option = $(this).closest('.option');
        var siblings = option.siblings();
        var fields = 'button, select, input[type="text"]';

        $(fields, option).removeAttr('disabled');
        $(fields, siblings).attr('disabled', 'disabled');
      }
    });
  }], ['splitter'],

  // Tabs
  ['tabs', '.tab-container:not(.vertical)'],

  // Vertical Tabs
  ['verticaltabs', '.tab-container.vertical'],

  // MultiTabs Containers
  ['multitabs', '.multitabs-container'],

  // Select / DropDowns
  ['dropdown', 'select.dropdown:not(.multiselect)'], ['dropdown', 'select.dropdown-xs:not(.multiselect)'], ['dropdown', 'select.dropdown-sm:not(.multiselect)'], ['dropdown', 'select.dropdown-lg:not(.multiselect)'],

  // Modals
  ['modal'],

  // Sliders
  ['slider', 'input[type="range"], .slider'],

  // Editors
  ['editor'],

  // Tooltips
  ['tooltip', 'button[title], span[title], .hyperlink[title], .icon[title], input[title]'],

  // Tree
  ['tree'],

  // Rating
  ['rating'],

  // Listbuilder
  ['listbuilder'],

  // Composite Form Wrapper
  ['compositeform', '.composite-form'],

  // Progress
  ['progress', '.progress-bar'],

  // Format
  ['mask', 'input[data-mask], .new-mask'],

  // Auto Complete
  ['autocomplete', '.autocomplete:not([data-init])'],

  // Multiselect
  ['multiselect', 'select[multiple]:not(.dropdown), .multiselect:not([data-init])'],

  // Button with Effects
  ['button', ['.btn', '.btn-toggle', '.btn-secondary', '.btn-primary', '.btn-modal-primary', '.btn-tertiary', '.btn-icon', '.btn-actions', '.btn-menu', '.btn-split', '.btn-secondary-border'].join(', ')],

  // Hide Focus
  ['hideFocus', 'a.hide-focus, a.tick, .checkbox, .radio, .switch'],

  // Circle Pager
  ['circlepager'],

  // Clear x
  ['clearable', '[data-clearable="true"]'],

  // Text Area
  ['textarea', 'textarea'],

  // Spinbox
  ['spinbox'],

  // sort drag and drop
  ['arrange'],

  // Swap List
  ['swaplist'],

  // Color Picker
  ['colorpicker'],

  // Date Picker
  ['datepicker'],

  // Time Picker
  ['timepicker'],

  // Tag
  ['tag'],

  // Busy Indicator
  ['busyindicator', '.busy, .busy-xs, .busy-sm'], ['header'], ['fileupload', 'input.fileupload:not(.fileupload-background-transparent)'], ['fileuploadadvanced', '.fileupload-advanced'], ['fieldfilter', '.field-filter'], ['fieldoptions', '.field-options'], ['about'], ['contextualactionpanel', '.contextual-action-panel-trigger'], ['expandablearea', '.expandable-area'], ['signin'], ['homepage'], ['lookup', '.lookup:not([data-init])'], ['wizard'], ['popdown', '[data-popdown]'], ['stepchart', '.step-chart'], ['calendar', '.calendar'], ['monthview', '.monthview'], ['listview'],

  // Track Dirty
  ['trackdirty', '[data-trackdirty="true"]'],

  // Context Menus - Popupmenu Components with no trigger buttons
  ['popupmenu', '[data-popupmenu]:not(.btn-actions, .btn-filter, .btn-menu)', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var popupElem = $(item);
      var settings = $.extend({}, utils.parseOptions(popupElem));
      var popupData = popupElem.attr('data-popupmenu');

      if (popupData) {
        settings.menuId = popupData;
      }

      invoke(popupElem, pluginName, settings);
    });
  }],

  // Menu Buttons - Popupmenu Components attached to trigger buttons
  ['popupmenu', '.btn-actions, .btn-filter, .btn-menu', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var triggerButton = $(item);

      // Don't auto-invoke Toolbar's Popupmenus.
      // Toolbar needs to completely control its contents and invoke each one manually.
      if (triggerButton.parents('.toolbar, .flex-toolbar').length > 0) {
        return;
      }

      invoke(triggerButton, pluginName);
    });
  }],

  // Popover
  ['popover', '[data-popover]', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function () {
      var options = utils.parseOptions(this);
      var obj = $(this);
      var trigger = obj.attr('data-trigger');
      var title = obj.attr('data-title');
      var placement = obj.attr('data-placement');

      if (!$.isEmptyObject(options)) {
        obj.popover({
          content: $(options.content),
          popover: true,
          trigger: options.trigger || 'click',
          title: options.title || undefined,
          placement: options.placement || 'right',
          extraClass: options.extraClass || undefined
        });
      } else {
        obj.popover({
          content: $('#' + obj.attr('data-popover')),
          popover: true,
          trigger: trigger || 'click',
          title: title || undefined,
          placement: placement || 'right',
          extraClass: options.extraClass || undefined
        });
      }
    });
  }],

  // Searchfield components need to be filtered for ToolbarSearchfield components,
  // which are invoked separately by their Toolbar element containers.
  ['searchfield', '.searchfield', function (rootElem, pluginName, selector) {
    var searchfields = matchedItems(rootElem, selector);
    var toolbarSearchfields = searchfields.filter(function () {
      return $(this).parents('.toolbar').length;
    });
    searchfields = searchfields.not(toolbarSearchfields);

    searchfields.each(function () {
      invoke(this, 'searchfield');
    });
  }],

  // Toolbar components that are invoked by parent Headers, Contextual Action Panels, and
  // Modal components should be excluded.
  ['toolbar', '.toolbar', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var t = $(item);

      if (t.parents('.header, .contextual-action-panel .modal-header').length && !rootElem.is('.toolbar')) {
        return;
      }

      invoke(t, 'toolbar');
    });
  }],

  // Flex Toolbar
  ['toolbarflex', '.flex-toolbar'],

  // Accordion components that are invoked by Application Menus should be excluded.
  ['accordion', '.accordion', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var a = $(item);
      if (a.parents('.application-menu').length) {
        return;
      }

      invoke(a, 'accordion');
    });
  }],

  // Form Compact Component
  ['formcompact', '.form-compact-container', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      invoke($(item), 'formcompact');
    });
  }],

  // List/Detail Pattern
  ['listdetail', '.list-detail', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      invoke($(item), 'listdetail');
    });
  }],

  // Inline text translations by Locale, via the `data-translate` attribute.
  // (Not all inline text items are powered by JS components)
  ['texttranslations', '[data-translate="text"]', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var obj = $(item);
      obj.text(Locale.translate(obj.text(), true));
    });
  }],

  // Translate `aria-label` attributes on Breadcrumb lists
  // (Breadcrumbs aren't invoked with a JS component)
  ['breadcrumblabels', '.breadcrumb ol', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).attr('aria-label', Locale.translate('Breadcrumb'));
  }],

  // Validation on individual fields (Should run last)
  ['validate', '[data-validate]', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).closest('form, body').validate();
  }],

  // Form validation
  ['validate', 'form[data-validate-on="submit"]']];

  // Invokes a specific Soho component type against an element, in some cases with
  // specified rules or CSS selectors.
  function mapToInit(elem, plugin, selector, callback) {
    // Don't continue if the jQuery constructor for this plugin isn't loaded.
    if (!$.fn[plugin] && plugin !== 'texttranslations') {
      return;
    }

    // Allow only the plugin name to be specified if the default selector is
    // a class with the same name, Like `$.fn.header` applying to elements that
    // match `.header`
    if (typeof selector === 'undefined') {
      selector = '.' + plugin;
    }

    // If a callback function is provided, run that instead of the normal init.
    // Functions contain more-customized initialization for some components.
    if (typeof callback === 'function') {
      callback(elem, plugin, selector);
      return;
    }

    // Run the matcher and do normal init.
    matchedItems(elem, selector).each(function () {
      var thisElem = $(this);

      // Don't init if this element or one of its containing elements is flagged
      // with `[data-init]` or `.no-init`.
      if (thisElem.is(noinitExcludes) || thisElem.parents(noinitExcludes).length) {
        return;
      }

      invoke(this, plugin);
    });
  }

  /**
   * Page Bootstrapper, will initialize all components on a page with default settings.
   * @class Initialize
   * @constructor
   * @param {jQuery[]|HTMLElement} element the root element to initialize
   * @param {object} [settings] incoming settings
   */
  function Initialize(element, settings) {
    // Settings and Options
    if (typeof settings === 'string') {
      settings = {
        locale: settings
      };
    }

    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, INITIALIZE_DEFAULTS);
    this.init();
  }

  // Plugin Methods
  Initialize.prototype = {

    /**
     * Makes sure the Locale is set before attempting initialize components
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      var self = this;
      var locale = this.settings.locale;
      if ((!Locale || !Locale.currentLocale) && !this.settings.locale) {
        locale = 'en-US';
      }

      if (locale) {
        Locale.set(locale).done(function () {
          self.initAll();
        });
      } else {
        self.initAll();
      }

      return this;
    },


    /**
     * Initializes all Soho components inside the root element provided.
      * @returns {this} component instance
     */
    initAll: function initAll() {
      var self = this;

      // Iterate all objects we are initializing
      this.element.each(function () {
        for (var i = 0; i < PLUGIN_MAPPINGS.length; i++) {
          mapToInit.apply(undefined, [$(this)].concat(toConsumableArray(PLUGIN_MAPPINGS[i])));
        }
      });

      // NOTE: use of .triggerHandler() here causes event listeners for "initialized"
      // to fire, but prevents the "initialized" event from bubbling up the DOM.
      // It should be possible to initialize just the contents of an element on
      // the page without causing the entire page to re-initialize.
      this.element.triggerHandler('initialized');

      // Run validation on the entire element, if applicable.
      if ($.fn.validate) {
        self.element.validate();
      }

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Initialize
   * @param {object} settings The settings to apply.
   * @returns {jQuery[]} The jquery object for chaining.
   */
  $.fn.initialize = function (settings) {
    return this.each(function () {
      return new Initialize(this, settings);
    });
  };

  var BEHAVIOR_NAME = 'longpress';

  // Default LongPress settings
  var LONGPRESS_DEFAULTS = {
    delay: 400,
    mouseEvents: false
  };

  /**
   * @class LongPress
   * @constructor
   * @param {Object} [settings] incoming settings
   * @param {Number} [settings.delay] the amount of time that should pass between the touch start, and
   *  the trigger of the "longpress" event.
   * @param {boolean} [settings.mouseEvents] if true, will setup longpress capability against mouse events
   *  as well as touch events.  If false, only touch events will be enabled, excluding mice from triggering
   *  the event.
   */
  function LongPress(settings) {
    this.settings = utils.mergeSettings(this.element, settings, LONGPRESS_DEFAULTS);
    return this.init();
  }

  LongPress.prototype = {

    /**
     * @property {RenderLoopItem} [timer=null]
     */
    timer: null,

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      var _this = this;

      var evts = this.getInputEventNames();
      var self = this;

      // User touches the screen.
      // If this goes uninterrupted for the defined duration, it causes a
      // `longpress` event to trigger on the target element.
      $(document).on(evts.mousedown + '.' + BEHAVIOR_NAME, function (e) {
        var target = e.target;

        // Add a timer to the renderLoop
        _this.timer = new RenderLoopItem({
          id: BEHAVIOR_NAME + '-timer',
          duration: math.convertDelayToFPS(_this.settings.delay),
          timeoutCallback: function timeoutCallback() {
            self.fire(target, e);
          }
        });
        renderLoop.register(_this.timer);
      });

      // User moves or releases the touch, causing the timer to be cancelled.
      $(document).on([evts.mouseup + '.' + BEHAVIOR_NAME, evts.mouseout + '.' + BEHAVIOR_NAME, evts.mousemove + '.' + BEHAVIOR_NAME].join(' '), function () {
        _this.killTimer();
      });
    },


    /**
     * @param {HTMLElement} target the target element on which to trigger the event
     * @param {jQuery.Event} [e=undefined] the original event, if applicable
     * @returns {void}
     */
    fire: function fire(target, e) {
      $(target).trigger('' + BEHAVIOR_NAME, [e]);
    },


    /**
     * @private
     * @returns {void}
     */
    killTimer: function killTimer() {
      if (!this.timer) {
        return;
      }

      // Kill the renderloop item with no call to the timeout callback
      this.timer.destroy(true);
      this.timer = null;
    },


    /**
     * @private
     * @returns {object} containing desired event names
     */
    getInputEventNames: function getInputEventNames() {
      var isTouch = Environment.features.touch;
      var useMouse = this.settings.mouseEvents;
      var testCondition = isTouch || !useMouse;

      return {
        mousedown: testCondition ? 'touchstart' : 'mousedown',
        mouseout: testCondition ? 'touchcancel' : 'mouseout',
        mouseup: testCondition ? 'touchend' : 'mouseup',
        mousemove: testCondition ? 'touchmove' : 'mousemove'
      };
    },


    /**
     * @param {object} settings updated incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.teardown();
      this.init();
    },


    /**
     * @returns {void}
     */
    teardown: function teardown() {
      var evts = this.getInputEventNames();

      this.killTimer();

      $(document).off([evts.mousedown + '.' + BEHAVIOR_NAME, evts.mouseup + '.' + BEHAVIOR_NAME, evts.mouseout + '.' + BEHAVIOR_NAME, evts.mousemove + '.' + BEHAVIOR_NAME].join(' '));
    }
  };

  // Setup a single instance of the LongPress behavior for export
  var longPress = new LongPress();

  // All desired Soho components ==================== /

  var components = /*#__PURE__*/Object.freeze({
    Button: Button,
    Hyperlink: Hyperlink,
    Icon: Icon,
    ListFilter: ListFilter,
    MaskInput: MaskInput,
    Modal: Modal,
    PopupMenu: PopupMenu,
    Tmpl: Tmpl,
    About: About,
    Accordion: Accordion,
    ApplicationMenu: ApplicationMenu,
    Autocomplete: Autocomplete,
    Bar: Bar,
    Blockgrid: Blockgrid,
    Bullet: Bullet,
    BusyIndicator: BusyIndicator,
    ColorPicker: ColorPicker,
    Column: Column,
    CompletionChart: CompletionChart,
    ContextualActionPanel: ContextualActionPanel,
    Drag: Drag,
    DatePicker: DatePicker,
    Dropdown: Dropdown,
    EmptyMessage: EmptyMessage,
    ExpandableArea: ExpandableArea,
    Line: Line,
    ListBuilder: ListBuilder,
    ListView: ListView,
    Message: Message,
    MultiSelect: MultiSelect,
    Notification: Notification,
    Pager: Pager,
    Pie: Pie,
    Popdown: Popdown,
    Radar: Radar,
    SearchField: SearchField,
    Slider: Slider,
    Sparkline: Sparkline,
    Spinbox: Spinbox,
    Splitter: Splitter,
    StepChart: StepChart,
    Tabs: Tabs,
    Tag: Tag,
    Textarea: Textarea,
    TimePicker: TimePicker,
    Toast: Toast,
    Toolbar: Toolbar,
    ToolbarFlex: ToolbarFlex,
    Tooltip: Tooltip,
    Tree: Tree,
    Treemap: Treemap,
    Validator: Validator,
    Wizard: Wizard,
    Zoom: Zoom,
    Calendar: Calendar,
    CompositeForm: CompositeForm,
    Datagrid: Datagrid,
    FormCompact: FormCompact,
    Header: Header,
    Lookup: Lookup,
    MonthView: MonthView,
    MultiTabs: MultiTabs
  });

  // Soho Patterns (jQuery Components)

  var patterns = /*#__PURE__*/Object.freeze({
    ListDetail: ListDetail,
    Stepprocess: Stepprocess
  });

  /* eslint-disable import/first */

  exports.DOM = DOM;
  exports.Editors = editors;
  exports.Formatters = formatters;
  exports.GroupBy = groupBy;
  exports.HideFocus = HideFocus;
  exports.Initialize = Initialize;
  exports.Locale = Locale;
  exports.Place = Place;
  exports.RenderLoopItem = RenderLoopItem;
  exports.Validation = Validation;
  exports.base = base;
  exports.breakpoints = breakpoints;
  exports.components = components;
  exports.debug = debug;
  exports.defer = defer;
  exports.env = Environment;
  exports.excel = excel;
  exports.getColorStyleSheet = getColorStyleSheet;
  exports.longPress = longPress;
  exports.masks = masks;
  exports.patterns = patterns;
  exports.personalization = personalization;
  exports.renderLoop = renderLoop;
  exports.setColors = setColors;
  exports.setTheme = setTheme;
  exports.smoothScrollTo = smoothScrollTo;
  exports.string = stringUtils;
  exports.uniqueIdCount = uniqueIdCount;
  exports.utils = utils;
  exports.version = version;
  exports.xss = xssUtils;

  return exports;

}({}));
//# sourceMappingURL=sohoxi.js.map

;
//# sourceMappingURL=scripts.js.map